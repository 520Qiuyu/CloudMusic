// ==UserScript==
// @name         cloudmusic
// @namespace    https://github.com/520Qiuyu/CloudMusic
// @version      0.0.0
// @author       520Qiuyu
// @description  网易云音乐文件快速上传工具，支持批量上传、进度显示、智能匹配歌曲信息、云盘音乐管理、资源偷取导出、手动匹配纠正、本地文件上传、JSON文件导入等功能，让web端也能便捷使用云盘音乐
// @icon         https://vitejs.dev/logo.svg
// @homepage     https://github.com/520Qiuyu/CloudMusic
// @homepageURL  https://github.com/520Qiuyu/CloudMusic
// @match        https://music.163.com/**/*
// @match        https://y.music.163.com/*
// @require      https://cdn.jsdelivr.net/npm/dayjs@1.11.13/dayjs.min.js
// @require      https://cdn.jsdelivr.net/npm/react@18.3.1/umd/react.production.min.js
// @require      https://cdn.jsdelivr.net/npm/react-dom@18.3.1/umd/react-dom.production.min.js
// @require      https://cdn.jsdelivr.net/npm/antd@5.25.4/dist/antd.min.js
// @require      https://cdn.jsdelivr.net/npm/@ant-design/icons@5.6.1/dist/index.umd.min.js
// @require      https://cdn.jsdelivr.net/npm/node-forge@1.3.1/dist/forge.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.15.1/dist/system.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.15.1/dist/extras/named-register.min.js
// @require      data:application/javascript,%3B(typeof%20System!%3D'undefined')%26%26(System%3Dnew%20System.constructor())%3B
// @connect      music.163.com
// @connect      interface.music.163.com
// @grant        GM_addStyle
// @grant        GM_xmlhttpRequest
// @grant        unsafeWindow
// ==/UserScript==

System.addImportMap({ imports: {"antd":"user:antd","react":"user:react","react-dom":"user:react-dom","@ant-design/icons":"user:@ant-design/icons","node-forge":"user:node-forge"} });
System.set("user:antd", (()=>{const _=antd;('default' in _)||(_.default=_);return _})());
System.set("user:react", (()=>{const _=React;('default' in _)||(_.default=_);return _})());
System.set("user:react-dom", (()=>{const _=ReactDOM;('default' in _)||(_.default=_);return _})());
System.set("user:@ant-design/icons", (()=>{const _=icons;('default' in _)||(_.default=_);return _})());
System.set("user:node-forge", (()=>{const _=forge;('default' in _)||(_.default=_);return _})());

System.register("./__entry.js", ['./__monkey.entry-DKLp9CGx.js'], (function (exports, module) {
	'use strict';
	return {
		setters: [null],
		execute: (function () {



		})
	};
}));

System.register("./__monkey.entry-DKLp9CGx.js", ['react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var forwardRef, useState, memo, useEffect, useMemo, useRef, useImperativeHandle, require$$0, message, Input, Modal, Table, Upload, Button, Tag, Typography, Avatar, Progress, Tabs, Form, Space, ConfigProvider, Select, Image, Spin, Tooltip, Empty, require$$0$1, UploadOutlined, GithubOutlined, InboxOutlined, PauseCircleFilled, PlayCircleFilled, CopyrightOutlined, PlayCircleOutlined, DownloadOutlined, FileOutlined, PauseCircleOutlined, CloudUploadOutlined, CustomerServiceOutlined, CodeOutlined, OrderedListOutlined, InfoCircleOutlined, forge;
  return {
    setters: [module => {
      forwardRef = module.forwardRef;
      useState = module.useState;
      memo = module.memo;
      useEffect = module.useEffect;
      useMemo = module.useMemo;
      useRef = module.useRef;
      useImperativeHandle = module.useImperativeHandle;
      require$$0 = module.default;
    }, module => {
      message = module.message;
      Input = module.Input;
      Modal = module.Modal;
      Table = module.Table;
      Upload = module.Upload;
      Button = module.Button;
      Tag = module.Tag;
      Typography = module.Typography;
      Avatar = module.Avatar;
      Progress = module.Progress;
      Tabs = module.Tabs;
      Form = module.Form;
      Space = module.Space;
      ConfigProvider = module.ConfigProvider;
      Select = module.Select;
      Image = module.Image;
      Spin = module.Spin;
      Tooltip = module.Tooltip;
      Empty = module.Empty;
    }, module => {
      require$$0$1 = module.default;
    }, module => {
      UploadOutlined = module.UploadOutlined;
      GithubOutlined = module.GithubOutlined;
      InboxOutlined = module.InboxOutlined;
      PauseCircleFilled = module.PauseCircleFilled;
      PlayCircleFilled = module.PlayCircleFilled;
      CopyrightOutlined = module.CopyrightOutlined;
      PlayCircleOutlined = module.PlayCircleOutlined;
      DownloadOutlined = module.DownloadOutlined;
      FileOutlined = module.FileOutlined;
      PauseCircleOutlined = module.PauseCircleOutlined;
      CloudUploadOutlined = module.CloudUploadOutlined;
      CustomerServiceOutlined = module.CustomerServiceOutlined;
      CodeOutlined = module.CodeOutlined;
      OrderedListOutlined = module.OrderedListOutlined;
      InfoCircleOutlined = module.InfoCircleOutlined;
    }, module => {
      forge = module.default;
    }],
    execute: (function () {

      exports({
        M: trimRightNull,
        R: findZero,
        a: isBitSet$1,
        g: getBitAllignedNumber,
        h: hexToUint8Array,
        j: getBit,
        l: decodeString,
        n: fromBuffer,
        s: stripNulls,
        u: uint8ArrayToHex,
        z: uint8ArrayToString
      });

      const d=new Set;const importCSS = async e=>{d.has(e)||(d.add(e),(t=>{typeof GM_addStyle=="function"?GM_addStyle(t):document.head.appendChild(document.createElement("style")).append(t);})(e));};

      importCSS(' @charset "UTF-8";._search-form_1aabt_1{padding:16px 0}._songInfoColumn_flki2_1{display:flex;align-items:center;gap:12px;padding:8px 0}._songInfoColumn_flki2_1 ._songIndex_flki2_7{font-size:15px;text-align:center;color:#666;font-weight:500;background-color:#f5f5f5;border-radius:6px;padding:2px 4px}._songInfoColumn_flki2_1 ._songCover_flki2_16{width:56px;height:56px;border-radius:6px;position:relative;cursor:pointer;overflow:hidden;transition:transform .2s ease}._songInfoColumn_flki2_1 ._songCover_flki2_16:hover{transform:scale(1.05)}._songInfoColumn_flki2_1 ._songCover_flki2_16:hover ._btnWrapper_flki2_28{opacity:1;-webkit-backdrop-filter:blur(2px);backdrop-filter:blur(2px);background-color:#0000004d}._songInfoColumn_flki2_1 ._songCover_flki2_16:hover ._songCoverImg_flki2_33{filter:brightness(.85)}._songInfoColumn_flki2_1 ._songCover_flki2_16 ._songCoverImg_flki2_33{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;border-radius:6px;transition:all .3s ease}._songInfoColumn_flki2_1 ._songCover_flki2_16 ._btnWrapper_flki2_28{position:absolute;inset:0;z-index:9;display:flex;align-items:center;justify-content:center;opacity:0;transition:all .3s ease}._songInfoColumn_flki2_1 ._songCover_flki2_16 ._btnWrapper_flki2_28 .anticon{font-size:28px;color:#fff;filter:drop-shadow(0 2px 4px rgba(0,0,0,.2))}._songInfoColumn_flki2_1 ._songInfo_flki2_1{flex:1 1 0px;overflow:hidden;display:flex;flex-direction:column;gap:4px}._songInfoColumn_flki2_1 ._songInfo_flki2_1 ._songName_flki2_67{font-size:15px;font-weight:500;color:#333;line-height:1.4;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._songInfoColumn_flki2_1 ._songInfo_flki2_1 ._subInfo_flki2_76{display:flex;align-items:center;flex-wrap:wrap;gap:3px;font-size:13px;color:#666}._songInfoColumn_flki2_1 ._songInfo_flki2_1 ._subInfo_flki2_76 ._artist_flki2_84,._songInfoColumn_flki2_1 ._songInfo_flki2_1 ._subInfo_flki2_76 ._album_flki2_85{text-overflow:ellipsis;white-space:nowrap}._songInfoColumn_flki2_1 ._songInfo_flki2_1 ._subInfo_flki2_76 ._artist_flki2_84{max-width:160px}._songInfoColumn_flki2_1 ._songInfo_flki2_1 ._subInfo_flki2_76 ._album_flki2_85{position:relative;max-width:140px}@property --degree{syntax: "<angle>"; inherits: false; initial-value: 0deg;}._currentSong_flki2_102{--degree: 0deg;--background: linear-gradient(var(--degree), #84fab0, #8fd3f4);background:var(--background);animation:_rotate_flki2_1 10s linear infinite}._currentSong_flki2_102 td{background:var(--background)!important;animation:_rotate_flki2_1 10s linear infinite}@keyframes _rotate_flki2_1{0%{--degree: 0deg}to{--degree: 360deg}}._matchError_flki2_121{background-color:#f06161}._matchError_flki2_121 td{background-color:#f06161!important}._footer_flki2_128{margin-top:16px;display:flex;justify-content:space-between;align-items:center;border-top:1px solid #f0f0f0;padding:16px 0}._footer_flki2_128 ._actions_flki2_136{display:flex;gap:8px}._stats_flki2_141{display:flex;align-items:center;gap:8px}._stats_flki2_141 ._size_flki2_146{color:#666}._stats_flki2_141 ._divider_flki2_149{color:#999;margin:0 4px}._stats_flki2_141 .ant-tag{margin:0}._playlist_flki2_157 .ant-modal-body{padding-bottom:0}._autoAddContent_flki2_161 ._title_flki2_161{font-size:16px;margin-bottom:8px}._autoAddContent_flki2_161 ._statsWrapper_flki2_165{margin-bottom:16px}._autoAddContent_flki2_161 ._statsContent_flki2_168{display:flex;gap:16px;background:#f5f5f5;padding:12px 16px;border-radius:8px}._autoAddContent_flki2_161 ._statsContent_flki2_168 ._label_flki2_175{color:#666}._autoAddContent_flki2_161 ._statsContent_flki2_168 ._value_flki2_178{color:#1890ff;font-size:18px;font-weight:700}._autoAddContent_flki2_161 ._listHeader_flki2_183{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}._autoAddContent_flki2_161 ._listWrapper_flki2_189{margin:8px 0;max-height:200px;overflow-y:auto;padding:12px;border:1px solid #d9d9d9;border-radius:8px;background:#fff}._autoAddContent_flki2_161 ._listWrapper_flki2_189::-webkit-scrollbar{width:6px;height:6px}._autoAddContent_flki2_161 ._listWrapper_flki2_189::-webkit-scrollbar-thumb{border-radius:3px;background:#0003}._autoAddContent_flki2_161 ._listWrapper_flki2_189::-webkit-scrollbar-track{border-radius:3px;background:#0000001a}._autoAddContent_flki2_161 ._listItem_flki2_210{margin-bottom:8px;display:flex;justify-content:space-between;padding:4px 8px;border-radius:4px;transition:all .3s;cursor:default;background:#fff}._autoAddContent_flki2_161 ._listItem_flki2_210:hover{background:#f5f5f5}._autoAddContent_flki2_161 ._listItem_flki2_210:last-child{margin-bottom:0}._autoAddContent_flki2_161 ._listItem_flki2_210 ._itemName_flki2_226{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._autoAddContent_flki2_161 ._listItem_flki2_210 ._itemCount_flki2_232{color:#1890ff;margin-left:8px}._deleteConfirmation_flki2_237{font-size:14px}._deleteConfirmation_flki2_237 ._title_flki2_161{font-size:16px;font-weight:700;margin-bottom:12px}._deleteConfirmation_flki2_237 ._title_flki2_161 ._count_flki2_245{color:#1890ff}._deleteConfirmation_flki2_237 ._songs_flki2_248{max-height:220px;overflow-y:auto;margin:12px 0;padding:8px;background:#f8f8f8;border-radius:6px;border:1px solid #e8e8e8;line-height:1.6;color:#666}._deleteConfirmation_flki2_237 ._songs_flki2_248 ._songItem_flki2_259{padding:4px 8px;border-radius:4px;transition:all .3s}._deleteConfirmation_flki2_237 ._songs_flki2_248 ._songItem_flki2_259:hover{background:#f0f0f0}._deleteConfirmation_flki2_237 ._songs_flki2_248 ._songItem_flki2_259:not(:last-child){margin-bottom:4px}._deleteConfirmation_flki2_237 ._warning_flki2_270{background:#fff2f0;border:1px solid #ffccc7;border-radius:6px;padding:5px;margin-top:12px}._deleteConfirmation_flki2_237 ._warning_flki2_270 ._text_flki2_277{color:#ff4d4f;margin:0;display:flex;align-items:center;gap:8px}._deleteConfirmation_flki2_237 ._warning_flki2_270 ._icon_flki2_284{flex:0 0 20px;display:inline-block;width:20px;height:20px;line-height:20px;text-align:center;border-radius:50%;background:#ff4d4f;color:#fff;font-size:14px;font-weight:700}._singer-option_flki2_298{display:flex;align-items:center;gap:8px;position:relative;background-image:var(--avatar-url);background-size:cover;background-position:center;background-repeat:no-repeat;height:90px;border-radius:8px;overflow:hidden}._singer-option_flki2_298 ._singer-option-content_flki2_311{display:flex;align-items:center;gap:8px;position:absolute;bottom:-30px;left:0;width:100%;height:30px;padding:0 12px;background-color:#00000080;color:#fff;border-radius:4px;transition:all .3s ease}._singer-option_flki2_298 ._singer-option-content_flki2_311 ._singer-option-name_flki2_326{font-size:14px}._singer-option_flki2_298 ._singer-option-content_flki2_311 ._singer-option-id_flki2_329{font-size:13px}._singer-option_flki2_298:hover ._singer-option-content_flki2_311{bottom:0;-webkit-backdrop-filter:blur(2px);backdrop-filter:blur(2px)}._song-label_flki2_337{display:flex;flex-direction:column;gap:8px;padding:8px 0}._song-label_flki2_337 ._song-name_flki2_343{font-size:14px;color:#333;font-weight:500}._song-label_flki2_337 ._tag-group_flki2_348{display:flex;gap:8px;flex-wrap:wrap}._song-option_flki2_354{display:flex;align-items:center;justify-content:space-between;width:100%;padding:8px 12px;border-radius:6px;transition:all .2s ease;cursor:pointer}._song-option_flki2_354:hover{background-color:#f5f5f5}._song-option_flki2_354 ._song-info_flki2_367{display:flex;flex-direction:column;gap:4px;flex:1;min-width:0}._song-option_flki2_354 ._song-name_flki2_343{font-size:14px;font-weight:500;color:#262626;line-height:1.4;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._song-option_flki2_354 ._tag-group_flki2_348{display:flex;gap:4px;flex-wrap:wrap;align-items:center}._song-option_flki2_354 ._tag-group_flki2_348 .ant-tag{margin:0;font-size:11px;line-height:1.2;padding:1px 6px;border-radius:3px}._song-option_flki2_354 ._album-cover_flki2_396{flex-shrink:0;width:32px;height:32px;margin-right:20px;border-radius:4px;object-fit:cover;border:1px solid #f0f0f0;margin-left:12px;transition:all .2s ease}._song-option_flki2_354 ._album-cover_flki2_396:hover{transform:scale(1.05);box-shadow:0 2px 8px #0000001a}._original-album_flki2_412{display:flex;flex-direction:column;gap:4px;padding:8px 12px;transition:all .2s ease}._original-album_flki2_412 ._song-info_flki2_367{font-size:14px;font-weight:500;color:#262626;line-height:1.4;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._original-album_flki2_412 ._artist-info_flki2_428{font-size:12px;color:#8c8c8c;line-height:1.3;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._original-album_flki2_412 ._album-info_flki2_436{font-size:12px;color:#595959;line-height:1.3;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;margin-top:2px;padding-top:2px}._githubContainer_b3krt_2{display:flex;flex-direction:column;align-items:center;padding:20px;text-align:center}._githubContainer_b3krt_2 ._userInfo_b3krt_9{display:flex;align-items:center;gap:16px;margin-bottom:20px}._githubContainer_b3krt_2 ._username_b3krt_15{margin:0}._githubContainer_b3krt_2 ._starCount_b3krt_18{display:block;color:#666;font-size:14px;margin-top:4px}._githubContainer_b3krt_2 ._bio_b3krt_24{color:#666;margin-bottom:20px}._githubContainer_b3krt_2 ._features_b3krt_28{width:100%;margin-bottom:24px;text-align:left}._githubContainer_b3krt_2 ._features_b3krt_28 h5{text-align:center;margin-bottom:16px}._githubContainer_b3krt_2 ._featureList_b3krt_37{list-style:none;padding:0;margin:0;max-height:300px;overflow-y:auto}._githubContainer_b3krt_2 ._featureList_b3krt_37::-webkit-scrollbar{width:6px}._githubContainer_b3krt_2 ._featureList_b3krt_37::-webkit-scrollbar-thumb{background-color:#d9d9d9;border-radius:3px}._githubContainer_b3krt_2 ._featureList_b3krt_37::-webkit-scrollbar-track{background-color:#f5f5f5}._githubContainer_b3krt_2 ._featureList_b3krt_37 li{margin-bottom:12px;font-size:14px;line-height:1.5;color:#666}._githubContainer_b3krt_2 ._profileButton_b3krt_61{background:#24292e;border-color:#24292e}._githubContainer_b3krt_2 ._profileButton_b3krt_61:hover{background:#2f363d;border-color:#2f363d}._local-upload_1latm_1{display:flex;flex-direction:column;gap:16px}._local-upload_1latm_1 ._upload-section_1latm_6{flex:0 0 170px;display:flex;flex-direction:column;gap:16px}._local-upload_1latm_1 ._upload-section_1latm_6 ._dragger_1latm_12{flex:1;display:flex;flex-direction:column;justify-content:center;align-items:center;border:2px dashed #d9d9d9;border-radius:8px;background:#fafafa;transition:border-color .3s}._local-upload_1latm_1 ._upload-section_1latm_6 ._dragger_1latm_12:hover{border-color:#c20c0c}._local-upload_1latm_1 ._upload-section_1latm_6 ._dragger_1latm_12 ._upload-icon_1latm_26{font-size:48px;color:#999}._local-upload_1latm_1 ._upload-section_1latm_6 ._dragger_1latm_12 ._upload-text_1latm_30{margin-top:16px;color:#666}._local-upload_1latm_1 ._upload-section_1latm_6 ._dragger_1latm_12 ._upload-hint_1latm_34{margin-top:8px;color:#999;font-size:13px}._local-upload_1latm_1 ._file-list_1latm_39{flex:1;display:flex;flex-direction:column;gap:16px;overflow:hidden}._local-upload_1latm_1 ._file-list_1latm_39 .ant-table{flex:1}._local-upload_1latm_1 ._upload-stats_1latm_49{display:flex;align-items:center;color:#666;font-size:13px}._local-upload_1latm_1 ._upload-stats_1latm_49 ._size-text_1latm_55{color:#999}._local-upload_1latm_1 ._upload-stats_1latm_49 ._divider_1latm_58{margin:0 8px;color:#d9d9d9}._local-upload_1latm_1 ._upload-stats_1latm_49 button{margin-left:10px}._songList_1r0t2_1 ._ant-table_1r0t2_1 ._ant-table-thead_1r0t2_1>tr>th{background-color:#f5f5f5}._playlist-id-input_1r0t2_5{margin-bottom:10px}._playlist-info_15nrq_1{display:flex;align-items:center;gap:12px;min-width:0;padding:8px 0}._playlist-info_15nrq_1 ._cover_15nrq_8{width:60px;height:60px;border-radius:6px;flex-shrink:0;overflow:hidden;cursor:pointer;transition:all .3s cubic-bezier(.4,0,.2,1);box-shadow:0 2px 8px #00000014;position:relative}._playlist-info_15nrq_1 ._cover_15nrq_8:before{content:"";position:absolute;inset:0;border-radius:6px;background:linear-gradient(135deg,#ffffff1a,#0000000d);opacity:0;transition:opacity .3s ease;z-index:1;pointer-events:none}._playlist-info_15nrq_1 ._cover_15nrq_8:hover{transform:scale(1.05);box-shadow:0 4px 16px #0000001f}._playlist-info_15nrq_1 ._cover_15nrq_8:hover:before{opacity:1}._playlist-info_15nrq_1 ._cover_15nrq_8:active{transform:scale(1.02)}._playlist-info_15nrq_1 ._info_15nrq_40{flex:1;min-width:0;display:flex;flex-direction:column;gap:6px}._playlist-info_15nrq_1 ._info_15nrq_40 ._name_15nrq_47{font-weight:500;font-size:14px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:#262626;line-height:1.4;transition:color .2s ease;cursor:default}._playlist-info_15nrq_1 ._info_15nrq_40 ._creator_15nrq_58{font-size:12px;color:#8c8c8c;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;line-height:1.3;transition:color .2s ease;cursor:default}._playlist-item_15nrq_69{transition:all .2s cubic-bezier(.4,0,.2,1);cursor:pointer}._playlist-item_15nrq_69:hover{background-color:#fafafa!important}._playlist-item_15nrq_69:active,._playlist-item_15nrq_69:active td{background-color:#f0f0f0!important}.ant-spin{width:100%;height:100%}.ant-modal-footer .ant-btn-default{border-color:#d9d9d9;color:#333}.ant-modal-footer .ant-btn-default:hover{border-color:#c20c0c;color:#c20c0c}.ant-modal-footer .ant-btn-primary{background:#c20c0c;border-color:#c20c0c}.ant-modal-footer .ant-btn-primary:hover{background:#a40a0a;border-color:#a40a0a}._quick-upload-tabs_1rogj_22 ._select_1rogj_22{width:100%}._singer-choose_1rogj_26 ._singer-choose-form_1rogj_26{display:flex;flex-direction:column;justify-content:space-between;height:400px}._singer-choose_1rogj_26 ._singer-choose-form_1rogj_26 ._btn-group_1rogj_32{display:flex;justify-content:flex-end}._singer-choose_1rogj_26 ._option-label_1rogj_36{display:flex;align-items:center;gap:8px;justify-content:space-between;width:100%}._singer-choose_1rogj_26 ._option-label_1rogj_36 ._singer-name_1rogj_43{font-weight:500}._singer-choose_1rogj_26 ._option-label_1rogj_36 ._tag-group_1rogj_46 ._tag_1rogj_46:not(:last-child){margin-right:8px}._upload-list_1rogj_50 .ant-table{margin:16px 0}._upload-footer_1rogj_54{width:100%;display:flex;justify-content:flex-end;align-items:center;gap:8px}._upload-stats_1rogj_62{color:#666;font-size:13px;margin-right:auto}._upload-stats_1rogj_62 ._size-text_1rogj_67{color:#999}._upload-stats_1rogj_62 ._divider_1rogj_70{margin:0 8px;color:#d9d9d9}._upload-confirm_1rogj_75{padding:16px 0;font-size:14px}._upload-confirm_1rogj_75 ._confirm-item_1rogj_79{display:flex;align-items:center;margin-bottom:12px}._upload-confirm_1rogj_75 ._confirm-item_1rogj_79:last-child{margin-bottom:0}._upload-confirm_1rogj_75 ._confirm-item_1rogj_79 ._label_1rogj_87{color:#666;width:80px;flex-shrink:0}._upload-confirm_1rogj_75 ._confirm-item_1rogj_79 ._value_1rogj_92{color:#333;font-weight:500}._upload-confirm_1rogj_75 ._confirm-item_1rogj_79 ._value_1rogj_92 ._size_1rogj_67{margin-left:4px;color:#999;font-weight:400}._upload-progress_1rogj_102 ._progress-header_1rogj_102{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;padding:0 4px}._upload-progress_1rogj_102 ._progress-header_1rogj_102 ._progress-info_1rogj_109{font-size:14px;color:#333}._upload-progress_1rogj_102 ._progress-header_1rogj_102 ._percentage_1rogj_113{font-size:14px;font-weight:500;color:#1890ff}._upload-progress_1rogj_102 ._progress-list_1rogj_118{max-height:300px;overflow-y:auto;padding:0 4px}._upload-progress_1rogj_102 ._progress-list_1rogj_118 ._progress-item_1rogj_123{display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid #f0f0f0}._upload-progress_1rogj_102 ._progress-list_1rogj_118 ._progress-item_1rogj_123:last-child{border-bottom:none}._upload-progress_1rogj_102 ._progress-list_1rogj_118 ._progress-item_1rogj_123 ._song-info_1rogj_133{flex:1;min-width:0;padding-right:16px}._upload-progress_1rogj_102 ._progress-list_1rogj_118 ._progress-item_1rogj_123 ._song-info_1rogj_133 ._name_1rogj_138{font-size:14px;color:#333}._upload-progress_1rogj_102 ._progress-list_1rogj_118 ._progress-item_1rogj_123 ._song-info_1rogj_133 ._artist_1rogj_142{font-size:14px;color:#666;margin-left:4px}._uploadProgressModal_1rogj_148 .ant-modal-body{padding:24px}._uploadProgressModal_1rogj_148 ._progressContent_1rogj_151{display:flex;flex-direction:column;align-items:center;gap:24px}._uploadProgressModal_1rogj_148 ._progressInfo_1rogj_157{display:flex;flex-direction:column;align-items:center}._uploadProgressModal_1rogj_148 ._progressInfo_1rogj_157 ._percentage_1rogj_113{font-size:24px;font-weight:500;color:#333}._uploadProgressModal_1rogj_148 ._progressInfo_1rogj_157 ._detail_1rogj_167{font-size:14px;color:#666;margin-top:4px}._uploadProgressModal_1rogj_148 ._statsContainer_1rogj_172{display:flex;justify-content:space-around;width:100%;padding:16px 0;border-top:1px solid #f0f0f0;border-bottom:1px solid #f0f0f0}._uploadProgressModal_1rogj_148 ._statsContainer_1rogj_172 ._statsItem_1rogj_180{text-align:center}._uploadProgressModal_1rogj_148 ._statsContainer_1rogj_172 ._statsItem_1rogj_180 ._label_1rogj_87{font-size:14px;color:#666;margin-bottom:8px}._uploadProgressModal_1rogj_148 ._statsContainer_1rogj_172 ._statsItem_1rogj_180 ._value_1rogj_92 .ant-tag{margin:0;font-size:14px;padding:4px 12px}._uploadProgressModal_1rogj_148 ._failedList_1rogj_193{width:100%}._uploadProgressModal_1rogj_148 ._failedList_1rogj_193 ._failedTitle_1rogj_196{font-size:14px;color:#333;margin-bottom:12px;font-weight:500}._uploadProgressModal_1rogj_148 ._failedList_1rogj_193 ._failedItem_1rogj_202{padding:8px 12px;background:#fff1f0;border-radius:4px;margin-bottom:8px}._uploadProgressModal_1rogj_148 ._failedList_1rogj_193 ._failedItem_1rogj_202 ._songName_1rogj_208{font-size:14px;color:#333;margin-bottom:4px}._uploadProgressModal_1rogj_148 ._failedList_1rogj_193 ._failedItem_1rogj_202 ._errorMsg_1rogj_213{font-size:12px;color:#ff4d4f}._uploadModal_1rogj_218 .ant-modal-body{padding:24px}._progressSection_1rogj_222{display:flex;flex-direction:column;align-items:center;margin-bottom:24px;padding-bottom:24px;border-bottom:1px solid #f0f0f0}._progressInfo_1rogj_157{display:flex;flex-direction:column;align-items:center}._progressInfo_1rogj_157 ._percentage_1rogj_113{font-size:24px;font-weight:500;color:#333}._progressInfo_1rogj_157 ._count_1rogj_241{font-size:14px;color:#666;margin-top:4px}._statsContainer_1rogj_172{display:flex;justify-content:center;gap:16px;margin-top:20px}._statsContainer_1rogj_172 ._statsItem_1rogj_180{text-align:center}._statsContainer_1rogj_172 ._statsTag_1rogj_256{padding:4px 12px;font-size:14px}._songList_1rogj_261{max-height:300px;overflow-y:auto;padding-right:4px}._songList_1rogj_261::-webkit-scrollbar{width:6px}._songList_1rogj_261::-webkit-scrollbar-thumb{background-color:#d9d9d9;border-radius:3px}._songList_1rogj_261::-webkit-scrollbar-thumb:hover{background-color:#bfbfbf}._songItem_1rogj_277{display:flex;justify-content:space-between;align-items:center;padding:12px;border-radius:4px;background:#fafafa}._songItem_1rogj_277:not(:last-child){margin-bottom:8px}._songItem_1rogj_277:hover{background:#f5f5f5}._songInfo_1rogj_292{display:flex;align-items:center;gap:8px;flex:1;min-width:0}._songInfo_1rogj_292 ._songName_1rogj_208{font-weight:500;color:#333;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._songInfo_1rogj_292 ._artistName_1rogj_306{color:#666;font-size:13px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._button-group_dcsms_1{position:fixed;right:20px;top:50%;width:44px;max-height:400px;overflow-y:auto;background:#ffffffe6;border-radius:22px;box-shadow:0 2px 10px #0000001a;padding:10px 0;z-index:999}._button-group_dcsms_1::-webkit-scrollbar{width:0;background:transparent}._button-group_dcsms_1 .ant-btn{width:36px;height:36px;padding:0;border:none;background:transparent;display:flex;align-items:center;justify-content:center;margin:4px auto;transition:all .3s}._button-group_dcsms_1 .ant-btn:hover{background:#c20c0c1a;color:#fff;transform:scale(1.1)}._button-group_dcsms_1 .ant-btn:active{transform:scale(.95)}._button-group_dcsms_1 .ant-btn .anticon{font-size:20px;color:#666}._button-group_dcsms_1 .ant-btn:hover .anticon{color:#fff}._button-group_dcsms_1 .ant-tooltip .ant-tooltip-inner{background-color:#000c;border-radius:4px;font-size:12px;padding:4px 8px}._button-group_dcsms_1 .ant-tooltip .ant-tooltip-arrow-content{background-color:#000c} ');

      function getDefaultExportFromCjs(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      var jsxRuntime = { exports: {} };
      var reactJsxRuntime_production_min = {};
      /**
       * @license React
       * react-jsx-runtime.production.min.js
       *
       * Copyright (c) Facebook, Inc. and its affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      var hasRequiredReactJsxRuntime_production_min;
      function requireReactJsxRuntime_production_min() {
        if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
        hasRequiredReactJsxRuntime_production_min = 1;
        var f = require$$0, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
        function q(c, a, g) {
          var b, d = {}, e = null, h = null;
          void 0 !== g && (e = "" + g);
          void 0 !== a.key && (e = "" + a.key);
          void 0 !== a.ref && (h = a.ref);
          for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
          if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
          return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
        }
        reactJsxRuntime_production_min.Fragment = l;
        reactJsxRuntime_production_min.jsx = q;
        reactJsxRuntime_production_min.jsxs = q;
        return reactJsxRuntime_production_min;
      }
      var hasRequiredJsxRuntime;
      function requireJsxRuntime() {
        if (hasRequiredJsxRuntime) return jsxRuntime.exports;
        hasRequiredJsxRuntime = 1;
        {
          jsxRuntime.exports = requireReactJsxRuntime_production_min();
        }
        return jsxRuntime.exports;
      }
      var jsxRuntimeExports = requireJsxRuntime();
      var client = {};
      var hasRequiredClient;
      function requireClient() {
        if (hasRequiredClient) return client;
        hasRequiredClient = 1;
        var m = require$$0$1;
        {
          client.createRoot = m.createRoot;
          client.hydrateRoot = m.hydrateRoot;
        }
        return client;
      }
      var clientExports = requireClient();
      const ReactDOM = getDefaultExportFromCjs(clientExports);
      var md5$1 = { exports: {} };
      var crypt = { exports: {} };
      var hasRequiredCrypt;
      function requireCrypt() {
        if (hasRequiredCrypt) return crypt.exports;
        hasRequiredCrypt = 1;
        (function() {
          var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt$1 = {
rotl: function(n, b) {
              return n << b | n >>> 32 - b;
            },
rotr: function(n, b) {
              return n << 32 - b | n >>> b;
            },
endian: function(n) {
              if (n.constructor == Number) {
                return crypt$1.rotl(n, 8) & 16711935 | crypt$1.rotl(n, 24) & 4278255360;
              }
              for (var i = 0; i < n.length; i++)
                n[i] = crypt$1.endian(n[i]);
              return n;
            },
randomBytes: function(n) {
              for (var bytes = []; n > 0; n--)
                bytes.push(Math.floor(Math.random() * 256));
              return bytes;
            },
bytesToWords: function(bytes) {
              for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
                words[b >>> 5] |= bytes[i] << 24 - b % 32;
              return words;
            },
wordsToBytes: function(words) {
              for (var bytes = [], b = 0; b < words.length * 32; b += 8)
                bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
              return bytes;
            },
bytesToHex: function(bytes) {
              for (var hex = [], i = 0; i < bytes.length; i++) {
                hex.push((bytes[i] >>> 4).toString(16));
                hex.push((bytes[i] & 15).toString(16));
              }
              return hex.join("");
            },
hexToBytes: function(hex) {
              for (var bytes = [], c = 0; c < hex.length; c += 2)
                bytes.push(parseInt(hex.substr(c, 2), 16));
              return bytes;
            },
bytesToBase64: function(bytes) {
              for (var base64 = [], i = 0; i < bytes.length; i += 3) {
                var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
                for (var j = 0; j < 4; j++)
                  if (i * 8 + j * 6 <= bytes.length * 8)
                    base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
                  else
                    base64.push("=");
              }
              return base64.join("");
            },
base64ToBytes: function(base64) {
              base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
              for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
                if (imod4 == 0) continue;
                bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
              }
              return bytes;
            }
          };
          crypt.exports = crypt$1;
        })();
        return crypt.exports;
      }
      var charenc_1;
      var hasRequiredCharenc;
      function requireCharenc() {
        if (hasRequiredCharenc) return charenc_1;
        hasRequiredCharenc = 1;
        var charenc = {
utf8: {
stringToBytes: function(str) {
              return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
            },
bytesToString: function(bytes) {
              return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
            }
          },
bin: {
stringToBytes: function(str) {
              for (var bytes = [], i = 0; i < str.length; i++)
                bytes.push(str.charCodeAt(i) & 255);
              return bytes;
            },
bytesToString: function(bytes) {
              for (var str = [], i = 0; i < bytes.length; i++)
                str.push(String.fromCharCode(bytes[i]));
              return str.join("");
            }
          }
        };
        charenc_1 = charenc;
        return charenc_1;
      }
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <https://feross.org>
       * @license  MIT
       */
      var isBuffer_1;
      var hasRequiredIsBuffer;
      function requireIsBuffer() {
        if (hasRequiredIsBuffer) return isBuffer_1;
        hasRequiredIsBuffer = 1;
        isBuffer_1 = function(obj) {
          return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
        };
        function isBuffer(obj) {
          return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
        }
        function isSlowBuffer(obj) {
          return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
        }
        return isBuffer_1;
      }
      var hasRequiredMd5;
      function requireMd5() {
        if (hasRequiredMd5) return md5$1.exports;
        hasRequiredMd5 = 1;
        (function() {
          var crypt2 = requireCrypt(), utf8 = requireCharenc().utf8, isBuffer = requireIsBuffer(), bin = requireCharenc().bin, md52 = function(message2, options) {
            if (message2.constructor == String)
              if (options && options.encoding === "binary")
                message2 = bin.stringToBytes(message2);
              else
                message2 = utf8.stringToBytes(message2);
            else if (isBuffer(message2))
              message2 = Array.prototype.slice.call(message2, 0);
            else if (!Array.isArray(message2) && message2.constructor !== Uint8Array)
              message2 = message2.toString();
            var m = crypt2.bytesToWords(message2), l = message2.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
            for (var i = 0; i < m.length; i++) {
              m[i] = (m[i] << 8 | m[i] >>> 24) & 16711935 | (m[i] << 24 | m[i] >>> 8) & 4278255360;
            }
            m[l >>> 5] |= 128 << l % 32;
            m[(l + 64 >>> 9 << 4) + 14] = l;
            var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
            for (var i = 0; i < m.length; i += 16) {
              var aa = a, bb = b, cc = c, dd = d;
              a = FF(a, b, c, d, m[i + 0], 7, -680876936);
              d = FF(d, a, b, c, m[i + 1], 12, -389564586);
              c = FF(c, d, a, b, m[i + 2], 17, 606105819);
              b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
              a = FF(a, b, c, d, m[i + 4], 7, -176418897);
              d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
              c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
              b = FF(b, c, d, a, m[i + 7], 22, -45705983);
              a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
              d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
              c = FF(c, d, a, b, m[i + 10], 17, -42063);
              b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
              a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
              d = FF(d, a, b, c, m[i + 13], 12, -40341101);
              c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
              b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
              a = GG(a, b, c, d, m[i + 1], 5, -165796510);
              d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
              c = GG(c, d, a, b, m[i + 11], 14, 643717713);
              b = GG(b, c, d, a, m[i + 0], 20, -373897302);
              a = GG(a, b, c, d, m[i + 5], 5, -701558691);
              d = GG(d, a, b, c, m[i + 10], 9, 38016083);
              c = GG(c, d, a, b, m[i + 15], 14, -660478335);
              b = GG(b, c, d, a, m[i + 4], 20, -405537848);
              a = GG(a, b, c, d, m[i + 9], 5, 568446438);
              d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
              c = GG(c, d, a, b, m[i + 3], 14, -187363961);
              b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
              a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
              d = GG(d, a, b, c, m[i + 2], 9, -51403784);
              c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
              b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
              a = HH(a, b, c, d, m[i + 5], 4, -378558);
              d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
              c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
              b = HH(b, c, d, a, m[i + 14], 23, -35309556);
              a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
              d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
              c = HH(c, d, a, b, m[i + 7], 16, -155497632);
              b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
              a = HH(a, b, c, d, m[i + 13], 4, 681279174);
              d = HH(d, a, b, c, m[i + 0], 11, -358537222);
              c = HH(c, d, a, b, m[i + 3], 16, -722521979);
              b = HH(b, c, d, a, m[i + 6], 23, 76029189);
              a = HH(a, b, c, d, m[i + 9], 4, -640364487);
              d = HH(d, a, b, c, m[i + 12], 11, -421815835);
              c = HH(c, d, a, b, m[i + 15], 16, 530742520);
              b = HH(b, c, d, a, m[i + 2], 23, -995338651);
              a = II(a, b, c, d, m[i + 0], 6, -198630844);
              d = II(d, a, b, c, m[i + 7], 10, 1126891415);
              c = II(c, d, a, b, m[i + 14], 15, -1416354905);
              b = II(b, c, d, a, m[i + 5], 21, -57434055);
              a = II(a, b, c, d, m[i + 12], 6, 1700485571);
              d = II(d, a, b, c, m[i + 3], 10, -1894986606);
              c = II(c, d, a, b, m[i + 10], 15, -1051523);
              b = II(b, c, d, a, m[i + 1], 21, -2054922799);
              a = II(a, b, c, d, m[i + 8], 6, 1873313359);
              d = II(d, a, b, c, m[i + 15], 10, -30611744);
              c = II(c, d, a, b, m[i + 6], 15, -1560198380);
              b = II(b, c, d, a, m[i + 13], 21, 1309151649);
              a = II(a, b, c, d, m[i + 4], 6, -145523070);
              d = II(d, a, b, c, m[i + 11], 10, -1120210379);
              c = II(c, d, a, b, m[i + 2], 15, 718787259);
              b = II(b, c, d, a, m[i + 9], 21, -343485551);
              a = a + aa >>> 0;
              b = b + bb >>> 0;
              c = c + cc >>> 0;
              d = d + dd >>> 0;
            }
            return crypt2.endian([a, b, c, d]);
          };
          md52._ff = function(a, b, c, d, x, s, t) {
            var n = a + (b & c | ~b & d) + (x >>> 0) + t;
            return (n << s | n >>> 32 - s) + b;
          };
          md52._gg = function(a, b, c, d, x, s, t) {
            var n = a + (b & d | c & ~d) + (x >>> 0) + t;
            return (n << s | n >>> 32 - s) + b;
          };
          md52._hh = function(a, b, c, d, x, s, t) {
            var n = a + (b ^ c ^ d) + (x >>> 0) + t;
            return (n << s | n >>> 32 - s) + b;
          };
          md52._ii = function(a, b, c, d, x, s, t) {
            var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
            return (n << s | n >>> 32 - s) + b;
          };
          md52._blocksize = 16;
          md52._digestsize = 16;
          md5$1.exports = function(message2, options) {
            if (message2 === void 0 || message2 === null)
              throw new Error("Illegal argument " + message2);
            var digestbytes = crypt2.wordsToBytes(md52(message2, options));
            return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt2.bytesToHex(digestbytes);
          };
        })();
        return md5$1.exports;
      }
      var md5Exports = requireMd5();
      const md5 = getDefaultExportFromCjs(md5Exports);
      var _GM_xmlhttpRequest = (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      var _unsafeWindow = (() => typeof unsafeWindow != "undefined" ? unsafeWindow : void 0)();
      const defaultMessages = "End-Of-Stream";
      class EndOfStreamError extends Error {
        constructor() {
          super(defaultMessages);
          this.name = "EndOfStreamError";
        }
      } exports("E", EndOfStreamError);
      class AbortError extends Error {
        constructor(message2 = "The operation was aborted") {
          super(message2);
          this.name = "AbortError";
        }
      }
      class AbstractStreamReader {
        constructor() {
          this.endOfStream = false;
          this.interrupted = false;
          this.peekQueue = [];
        }
        async peek(uint8Array, mayBeLess = false) {
          const bytesRead = await this.read(uint8Array, mayBeLess);
          this.peekQueue.push(uint8Array.subarray(0, bytesRead));
          return bytesRead;
        }
        async read(buffer, mayBeLess = false) {
          if (buffer.length === 0) {
            return 0;
          }
          let bytesRead = this.readFromPeekBuffer(buffer);
          if (!this.endOfStream) {
            bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
          }
          if (bytesRead === 0) {
            throw new EndOfStreamError();
          }
          return bytesRead;
        }
readFromPeekBuffer(buffer) {
          let remaining = buffer.length;
          let bytesRead = 0;
          while (this.peekQueue.length > 0 && remaining > 0) {
            const peekData = this.peekQueue.pop();
            if (!peekData)
              throw new Error("peekData should be defined");
            const lenCopy = Math.min(peekData.length, remaining);
            buffer.set(peekData.subarray(0, lenCopy), bytesRead);
            bytesRead += lenCopy;
            remaining -= lenCopy;
            if (lenCopy < peekData.length) {
              this.peekQueue.push(peekData.subarray(lenCopy));
            }
          }
          return bytesRead;
        }
        async readRemainderFromStream(buffer, mayBeLess) {
          let bytesRead = 0;
          while (bytesRead < buffer.length && !this.endOfStream) {
            if (this.interrupted) {
              throw new AbortError();
            }
            const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
            if (chunkLen === 0)
              break;
            bytesRead += chunkLen;
          }
          if (!mayBeLess && bytesRead < buffer.length) {
            throw new EndOfStreamError();
          }
          return bytesRead;
        }
      }
      class WebStreamReader extends AbstractStreamReader {
        constructor(reader) {
          super();
          this.reader = reader;
        }
        async abort() {
          return this.close();
        }
        async close() {
          this.reader.releaseLock();
        }
      }
      class WebStreamByobReader extends WebStreamReader {
async readFromStream(buffer, mayBeLess) {
          if (buffer.length === 0)
            return 0;
          const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? void 0 : buffer.length });
          if (result.done) {
            this.endOfStream = result.done;
          }
          if (result.value) {
            buffer.set(result.value);
            return result.value.length;
          }
          return 0;
        }
      }
      class WebStreamDefaultReader extends AbstractStreamReader {
        constructor(reader) {
          super();
          this.reader = reader;
          this.buffer = null;
        }
writeChunk(target, chunk) {
          const written = Math.min(chunk.length, target.length);
          target.set(chunk.subarray(0, written));
          if (written < chunk.length) {
            this.buffer = chunk.subarray(written);
          } else {
            this.buffer = null;
          }
          return written;
        }
async readFromStream(buffer, mayBeLess) {
          if (buffer.length === 0)
            return 0;
          let totalBytesRead = 0;
          if (this.buffer) {
            totalBytesRead += this.writeChunk(buffer, this.buffer);
          }
          while (totalBytesRead < buffer.length && !this.endOfStream) {
            const result = await this.reader.read();
            if (result.done) {
              this.endOfStream = true;
              break;
            }
            if (result.value) {
              totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
            }
          }
          if (totalBytesRead === 0 && this.endOfStream) {
            throw new EndOfStreamError();
          }
          return totalBytesRead;
        }
        abort() {
          this.interrupted = true;
          return this.reader.cancel();
        }
        async close() {
          await this.abort();
          this.reader.releaseLock();
        }
      }
      function makeWebStreamReader(stream) {
        try {
          const reader = stream.getReader({ mode: "byob" });
          if (reader instanceof ReadableStreamDefaultReader) {
            return new WebStreamDefaultReader(reader);
          }
          return new WebStreamByobReader(reader);
        } catch (error) {
          if (error instanceof TypeError) {
            return new WebStreamDefaultReader(stream.getReader());
          }
          throw error;
        }
      }
      class AbstractTokenizer {
constructor(options) {
          this.numBuffer = new Uint8Array(8);
          this.position = 0;
          this.onClose = options?.onClose;
          if (options?.abortSignal) {
            options.abortSignal.addEventListener("abort", () => {
              this.abort();
            });
          }
        }
async readToken(token, position = this.position) {
          const uint8Array = new Uint8Array(token.len);
          const len = await this.readBuffer(uint8Array, { position });
          if (len < token.len)
            throw new EndOfStreamError();
          return token.get(uint8Array, 0);
        }
async peekToken(token, position = this.position) {
          const uint8Array = new Uint8Array(token.len);
          const len = await this.peekBuffer(uint8Array, { position });
          if (len < token.len)
            throw new EndOfStreamError();
          return token.get(uint8Array, 0);
        }
async readNumber(token) {
          const len = await this.readBuffer(this.numBuffer, { length: token.len });
          if (len < token.len)
            throw new EndOfStreamError();
          return token.get(this.numBuffer, 0);
        }
async peekNumber(token) {
          const len = await this.peekBuffer(this.numBuffer, { length: token.len });
          if (len < token.len)
            throw new EndOfStreamError();
          return token.get(this.numBuffer, 0);
        }
async ignore(length) {
          if (this.fileInfo.size !== void 0) {
            const bytesLeft = this.fileInfo.size - this.position;
            if (length > bytesLeft) {
              this.position += bytesLeft;
              return bytesLeft;
            }
          }
          this.position += length;
          return length;
        }
        async close() {
          await this.abort();
          await this.onClose?.();
        }
        normalizeOptions(uint8Array, options) {
          if (!this.supportsRandomAccess() && options && options.position !== void 0 && options.position < this.position) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          return {
            ...{
              mayBeLess: false,
              offset: 0,
              length: uint8Array.length,
              position: this.position
            },
            ...options
          };
        }
        abort() {
          return Promise.resolve();
        }
      }
      const maxBufferSize = 256e3;
      class ReadStreamTokenizer extends AbstractTokenizer {
constructor(streamReader, options) {
          super(options);
          this.streamReader = streamReader;
          this.fileInfo = options?.fileInfo ?? {};
        }
async readBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          const skipBytes = normOptions.position - this.position;
          if (skipBytes > 0) {
            await this.ignore(skipBytes);
            return this.readBuffer(uint8Array, options);
          }
          if (skipBytes < 0) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          if (normOptions.length === 0) {
            return 0;
          }
          const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
          this.position += bytesRead;
          if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
            throw new EndOfStreamError();
          }
          return bytesRead;
        }
async peekBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          let bytesRead = 0;
          if (normOptions.position) {
            const skipBytes = normOptions.position - this.position;
            if (skipBytes > 0) {
              const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
              bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
              uint8Array.set(skipBuffer.subarray(skipBytes));
              return bytesRead - skipBytes;
            }
            if (skipBytes < 0) {
              throw new Error("Cannot peek from a negative offset in a stream");
            }
          }
          if (normOptions.length > 0) {
            try {
              bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
            } catch (err2) {
              if (options?.mayBeLess && err2 instanceof EndOfStreamError) {
                return 0;
              }
              throw err2;
            }
            if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
              throw new EndOfStreamError();
            }
          }
          return bytesRead;
        }
        async ignore(length) {
          const bufSize = Math.min(maxBufferSize, length);
          const buf = new Uint8Array(bufSize);
          let totBytesRead = 0;
          while (totBytesRead < length) {
            const remaining = length - totBytesRead;
            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
            if (bytesRead < 0) {
              return bytesRead;
            }
            totBytesRead += bytesRead;
          }
          return totBytesRead;
        }
        abort() {
          return this.streamReader.abort();
        }
        async close() {
          return this.streamReader.close();
        }
        supportsRandomAccess() {
          return false;
        }
      }
      class BufferTokenizer extends AbstractTokenizer {
constructor(uint8Array, options) {
          super(options);
          this.uint8Array = uint8Array;
          this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
        }
async readBuffer(uint8Array, options) {
          if (options?.position) {
            this.position = options.position;
          }
          const bytesRead = await this.peekBuffer(uint8Array, options);
          this.position += bytesRead;
          return bytesRead;
        }
async peekBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
          if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
            throw new EndOfStreamError();
          }
          uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
          return bytes2read;
        }
        close() {
          return super.close();
        }
        supportsRandomAccess() {
          return true;
        }
        setPosition(position) {
          this.position = position;
        }
      }
      function fromWebStream(webStream, options) {
        const webStreamReader = makeWebStreamReader(webStream);
        const _options = options ?? {};
        const chainedClose = _options.onClose;
        _options.onClose = async () => {
          await webStreamReader.close();
          if (chainedClose) {
            return chainedClose();
          }
        };
        return new ReadStreamTokenizer(webStreamReader, _options);
      }
      function fromBuffer(uint8Array, options) {
        return new BufferTokenizer(uint8Array, options);
      }
      var ieee754 = {};
var hasRequiredIeee754;
      function requireIeee754() {
        if (hasRequiredIeee754) return ieee754;
        hasRequiredIeee754 = 1;
        ieee754.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        ieee754.write = function(buffer, value2, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
          value2 = Math.abs(value2);
          if (isNaN(value2) || value2 === Infinity) {
            m = isNaN(value2) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value2) / Math.LN2);
            if (value2 * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value2 += rt / c;
            } else {
              value2 += rt * Math.pow(2, 1 - eBias);
            }
            if (value2 * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value2 * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e = e << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        };
        return ieee754;
      }
      var ieee754Exports = requireIeee754();
      function dv(array) {
        return new DataView(array.buffer, array.byteOffset);
      }
      const UINT8 = exports("d", {
        len: 1,
        get(array, offset) {
          return dv(array).getUint8(offset);
        },
        put(array, offset, value2) {
          dv(array).setUint8(offset, value2);
          return offset + 1;
        }
      });
      const UINT16_LE = exports("k", {
        len: 2,
        get(array, offset) {
          return dv(array).getUint16(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setUint16(offset, value2, true);
          return offset + 2;
        }
      });
      const UINT16_BE = exports("c", {
        len: 2,
        get(array, offset) {
          return dv(array).getUint16(offset);
        },
        put(array, offset, value2) {
          dv(array).setUint16(offset, value2);
          return offset + 2;
        }
      });
      const UINT24_LE = exports("N", {
        len: 3,
        get(array, offset) {
          const dataView = dv(array);
          return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
        },
        put(array, offset, value2) {
          const dataView = dv(array);
          dataView.setUint8(offset, value2 & 255);
          dataView.setUint16(offset + 1, value2 >> 8, true);
          return offset + 3;
        }
      });
      const UINT24_BE = exports("r", {
        len: 3,
        get(array, offset) {
          const dataView = dv(array);
          return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
        },
        put(array, offset, value2) {
          const dataView = dv(array);
          dataView.setUint16(offset, value2 >> 8);
          dataView.setUint8(offset + 2, value2 & 255);
          return offset + 3;
        }
      });
      const UINT32_LE = exports("e", {
        len: 4,
        get(array, offset) {
          return dv(array).getUint32(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setUint32(offset, value2, true);
          return offset + 4;
        }
      });
      const UINT32_BE = exports("b", {
        len: 4,
        get(array, offset) {
          return dv(array).getUint32(offset);
        },
        put(array, offset, value2) {
          dv(array).setUint32(offset, value2);
          return offset + 4;
        }
      });
      const INT8 = exports("H", {
        len: 1,
        get(array, offset) {
          return dv(array).getInt8(offset);
        },
        put(array, offset, value2) {
          dv(array).setInt8(offset, value2);
          return offset + 1;
        }
      });
      const INT16_BE = exports("I", {
        len: 2,
        get(array, offset) {
          return dv(array).getInt16(offset);
        },
        put(array, offset, value2) {
          dv(array).setInt16(offset, value2);
          return offset + 2;
        }
      });
      const INT16_LE = {
        len: 2,
        get(array, offset) {
          return dv(array).getInt16(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setInt16(offset, value2, true);
          return offset + 2;
        }
      };
      const INT24_LE = {
        len: 3,
        get(array, offset) {
          const unsigned = UINT24_LE.get(array, offset);
          return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
        },
        put(array, offset, value2) {
          const dataView = dv(array);
          dataView.setUint8(offset, value2 & 255);
          dataView.setUint16(offset + 1, value2 >> 8, true);
          return offset + 3;
        }
      };
      const INT24_BE = exports("D", {
        len: 3,
        get(array, offset) {
          const unsigned = UINT24_BE.get(array, offset);
          return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
        },
        put(array, offset, value2) {
          const dataView = dv(array);
          dataView.setUint16(offset, value2 >> 8);
          dataView.setUint8(offset + 2, value2 & 255);
          return offset + 3;
        }
      });
      const INT32_BE = exports("C", {
        len: 4,
        get(array, offset) {
          return dv(array).getInt32(offset);
        },
        put(array, offset, value2) {
          dv(array).setInt32(offset, value2);
          return offset + 4;
        }
      });
      const INT32_LE = exports("q", {
        len: 4,
        get(array, offset) {
          return dv(array).getInt32(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setInt32(offset, value2, true);
          return offset + 4;
        }
      });
      const UINT64_LE = exports("f", {
        len: 8,
        get(array, offset) {
          return dv(array).getBigUint64(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setBigUint64(offset, value2, true);
          return offset + 8;
        }
      });
      const INT64_LE = exports("p", {
        len: 8,
        get(array, offset) {
          return dv(array).getBigInt64(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setBigInt64(offset, value2, true);
          return offset + 8;
        }
      });
      const UINT64_BE = exports("x", {
        len: 8,
        get(array, offset) {
          return dv(array).getBigUint64(offset);
        },
        put(array, offset, value2) {
          dv(array).setBigUint64(offset, value2);
          return offset + 8;
        }
      });
      const INT64_BE = exports("o", {
        len: 8,
        get(array, offset) {
          return dv(array).getBigInt64(offset);
        },
        put(array, offset, value2) {
          dv(array).setBigInt64(offset, value2);
          return offset + 8;
        }
      });
      const Float16_BE = {
        len: 2,
        get(dataView, offset) {
          return ieee754Exports.read(dataView, offset, false, 10, this.len);
        },
        put(dataView, offset, value2) {
          ieee754Exports.write(dataView, value2, offset, false, 10, this.len);
          return offset + this.len;
        }
      };
      const Float16_LE = {
        len: 2,
        get(array, offset) {
          return ieee754Exports.read(array, offset, true, 10, this.len);
        },
        put(array, offset, value2) {
          ieee754Exports.write(array, value2, offset, true, 10, this.len);
          return offset + this.len;
        }
      };
      const Float32_BE = exports("w", {
        len: 4,
        get(array, offset) {
          return dv(array).getFloat32(offset);
        },
        put(array, offset, value2) {
          dv(array).setFloat32(offset, value2);
          return offset + 4;
        }
      });
      const Float32_LE = {
        len: 4,
        get(array, offset) {
          return dv(array).getFloat32(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setFloat32(offset, value2, true);
          return offset + 4;
        }
      };
      const Float64_BE = exports("v", {
        len: 8,
        get(array, offset) {
          return dv(array).getFloat64(offset);
        },
        put(array, offset, value2) {
          dv(array).setFloat64(offset, value2);
          return offset + 8;
        }
      });
      const Float64_LE = {
        len: 8,
        get(array, offset) {
          return dv(array).getFloat64(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setFloat64(offset, value2, true);
          return offset + 8;
        }
      };
      const Float80_BE = {
        len: 10,
        get(array, offset) {
          return ieee754Exports.read(array, offset, false, 63, this.len);
        },
        put(array, offset, value2) {
          ieee754Exports.write(array, value2, offset, false, 63, this.len);
          return offset + this.len;
        }
      };
      const Float80_LE = {
        len: 10,
        get(array, offset) {
          return ieee754Exports.read(array, offset, true, 63, this.len);
        },
        put(array, offset, value2) {
          ieee754Exports.write(array, value2, offset, true, 63, this.len);
          return offset + this.len;
        }
      };
      class IgnoreType {
constructor(len) {
          this.len = len;
        }

get(array, off2) {
        }
      }
      class Uint8ArrayType {
        constructor(len) {
          this.len = len;
        }
        get(array, offset) {
          return array.subarray(offset, offset + this.len);
        }
      } exports("U", Uint8ArrayType);
      class StringType {
        constructor(len, encoding) {
          this.len = len;
          this.encoding = encoding;
          this.textDecoder = new TextDecoder(encoding);
        }
        get(uint8Array, offset) {
          return this.textDecoder.decode(uint8Array.subarray(offset, offset + this.len));
        }
      } exports("S", StringType);
      class AnsiStringType {
        constructor(len) {
          this.len = len;
          this.textDecoder = new TextDecoder("windows-1252");
        }
        get(uint8Array, offset = 0) {
          return this.textDecoder.decode(uint8Array.subarray(offset, offset + this.len));
        }
      }
      const Token = exports("y", Object.freeze( Object.defineProperty({
        __proto__: null,
        AnsiStringType,
        Float16_BE,
        Float16_LE,
        Float32_BE,
        Float32_LE,
        Float64_BE,
        Float64_LE,
        Float80_BE,
        Float80_LE,
        INT16_BE,
        INT16_LE,
        INT24_BE,
        INT24_LE,
        INT32_BE,
        INT32_LE,
        INT64_BE,
        INT64_LE,
        INT8,
        IgnoreType,
        StringType,
        UINT16_BE,
        UINT16_LE,
        UINT24_BE,
        UINT24_LE,
        UINT32_BE,
        UINT32_LE,
        UINT64_BE,
        UINT64_LE,
        UINT8,
        Uint8ArrayType
      }, Symbol.toStringTag, { value: "Module" })));
      var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
      var fleb = new u8([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0,
0,
        0,
0
      ]);
      var fdeb = new u8([
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13,
0,
        0
      ]);
      var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      var freb = function(eb, start) {
        var b = new u16(31);
        for (var i = 0; i < 31; ++i) {
          b[i] = start += 1 << eb[i - 1];
        }
        var r = new i32(b[30]);
        for (var i = 1; i < 30; ++i) {
          for (var j = b[i]; j < b[i + 1]; ++j) {
            r[j] = j - b[i] << 5 | i;
          }
        }
        return { b, r };
      };
      var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
      fl[28] = 258, revfl[258] = 28;
      var _b = freb(fdeb, 0), fd = _b.b;
      var rev = new u16(32768);
      for (var i = 0; i < 32768; ++i) {
        var x = (i & 43690) >> 1 | (i & 21845) << 1;
        x = (x & 52428) >> 2 | (x & 13107) << 2;
        x = (x & 61680) >> 4 | (x & 3855) << 4;
        rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
      }
      var hMap = (function(cd, mb, r) {
        var s = cd.length;
        var i = 0;
        var l = new u16(mb);
        for (; i < s; ++i) {
          if (cd[i])
            ++l[cd[i] - 1];
        }
        var le = new u16(mb);
        for (i = 1; i < mb; ++i) {
          le[i] = le[i - 1] + l[i - 1] << 1;
        }
        var co;
        {
          co = new u16(1 << mb);
          var rvb = 15 - mb;
          for (i = 0; i < s; ++i) {
            if (cd[i]) {
              var sv = i << 4 | cd[i];
              var r_1 = mb - cd[i];
              var v = le[cd[i] - 1]++ << r_1;
              for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
                co[rev[v] >> rvb] = sv;
              }
            }
          }
        }
        return co;
      });
      var flt = new u8(288);
      for (var i = 0; i < 144; ++i)
        flt[i] = 8;
      for (var i = 144; i < 256; ++i)
        flt[i] = 9;
      for (var i = 256; i < 280; ++i)
        flt[i] = 7;
      for (var i = 280; i < 288; ++i)
        flt[i] = 8;
      var fdt = new u8(32);
      for (var i = 0; i < 32; ++i)
        fdt[i] = 5;
      var flrm = hMap(flt, 9);
      var fdrm = hMap(fdt, 5);
      var max = function(a) {
        var m = a[0];
        for (var i = 1; i < a.length; ++i) {
          if (a[i] > m)
            m = a[i];
        }
        return m;
      };
      var bits = function(d, p, m) {
        var o = p / 8 | 0;
        return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
      };
      var bits16 = function(d, p) {
        var o = p / 8 | 0;
        return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
      };
      var shft = function(p) {
        return (p + 7) / 8 | 0;
      };
      var slc = function(v, s, e) {
        if (e == null || e > v.length)
          e = v.length;
        return new u8(v.subarray(s, e));
      };
      var ec = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data"
];
      var err = function(ind, msg, nt) {
        var e = new Error(msg || ec[ind]);
        e.code = ind;
        if (Error.captureStackTrace)
          Error.captureStackTrace(e, err);
        if (!nt)
          throw e;
        return e;
      };
      var inflt = function(dat, st, buf, dict) {
        var sl = dat.length, dl = 0;
        if (!sl || st.f && !st.l)
          return buf || new u8(0);
        var noBuf = !buf;
        var resize = noBuf || st.i != 2;
        var noSt = st.i;
        if (noBuf)
          buf = new u8(sl * 3);
        var cbuf = function(l2) {
          var bl = buf.length;
          if (l2 > bl) {
            var nbuf = new u8(Math.max(bl * 2, l2));
            nbuf.set(buf);
            buf = nbuf;
          }
        };
        var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
        var tbts = sl * 8;
        do {
          if (!lm) {
            final = bits(dat, pos, 1);
            var type = bits(dat, pos + 1, 3);
            pos += 3;
            if (!type) {
              var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
              if (t > sl) {
                if (noSt)
                  err(0);
                break;
              }
              if (resize)
                cbuf(bt + l);
              buf.set(dat.subarray(s, t), bt);
              st.b = bt += l, st.p = pos = t * 8, st.f = final;
              continue;
            } else if (type == 1)
              lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
            else if (type == 2) {
              var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
              var tl = hLit + bits(dat, pos + 5, 31) + 1;
              pos += 14;
              var ldt = new u8(tl);
              var clt = new u8(19);
              for (var i = 0; i < hcLen; ++i) {
                clt[clim[i]] = bits(dat, pos + i * 3, 7);
              }
              pos += hcLen * 3;
              var clb = max(clt), clbmsk = (1 << clb) - 1;
              var clm = hMap(clt, clb);
              for (var i = 0; i < tl; ) {
                var r = clm[bits(dat, pos, clbmsk)];
                pos += r & 15;
                var s = r >> 4;
                if (s < 16) {
                  ldt[i++] = s;
                } else {
                  var c = 0, n = 0;
                  if (s == 16)
                    n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
                  else if (s == 17)
                    n = 3 + bits(dat, pos, 7), pos += 3;
                  else if (s == 18)
                    n = 11 + bits(dat, pos, 127), pos += 7;
                  while (n--)
                    ldt[i++] = c;
                }
              }
              var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
              lbt = max(lt);
              dbt = max(dt);
              lm = hMap(lt, lbt);
              dm = hMap(dt, dbt);
            } else
              err(1);
            if (pos > tbts) {
              if (noSt)
                err(0);
              break;
            }
          }
          if (resize)
            cbuf(bt + 131072);
          var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
          var lpos = pos;
          for (; ; lpos = pos) {
            var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
            pos += c & 15;
            if (pos > tbts) {
              if (noSt)
                err(0);
              break;
            }
            if (!c)
              err(2);
            if (sym < 256)
              buf[bt++] = sym;
            else if (sym == 256) {
              lpos = pos, lm = null;
              break;
            } else {
              var add = sym - 254;
              if (sym > 264) {
                var i = sym - 257, b = fleb[i];
                add = bits(dat, pos, (1 << b) - 1) + fl[i];
                pos += b;
              }
              var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
              if (!d)
                err(3);
              pos += d & 15;
              var dt = fd[dsym];
              if (dsym > 3) {
                var b = fdeb[dsym];
                dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
              }
              if (pos > tbts) {
                if (noSt)
                  err(0);
                break;
              }
              if (resize)
                cbuf(bt + 131072);
              var end = bt + add;
              if (bt < dt) {
                var shift = dl - dt, dend = Math.min(dt, end);
                if (shift + bt < 0)
                  err(3);
                for (; bt < dend; ++bt)
                  buf[bt] = dict[shift + bt];
              }
              for (; bt < end; ++bt)
                buf[bt] = buf[bt - dt];
            }
          }
          st.l = lm, st.p = lpos, st.b = bt, st.f = final;
          if (lm)
            final = 1, st.m = lbt, st.d = dm, st.n = dbt;
        } while (!final);
        return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
      };
      var et = new u8(0);
      var gzs = function(d) {
        if (d[0] != 31 || d[1] != 139 || d[2] != 8)
          err(6, "invalid gzip data");
        var flg = d[3];
        var st = 10;
        if (flg & 4)
          st += (d[10] | d[11] << 8) + 2;
        for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])
          ;
        return st + (flg & 2);
      };
      var gzl = function(d) {
        var l = d.length;
        return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
      };
      var zls = function(d, dict) {
        if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
          err(6, "invalid zlib data");
        if ((d[1] >> 5 & 1) == 1)
          err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
        return (d[1] >> 3 & 4) + 2;
      };
      function inflateSync(data, opts) {
        return inflt(data, { i: 2 }, opts, opts);
      }
      function gunzipSync(data, opts) {
        var st = gzs(data);
        if (st + 8 > data.length)
          err(6, "invalid gzip data");
        return inflt(data.subarray(st, -8), { i: 2 }, new u8(gzl(data)), opts);
      }
      function unzlibSync(data, opts) {
        return inflt(data.subarray(zls(data), -4), { i: 2 }, opts, opts);
      }
      function decompressSync(data, opts) {
        return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
      }
      var td = typeof TextDecoder != "undefined" && new TextDecoder();
      var tds = 0;
      try {
        td.decode(et, { stream: true });
        tds = 1;
      } catch (e) {
      }
      var browser$1 = { exports: {} };
      var ms;
      var hasRequiredMs;
      function requireMs() {
        if (hasRequiredMs) return ms;
        hasRequiredMs = 1;
        var s = 1e3;
        var m = s * 60;
        var h = m * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        ms = function(val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse(val);
          } else if (type === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
          );
        };
        function parse(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str
          );
          if (!match) {
            return;
          }
          var n = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n * y;
            case "weeks":
            case "week":
            case "w":
              return n * w;
            case "days":
            case "day":
            case "d":
              return n * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n * m;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n;
            default:
              return void 0;
          }
        }
        function fmtShort(ms2) {
          var msAbs = Math.abs(ms2);
          if (msAbs >= d) {
            return Math.round(ms2 / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms2 / h) + "h";
          }
          if (msAbs >= m) {
            return Math.round(ms2 / m) + "m";
          }
          if (msAbs >= s) {
            return Math.round(ms2 / s) + "s";
          }
          return ms2 + "ms";
        }
        function fmtLong(ms2) {
          var msAbs = Math.abs(ms2);
          if (msAbs >= d) {
            return plural(ms2, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms2, msAbs, h, "hour");
          }
          if (msAbs >= m) {
            return plural(ms2, msAbs, m, "minute");
          }
          if (msAbs >= s) {
            return plural(ms2, msAbs, s, "second");
          }
          return ms2 + " ms";
        }
        function plural(ms2, msAbs, n, name2) {
          var isPlural = msAbs >= n * 1.5;
          return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
        }
        return ms;
      }
      var common$1;
      var hasRequiredCommon$1;
      function requireCommon$1() {
        if (hasRequiredCommon$1) return common$1;
        hasRequiredCommon$1 = 1;
        function setup(env) {
          createDebug.debug = createDebug;
          createDebug.default = createDebug;
          createDebug.coerce = coerce;
          createDebug.disable = disable;
          createDebug.enable = enable;
          createDebug.enabled = enabled;
          createDebug.humanize = requireMs();
          createDebug.destroy = destroy;
          Object.keys(env).forEach((key) => {
            createDebug[key] = env[key];
          });
          createDebug.names = [];
          createDebug.skips = [];
          createDebug.formatters = {};
          function selectColor(namespace) {
            let hash = 0;
            for (let i = 0; i < namespace.length; i++) {
              hash = (hash << 5) - hash + namespace.charCodeAt(i);
              hash |= 0;
            }
            return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
          }
          createDebug.selectColor = selectColor;
          function createDebug(namespace) {
            let prevTime;
            let enableOverride = null;
            let namespacesCache;
            let enabledCache;
            function debug2(...args) {
              if (!debug2.enabled) {
                return;
              }
              const self2 = debug2;
              const curr = Number( new Date());
              const ms2 = curr - (prevTime || curr);
              self2.diff = ms2;
              self2.prev = prevTime;
              self2.curr = curr;
              prevTime = curr;
              args[0] = createDebug.coerce(args[0]);
              if (typeof args[0] !== "string") {
                args.unshift("%O");
              }
              let index = 0;
              args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                if (match === "%%") {
                  return "%";
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === "function") {
                  const val = args[index];
                  match = formatter.call(self2, val);
                  args.splice(index, 1);
                  index--;
                }
                return match;
              });
              createDebug.formatArgs.call(self2, args);
              const logFn = self2.log || createDebug.log;
              logFn.apply(self2, args);
            }
            debug2.namespace = namespace;
            debug2.useColors = createDebug.useColors();
            debug2.color = createDebug.selectColor(namespace);
            debug2.extend = extend;
            debug2.destroy = createDebug.destroy;
            Object.defineProperty(debug2, "enabled", {
              enumerable: true,
              configurable: false,
              get: () => {
                if (enableOverride !== null) {
                  return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                  namespacesCache = createDebug.namespaces;
                  enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
              },
              set: (v) => {
                enableOverride = v;
              }
            });
            if (typeof createDebug.init === "function") {
              createDebug.init(debug2);
            }
            return debug2;
          }
          function extend(namespace, delimiter) {
            const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
            newDebug.log = this.log;
            return newDebug;
          }
          function enable(namespaces) {
            createDebug.save(namespaces);
            createDebug.namespaces = namespaces;
            createDebug.names = [];
            createDebug.skips = [];
            const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
            for (const ns of split) {
              if (ns[0] === "-") {
                createDebug.skips.push(ns.slice(1));
              } else {
                createDebug.names.push(ns);
              }
            }
          }
          function matchesTemplate(search, template) {
            let searchIndex = 0;
            let templateIndex = 0;
            let starIndex = -1;
            let matchIndex = 0;
            while (searchIndex < search.length) {
              if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
                if (template[templateIndex] === "*") {
                  starIndex = templateIndex;
                  matchIndex = searchIndex;
                  templateIndex++;
                } else {
                  searchIndex++;
                  templateIndex++;
                }
              } else if (starIndex !== -1) {
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
              } else {
                return false;
              }
            }
            while (templateIndex < template.length && template[templateIndex] === "*") {
              templateIndex++;
            }
            return templateIndex === template.length;
          }
          function disable() {
            const namespaces = [
              ...createDebug.names,
              ...createDebug.skips.map((namespace) => "-" + namespace)
            ].join(",");
            createDebug.enable("");
            return namespaces;
          }
          function enabled(name2) {
            for (const skip of createDebug.skips) {
              if (matchesTemplate(name2, skip)) {
                return false;
              }
            }
            for (const ns of createDebug.names) {
              if (matchesTemplate(name2, ns)) {
                return true;
              }
            }
            return false;
          }
          function coerce(val) {
            if (val instanceof Error) {
              return val.stack || val.message;
            }
            return val;
          }
          function destroy() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
          createDebug.enable(createDebug.load());
          return createDebug;
        }
        common$1 = setup;
        return common$1;
      }
      var hasRequiredBrowser$1;
      function requireBrowser$1() {
        if (hasRequiredBrowser$1) return browser$1.exports;
        hasRequiredBrowser$1 = 1;
        (function(module, exports) {
          var define_process_env_default = {};
          exports.formatArgs = formatArgs;
          exports.save = save;
          exports.load = load;
          exports.useColors = useColors;
          exports.storage = localstorage();
          exports.destroy = (() => {
            let warned = false;
            return () => {
              if (!warned) {
                warned = true;
                console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
              }
            };
          })();
          exports.colors = [
            "#0000CC",
            "#0000FF",
            "#0033CC",
            "#0033FF",
            "#0066CC",
            "#0066FF",
            "#0099CC",
            "#0099FF",
            "#00CC00",
            "#00CC33",
            "#00CC66",
            "#00CC99",
            "#00CCCC",
            "#00CCFF",
            "#3300CC",
            "#3300FF",
            "#3333CC",
            "#3333FF",
            "#3366CC",
            "#3366FF",
            "#3399CC",
            "#3399FF",
            "#33CC00",
            "#33CC33",
            "#33CC66",
            "#33CC99",
            "#33CCCC",
            "#33CCFF",
            "#6600CC",
            "#6600FF",
            "#6633CC",
            "#6633FF",
            "#66CC00",
            "#66CC33",
            "#9900CC",
            "#9900FF",
            "#9933CC",
            "#9933FF",
            "#99CC00",
            "#99CC33",
            "#CC0000",
            "#CC0033",
            "#CC0066",
            "#CC0099",
            "#CC00CC",
            "#CC00FF",
            "#CC3300",
            "#CC3333",
            "#CC3366",
            "#CC3399",
            "#CC33CC",
            "#CC33FF",
            "#CC6600",
            "#CC6633",
            "#CC9900",
            "#CC9933",
            "#CCCC00",
            "#CCCC33",
            "#FF0000",
            "#FF0033",
            "#FF0066",
            "#FF0099",
            "#FF00CC",
            "#FF00FF",
            "#FF3300",
            "#FF3333",
            "#FF3366",
            "#FF3399",
            "#FF33CC",
            "#FF33FF",
            "#FF6600",
            "#FF6633",
            "#FF9900",
            "#FF9933",
            "#FFCC00",
            "#FFCC33"
          ];
          function useColors() {
            if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
              return true;
            }
            if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
              return false;
            }
            let m;
            return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) ||

typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 ||
typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          }
          function formatArgs(args) {
            args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
            if (!this.useColors) {
              return;
            }
            const c = "color: " + this.color;
            args.splice(1, 0, c, "color: inherit");
            let index = 0;
            let lastC = 0;
            args[0].replace(/%[a-zA-Z%]/g, (match) => {
              if (match === "%%") {
                return;
              }
              index++;
              if (match === "%c") {
                lastC = index;
              }
            });
            args.splice(lastC, 0, c);
          }
          exports.log = console.debug || console.log || (() => {
          });
          function save(namespaces) {
            try {
              if (namespaces) {
                exports.storage.setItem("debug", namespaces);
              } else {
                exports.storage.removeItem("debug");
              }
            } catch (error) {
            }
          }
          function load() {
            let r;
            try {
              r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
            } catch (error) {
            }
            if (!r && typeof process !== "undefined" && "env" in process) {
              r = define_process_env_default.DEBUG;
            }
            return r;
          }
          function localstorage() {
            try {
              return localStorage;
            } catch (error) {
            }
          }
          module.exports = requireCommon$1()(exports);
          const { formatters } = module.exports;
          formatters.j = function(v) {
            try {
              return JSON.stringify(v);
            } catch (error) {
              return "[UnexpectedJSONParseError]: " + error.message;
            }
          };
        })(browser$1, browser$1.exports);
        return browser$1.exports;
      }
      var browserExports$1 = requireBrowser$1();
      const initDebug = exports("i", getDefaultExportFromCjs(browserExports$1));
      const Signature = {
        LocalFileHeader: 67324752,
        DataDescriptor: 134695760,
        CentralFileHeader: 33639248,
        EndOfCentralDirectory: 101010256
      };
      const DataDescriptor = {
        get(array) {
          UINT16_LE.get(array, 6);
          return {
            signature: UINT32_LE.get(array, 0),
            compressedSize: UINT32_LE.get(array, 8),
            uncompressedSize: UINT32_LE.get(array, 12)
          };
        },
        len: 16
      };
      const LocalFileHeaderToken = {
        get(array) {
          const flags = UINT16_LE.get(array, 6);
          return {
            signature: UINT32_LE.get(array, 0),
            minVersion: UINT16_LE.get(array, 4),
            dataDescriptor: !!(flags & 8),
            compressedMethod: UINT16_LE.get(array, 8),
            compressedSize: UINT32_LE.get(array, 18),
            uncompressedSize: UINT32_LE.get(array, 22),
            filenameLength: UINT16_LE.get(array, 26),
            extraFieldLength: UINT16_LE.get(array, 28),
            filename: null
          };
        },
        len: 30
      };
      const EndOfCentralDirectoryRecordToken = {
        get(array) {
          return {
            signature: UINT32_LE.get(array, 0),
            nrOfThisDisk: UINT16_LE.get(array, 4),
            nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
            nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
            nrOfEntriesOfSize: UINT16_LE.get(array, 10),
            sizeOfCd: UINT32_LE.get(array, 12),
            offsetOfStartOfCd: UINT32_LE.get(array, 16),
            zipFileCommentLength: UINT16_LE.get(array, 20)
          };
        },
        len: 22
      };
      const FileHeader = {
        get(array) {
          const flags = UINT16_LE.get(array, 8);
          return {
            signature: UINT32_LE.get(array, 0),
            minVersion: UINT16_LE.get(array, 6),
            dataDescriptor: !!(flags & 8),
            compressedMethod: UINT16_LE.get(array, 10),
            compressedSize: UINT32_LE.get(array, 20),
            uncompressedSize: UINT32_LE.get(array, 24),
            filenameLength: UINT16_LE.get(array, 28),
            extraFieldLength: UINT16_LE.get(array, 30),
            fileCommentLength: UINT16_LE.get(array, 32),
            relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
            filename: null
          };
        },
        len: 46
      };
      function signatureToArray(signature) {
        const signatureBytes = new Uint8Array(UINT32_LE.len);
        UINT32_LE.put(signatureBytes, 0, signature);
        return signatureBytes;
      }
      const debug$4 = initDebug("tokenizer:inflate");
      const syncBufferSize = 256 * 1024;
      const ddSignatureArray = signatureToArray(Signature.DataDescriptor);
      const eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
      class ZipHandler {
        constructor(tokenizer) {
          this.tokenizer = tokenizer;
          this.syncBuffer = new Uint8Array(syncBufferSize);
        }
        async isZip() {
          return await this.peekSignature() === Signature.LocalFileHeader;
        }
        peekSignature() {
          return this.tokenizer.peekToken(UINT32_LE);
        }
        async findEndOfCentralDirectoryLocator() {
          const randomReadTokenizer = this.tokenizer;
          const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
          const buffer = this.syncBuffer.subarray(0, chunkLength);
          await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
          for (let i = buffer.length - 4; i >= 0; i--) {
            if (buffer[i] === eocdSignatureBytes[0] && buffer[i + 1] === eocdSignatureBytes[1] && buffer[i + 2] === eocdSignatureBytes[2] && buffer[i + 3] === eocdSignatureBytes[3]) {
              return randomReadTokenizer.fileInfo.size - chunkLength + i;
            }
          }
          return -1;
        }
        async readCentralDirectory() {
          if (!this.tokenizer.supportsRandomAccess()) {
            debug$4("Cannot reading central-directory without random-read support");
            return;
          }
          debug$4("Reading central-directory...");
          const pos = this.tokenizer.position;
          const offset = await this.findEndOfCentralDirectoryLocator();
          if (offset > 0) {
            debug$4("Central-directory 32-bit signature found");
            const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
            const files = [];
            this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
            for (let n = 0; n < eocdHeader.nrOfEntriesOfSize; ++n) {
              const entry = await this.tokenizer.readToken(FileHeader);
              if (entry.signature !== Signature.CentralFileHeader) {
                throw new Error("Expected Central-File-Header signature");
              }
              entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, "utf-8"));
              await this.tokenizer.ignore(entry.extraFieldLength);
              await this.tokenizer.ignore(entry.fileCommentLength);
              files.push(entry);
              debug$4(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
            }
            this.tokenizer.setPosition(pos);
            return files;
          }
          this.tokenizer.setPosition(pos);
        }
        async unzip(fileCb) {
          const entries = await this.readCentralDirectory();
          if (entries) {
            return this.iterateOverCentralDirectory(entries, fileCb);
          }
          let stop = false;
          do {
            const zipHeader = await this.readLocalFileHeader();
            if (!zipHeader)
              break;
            const next = fileCb(zipHeader);
            stop = !!next.stop;
            let fileData = void 0;
            await this.tokenizer.ignore(zipHeader.extraFieldLength);
            if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
              const chunks = [];
              let len = syncBufferSize;
              debug$4("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
              let nextHeaderIndex = -1;
              while (nextHeaderIndex < 0 && len === syncBufferSize) {
                len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
                nextHeaderIndex = indexOf$1(this.syncBuffer.subarray(0, len), ddSignatureArray);
                const size2 = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
                if (next.handler) {
                  const data = new Uint8Array(size2);
                  await this.tokenizer.readBuffer(data);
                  chunks.push(data);
                } else {
                  await this.tokenizer.ignore(size2);
                }
              }
              debug$4(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
              if (next.handler) {
                await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
              }
            } else {
              if (next.handler) {
                debug$4(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
                fileData = new Uint8Array(zipHeader.compressedSize);
                await this.tokenizer.readBuffer(fileData);
                await this.inflate(zipHeader, fileData, next.handler);
              } else {
                debug$4(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
                await this.tokenizer.ignore(zipHeader.compressedSize);
              }
            }
            debug$4(`Reading data-descriptor at pos=${this.tokenizer.position}`);
            if (zipHeader.dataDescriptor) {
              const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
              if (dataDescriptor.signature !== 134695760) {
                throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
              }
            }
          } while (!stop);
        }
        async iterateOverCentralDirectory(entries, fileCb) {
          for (const fileHeader of entries) {
            const next = fileCb(fileHeader);
            if (next.handler) {
              this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
              const zipHeader = await this.readLocalFileHeader();
              if (zipHeader) {
                await this.tokenizer.ignore(zipHeader.extraFieldLength);
                const fileData = new Uint8Array(fileHeader.compressedSize);
                await this.tokenizer.readBuffer(fileData);
                await this.inflate(zipHeader, fileData, next.handler);
              }
            }
            if (next.stop)
              break;
          }
        }
        inflate(zipHeader, fileData, cb) {
          if (zipHeader.compressedMethod === 0) {
            return cb(fileData);
          }
          debug$4(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
          const uncompressedData = decompressSync(fileData);
          return cb(uncompressedData);
        }
        async readLocalFileHeader() {
          const signature = await this.tokenizer.peekToken(UINT32_LE);
          if (signature === Signature.LocalFileHeader) {
            const header = await this.tokenizer.readToken(LocalFileHeaderToken);
            header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, "utf-8"));
            return header;
          }
          if (signature === Signature.CentralFileHeader) {
            return false;
          }
          if (signature === 3759263696) {
            throw new Error("Encrypted ZIP");
          }
          throw new Error("Unexpected signature");
        }
      }
      function indexOf$1(buffer, portion) {
        const bufferLength = buffer.length;
        const portionLength = portion.length;
        if (portionLength > bufferLength)
          return -1;
        for (let i = 0; i <= bufferLength - portionLength; i++) {
          let found = true;
          for (let j = 0; j < portionLength; j++) {
            if (buffer[i + j] !== portion[j]) {
              found = false;
              break;
            }
          }
          if (found) {
            return i;
          }
        }
        return -1;
      }
      function mergeArrays(chunks) {
        const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
        const mergedArray = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          mergedArray.set(chunk, offset);
          offset += chunk.length;
        }
        return mergedArray;
      }
      const objectToString = Object.prototype.toString;
      const uint8ArrayStringified = "[object Uint8Array]";
      const arrayBufferStringified = "[object ArrayBuffer]";
      function isType(value2, typeConstructor, typeStringified) {
        if (!value2) {
          return false;
        }
        if (value2.constructor === typeConstructor) {
          return true;
        }
        return objectToString.call(value2) === typeStringified;
      }
      function isUint8Array(value2) {
        return isType(value2, Uint8Array, uint8ArrayStringified);
      }
      function isArrayBuffer(value2) {
        return isType(value2, ArrayBuffer, arrayBufferStringified);
      }
      function isUint8ArrayOrArrayBuffer(value2) {
        return isUint8Array(value2) || isArrayBuffer(value2);
      }
      function assertUint8Array(value2) {
        if (!isUint8Array(value2)) {
          throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof value2}\``);
        }
      }
      function assertUint8ArrayOrArrayBuffer(value2) {
        if (!isUint8ArrayOrArrayBuffer(value2)) {
          throw new TypeError(`Expected \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof value2}\``);
        }
      }
      const cachedDecoders = {
        utf8: new globalThis.TextDecoder("utf8")
      };
      function uint8ArrayToString(array, encoding = "utf8") {
        assertUint8ArrayOrArrayBuffer(array);
        cachedDecoders[encoding] ??= new globalThis.TextDecoder(encoding);
        return cachedDecoders[encoding].decode(array);
      }
      function assertString(value2) {
        if (typeof value2 !== "string") {
          throw new TypeError(`Expected \`string\`, got \`${typeof value2}\``);
        }
      }
      const cachedEncoder = new globalThis.TextEncoder();
      function stringToUint8Array(string) {
        assertString(string);
        return cachedEncoder.encode(string);
      }
      const byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
      function uint8ArrayToHex(array) {
        assertUint8Array(array);
        let hexString = "";
        for (let index = 0; index < array.length; index++) {
          hexString += byteToHexLookupTable[array[index]];
        }
        return hexString;
      }
      const hexToDecimalLookupTable = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        b: 11,
        c: 12,
        d: 13,
        e: 14,
        f: 15,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15
      };
      function hexToUint8Array(hexString) {
        assertString(hexString);
        if (hexString.length % 2 !== 0) {
          throw new Error("Invalid Hex string length.");
        }
        const resultLength = hexString.length / 2;
        const bytes = new Uint8Array(resultLength);
        for (let index = 0; index < resultLength; index++) {
          const highNibble = hexToDecimalLookupTable[hexString[index * 2]];
          const lowNibble = hexToDecimalLookupTable[hexString[index * 2 + 1]];
          if (highNibble === void 0 || lowNibble === void 0) {
            throw new Error(`Invalid Hex character encountered at position ${index * 2}`);
          }
          bytes[index] = highNibble << 4 | lowNibble;
        }
        return bytes;
      }
      function getUintBE(view) {
        const { byteLength } = view;
        if (byteLength === 6) {
          return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
        }
        if (byteLength === 5) {
          return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
        }
        if (byteLength === 4) {
          return view.getUint32(0);
        }
        if (byteLength === 3) {
          return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
        }
        if (byteLength === 2) {
          return view.getUint16(0);
        }
        if (byteLength === 1) {
          return view.getUint8(0);
        }
      }
      function indexOf(array, value2) {
        const arrayLength = array.length;
        const valueLength = value2.length;
        if (valueLength === 0) {
          return -1;
        }
        if (valueLength > arrayLength) {
          return -1;
        }
        const validOffsetLength = arrayLength - valueLength;
        for (let index = 0; index <= validOffsetLength; index++) {
          let isMatch = true;
          for (let index2 = 0; index2 < valueLength; index2++) {
            if (array[index + index2] !== value2[index2]) {
              isMatch = false;
              break;
            }
          }
          if (isMatch) {
            return index;
          }
        }
        return -1;
      }
      function includes(array, value2) {
        return indexOf(array, value2) !== -1;
      }
      function stringToBytes(string) {
        return [...string].map((character) => character.charCodeAt(0));
      }
      function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
        const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
        if (Number.isNaN(readSum)) {
          return false;
        }
        let sum = 8 * 32;
        for (let index = offset; index < offset + 148; index++) {
          sum += arrayBuffer[index];
        }
        for (let index = offset + 156; index < offset + 512; index++) {
          sum += arrayBuffer[index];
        }
        return readSum === sum;
      }
      const uint32SyncSafeToken = {
        get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
        len: 4
      };
      const extensions = [
        "jpg",
        "png",
        "apng",
        "gif",
        "webp",
        "flif",
        "xcf",
        "cr2",
        "cr3",
        "orf",
        "arw",
        "dng",
        "nef",
        "rw2",
        "raf",
        "tif",
        "bmp",
        "icns",
        "jxr",
        "psd",
        "indd",
        "zip",
        "tar",
        "rar",
        "gz",
        "bz2",
        "7z",
        "dmg",
        "mp4",
        "mid",
        "mkv",
        "webm",
        "mov",
        "avi",
        "mpg",
        "mp2",
        "mp3",
        "m4a",
        "oga",
        "ogg",
        "ogv",
        "opus",
        "flac",
        "wav",
        "spx",
        "amr",
        "pdf",
        "epub",
        "elf",
        "macho",
        "exe",
        "swf",
        "rtf",
        "wasm",
        "woff",
        "woff2",
        "eot",
        "ttf",
        "otf",
        "ttc",
        "ico",
        "flv",
        "ps",
        "xz",
        "sqlite",
        "nes",
        "crx",
        "xpi",
        "cab",
        "deb",
        "ar",
        "rpm",
        "Z",
        "lz",
        "cfb",
        "mxf",
        "mts",
        "blend",
        "bpg",
        "docx",
        "pptx",
        "xlsx",
        "3gp",
        "3g2",
        "j2c",
        "jp2",
        "jpm",
        "jpx",
        "mj2",
        "aif",
        "qcp",
        "odt",
        "ods",
        "odp",
        "xml",
        "mobi",
        "heic",
        "cur",
        "ktx",
        "ape",
        "wv",
        "dcm",
        "ics",
        "glb",
        "pcap",
        "dsf",
        "lnk",
        "alias",
        "voc",
        "ac3",
        "m4v",
        "m4p",
        "m4b",
        "f4v",
        "f4p",
        "f4b",
        "f4a",
        "mie",
        "asf",
        "ogm",
        "ogx",
        "mpc",
        "arrow",
        "shp",
        "aac",
        "mp1",
        "it",
        "s3m",
        "xm",
        "ai",
        "skp",
        "avif",
        "eps",
        "lzh",
        "pgp",
        "asar",
        "stl",
        "chm",
        "3mf",
        "zst",
        "jxl",
        "vcf",
        "jls",
        "pst",
        "dwg",
        "parquet",
        "class",
        "arj",
        "cpio",
        "ace",
        "avro",
        "icc",
        "fbx",
        "vsdx",
        "vtt",
        "apk",
        "drc",
        "lz4",
        "potx",
        "xltx",
        "dotx",
        "xltm",
        "ott",
        "ots",
        "otp",
        "odg",
        "otg",
        "xlsm",
        "docm",
        "dotm",
        "potm",
        "pptm",
        "jar",
        "rm",
        "ppsm",
        "ppsx"
      ];
      const mimeTypes = [
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "image/flif",
        "image/x-xcf",
        "image/x-canon-cr2",
        "image/x-canon-cr3",
        "image/tiff",
        "image/bmp",
        "image/vnd.ms-photo",
        "image/vnd.adobe.photoshop",
        "application/x-indesign",
        "application/epub+zip",
        "application/x-xpinstall",
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
        "application/vnd.oasis.opendocument.text",
        "application/vnd.oasis.opendocument.spreadsheet",
        "application/vnd.oasis.opendocument.presentation",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
        "application/zip",
        "application/x-tar",
        "application/x-rar-compressed",
        "application/gzip",
        "application/x-bzip2",
        "application/x-7z-compressed",
        "application/x-apple-diskimage",
        "application/x-apache-arrow",
        "video/mp4",
        "audio/midi",
        "video/x-matroska",
        "video/webm",
        "video/quicktime",
        "video/vnd.avi",
        "audio/wav",
        "audio/qcelp",
        "audio/x-ms-asf",
        "video/x-ms-asf",
        "application/vnd.ms-asf",
        "video/mpeg",
        "video/3gpp",
        "audio/mpeg",
        "audio/mp4",
"video/ogg",
        "audio/ogg",
        "audio/ogg; codecs=opus",
        "application/ogg",
        "audio/x-flac",
        "audio/ape",
        "audio/wavpack",
        "audio/amr",
        "application/pdf",
        "application/x-elf",
        "application/x-mach-binary",
        "application/x-msdownload",
        "application/x-shockwave-flash",
        "application/rtf",
        "application/wasm",
        "font/woff",
        "font/woff2",
        "application/vnd.ms-fontobject",
        "font/ttf",
        "font/otf",
        "font/collection",
        "image/x-icon",
        "video/x-flv",
        "application/postscript",
        "application/eps",
        "application/x-xz",
        "application/x-sqlite3",
        "application/x-nintendo-nes-rom",
        "application/x-google-chrome-extension",
        "application/vnd.ms-cab-compressed",
        "application/x-deb",
        "application/x-unix-archive",
        "application/x-rpm",
        "application/x-compress",
        "application/x-lzip",
        "application/x-cfb",
        "application/x-mie",
        "application/mxf",
        "video/mp2t",
        "application/x-blender",
        "image/bpg",
        "image/j2c",
        "image/jp2",
        "image/jpx",
        "image/jpm",
        "image/mj2",
        "audio/aiff",
        "application/xml",
        "application/x-mobipocket-ebook",
        "image/heif",
        "image/heif-sequence",
        "image/heic",
        "image/heic-sequence",
        "image/icns",
        "image/ktx",
        "application/dicom",
        "audio/x-musepack",
        "text/calendar",
        "text/vcard",
        "text/vtt",
        "model/gltf-binary",
        "application/vnd.tcpdump.pcap",
        "audio/x-dsf",
"application/x.ms.shortcut",
"application/x.apple.alias",
"audio/x-voc",
        "audio/vnd.dolby.dd-raw",
        "audio/x-m4a",
        "image/apng",
        "image/x-olympus-orf",
        "image/x-sony-arw",
        "image/x-adobe-dng",
        "image/x-nikon-nef",
        "image/x-panasonic-rw2",
        "image/x-fujifilm-raf",
        "video/x-m4v",
        "video/3gpp2",
        "application/x-esri-shape",
        "audio/aac",
        "audio/x-it",
        "audio/x-s3m",
        "audio/x-xm",
        "video/MP1S",
        "video/MP2P",
        "application/vnd.sketchup.skp",
        "image/avif",
        "application/x-lzh-compressed",
        "application/pgp-encrypted",
        "application/x-asar",
        "model/stl",
        "application/vnd.ms-htmlhelp",
        "model/3mf",
        "image/jxl",
        "application/zstd",
        "image/jls",
        "application/vnd.ms-outlook",
        "image/vnd.dwg",
        "application/x-parquet",
        "application/java-vm",
        "application/x-arj",
        "application/x-cpio",
        "application/x-ace-compressed",
        "application/avro",
        "application/vnd.iccprofile",
        "application/x.autodesk.fbx",
"application/vnd.visio",
        "application/vnd.android.package-archive",
        "application/vnd.google.draco",
"application/x-lz4",
"application/vnd.openxmlformats-officedocument.presentationml.template",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
        "application/vnd.ms-excel.template.macroenabled.12",
        "application/vnd.oasis.opendocument.text-template",
        "application/vnd.oasis.opendocument.spreadsheet-template",
        "application/vnd.oasis.opendocument.presentation-template",
        "application/vnd.oasis.opendocument.graphics",
        "application/vnd.oasis.opendocument.graphics-template",
        "application/vnd.ms-excel.sheet.macroenabled.12",
        "application/vnd.ms-word.document.macroenabled.12",
        "application/vnd.ms-word.template.macroenabled.12",
        "application/vnd.ms-powerpoint.template.macroenabled.12",
        "application/vnd.ms-powerpoint.presentation.macroenabled.12",
        "application/java-archive",
        "application/vnd.rn-realmedia"
      ];
      const reasonableDetectionSizeInBytes = 4100;
      async function fileTypeFromBuffer(input) {
        return new FileTypeParser().fromBuffer(input);
      }
      function getFileTypeFromMimeType(mimeType) {
        switch (mimeType.toLowerCase()) {
          case "application/epub+zip":
            return {
              ext: "epub",
              mime: "application/epub+zip"
            };
          case "application/vnd.oasis.opendocument.text":
            return {
              ext: "odt",
              mime: "application/vnd.oasis.opendocument.text"
            };
          case "application/vnd.oasis.opendocument.text-template":
            return {
              ext: "ott",
              mime: "application/vnd.oasis.opendocument.text-template"
            };
          case "application/vnd.oasis.opendocument.spreadsheet":
            return {
              ext: "ods",
              mime: "application/vnd.oasis.opendocument.spreadsheet"
            };
          case "application/vnd.oasis.opendocument.spreadsheet-template":
            return {
              ext: "ots",
              mime: "application/vnd.oasis.opendocument.spreadsheet-template"
            };
          case "application/vnd.oasis.opendocument.presentation":
            return {
              ext: "odp",
              mime: "application/vnd.oasis.opendocument.presentation"
            };
          case "application/vnd.oasis.opendocument.presentation-template":
            return {
              ext: "otp",
              mime: "application/vnd.oasis.opendocument.presentation-template"
            };
          case "application/vnd.oasis.opendocument.graphics":
            return {
              ext: "odg",
              mime: "application/vnd.oasis.opendocument.graphics"
            };
          case "application/vnd.oasis.opendocument.graphics-template":
            return {
              ext: "otg",
              mime: "application/vnd.oasis.opendocument.graphics-template"
            };
          case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
            return {
              ext: "ppsx",
              mime: "application/vnd.openxmlformats-officedocument.presentationml.slideshow"
            };
          case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
            return {
              ext: "xlsx",
              mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            };
          case "application/vnd.ms-excel.sheet.macroenabled":
            return {
              ext: "xlsm",
              mime: "application/vnd.ms-excel.sheet.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
            return {
              ext: "xltx",
              mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.template"
            };
          case "application/vnd.ms-excel.template.macroenabled":
            return {
              ext: "xltm",
              mime: "application/vnd.ms-excel.template.macroenabled.12"
            };
          case "application/vnd.ms-powerpoint.slideshow.macroenabled":
            return {
              ext: "ppsm",
              mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
            return {
              ext: "docx",
              mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            };
          case "application/vnd.ms-word.document.macroenabled":
            return {
              ext: "docm",
              mime: "application/vnd.ms-word.document.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
            return {
              ext: "dotx",
              mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.template"
            };
          case "application/vnd.ms-word.template.macroenabledtemplate":
            return {
              ext: "dotm",
              mime: "application/vnd.ms-word.template.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.presentationml.template":
            return {
              ext: "potx",
              mime: "application/vnd.openxmlformats-officedocument.presentationml.template"
            };
          case "application/vnd.ms-powerpoint.template.macroenabled":
            return {
              ext: "potm",
              mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
            };
          case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
            return {
              ext: "pptx",
              mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
            };
          case "application/vnd.ms-powerpoint.presentation.macroenabled":
            return {
              ext: "pptm",
              mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
            };
          case "application/vnd.ms-visio.drawing":
            return {
              ext: "vsdx",
              mime: "application/vnd.visio"
            };
          case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
            return {
              ext: "3mf",
              mime: "model/3mf"
            };
        }
      }
      function _check(buffer, headers, options) {
        options = {
          offset: 0,
          ...options
        };
        for (const [index, header] of headers.entries()) {
          if (options.mask) {
            if (header !== (options.mask[index] & buffer[index + options.offset])) {
              return false;
            }
          } else if (header !== buffer[index + options.offset]) {
            return false;
          }
        }
        return true;
      }
      class FileTypeParser {
        constructor(options) {
          this.detectors = [
            ...options?.customDetectors ?? [],
            { id: "core", detect: this.detectConfident },
            { id: "core.imprecise", detect: this.detectImprecise }
          ];
          this.tokenizerOptions = {
            abortSignal: options?.signal
          };
        }
        async fromTokenizer(tokenizer) {
          const initialPosition = tokenizer.position;
          for (const detector of this.detectors) {
            const fileType = await detector.detect(tokenizer);
            if (fileType) {
              return fileType;
            }
            if (initialPosition !== tokenizer.position) {
              return void 0;
            }
          }
        }
        async fromBuffer(input) {
          if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
            throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
          }
          const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
          if (!(buffer?.length > 1)) {
            return;
          }
          return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
        }
        async fromBlob(blob) {
          return this.fromStream(blob.stream());
        }
        async fromStream(stream) {
          const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
          try {
            return await this.fromTokenizer(tokenizer);
          } finally {
            await tokenizer.close();
          }
        }
        async toDetectionStream(stream, options) {
          const { sampleSize = reasonableDetectionSizeInBytes } = options;
          let detectedFileType;
          let firstChunk;
          const reader = stream.getReader({ mode: "byob" });
          try {
            const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
            firstChunk = chunk;
            if (!done && chunk) {
              try {
                detectedFileType = await this.fromBuffer(chunk.slice(0, sampleSize));
              } catch (error) {
                if (!(error instanceof EndOfStreamError)) {
                  throw error;
                }
                detectedFileType = void 0;
              }
            }
            firstChunk = chunk;
          } finally {
            reader.releaseLock();
          }
          const transformStream = new TransformStream({
            async start(controller) {
              controller.enqueue(firstChunk);
            },
            transform(chunk, controller) {
              controller.enqueue(chunk);
            }
          });
          const newStream = stream.pipeThrough(transformStream);
          newStream.fileType = detectedFileType;
          return newStream;
        }
        check(header, options) {
          return _check(this.buffer, header, options);
        }
        checkString(header, options) {
          return this.check(stringToBytes(header), options);
        }
detectConfident = async (tokenizer) => {
          this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
          if (tokenizer.fileInfo.size === void 0) {
            tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
          }
          this.tokenizer = tokenizer;
          await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
          if (this.check([66, 77])) {
            return {
              ext: "bmp",
              mime: "image/bmp"
            };
          }
          if (this.check([11, 119])) {
            return {
              ext: "ac3",
              mime: "audio/vnd.dolby.dd-raw"
            };
          }
          if (this.check([120, 1])) {
            return {
              ext: "dmg",
              mime: "application/x-apple-diskimage"
            };
          }
          if (this.check([77, 90])) {
            return {
              ext: "exe",
              mime: "application/x-msdownload"
            };
          }
          if (this.check([37, 33])) {
            await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
            if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
              return {
                ext: "eps",
                mime: "application/eps"
              };
            }
            return {
              ext: "ps",
              mime: "application/postscript"
            };
          }
          if (this.check([31, 160]) || this.check([31, 157])) {
            return {
              ext: "Z",
              mime: "application/x-compress"
            };
          }
          if (this.check([199, 113])) {
            return {
              ext: "cpio",
              mime: "application/x-cpio"
            };
          }
          if (this.check([96, 234])) {
            return {
              ext: "arj",
              mime: "application/x-arj"
            };
          }
          if (this.check([239, 187, 191])) {
            this.tokenizer.ignore(3);
            return this.detectConfident(tokenizer);
          }
          if (this.check([71, 73, 70])) {
            return {
              ext: "gif",
              mime: "image/gif"
            };
          }
          if (this.check([73, 73, 188])) {
            return {
              ext: "jxr",
              mime: "image/vnd.ms-photo"
            };
          }
          if (this.check([31, 139, 8])) {
            return {
              ext: "gz",
              mime: "application/gzip"
            };
          }
          if (this.check([66, 90, 104])) {
            return {
              ext: "bz2",
              mime: "application/x-bzip2"
            };
          }
          if (this.checkString("ID3")) {
            await tokenizer.ignore(6);
            const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
            if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
              return {
                ext: "mp3",
                mime: "audio/mpeg"
              };
            }
            await tokenizer.ignore(id3HeaderLength);
            return this.fromTokenizer(tokenizer);
          }
          if (this.checkString("MP+")) {
            return {
              ext: "mpc",
              mime: "audio/x-musepack"
            };
          }
          if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
            return {
              ext: "swf",
              mime: "application/x-shockwave-flash"
            };
          }
          if (this.check([255, 216, 255])) {
            if (this.check([247], { offset: 3 })) {
              return {
                ext: "jls",
                mime: "image/jls"
              };
            }
            return {
              ext: "jpg",
              mime: "image/jpeg"
            };
          }
          if (this.check([79, 98, 106, 1])) {
            return {
              ext: "avro",
              mime: "application/avro"
            };
          }
          if (this.checkString("FLIF")) {
            return {
              ext: "flif",
              mime: "image/flif"
            };
          }
          if (this.checkString("8BPS")) {
            return {
              ext: "psd",
              mime: "image/vnd.adobe.photoshop"
            };
          }
          if (this.checkString("MPCK")) {
            return {
              ext: "mpc",
              mime: "audio/x-musepack"
            };
          }
          if (this.checkString("FORM")) {
            return {
              ext: "aif",
              mime: "audio/aiff"
            };
          }
          if (this.checkString("icns", { offset: 0 })) {
            return {
              ext: "icns",
              mime: "image/icns"
            };
          }
          if (this.check([80, 75, 3, 4])) {
            let fileType;
            await new ZipHandler(tokenizer).unzip((zipHeader) => {
              switch (zipHeader.filename) {
                case "META-INF/mozilla.rsa":
                  fileType = {
                    ext: "xpi",
                    mime: "application/x-xpinstall"
                  };
                  return {
                    stop: true
                  };
                case "META-INF/MANIFEST.MF":
                  fileType = {
                    ext: "jar",
                    mime: "application/java-archive"
                  };
                  return {
                    stop: true
                  };
                case "mimetype":
                  return {
                    async handler(fileData) {
                      const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                      fileType = getFileTypeFromMimeType(mimeType);
                    },
                    stop: true
                  };
                case "[Content_Types].xml":
                  return {
                    async handler(fileData) {
                      let xmlContent = new TextDecoder("utf-8").decode(fileData);
                      const endPos = xmlContent.indexOf('.main+xml"');
                      if (endPos === -1) {
                        const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                        if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                          fileType = getFileTypeFromMimeType(mimeType);
                        }
                      } else {
                        xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                        const firstPos = xmlContent.lastIndexOf('"');
                        const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                        fileType = getFileTypeFromMimeType(mimeType);
                      }
                    },
                    stop: true
                  };
                default:
                  if (/classes\d*\.dex/.test(zipHeader.filename)) {
                    fileType = {
                      ext: "apk",
                      mime: "application/vnd.android.package-archive"
                    };
                    return { stop: true };
                  }
                  return {};
              }
            });
            return fileType ?? {
              ext: "zip",
              mime: "application/zip"
            };
          }
          if (this.checkString("OggS")) {
            await tokenizer.ignore(28);
            const type = new Uint8Array(8);
            await tokenizer.readBuffer(type);
            if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
              return {
                ext: "opus",
                mime: "audio/ogg; codecs=opus"
              };
            }
            if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
              return {
                ext: "ogv",
                mime: "video/ogg"
              };
            }
            if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
              return {
                ext: "ogm",
                mime: "video/ogg"
              };
            }
            if (_check(type, [127, 70, 76, 65, 67])) {
              return {
                ext: "oga",
                mime: "audio/ogg"
              };
            }
            if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
              return {
                ext: "spx",
                mime: "audio/ogg"
              };
            }
            if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
              return {
                ext: "ogg",
                mime: "audio/ogg"
              };
            }
            return {
              ext: "ogx",
              mime: "application/ogg"
            };
          }
          if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
            return {
              ext: "zip",
              mime: "application/zip"
            };
          }
          if (this.checkString("MThd")) {
            return {
              ext: "mid",
              mime: "audio/midi"
            };
          }
          if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
            return {
              ext: "woff",
              mime: "font/woff"
            };
          }
          if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
            return {
              ext: "woff2",
              mime: "font/woff2"
            };
          }
          if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
            return {
              ext: "pcap",
              mime: "application/vnd.tcpdump.pcap"
            };
          }
          if (this.checkString("DSD ")) {
            return {
              ext: "dsf",
              mime: "audio/x-dsf"
};
          }
          if (this.checkString("LZIP")) {
            return {
              ext: "lz",
              mime: "application/x-lzip"
            };
          }
          if (this.checkString("fLaC")) {
            return {
              ext: "flac",
              mime: "audio/x-flac"
            };
          }
          if (this.check([66, 80, 71, 251])) {
            return {
              ext: "bpg",
              mime: "image/bpg"
            };
          }
          if (this.checkString("wvpk")) {
            return {
              ext: "wv",
              mime: "audio/wavpack"
            };
          }
          if (this.checkString("%PDF")) {
            try {
              const skipBytes = 1350;
              if (skipBytes === await tokenizer.ignore(skipBytes)) {
                const maxBufferSize2 = 10 * 1024 * 1024;
                const buffer = new Uint8Array(Math.min(maxBufferSize2, tokenizer.fileInfo.size - skipBytes));
                await tokenizer.readBuffer(buffer, { mayBeLess: true });
                if (includes(buffer, new TextEncoder().encode("AIPrivateData"))) {
                  return {
                    ext: "ai",
                    mime: "application/postscript"
                  };
                }
              }
            } catch (error) {
              if (!(error instanceof EndOfStreamError)) {
                throw error;
              }
            }
            return {
              ext: "pdf",
              mime: "application/pdf"
            };
          }
          if (this.check([0, 97, 115, 109])) {
            return {
              ext: "wasm",
              mime: "application/wasm"
            };
          }
          if (this.check([73, 73])) {
            const fileType = await this.readTiffHeader(false);
            if (fileType) {
              return fileType;
            }
          }
          if (this.check([77, 77])) {
            const fileType = await this.readTiffHeader(true);
            if (fileType) {
              return fileType;
            }
          }
          if (this.checkString("MAC ")) {
            return {
              ext: "ape",
              mime: "audio/ape"
            };
          }
          if (this.check([26, 69, 223, 163])) {
            async function readField() {
              const msb = await tokenizer.peekNumber(UINT8);
              let mask = 128;
              let ic = 0;
              while ((msb & mask) === 0 && mask !== 0) {
                ++ic;
                mask >>= 1;
              }
              const id = new Uint8Array(ic + 1);
              await tokenizer.readBuffer(id);
              return id;
            }
            async function readElement() {
              const idField = await readField();
              const lengthField = await readField();
              lengthField[0] ^= 128 >> lengthField.length - 1;
              const nrLength = Math.min(6, lengthField.length);
              const idView = new DataView(idField.buffer);
              const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
              return {
                id: getUintBE(idView),
                len: getUintBE(lengthView)
              };
            }
            async function readChildren(children) {
              while (children > 0) {
                const element = await readElement();
                if (element.id === 17026) {
                  const rawValue = await tokenizer.readToken(new StringType(element.len));
                  return rawValue.replaceAll(/\00.*$/g, "");
                }
                await tokenizer.ignore(element.len);
                --children;
              }
            }
            const re = await readElement();
            const documentType = await readChildren(re.len);
            switch (documentType) {
              case "webm":
                return {
                  ext: "webm",
                  mime: "video/webm"
                };
              case "matroska":
                return {
                  ext: "mkv",
                  mime: "video/x-matroska"
                };
              default:
                return;
            }
          }
          if (this.checkString("SQLi")) {
            return {
              ext: "sqlite",
              mime: "application/x-sqlite3"
            };
          }
          if (this.check([78, 69, 83, 26])) {
            return {
              ext: "nes",
              mime: "application/x-nintendo-nes-rom"
            };
          }
          if (this.checkString("Cr24")) {
            return {
              ext: "crx",
              mime: "application/x-google-chrome-extension"
            };
          }
          if (this.checkString("MSCF") || this.checkString("ISc(")) {
            return {
              ext: "cab",
              mime: "application/vnd.ms-cab-compressed"
            };
          }
          if (this.check([237, 171, 238, 219])) {
            return {
              ext: "rpm",
              mime: "application/x-rpm"
            };
          }
          if (this.check([197, 208, 211, 198])) {
            return {
              ext: "eps",
              mime: "application/eps"
            };
          }
          if (this.check([40, 181, 47, 253])) {
            return {
              ext: "zst",
              mime: "application/zstd"
            };
          }
          if (this.check([127, 69, 76, 70])) {
            return {
              ext: "elf",
              mime: "application/x-elf"
            };
          }
          if (this.check([33, 66, 68, 78])) {
            return {
              ext: "pst",
              mime: "application/vnd.ms-outlook"
            };
          }
          if (this.checkString("PAR1")) {
            return {
              ext: "parquet",
              mime: "application/x-parquet"
            };
          }
          if (this.checkString("ttcf")) {
            return {
              ext: "ttc",
              mime: "font/collection"
            };
          }
          if (this.check([207, 250, 237, 254])) {
            return {
              ext: "macho",
              mime: "application/x-mach-binary"
            };
          }
          if (this.check([4, 34, 77, 24])) {
            return {
              ext: "lz4",
              mime: "application/x-lz4"
};
          }
          if (this.check([79, 84, 84, 79, 0])) {
            return {
              ext: "otf",
              mime: "font/otf"
            };
          }
          if (this.checkString("#!AMR")) {
            return {
              ext: "amr",
              mime: "audio/amr"
            };
          }
          if (this.checkString("{\\rtf")) {
            return {
              ext: "rtf",
              mime: "application/rtf"
            };
          }
          if (this.check([70, 76, 86, 1])) {
            return {
              ext: "flv",
              mime: "video/x-flv"
            };
          }
          if (this.checkString("IMPM")) {
            return {
              ext: "it",
              mime: "audio/x-it"
            };
          }
          if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
            return {
              ext: "lzh",
              mime: "application/x-lzh-compressed"
            };
          }
          if (this.check([0, 0, 1, 186])) {
            if (this.check([33], { offset: 4, mask: [241] })) {
              return {
                ext: "mpg",
mime: "video/MP1S"
              };
            }
            if (this.check([68], { offset: 4, mask: [196] })) {
              return {
                ext: "mpg",
mime: "video/MP2P"
              };
            }
          }
          if (this.checkString("ITSF")) {
            return {
              ext: "chm",
              mime: "application/vnd.ms-htmlhelp"
            };
          }
          if (this.check([202, 254, 186, 190])) {
            return {
              ext: "class",
              mime: "application/java-vm"
            };
          }
          if (this.checkString(".RMF")) {
            return {
              ext: "rm",
              mime: "application/vnd.rn-realmedia"
            };
          }
          if (this.checkString("DRACO")) {
            return {
              ext: "drc",
              mime: "application/vnd.google.draco"
};
          }
          if (this.check([253, 55, 122, 88, 90, 0])) {
            return {
              ext: "xz",
              mime: "application/x-xz"
            };
          }
          if (this.checkString("<?xml ")) {
            return {
              ext: "xml",
              mime: "application/xml"
            };
          }
          if (this.check([55, 122, 188, 175, 39, 28])) {
            return {
              ext: "7z",
              mime: "application/x-7z-compressed"
            };
          }
          if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
            return {
              ext: "rar",
              mime: "application/x-rar-compressed"
            };
          }
          if (this.checkString("solid ")) {
            return {
              ext: "stl",
              mime: "model/stl"
            };
          }
          if (this.checkString("AC")) {
            const version2 = new StringType(4, "latin1").get(this.buffer, 2);
            if (version2.match("^d*") && version2 >= 1e3 && version2 <= 1050) {
              return {
                ext: "dwg",
                mime: "image/vnd.dwg"
              };
            }
          }
          if (this.checkString("070707")) {
            return {
              ext: "cpio",
              mime: "application/x-cpio"
            };
          }
          if (this.checkString("BLENDER")) {
            return {
              ext: "blend",
              mime: "application/x-blender"
            };
          }
          if (this.checkString("!<arch>")) {
            await tokenizer.ignore(8);
            const string = await tokenizer.readToken(new StringType(13, "ascii"));
            if (string === "debian-binary") {
              return {
                ext: "deb",
                mime: "application/x-deb"
              };
            }
            return {
              ext: "ar",
              mime: "application/x-unix-archive"
            };
          }
          if (this.checkString("WEBVTT") &&
["\n", "\r", "	", " ", "\0"].some((char7) => this.checkString(char7, { offset: 6 }))) {
            return {
              ext: "vtt",
              mime: "text/vtt"
            };
          }
          if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
            await tokenizer.ignore(8);
            async function readChunkHeader() {
              return {
                length: await tokenizer.readToken(INT32_BE),
                type: await tokenizer.readToken(new StringType(4, "latin1"))
              };
            }
            do {
              const chunk = await readChunkHeader();
              if (chunk.length < 0) {
                return;
              }
              switch (chunk.type) {
                case "IDAT":
                  return {
                    ext: "png",
                    mime: "image/png"
                  };
                case "acTL":
                  return {
                    ext: "apng",
                    mime: "image/apng"
                  };
                default:
                  await tokenizer.ignore(chunk.length + 4);
              }
            } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
            return {
              ext: "png",
              mime: "image/png"
            };
          }
          if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
            return {
              ext: "arrow",
              mime: "application/x-apache-arrow"
            };
          }
          if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
            return {
              ext: "glb",
              mime: "model/gltf-binary"
            };
          }
          if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
            return {
              ext: "mov",
              mime: "video/quicktime"
            };
          }
          if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
            return {
              ext: "orf",
              mime: "image/x-olympus-orf"
            };
          }
          if (this.checkString("gimp xcf ")) {
            return {
              ext: "xcf",
              mime: "image/x-xcf"
            };
          }
          if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
            const brandMajor = new StringType(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
            switch (brandMajor) {
              case "avif":
              case "avis":
                return { ext: "avif", mime: "image/avif" };
              case "mif1":
                return { ext: "heic", mime: "image/heif" };
              case "msf1":
                return { ext: "heic", mime: "image/heif-sequence" };
              case "heic":
              case "heix":
                return { ext: "heic", mime: "image/heic" };
              case "hevc":
              case "hevx":
                return { ext: "heic", mime: "image/heic-sequence" };
              case "qt":
                return { ext: "mov", mime: "video/quicktime" };
              case "M4V":
              case "M4VH":
              case "M4VP":
                return { ext: "m4v", mime: "video/x-m4v" };
              case "M4P":
                return { ext: "m4p", mime: "video/mp4" };
              case "M4B":
                return { ext: "m4b", mime: "audio/mp4" };
              case "M4A":
                return { ext: "m4a", mime: "audio/x-m4a" };
              case "F4V":
                return { ext: "f4v", mime: "video/mp4" };
              case "F4P":
                return { ext: "f4p", mime: "video/mp4" };
              case "F4A":
                return { ext: "f4a", mime: "audio/mp4" };
              case "F4B":
                return { ext: "f4b", mime: "audio/mp4" };
              case "crx":
                return { ext: "cr3", mime: "image/x-canon-cr3" };
              default:
                if (brandMajor.startsWith("3g")) {
                  if (brandMajor.startsWith("3g2")) {
                    return { ext: "3g2", mime: "video/3gpp2" };
                  }
                  return { ext: "3gp", mime: "video/3gpp" };
                }
                return { ext: "mp4", mime: "video/mp4" };
            }
          }
          if (this.check([82, 73, 70, 70])) {
            if (this.checkString("WEBP", { offset: 8 })) {
              return {
                ext: "webp",
                mime: "image/webp"
              };
            }
            if (this.check([65, 86, 73], { offset: 8 })) {
              return {
                ext: "avi",
                mime: "video/vnd.avi"
              };
            }
            if (this.check([87, 65, 86, 69], { offset: 8 })) {
              return {
                ext: "wav",
                mime: "audio/wav"
              };
            }
            if (this.check([81, 76, 67, 77], { offset: 8 })) {
              return {
                ext: "qcp",
                mime: "audio/qcelp"
              };
            }
          }
          if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
            return {
              ext: "rw2",
              mime: "image/x-panasonic-rw2"
            };
          }
          if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
            async function readHeader() {
              const guid = new Uint8Array(16);
              await tokenizer.readBuffer(guid);
              return {
                id: guid,
                size: Number(await tokenizer.readToken(UINT64_LE))
              };
            }
            await tokenizer.ignore(30);
            while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
              const header = await readHeader();
              let payload = header.size - 24;
              if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
                const typeId = new Uint8Array(16);
                payload -= await tokenizer.readBuffer(typeId);
                if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
                  return {
                    ext: "asf",
                    mime: "audio/x-ms-asf"
                  };
                }
                if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
                  return {
                    ext: "asf",
                    mime: "video/x-ms-asf"
                  };
                }
                break;
              }
              await tokenizer.ignore(payload);
            }
            return {
              ext: "asf",
              mime: "application/vnd.ms-asf"
            };
          }
          if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
            return {
              ext: "ktx",
              mime: "image/ktx"
            };
          }
          if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
            return {
              ext: "mie",
              mime: "application/x-mie"
            };
          }
          if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
            return {
              ext: "shp",
              mime: "application/x-esri-shape"
            };
          }
          if (this.check([255, 79, 255, 81])) {
            return {
              ext: "j2c",
              mime: "image/j2c"
            };
          }
          if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
            await tokenizer.ignore(20);
            const type = await tokenizer.readToken(new StringType(4, "ascii"));
            switch (type) {
              case "jp2 ":
                return {
                  ext: "jp2",
                  mime: "image/jp2"
                };
              case "jpx ":
                return {
                  ext: "jpx",
                  mime: "image/jpx"
                };
              case "jpm ":
                return {
                  ext: "jpm",
                  mime: "image/jpm"
                };
              case "mjp2":
                return {
                  ext: "mj2",
                  mime: "image/mj2"
                };
              default:
                return;
            }
          }
          if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
            return {
              ext: "jxl",
              mime: "image/jxl"
            };
          }
          if (this.check([254, 255])) {
            if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
              return {
                ext: "xml",
                mime: "application/xml"
              };
            }
            return void 0;
          }
          if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
            return {
              ext: "cfb",
              mime: "application/x-cfb"
            };
          }
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
          if (this.check([97, 99, 115, 112], { offset: 36 })) {
            return {
              ext: "icc",
              mime: "application/vnd.iccprofile"
            };
          }
          if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
            return {
              ext: "ace",
              mime: "application/x-ace-compressed"
            };
          }
          if (this.checkString("BEGIN:")) {
            if (this.checkString("VCARD", { offset: 6 })) {
              return {
                ext: "vcf",
                mime: "text/vcard"
              };
            }
            if (this.checkString("VCALENDAR", { offset: 6 })) {
              return {
                ext: "ics",
                mime: "text/calendar"
              };
            }
          }
          if (this.checkString("FUJIFILMCCD-RAW")) {
            return {
              ext: "raf",
              mime: "image/x-fujifilm-raf"
            };
          }
          if (this.checkString("Extended Module:")) {
            return {
              ext: "xm",
              mime: "audio/x-xm"
            };
          }
          if (this.checkString("Creative Voice File")) {
            return {
              ext: "voc",
              mime: "audio/x-voc"
            };
          }
          if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
            const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
            if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
              try {
                const header = new TextDecoder().decode(this.buffer.slice(16, jsonSize + 16));
                const json = JSON.parse(header);
                if (json.files) {
                  return {
                    ext: "asar",
                    mime: "application/x-asar"
                  };
                }
              } catch {
              }
            }
          }
          if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
            return {
              ext: "mxf",
              mime: "application/mxf"
            };
          }
          if (this.checkString("SCRM", { offset: 44 })) {
            return {
              ext: "s3m",
              mime: "audio/x-s3m"
            };
          }
          if (this.check([71]) && this.check([71], { offset: 188 })) {
            return {
              ext: "mts",
              mime: "video/mp2t"
            };
          }
          if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
            return {
              ext: "mts",
              mime: "video/mp2t"
            };
          }
          if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
            return {
              ext: "mobi",
              mime: "application/x-mobipocket-ebook"
            };
          }
          if (this.check([68, 73, 67, 77], { offset: 128 })) {
            return {
              ext: "dcm",
              mime: "application/dicom"
            };
          }
          if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
            return {
              ext: "lnk",
              mime: "application/x.ms.shortcut"
};
          }
          if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
            return {
              ext: "alias",
              mime: "application/x.apple.alias"
};
          }
          if (this.checkString("Kaydara FBX Binary  \0")) {
            return {
              ext: "fbx",
              mime: "application/x.autodesk.fbx"
};
          }
          if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
            return {
              ext: "eot",
              mime: "application/vnd.ms-fontobject"
            };
          }
          if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
            return {
              ext: "indd",
              mime: "application/x-indesign"
            };
          }
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
          if (tarHeaderChecksumMatches(this.buffer)) {
            return {
              ext: "tar",
              mime: "application/x-tar"
            };
          }
          if (this.check([255, 254])) {
            if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
              return {
                ext: "xml",
                mime: "application/xml"
              };
            }
            if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
              return {
                ext: "skp",
                mime: "application/vnd.sketchup.skp"
              };
            }
            return void 0;
          }
          if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
            return {
              ext: "pgp",
              mime: "application/pgp-encrypted"
            };
          }
        };
detectImprecise = async (tokenizer) => {
          this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
          if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
            return {
              ext: "mpg",
              mime: "video/mpeg"
            };
          }
          if (this.check([0, 1, 0, 0, 0])) {
            return {
              ext: "ttf",
              mime: "font/ttf"
            };
          }
          if (this.check([0, 0, 1, 0])) {
            return {
              ext: "ico",
              mime: "image/x-icon"
            };
          }
          if (this.check([0, 0, 2, 0])) {
            return {
              ext: "cur",
              mime: "image/x-icon"
            };
          }
          if (this.buffer.length >= 2 && this.check([255, 224], { offset: 0, mask: [255, 224] })) {
            if (this.check([16], { offset: 1, mask: [22] })) {
              if (this.check([8], { offset: 1, mask: [8] })) {
                return {
                  ext: "aac",
                  mime: "audio/aac"
                };
              }
              return {
                ext: "aac",
                mime: "audio/aac"
              };
            }
            if (this.check([2], { offset: 1, mask: [6] })) {
              return {
                ext: "mp3",
                mime: "audio/mpeg"
              };
            }
            if (this.check([4], { offset: 1, mask: [6] })) {
              return {
                ext: "mp2",
                mime: "audio/mpeg"
              };
            }
            if (this.check([6], { offset: 1, mask: [6] })) {
              return {
                ext: "mp1",
                mime: "audio/mpeg"
              };
            }
          }
        };
        async readTiffTag(bigEndian) {
          const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
          this.tokenizer.ignore(10);
          switch (tagId) {
            case 50341:
              return {
                ext: "arw",
                mime: "image/x-sony-arw"
              };
            case 50706:
              return {
                ext: "dng",
                mime: "image/x-adobe-dng"
              };
          }
        }
        async readTiffIFD(bigEndian) {
          const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
          for (let n = 0; n < numberOfTags; ++n) {
            const fileType = await this.readTiffTag(bigEndian);
            if (fileType) {
              return fileType;
            }
          }
        }
        async readTiffHeader(bigEndian) {
          const version2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
          const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
          if (version2 === 42) {
            if (ifdOffset >= 6) {
              if (this.checkString("CR", { offset: 8 })) {
                return {
                  ext: "cr2",
                  mime: "image/x-canon-cr2"
                };
              }
              if (ifdOffset >= 8) {
                const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
                const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
                if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
                  return {
                    ext: "nef",
                    mime: "image/x-nikon-nef"
                  };
                }
              }
            }
            await this.tokenizer.ignore(ifdOffset);
            const fileType = await this.readTiffIFD(bigEndian);
            return fileType ?? {
              ext: "tif",
              mime: "image/tiff"
            };
          }
          if (version2 === 43) {
            return {
              ext: "tif",
              mime: "image/tiff"
            };
          }
        }
      }
      new Set(extensions);
      new Set(mimeTypes);
      var contentType = {};
var hasRequiredContentType;
      function requireContentType() {
        if (hasRequiredContentType) return contentType;
        hasRequiredContentType = 1;
        var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
        var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
        var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
        var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
        var QUOTE_REGEXP = /([\\"])/g;
        var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
        contentType.format = format;
        contentType.parse = parse;
        function format(obj) {
          if (!obj || typeof obj !== "object") {
            throw new TypeError("argument obj is required");
          }
          var parameters = obj.parameters;
          var type = obj.type;
          if (!type || !TYPE_REGEXP.test(type)) {
            throw new TypeError("invalid type");
          }
          var string = type;
          if (parameters && typeof parameters === "object") {
            var param;
            var params = Object.keys(parameters).sort();
            for (var i = 0; i < params.length; i++) {
              param = params[i];
              if (!TOKEN_REGEXP.test(param)) {
                throw new TypeError("invalid parameter name");
              }
              string += "; " + param + "=" + qstring(parameters[param]);
            }
          }
          return string;
        }
        function parse(string) {
          if (!string) {
            throw new TypeError("argument string is required");
          }
          var header = typeof string === "object" ? getcontenttype(string) : string;
          if (typeof header !== "string") {
            throw new TypeError("argument string is required to be a string");
          }
          var index = header.indexOf(";");
          var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
          if (!TYPE_REGEXP.test(type)) {
            throw new TypeError("invalid media type");
          }
          var obj = new ContentType2(type.toLowerCase());
          if (index !== -1) {
            var key;
            var match;
            var value2;
            PARAM_REGEXP.lastIndex = index;
            while (match = PARAM_REGEXP.exec(header)) {
              if (match.index !== index) {
                throw new TypeError("invalid parameter format");
              }
              index += match[0].length;
              key = match[1].toLowerCase();
              value2 = match[2];
              if (value2.charCodeAt(0) === 34) {
                value2 = value2.slice(1, -1);
                if (value2.indexOf("\\") !== -1) {
                  value2 = value2.replace(QESC_REGEXP, "$1");
                }
              }
              obj.parameters[key] = value2;
            }
            if (index !== header.length) {
              throw new TypeError("invalid parameter format");
            }
          }
          return obj;
        }
        function getcontenttype(obj) {
          var header;
          if (typeof obj.getHeader === "function") {
            header = obj.getHeader("content-type");
          } else if (typeof obj.headers === "object") {
            header = obj.headers && obj.headers["content-type"];
          }
          if (typeof header !== "string") {
            throw new TypeError("content-type header is missing from object");
          }
          return header;
        }
        function qstring(val) {
          var str = String(val);
          if (TOKEN_REGEXP.test(str)) {
            return str;
          }
          if (str.length > 0 && !TEXT_REGEXP.test(str)) {
            throw new TypeError("invalid parameter value");
          }
          return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
        }
        function ContentType2(type) {
          this.parameters = Object.create(null);
          this.type = type;
        }
        return contentType;
      }
      var contentTypeExports = requireContentType();
      const ContentType = getDefaultExportFromCjs(contentTypeExports);
      var mediaTyper = {};
var hasRequiredMediaTyper;
      function requireMediaTyper() {
        if (hasRequiredMediaTyper) return mediaTyper;
        hasRequiredMediaTyper = 1;
        var SUBTYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
        var TYPE_NAME_REGEXP = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
        var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
        mediaTyper.format = format;
        mediaTyper.parse = parse;
        mediaTyper.test = test;
        function format(obj) {
          if (!obj || typeof obj !== "object") {
            throw new TypeError("argument obj is required");
          }
          var subtype = obj.subtype;
          var suffix = obj.suffix;
          var type = obj.type;
          if (!type || !TYPE_NAME_REGEXP.test(type)) {
            throw new TypeError("invalid type");
          }
          if (!subtype || !SUBTYPE_NAME_REGEXP.test(subtype)) {
            throw new TypeError("invalid subtype");
          }
          var string = type + "/" + subtype;
          if (suffix) {
            if (!TYPE_NAME_REGEXP.test(suffix)) {
              throw new TypeError("invalid suffix");
            }
            string += "+" + suffix;
          }
          return string;
        }
        function test(string) {
          if (!string) {
            throw new TypeError("argument string is required");
          }
          if (typeof string !== "string") {
            throw new TypeError("argument string is required to be a string");
          }
          return TYPE_REGEXP.test(string.toLowerCase());
        }
        function parse(string) {
          if (!string) {
            throw new TypeError("argument string is required");
          }
          if (typeof string !== "string") {
            throw new TypeError("argument string is required to be a string");
          }
          var match = TYPE_REGEXP.exec(string.toLowerCase());
          if (!match) {
            throw new TypeError("invalid media type");
          }
          var type = match[1];
          var subtype = match[2];
          var suffix;
          var index = subtype.lastIndexOf("+");
          if (index !== -1) {
            suffix = subtype.substr(index + 1);
            subtype = subtype.substr(0, index);
          }
          return new MediaType(type, subtype, suffix);
        }
        function MediaType(type, subtype, suffix) {
          this.type = type;
          this.subtype = subtype;
          this.suffix = suffix;
        }
        return mediaTyper;
      }
      var mediaTyperExports = requireMediaTyper();
      const TargetType = exports("t", {
        10: "shot",
        20: "scene",
        30: "track",
        40: "part",
        50: "album",
        60: "edition",
        70: "collection"
      });
      const TrackType = exports("T", {
        video: 1,
        audio: 2,
        complex: 3,
        logo: 4,
        subtitle: 17,
        button: 18,
        control: 32
      });
      const TrackTypeValueToKeyMap = {
        [TrackType.video]: "video",
        [TrackType.audio]: "audio",
        [TrackType.complex]: "complex",
        [TrackType.logo]: "logo",
        [TrackType.subtitle]: "subtitle",
        [TrackType.button]: "button",
        [TrackType.control]: "control"
      };
      const makeParseError = (name2) => {
        return class ParseError extends Error {
          constructor(message2) {
            super(message2);
            this.name = name2;
          }
        };
      };
      class CouldNotDetermineFileTypeError extends makeParseError("CouldNotDetermineFileTypeError") {
      }
      class UnsupportedFileTypeError extends makeParseError("UnsupportedFileTypeError") {
      }
      class UnexpectedFileContentError extends makeParseError("UnexpectedFileContentError") {
        constructor(fileType, message2) {
          super(message2);
          this.fileType = fileType;
        }
toString() {
          return `${this.name} (FileType: ${this.fileType}): ${this.message}`;
        }
      }
      class FieldDecodingError extends makeParseError("FieldDecodingError") {
      }
      class InternalParserError extends makeParseError("InternalParserError") {
      }
      const makeUnexpectedFileContentError = exports("m", (fileType) => {
        return class extends UnexpectedFileContentError {
          constructor(message2) {
            super(fileType, message2);
          }
        };
      });
      function getBit(buf, off2, bit) {
        return (buf[off2] & 1 << bit) !== 0;
      }
      function findZero(uint8Array, start, end, encoding) {
        let i = start;
        if (encoding === "utf-16le") {
          while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {
            if (i >= end)
              return end;
            i += 2;
          }
          return i;
        }
        while (uint8Array[i] !== 0) {
          if (i >= end)
            return end;
          i++;
        }
        return i;
      }
      function trimRightNull(x) {
        const pos0 = x.indexOf("\0");
        return pos0 === -1 ? x : x.substr(0, pos0);
      }
      function swapBytes(uint8Array) {
        const l = uint8Array.length;
        if ((l & 1) !== 0)
          throw new FieldDecodingError("Buffer length must be even");
        for (let i = 0; i < l; i += 2) {
          const a = uint8Array[i];
          uint8Array[i] = uint8Array[i + 1];
          uint8Array[i + 1] = a;
        }
        return uint8Array;
      }
      function decodeString(uint8Array, encoding) {
        if (uint8Array[0] === 255 && uint8Array[1] === 254) {
          return decodeString(uint8Array.subarray(2), encoding);
        }
        if (encoding === "utf-16le" && uint8Array[0] === 254 && uint8Array[1] === 255) {
          if ((uint8Array.length & 1) !== 0)
            throw new FieldDecodingError("Expected even number of octets for 16-bit unicode string");
          return decodeString(swapBytes(uint8Array), encoding);
        }
        return new StringType(uint8Array.length, encoding).get(uint8Array, 0);
      }
      function stripNulls(str) {
        str = str.replace(/^\x00+/g, "");
        str = str.replace(/\x00+$/g, "");
        return str;
      }
      function getBitAllignedNumber(source, byteOffset, bitOffset, len) {
        const byteOff = byteOffset + ~~(bitOffset / 8);
        const bitOff = bitOffset % 8;
        let value2 = source[byteOff];
        value2 &= 255 >> bitOff;
        const bitsRead = 8 - bitOff;
        const bitsLeft = len - bitsRead;
        if (bitsLeft < 0) {
          value2 >>= 8 - bitOff - len;
        } else if (bitsLeft > 0) {
          value2 <<= bitsLeft;
          value2 |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft);
        }
        return value2;
      }
      function isBitSet$1(source, byteOffset, bitOffset) {
        return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;
      }
      function a2hex(str) {
        const arr = [];
        for (let i = 0, l = str.length; i < l; i++) {
          const hex = Number(str.charCodeAt(i)).toString(16);
          arr.push(hex.length === 1 ? `0${hex}` : hex);
        }
        return arr.join(" ");
      }
      function ratioToDb(ratio) {
        return 10 * Math.log10(ratio);
      }
      function dbToRatio(dB) {
        return 10 ** (dB / 10);
      }
      function toRatio(value2) {
        const ps = value2.split(" ").map((p) => p.trim().toLowerCase());
        if (ps.length >= 1) {
          const v = Number.parseFloat(ps[0]);
          return ps.length === 2 && ps[1] === "db" ? {
            dB: v,
            ratio: dbToRatio(v)
          } : {
            dB: ratioToDb(v),
            ratio: v
          };
        }
      }
      const AttachedPictureType = exports("A", {
        0: "Other",
        1: "32x32 pixels 'file icon' (PNG only)",
        2: "Other file icon",
        3: "Cover (front)",
        4: "Cover (back)",
        5: "Leaflet page",
        6: "Media (e.g. label side of CD)",
        7: "Lead artist/lead performer/soloist",
        8: "Artist/performer",
        9: "Conductor",
        10: "Band/Orchestra",
        11: "Composer",
        12: "Lyricist/text writer",
        13: "Recording Location",
        14: "During recording",
        15: "During performance",
        16: "Movie/video screen capture",
        17: "A bright coloured fish",
        18: "Illustration",
        19: "Band/artist logotype",
        20: "Publisher/Studio logotype"
      });
      const LyricsContentType = {
        lyrics: 1
      };
      const TimestampFormat = {
        milliseconds: 2
      };
      const UINT32SYNCSAFE = exports("P", {
        get: (buf, off2) => {
          return buf[off2 + 3] & 127 | buf[off2 + 2] << 7 | buf[off2 + 1] << 14 | buf[off2] << 21;
        },
        len: 4
      });
      const ID3v2Header = exports("K", {
        len: 10,
        get: (buf, off2) => {
          return {
fileIdentifier: new StringType(3, "ascii").get(buf, off2),
version: {
              major: INT8.get(buf, off2 + 3),
              revision: INT8.get(buf, off2 + 4)
            },
flags: {
unsynchronisation: getBit(buf, off2 + 5, 7),
isExtendedHeader: getBit(buf, off2 + 5, 6),
expIndicator: getBit(buf, off2 + 5, 5),
              footer: getBit(buf, off2 + 5, 4)
            },
            size: UINT32SYNCSAFE.get(buf, off2 + 6)
          };
        }
      });
      const ExtendedHeader = exports("O", {
        len: 10,
        get: (buf, off2) => {
          return {
size: UINT32_BE.get(buf, off2),
extendedFlags: UINT16_BE.get(buf, off2 + 4),
sizeOfPadding: UINT32_BE.get(buf, off2 + 6),
crcDataPresent: getBit(buf, off2 + 4, 31)
          };
        }
      });
      const TextEncodingToken = exports("Q", {
        len: 1,
        get: (uint8Array, off2) => {
          switch (uint8Array[off2]) {
            case 0:
              return { encoding: "latin1" };
case 1:
              return { encoding: "utf-16le", bom: true };
            case 2:
              return { encoding: "utf-16le", bom: false };
            case 3:
              return { encoding: "utf8", bom: false };
            default:
              return { encoding: "utf8", bom: false };
          }
        }
      });
      const TextHeader = exports("V", {
        len: 4,
        get: (uint8Array, off2) => {
          return {
            encoding: TextEncodingToken.get(uint8Array, off2),
            language: new StringType(3, "latin1").get(uint8Array, off2 + 1)
          };
        }
      });
      const SyncTextHeader = exports("W", {
        len: 6,
        get: (uint8Array, off2) => {
          const text2 = TextHeader.get(uint8Array, off2);
          return {
            encoding: text2.encoding,
            language: text2.language,
            timeStampFormat: UINT8.get(uint8Array, off2 + 4),
            contentType: UINT8.get(uint8Array, off2 + 5)
          };
        }
      });
      const defaultTagInfo = {
        multiple: false
      };
      const commonTags = {
        year: defaultTagInfo,
        track: defaultTagInfo,
        disk: defaultTagInfo,
        title: defaultTagInfo,
        artist: defaultTagInfo,
        artists: { multiple: true, unique: true },
        albumartist: defaultTagInfo,
        album: defaultTagInfo,
        date: defaultTagInfo,
        originaldate: defaultTagInfo,
        originalyear: defaultTagInfo,
        releasedate: defaultTagInfo,
        comment: { multiple: true, unique: false },
        genre: { multiple: true, unique: true },
        picture: { multiple: true, unique: true },
        composer: { multiple: true, unique: true },
        lyrics: { multiple: true, unique: false },
        albumsort: { multiple: false, unique: true },
        titlesort: { multiple: false, unique: true },
        work: { multiple: false, unique: true },
        artistsort: { multiple: false, unique: true },
        albumartistsort: { multiple: false, unique: true },
        composersort: { multiple: false, unique: true },
        lyricist: { multiple: true, unique: true },
        writer: { multiple: true, unique: true },
        conductor: { multiple: true, unique: true },
        remixer: { multiple: true, unique: true },
        arranger: { multiple: true, unique: true },
        engineer: { multiple: true, unique: true },
        producer: { multiple: true, unique: true },
        technician: { multiple: true, unique: true },
        djmixer: { multiple: true, unique: true },
        mixer: { multiple: true, unique: true },
        label: { multiple: true, unique: true },
        grouping: defaultTagInfo,
        subtitle: { multiple: true },
        discsubtitle: defaultTagInfo,
        totaltracks: defaultTagInfo,
        totaldiscs: defaultTagInfo,
        compilation: defaultTagInfo,
        rating: { multiple: true },
        bpm: defaultTagInfo,
        mood: defaultTagInfo,
        media: defaultTagInfo,
        catalognumber: { multiple: true, unique: true },
        tvShow: defaultTagInfo,
        tvShowSort: defaultTagInfo,
        tvSeason: defaultTagInfo,
        tvEpisode: defaultTagInfo,
        tvEpisodeId: defaultTagInfo,
        tvNetwork: defaultTagInfo,
        podcast: defaultTagInfo,
        podcasturl: defaultTagInfo,
        releasestatus: defaultTagInfo,
        releasetype: { multiple: true },
        releasecountry: defaultTagInfo,
        script: defaultTagInfo,
        language: defaultTagInfo,
        copyright: defaultTagInfo,
        license: defaultTagInfo,
        encodedby: defaultTagInfo,
        encodersettings: defaultTagInfo,
        gapless: defaultTagInfo,
        barcode: defaultTagInfo,
        isrc: { multiple: true },
        asin: defaultTagInfo,
        musicbrainz_recordingid: defaultTagInfo,
        musicbrainz_trackid: defaultTagInfo,
        musicbrainz_albumid: defaultTagInfo,
        musicbrainz_artistid: { multiple: true },
        musicbrainz_albumartistid: { multiple: true },
        musicbrainz_releasegroupid: defaultTagInfo,
        musicbrainz_workid: defaultTagInfo,
        musicbrainz_trmid: defaultTagInfo,
        musicbrainz_discid: defaultTagInfo,
        acoustid_id: defaultTagInfo,
        acoustid_fingerprint: defaultTagInfo,
        musicip_puid: defaultTagInfo,
        musicip_fingerprint: defaultTagInfo,
        website: defaultTagInfo,
        "performer:instrument": { multiple: true, unique: true },
        averageLevel: defaultTagInfo,
        peakLevel: defaultTagInfo,
        notes: { multiple: true, unique: false },
        key: defaultTagInfo,
        originalalbum: defaultTagInfo,
        originalartist: defaultTagInfo,
        discogs_artist_id: { multiple: true, unique: true },
        discogs_release_id: defaultTagInfo,
        discogs_label_id: defaultTagInfo,
        discogs_master_release_id: defaultTagInfo,
        discogs_votes: defaultTagInfo,
        discogs_rating: defaultTagInfo,
        replaygain_track_peak: defaultTagInfo,
        replaygain_track_gain: defaultTagInfo,
        replaygain_album_peak: defaultTagInfo,
        replaygain_album_gain: defaultTagInfo,
        replaygain_track_minmax: defaultTagInfo,
        replaygain_album_minmax: defaultTagInfo,
        replaygain_undo: defaultTagInfo,
        description: { multiple: true },
        longDescription: defaultTagInfo,
        category: { multiple: true },
        hdVideo: defaultTagInfo,
        keywords: { multiple: true },
        movement: defaultTagInfo,
        movementIndex: defaultTagInfo,
        movementTotal: defaultTagInfo,
        podcastId: defaultTagInfo,
        showMovement: defaultTagInfo,
        stik: defaultTagInfo
      };
      function isSingleton(alias) {
        return commonTags[alias] && !commonTags[alias].multiple;
      }
      function isUnique(alias) {
        return !commonTags[alias].multiple || commonTags[alias].unique || false;
      }
      class CommonTagMapper {
        static toIntOrNull(str) {
          const cleaned = Number.parseInt(str, 10);
          return Number.isNaN(cleaned) ? null : cleaned;
        }


static normalizeTrack(origVal) {
          const split = origVal.toString().split("/");
          return {
            no: Number.parseInt(split[0], 10) || null,
            of: Number.parseInt(split[1], 10) || null
          };
        }
        constructor(tagTypes, tagMap2) {
          this.tagTypes = tagTypes;
          this.tagMap = tagMap2;
        }
mapGenericTag(tag2, warnings) {
          tag2 = { id: tag2.id, value: tag2.value };
          this.postMap(tag2, warnings);
          const id = this.getCommonName(tag2.id);
          return id ? { id, value: tag2.value } : null;
        }
getCommonName(tag2) {
          return this.tagMap[tag2];
        }
postMap(tag2, warnings) {
          return;
        }
      }
      CommonTagMapper.maxRatingScore = 1;
      const id3v1TagMap = {
        title: "title",
        artist: "artist",
        album: "album",
        year: "year",
        comment: "comment",
        track: "track",
        genre: "genre"
      };
      class ID3v1TagMapper extends CommonTagMapper {
        constructor() {
          super(["ID3v1"], id3v1TagMap);
        }
      }
      class CaseInsensitiveTagMap extends CommonTagMapper {
        constructor(tagTypes, tagMap2) {
          const upperCaseMap = {};
          for (const tag2 of Object.keys(tagMap2)) {
            upperCaseMap[tag2.toUpperCase()] = tagMap2[tag2];
          }
          super(tagTypes, upperCaseMap);
        }
getCommonName(tag2) {
          return this.tagMap[tag2.toUpperCase()];
        }
      }
      const id3v24TagMap = {
TIT2: "title",
        TPE1: "artist",
        "TXXX:Artists": "artists",
        TPE2: "albumartist",
        TALB: "album",
        TDRV: "date",

TORY: "originalyear",
        TPOS: "disk",
        TCON: "genre",
        APIC: "picture",
        TCOM: "composer",
        USLT: "lyrics",
        TSOA: "albumsort",
        TSOT: "titlesort",
        TOAL: "originalalbum",
        TSOP: "artistsort",
        TSO2: "albumartistsort",
        TSOC: "composersort",
        TEXT: "lyricist",
        "TXXX:Writer": "writer",
        TPE3: "conductor",
TPE4: "remixer",
        "IPLS:arranger": "arranger",
        "IPLS:engineer": "engineer",
        "IPLS:producer": "producer",
        "IPLS:DJ-mix": "djmixer",
        "IPLS:mix": "mixer",
        TPUB: "label",
        TIT1: "grouping",
        TIT3: "subtitle",
        TRCK: "track",
        TCMP: "compilation",
        POPM: "rating",
        TBPM: "bpm",
        TMED: "media",
        "TXXX:CATALOGNUMBER": "catalognumber",
        "TXXX:MusicBrainz Album Status": "releasestatus",
        "TXXX:MusicBrainz Album Type": "releasetype",
"TXXX:MusicBrainz Album Release Country": "releasecountry",
"TXXX:RELEASECOUNTRY": "releasecountry",
        "TXXX:SCRIPT": "script",
        TLAN: "language",
        TCOP: "copyright",
        WCOP: "license",
        TENC: "encodedby",
        TSSE: "encodersettings",
        "TXXX:BARCODE": "barcode",
        "TXXX:ISRC": "isrc",
        TSRC: "isrc",
        "TXXX:ASIN": "asin",
        "TXXX:originalyear": "originalyear",
        "UFID:http://musicbrainz.org": "musicbrainz_recordingid",
        "TXXX:MusicBrainz Release Track Id": "musicbrainz_trackid",
        "TXXX:MusicBrainz Album Id": "musicbrainz_albumid",
        "TXXX:MusicBrainz Artist Id": "musicbrainz_artistid",
        "TXXX:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
        "TXXX:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
        "TXXX:MusicBrainz Work Id": "musicbrainz_workid",
        "TXXX:MusicBrainz TRM Id": "musicbrainz_trmid",
        "TXXX:MusicBrainz Disc Id": "musicbrainz_discid",
        "TXXX:ACOUSTID_ID": "acoustid_id",
        "TXXX:Acoustid Id": "acoustid_id",
        "TXXX:Acoustid Fingerprint": "acoustid_fingerprint",
        "TXXX:MusicIP PUID": "musicip_puid",
        "TXXX:MusicMagic Fingerprint": "musicip_fingerprint",
        WOAR: "website",

TDRC: "date",
TYER: "year",
        TDOR: "originaldate",
"TIPL:arranger": "arranger",
        "TIPL:engineer": "engineer",
        "TIPL:producer": "producer",
        "TIPL:DJ-mix": "djmixer",
        "TIPL:mix": "mixer",
        TMOO: "mood",
SYLT: "lyrics",
        TSST: "discsubtitle",
        TKEY: "key",
        COMM: "comment",
        TOPE: "originalartist",
"PRIV:AverageLevel": "averageLevel",
        "PRIV:PeakLevel": "peakLevel",
"TXXX:DISCOGS_ARTIST_ID": "discogs_artist_id",
        "TXXX:DISCOGS_ARTISTS": "artists",
        "TXXX:DISCOGS_ARTIST_NAME": "artists",
        "TXXX:DISCOGS_ALBUM_ARTISTS": "albumartist",
        "TXXX:DISCOGS_CATALOG": "catalognumber",
        "TXXX:DISCOGS_COUNTRY": "releasecountry",
        "TXXX:DISCOGS_DATE": "originaldate",
        "TXXX:DISCOGS_LABEL": "label",
        "TXXX:DISCOGS_LABEL_ID": "discogs_label_id",
        "TXXX:DISCOGS_MASTER_RELEASE_ID": "discogs_master_release_id",
        "TXXX:DISCOGS_RATING": "discogs_rating",
        "TXXX:DISCOGS_RELEASED": "date",
        "TXXX:DISCOGS_RELEASE_ID": "discogs_release_id",
        "TXXX:DISCOGS_VOTES": "discogs_votes",
        "TXXX:CATALOGID": "catalognumber",
        "TXXX:STYLE": "genre",
        "TXXX:REPLAYGAIN_TRACK_PEAK": "replaygain_track_peak",
        "TXXX:REPLAYGAIN_TRACK_GAIN": "replaygain_track_gain",
        "TXXX:REPLAYGAIN_ALBUM_PEAK": "replaygain_album_peak",
        "TXXX:REPLAYGAIN_ALBUM_GAIN": "replaygain_album_gain",
        "TXXX:MP3GAIN_MINMAX": "replaygain_track_minmax",
        "TXXX:MP3GAIN_ALBUM_MINMAX": "replaygain_album_minmax",
        "TXXX:MP3GAIN_UNDO": "replaygain_undo",
        MVNM: "movement",
        MVIN: "movementIndex",
        PCST: "podcast",
        TCAT: "category",
        TDES: "description",
        TDRL: "releasedate",
        TGID: "podcastId",
        TKWD: "keywords",
        WFED: "podcasturl",
        GRP1: "grouping"
      };
      class ID3v24TagMapper extends CaseInsensitiveTagMap {
        static toRating(popm) {
          return {
            source: popm.email,
            rating: popm.rating > 0 ? (popm.rating - 1) / 254 * CommonTagMapper.maxRatingScore : void 0
          };
        }
        constructor() {
          super(["ID3v2.3", "ID3v2.4"], id3v24TagMap);
        }
postMap(tag2, warnings) {
          switch (tag2.id) {
            case "UFID":
              {
                const idTag = tag2.value;
                if (idTag.owner_identifier === "http://musicbrainz.org") {
                  tag2.id += `:${idTag.owner_identifier}`;
                  tag2.value = decodeString(idTag.identifier, "latin1");
                }
              }
              break;
            case "PRIV":
              {
                const customTag = tag2.value;
                switch (customTag.owner_identifier) {
case "AverageLevel":
                  case "PeakValue":
                    tag2.id += `:${customTag.owner_identifier}`;
                    tag2.value = customTag.data.length === 4 ? UINT32_LE.get(customTag.data, 0) : null;
                    if (tag2.value === null) {
                      warnings.addWarning("Failed to parse PRIV:PeakValue");
                    }
                    break;
                  default:
                    warnings.addWarning(`Unknown PRIV owner-identifier: ${customTag.data}`);
                }
              }
              break;
            case "POPM":
              tag2.value = ID3v24TagMapper.toRating(tag2.value);
              break;
          }
        }
      }
      const asfTagMap = {
        Title: "title",
        Author: "artist",
        "WM/AlbumArtist": "albumartist",
        "WM/AlbumTitle": "album",
        "WM/Year": "date",
"WM/OriginalReleaseTime": "originaldate",
        "WM/OriginalReleaseYear": "originalyear",
        Description: "comment",
        "WM/TrackNumber": "track",
        "WM/PartOfSet": "disk",
        "WM/Genre": "genre",
        "WM/Composer": "composer",
        "WM/Lyrics": "lyrics",
        "WM/AlbumSortOrder": "albumsort",
        "WM/TitleSortOrder": "titlesort",
        "WM/ArtistSortOrder": "artistsort",
        "WM/AlbumArtistSortOrder": "albumartistsort",
        "WM/ComposerSortOrder": "composersort",
        "WM/Writer": "lyricist",
        "WM/Conductor": "conductor",
        "WM/ModifiedBy": "remixer",
        "WM/Engineer": "engineer",
        "WM/Producer": "producer",
        "WM/DJMixer": "djmixer",
        "WM/Mixer": "mixer",
        "WM/Publisher": "label",
        "WM/ContentGroupDescription": "grouping",
        "WM/SubTitle": "subtitle",
        "WM/SetSubTitle": "discsubtitle",
"WM/IsCompilation": "compilation",
        "WM/SharedUserRating": "rating",
        "WM/BeatsPerMinute": "bpm",
        "WM/Mood": "mood",
        "WM/Media": "media",
        "WM/CatalogNo": "catalognumber",
        "MusicBrainz/Album Status": "releasestatus",
        "MusicBrainz/Album Type": "releasetype",
        "MusicBrainz/Album Release Country": "releasecountry",
        "WM/Script": "script",
        "WM/Language": "language",
        Copyright: "copyright",
        LICENSE: "license",
        "WM/EncodedBy": "encodedby",
        "WM/EncodingSettings": "encodersettings",
        "WM/Barcode": "barcode",
        "WM/ISRC": "isrc",
        "MusicBrainz/Track Id": "musicbrainz_recordingid",
        "MusicBrainz/Release Track Id": "musicbrainz_trackid",
        "MusicBrainz/Album Id": "musicbrainz_albumid",
        "MusicBrainz/Artist Id": "musicbrainz_artistid",
        "MusicBrainz/Album Artist Id": "musicbrainz_albumartistid",
        "MusicBrainz/Release Group Id": "musicbrainz_releasegroupid",
        "MusicBrainz/Work Id": "musicbrainz_workid",
        "MusicBrainz/TRM Id": "musicbrainz_trmid",
        "MusicBrainz/Disc Id": "musicbrainz_discid",
        "Acoustid/Id": "acoustid_id",
        "Acoustid/Fingerprint": "acoustid_fingerprint",
        "MusicIP/PUID": "musicip_puid",
        "WM/ARTISTS": "artists",
        "WM/InitialKey": "key",
        ASIN: "asin",
        "WM/Work": "work",
        "WM/AuthorURL": "website",
        "WM/Picture": "picture"
      };
      class AsfTagMapper extends CommonTagMapper {
        static toRating(rating) {
          return {
            rating: Number.parseFloat(rating + 1) / 5
          };
        }
        constructor() {
          super(["asf"], asfTagMap);
        }
        postMap(tag2) {
          switch (tag2.id) {
            case "WM/SharedUserRating": {
              const keys = tag2.id.split(":");
              tag2.value = AsfTagMapper.toRating(tag2.value);
              tag2.id = keys[0];
              break;
            }
          }
        }
      }
      const id3v22TagMap = {
        TT2: "title",
        TP1: "artist",
        TP2: "albumartist",
        TAL: "album",
        TYE: "year",
        COM: "comment",
        TRK: "track",
        TPA: "disk",
        TCO: "genre",
        PIC: "picture",
        TCM: "composer",
        TOR: "originaldate",
        TOT: "originalalbum",
        TXT: "lyricist",
        TP3: "conductor",
        TPB: "label",
        TT1: "grouping",
        TT3: "subtitle",
        TLA: "language",
        TCR: "copyright",
        WCP: "license",
        TEN: "encodedby",
        TSS: "encodersettings",
        WAR: "website",
        PCS: "podcast",
        TCP: "compilation",
        TDR: "date",
        TS2: "albumartistsort",
        TSA: "albumsort",
        TSC: "composersort",
        TSP: "artistsort",
        TST: "titlesort",
        WFD: "podcasturl",
        TBP: "bpm"
      };
      class ID3v22TagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super(["ID3v2.2"], id3v22TagMap);
        }
      }
      const apev2TagMap = {
        Title: "title",
        Artist: "artist",
        Artists: "artists",
        "Album Artist": "albumartist",
        Album: "album",
        Year: "date",
        Originalyear: "originalyear",
        Originaldate: "originaldate",
        Releasedate: "releasedate",
        Comment: "comment",
        Track: "track",
        Disc: "disk",
        DISCNUMBER: "disk",
Genre: "genre",
        "Cover Art (Front)": "picture",
        "Cover Art (Back)": "picture",
        Composer: "composer",
        Lyrics: "lyrics",
        ALBUMSORT: "albumsort",
        TITLESORT: "titlesort",
        WORK: "work",
        ARTISTSORT: "artistsort",
        ALBUMARTISTSORT: "albumartistsort",
        COMPOSERSORT: "composersort",
        Lyricist: "lyricist",
        Writer: "writer",
        Conductor: "conductor",
MixArtist: "remixer",
        Arranger: "arranger",
        Engineer: "engineer",
        Producer: "producer",
        DJMixer: "djmixer",
        Mixer: "mixer",
        Label: "label",
        Grouping: "grouping",
        Subtitle: "subtitle",
        DiscSubtitle: "discsubtitle",
        Compilation: "compilation",
        BPM: "bpm",
        Mood: "mood",
        Media: "media",
        CatalogNumber: "catalognumber",
        MUSICBRAINZ_ALBUMSTATUS: "releasestatus",
        MUSICBRAINZ_ALBUMTYPE: "releasetype",
        RELEASECOUNTRY: "releasecountry",
        Script: "script",
        Language: "language",
        Copyright: "copyright",
        LICENSE: "license",
        EncodedBy: "encodedby",
        EncoderSettings: "encodersettings",
        Barcode: "barcode",
        ISRC: "isrc",
        ASIN: "asin",
        musicbrainz_trackid: "musicbrainz_recordingid",
        musicbrainz_releasetrackid: "musicbrainz_trackid",
        MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
        MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
        MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
        MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
        MUSICBRAINZ_WORKID: "musicbrainz_workid",
        MUSICBRAINZ_TRMID: "musicbrainz_trmid",
        MUSICBRAINZ_DISCID: "musicbrainz_discid",
        Acoustid_Id: "acoustid_id",
        ACOUSTID_FINGERPRINT: "acoustid_fingerprint",
        MUSICIP_PUID: "musicip_puid",
        Weblink: "website",
        REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
        REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
        MP3GAIN_MINMAX: "replaygain_track_minmax",
        MP3GAIN_UNDO: "replaygain_undo"
      };
      class APEv2TagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super(["APEv2"], apev2TagMap);
        }
      }
      const mp4TagMap = {
        "©nam": "title",
        "©ART": "artist",
        aART: "albumartist",
"----:com.apple.iTunes:Band": "albumartist",
        "©alb": "album",
        "©day": "date",
        "©cmt": "comment",
        "©com": "comment",
        trkn: "track",
        disk: "disk",
        "©gen": "genre",
        covr: "picture",
        "©wrt": "composer",
        "©lyr": "lyrics",
        soal: "albumsort",
        sonm: "titlesort",
        soar: "artistsort",
        soaa: "albumartistsort",
        soco: "composersort",
        "----:com.apple.iTunes:LYRICIST": "lyricist",
        "----:com.apple.iTunes:CONDUCTOR": "conductor",
        "----:com.apple.iTunes:REMIXER": "remixer",
        "----:com.apple.iTunes:ENGINEER": "engineer",
        "----:com.apple.iTunes:PRODUCER": "producer",
        "----:com.apple.iTunes:DJMIXER": "djmixer",
        "----:com.apple.iTunes:MIXER": "mixer",
        "----:com.apple.iTunes:LABEL": "label",
        "©grp": "grouping",
        "----:com.apple.iTunes:SUBTITLE": "subtitle",
        "----:com.apple.iTunes:DISCSUBTITLE": "discsubtitle",
        cpil: "compilation",
        tmpo: "bpm",
        "----:com.apple.iTunes:MOOD": "mood",
        "----:com.apple.iTunes:MEDIA": "media",
        "----:com.apple.iTunes:CATALOGNUMBER": "catalognumber",
        tvsh: "tvShow",
        tvsn: "tvSeason",
        tves: "tvEpisode",
        sosn: "tvShowSort",
        tven: "tvEpisodeId",
        tvnn: "tvNetwork",
        pcst: "podcast",
        purl: "podcasturl",
        "----:com.apple.iTunes:MusicBrainz Album Status": "releasestatus",
        "----:com.apple.iTunes:MusicBrainz Album Type": "releasetype",
        "----:com.apple.iTunes:MusicBrainz Album Release Country": "releasecountry",
        "----:com.apple.iTunes:SCRIPT": "script",
        "----:com.apple.iTunes:LANGUAGE": "language",
        cprt: "copyright",
        "©cpy": "copyright",
        "----:com.apple.iTunes:LICENSE": "license",
        "©too": "encodedby",
        pgap: "gapless",
        "----:com.apple.iTunes:BARCODE": "barcode",
        "----:com.apple.iTunes:ISRC": "isrc",
        "----:com.apple.iTunes:ASIN": "asin",
        "----:com.apple.iTunes:NOTES": "comment",
        "----:com.apple.iTunes:MusicBrainz Track Id": "musicbrainz_recordingid",
        "----:com.apple.iTunes:MusicBrainz Release Track Id": "musicbrainz_trackid",
        "----:com.apple.iTunes:MusicBrainz Album Id": "musicbrainz_albumid",
        "----:com.apple.iTunes:MusicBrainz Artist Id": "musicbrainz_artistid",
        "----:com.apple.iTunes:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
        "----:com.apple.iTunes:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
        "----:com.apple.iTunes:MusicBrainz Work Id": "musicbrainz_workid",
        "----:com.apple.iTunes:MusicBrainz TRM Id": "musicbrainz_trmid",
        "----:com.apple.iTunes:MusicBrainz Disc Id": "musicbrainz_discid",
        "----:com.apple.iTunes:Acoustid Id": "acoustid_id",
        "----:com.apple.iTunes:Acoustid Fingerprint": "acoustid_fingerprint",
        "----:com.apple.iTunes:MusicIP PUID": "musicip_puid",
        "----:com.apple.iTunes:fingerprint": "musicip_fingerprint",
        "----:com.apple.iTunes:replaygain_track_gain": "replaygain_track_gain",
        "----:com.apple.iTunes:replaygain_track_peak": "replaygain_track_peak",
        "----:com.apple.iTunes:replaygain_album_gain": "replaygain_album_gain",
        "----:com.apple.iTunes:replaygain_album_peak": "replaygain_album_peak",
        "----:com.apple.iTunes:replaygain_track_minmax": "replaygain_track_minmax",
        "----:com.apple.iTunes:replaygain_album_minmax": "replaygain_album_minmax",
        "----:com.apple.iTunes:replaygain_undo": "replaygain_undo",
gnre: "genre",
"----:com.apple.iTunes:ALBUMARTISTSORT": "albumartistsort",
        "----:com.apple.iTunes:ARTISTS": "artists",
        "----:com.apple.iTunes:ORIGINALDATE": "originaldate",
        "----:com.apple.iTunes:ORIGINALYEAR": "originalyear",
        "----:com.apple.iTunes:RELEASEDATE": "releasedate",
desc: "description",
        ldes: "longDescription",
        "©mvn": "movement",
        "©mvi": "movementIndex",
        "©mvc": "movementTotal",
        "©wrk": "work",
        catg: "category",
        egid: "podcastId",
        hdvd: "hdVideo",
        keyw: "keywords",
        shwm: "showMovement",
        stik: "stik",
        rate: "rating"
      };
      const tagType = "iTunes";
      class MP4TagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super([tagType], mp4TagMap);
        }
        postMap(tag2, warnings) {
          switch (tag2.id) {
            case "rate":
              tag2.value = {
                source: void 0,
                rating: Number.parseFloat(tag2.value) / 100
              };
              break;
          }
        }
      }
      const vorbisTagMap = {
        TITLE: "title",
        ARTIST: "artist",
        ARTISTS: "artists",
        ALBUMARTIST: "albumartist",
        "ALBUM ARTIST": "albumartist",
        ALBUM: "album",
        DATE: "date",
        ORIGINALDATE: "originaldate",
        ORIGINALYEAR: "originalyear",
        RELEASEDATE: "releasedate",
        COMMENT: "comment",
        TRACKNUMBER: "track",
        DISCNUMBER: "disk",
        GENRE: "genre",
        METADATA_BLOCK_PICTURE: "picture",
        COMPOSER: "composer",
        LYRICS: "lyrics",
        ALBUMSORT: "albumsort",
        TITLESORT: "titlesort",
        WORK: "work",
        ARTISTSORT: "artistsort",
        ALBUMARTISTSORT: "albumartistsort",
        COMPOSERSORT: "composersort",
        LYRICIST: "lyricist",
        WRITER: "writer",
        CONDUCTOR: "conductor",
REMIXER: "remixer",
        ARRANGER: "arranger",
        ENGINEER: "engineer",
        PRODUCER: "producer",
        DJMIXER: "djmixer",
        MIXER: "mixer",
        LABEL: "label",
        GROUPING: "grouping",
        SUBTITLE: "subtitle",
        DISCSUBTITLE: "discsubtitle",
        TRACKTOTAL: "totaltracks",
        DISCTOTAL: "totaldiscs",
        COMPILATION: "compilation",
        RATING: "rating",
        BPM: "bpm",
        KEY: "key",
        MOOD: "mood",
        MEDIA: "media",
        CATALOGNUMBER: "catalognumber",
        RELEASESTATUS: "releasestatus",
        RELEASETYPE: "releasetype",
        RELEASECOUNTRY: "releasecountry",
        SCRIPT: "script",
        LANGUAGE: "language",
        COPYRIGHT: "copyright",
        LICENSE: "license",
        ENCODEDBY: "encodedby",
        ENCODERSETTINGS: "encodersettings",
        BARCODE: "barcode",
        ISRC: "isrc",
        ASIN: "asin",
        MUSICBRAINZ_TRACKID: "musicbrainz_recordingid",
        MUSICBRAINZ_RELEASETRACKID: "musicbrainz_trackid",
        MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
        MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
        MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
        MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
        MUSICBRAINZ_WORKID: "musicbrainz_workid",
        MUSICBRAINZ_TRMID: "musicbrainz_trmid",
        MUSICBRAINZ_DISCID: "musicbrainz_discid",
        ACOUSTID_ID: "acoustid_id",
        ACOUSTID_ID_FINGERPRINT: "acoustid_fingerprint",
        MUSICIP_PUID: "musicip_puid",
WEBSITE: "website",
        NOTES: "notes",
        TOTALTRACKS: "totaltracks",
        TOTALDISCS: "totaldiscs",
DISCOGS_ARTIST_ID: "discogs_artist_id",
        DISCOGS_ARTISTS: "artists",
        DISCOGS_ARTIST_NAME: "artists",
        DISCOGS_ALBUM_ARTISTS: "albumartist",
        DISCOGS_CATALOG: "catalognumber",
        DISCOGS_COUNTRY: "releasecountry",
        DISCOGS_DATE: "originaldate",
        DISCOGS_LABEL: "label",
        DISCOGS_LABEL_ID: "discogs_label_id",
        DISCOGS_MASTER_RELEASE_ID: "discogs_master_release_id",
        DISCOGS_RATING: "discogs_rating",
        DISCOGS_RELEASED: "date",
        DISCOGS_RELEASE_ID: "discogs_release_id",
        DISCOGS_VOTES: "discogs_votes",
        CATALOGID: "catalognumber",
        STYLE: "genre",
REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
        REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
        REPLAYGAIN_ALBUM_GAIN: "replaygain_album_gain",
        REPLAYGAIN_ALBUM_PEAK: "replaygain_album_peak",
REPLAYGAIN_MINMAX: "replaygain_track_minmax",
        REPLAYGAIN_ALBUM_MINMAX: "replaygain_album_minmax",
        REPLAYGAIN_UNDO: "replaygain_undo"
      };
      class VorbisTagMapper extends CommonTagMapper {
        static toRating(email, rating, maxScore) {
          return {
            source: email ? email.toLowerCase() : void 0,
            rating: Number.parseFloat(rating) / maxScore * CommonTagMapper.maxRatingScore
          };
        }
        constructor() {
          super(["vorbis"], vorbisTagMap);
        }
        postMap(tag2) {
          if (tag2.id === "RATING") {
            tag2.value = VorbisTagMapper.toRating(void 0, tag2.value, 100);
          } else if (tag2.id.indexOf("RATING:") === 0) {
            const keys = tag2.id.split(":");
            tag2.value = VorbisTagMapper.toRating(keys[1], tag2.value, 1);
            tag2.id = keys[0];
          }
        }
      }
      const riffInfoTagMap = {
        IART: "artist",
ICRD: "date",
INAM: "title",
TITL: "title",
        IPRD: "album",
ITRK: "track",
        IPRT: "track",
COMM: "comment",
ICMT: "comment",
ICNT: "releasecountry",
        GNRE: "genre",
IWRI: "writer",
RATE: "rating",
        YEAR: "year",
        ISFT: "encodedby",
CODE: "encodedby",
TURL: "website",
IGNR: "genre",
IENG: "engineer",
ITCH: "technician",
IMED: "media",
IRPD: "album"
};
      class RiffInfoTagMapper extends CommonTagMapper {
        constructor() {
          super(["exif"], riffInfoTagMap);
        }
      }
      const ebmlTagMap = {
        "segment:title": "title",
        "album:ARTIST": "albumartist",
        "album:ARTISTSORT": "albumartistsort",
        "album:TITLE": "album",
        "album:DATE_RECORDED": "originaldate",
        "album:DATE_RELEASED": "releasedate",
        "album:PART_NUMBER": "disk",
        "album:TOTAL_PARTS": "totaltracks",
        "track:ARTIST": "artist",
        "track:ARTISTSORT": "artistsort",
        "track:TITLE": "title",
        "track:PART_NUMBER": "track",
        "track:MUSICBRAINZ_TRACKID": "musicbrainz_recordingid",
        "track:MUSICBRAINZ_ALBUMID": "musicbrainz_albumid",
        "track:MUSICBRAINZ_ARTISTID": "musicbrainz_artistid",
        "track:PUBLISHER": "label",
        "track:GENRE": "genre",
        "track:ENCODER": "encodedby",
        "track:ENCODER_OPTIONS": "encodersettings",
        "edition:TOTAL_PARTS": "totaldiscs",
        picture: "picture"
      };
      class MatroskaTagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super(["matroska"], ebmlTagMap);
        }
      }
      const tagMap = {
        NAME: "title",
        AUTH: "artist",
        "(c) ": "copyright",
        ANNO: "comment"
      };
      class AiffTagMapper extends CommonTagMapper {
        constructor() {
          super(["AIFF"], tagMap);
        }
      }
      class CombinedTagMapper {
        constructor() {
          this.tagMappers = {};
          [
            new ID3v1TagMapper(),
            new ID3v22TagMapper(),
            new ID3v24TagMapper(),
            new MP4TagMapper(),
            new MP4TagMapper(),
            new VorbisTagMapper(),
            new APEv2TagMapper(),
            new AsfTagMapper(),
            new RiffInfoTagMapper(),
            new MatroskaTagMapper(),
            new AiffTagMapper()
          ].forEach((mapper) => {
            this.registerTagMapper(mapper);
          });
        }
mapTag(tagType2, tag2, warnings) {
          const tagMapper = this.tagMappers[tagType2];
          if (tagMapper) {
            return this.tagMappers[tagType2].mapGenericTag(tag2, warnings);
          }
          throw new InternalParserError(`No generic tag mapper defined for tag-format: ${tagType2}`);
        }
        registerTagMapper(genericTagMapper) {
          for (const tagType2 of genericTagMapper.tagTypes) {
            this.tagMappers[tagType2] = genericTagMapper;
          }
        }
      }
      function parseLrc(lrcString) {
        const lines = lrcString.split("\n");
        const syncText = [];
        const timestampRegex = /\[(\d{2}):(\d{2})\.(\d{2})\]/;
        for (const line of lines) {
          const match = line.match(timestampRegex);
          if (match) {
            const minutes = Number.parseInt(match[1], 10);
            const seconds = Number.parseInt(match[2], 10);
            const hundredths = Number.parseInt(match[3], 10);
            const timestamp = (minutes * 60 + seconds) * 1e3 + hundredths * 10;
            const text2 = line.replace(timestampRegex, "").trim();
            syncText.push({ timestamp, text: text2 });
          }
        }
        return {
          contentType: LyricsContentType.lyrics,
          timeStampFormat: TimestampFormat.milliseconds,
          syncText
        };
      }
      const debug$3 = initDebug("music-metadata:collector");
      const TagPriority = ["matroska", "APEv2", "vorbis", "ID3v2.4", "ID3v2.3", "ID3v2.2", "exif", "asf", "iTunes", "AIFF", "ID3v1"];
      class MetadataCollector {
        constructor(opts) {
          this.format = {
            tagTypes: [],
            trackInfo: []
          };
          this.native = {};
          this.common = {
            track: { no: null, of: null },
            disk: { no: null, of: null },
            movementIndex: { no: null, of: null }
          };
          this.quality = {
            warnings: []
          };
          this.commonOrigin = {};
          this.originPriority = {};
          this.tagMapper = new CombinedTagMapper();
          this.opts = opts;
          let priority = 1;
          for (const tagType2 of TagPriority) {
            this.originPriority[tagType2] = priority++;
          }
          this.originPriority.artificial = 500;
          this.originPriority.id3v1 = 600;
        }
hasAny() {
          return Object.keys(this.native).length > 0;
        }
        addStreamInfo(streamInfo) {
          debug$3(`streamInfo: type=${streamInfo.type ? TrackTypeValueToKeyMap[streamInfo.type] : "?"}, codec=${streamInfo.codecName}`);
          this.format.trackInfo.push(streamInfo);
        }
        setFormat(key, value2) {
          debug$3(`format: ${key} = ${value2}`);
          this.format[key] = value2;
          if (this.opts?.observer) {
            this.opts.observer({ metadata: this, tag: { type: "format", id: key, value: value2 } });
          }
        }
        async addTag(tagType2, tagId, value2) {
          debug$3(`tag ${tagType2}.${tagId} = ${value2}`);
          if (!this.native[tagType2]) {
            this.format.tagTypes.push(tagType2);
            this.native[tagType2] = [];
          }
          this.native[tagType2].push({ id: tagId, value: value2 });
          await this.toCommon(tagType2, tagId, value2);
        }
        addWarning(warning2) {
          this.quality.warnings.push({ message: warning2 });
        }
        async postMap(tagType2, tag2) {
          switch (tag2.id) {
            case "artist":
              if (this.commonOrigin.artist === this.originPriority[tagType2]) {
                return this.postMap("artificial", { id: "artists", value: tag2.value });
              }
              if (!this.common.artists) {
                this.setGenericTag("artificial", { id: "artists", value: tag2.value });
              }
              break;
            case "artists":
              if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {
                if (!this.common.artists || this.common.artists.indexOf(tag2.value) === -1) {
                  const artists = (this.common.artists || []).concat([tag2.value]);
                  const value2 = joinArtists(artists);
                  const artistTag = { id: "artist", value: value2 };
                  this.setGenericTag("artificial", artistTag);
                }
              }
              break;
            case "picture":
              return this.postFixPicture(tag2.value).then((picture) => {
                if (picture !== null) {
                  tag2.value = picture;
                  this.setGenericTag(tagType2, tag2);
                }
              });
            case "totaltracks":
              this.common.track.of = CommonTagMapper.toIntOrNull(tag2.value);
              return;
            case "totaldiscs":
              this.common.disk.of = CommonTagMapper.toIntOrNull(tag2.value);
              return;
            case "movementTotal":
              this.common.movementIndex.of = CommonTagMapper.toIntOrNull(tag2.value);
              return;
            case "track":
            case "disk":
            case "movementIndex": {
              const of = this.common[tag2.id].of;
              this.common[tag2.id] = CommonTagMapper.normalizeTrack(tag2.value);
              this.common[tag2.id].of = of != null ? of : this.common[tag2.id].of;
              return;
            }
            case "bpm":
            case "year":
            case "originalyear":
              tag2.value = Number.parseInt(tag2.value, 10);
              break;
            case "date": {
              const year = Number.parseInt(tag2.value.substr(0, 4), 10);
              if (!Number.isNaN(year)) {
                this.common.year = year;
              }
              break;
            }
            case "discogs_label_id":
            case "discogs_release_id":
            case "discogs_master_release_id":
            case "discogs_artist_id":
            case "discogs_votes":
              tag2.value = typeof tag2.value === "string" ? Number.parseInt(tag2.value, 10) : tag2.value;
              break;
            case "replaygain_track_gain":
            case "replaygain_track_peak":
            case "replaygain_album_gain":
            case "replaygain_album_peak":
              tag2.value = toRatio(tag2.value);
              break;
            case "replaygain_track_minmax":
              tag2.value = tag2.value.split(",").map((v) => Number.parseInt(v, 10));
              break;
            case "replaygain_undo": {
              const minMix = tag2.value.split(",").map((v) => Number.parseInt(v, 10));
              tag2.value = {
                leftChannel: minMix[0],
                rightChannel: minMix[1]
              };
              break;
            }
            case "gapless":
case "compilation":
            case "podcast":
            case "showMovement":
              tag2.value = tag2.value === "1" || tag2.value === 1;
              break;
            case "isrc": {
              const commonTag = this.common[tag2.id];
              if (commonTag && commonTag.indexOf(tag2.value) !== -1)
                return;
              break;
            }
            case "comment":
              if (typeof tag2.value === "string") {
                tag2.value = { text: tag2.value };
              }
              if (tag2.value.descriptor === "iTunPGAP") {
                this.setGenericTag(tagType2, { id: "gapless", value: tag2.value.text === "1" });
              }
              break;
            case "lyrics":
              if (typeof tag2.value === "string") {
                tag2.value = parseLrc(tag2.value);
              }
              break;
          }
          if (tag2.value !== null) {
            this.setGenericTag(tagType2, tag2);
          }
        }
toCommonMetadata() {
          return {
            format: this.format,
            native: this.native,
            quality: this.quality,
            common: this.common
          };
        }
async postFixPicture(picture) {
          if (picture.data && picture.data.length > 0) {
            if (!picture.format) {
              const fileType = await fileTypeFromBuffer(Uint8Array.from(picture.data));
              if (fileType) {
                picture.format = fileType.mime;
              } else {
                return null;
              }
            }
            picture.format = picture.format.toLocaleLowerCase();
            switch (picture.format) {
              case "image/jpg":
                picture.format = "image/jpeg";
            }
            return picture;
          }
          this.addWarning("Empty picture tag found");
          return null;
        }
async toCommon(tagType2, tagId, value2) {
          const tag2 = { id: tagId, value: value2 };
          const genericTag = this.tagMapper.mapTag(tagType2, tag2, this);
          if (genericTag) {
            await this.postMap(tagType2, genericTag);
          }
        }
setGenericTag(tagType2, tag2) {
          debug$3(`common.${tag2.id} = ${tag2.value}`);
          const prio0 = this.commonOrigin[tag2.id] || 1e3;
          const prio1 = this.originPriority[tagType2];
          if (isSingleton(tag2.id)) {
            if (prio1 <= prio0) {
              this.common[tag2.id] = tag2.value;
              this.commonOrigin[tag2.id] = prio1;
            } else {
              return debug$3(`Ignore native tag (singleton): ${tagType2}.${tag2.id} = ${tag2.value}`);
            }
          } else {
            if (prio1 === prio0) {
              if (!isUnique(tag2.id) || this.common[tag2.id].indexOf(tag2.value) === -1) {
                this.common[tag2.id].push(tag2.value);
              } else {
                debug$3(`Ignore duplicate value: ${tagType2}.${tag2.id} = ${tag2.value}`);
              }
            } else if (prio1 < prio0) {
              this.common[tag2.id] = [tag2.value];
              this.commonOrigin[tag2.id] = prio1;
            } else {
              return debug$3(`Ignore native tag (list): ${tagType2}.${tag2.id} = ${tag2.value}`);
            }
          }
          if (this.opts?.observer) {
            this.opts.observer({ metadata: this, tag: { type: "common", id: tag2.id, value: tag2.value } });
          }
        }
      }
      function joinArtists(artists) {
        if (artists.length > 2) {
          return `${artists.slice(0, artists.length - 1).join(", ")} & ${artists[artists.length - 1]}`;
        }
        return artists.join(" & ");
      }
      const scriptRel = (function detectScriptRel() {
        const relList = typeof document !== "undefined" && document.createElement("link").relList;
        return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
      })();
      const assetsURL = function(dep) {
        return "/" + dep;
      };
      const seen = {};
      const __vitePreload = function preload(baseModule, deps, importerUrl) {
        let promise = Promise.resolve();
        if (deps && deps.length > 0) {
          let allSettled = function(promises$2) {
            return Promise.all(promises$2.map((p) => Promise.resolve(p).then((value$12) => ({
              status: "fulfilled",
              value: value$12
            }), (reason) => ({
              status: "rejected",
              reason
            }))));
          };
          document.getElementsByTagName("link");
          const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
          const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
          promise = allSettled(deps.map((dep) => {
            dep = assetsURL(dep);
            if (dep in seen) return;
            seen[dep] = true;
            const isCss = dep.endsWith(".css");
            const cssSelector = isCss ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
            const link = document.createElement("link");
            link.rel = isCss ? "stylesheet" : scriptRel;
            if (!isCss) link.as = "script";
            link.crossOrigin = "";
            link.href = dep;
            if (cspNonce) link.setAttribute("nonce", cspNonce);
            document.head.appendChild(link);
            if (isCss) return new Promise((res, rej) => {
              link.addEventListener("load", res);
              link.addEventListener("error", () => rej( new Error(`Unable to preload CSS for ${dep}`)));
            });
          }));
        }
        function handlePreloadError(err$2) {
          const e$1 = new Event("vite:preloadError", { cancelable: true });
          e$1.payload = err$2;
          window.dispatchEvent(e$1);
          if (!e$1.defaultPrevented) throw err$2;
        }
        return promise.then((res) => {
          for (const item of res || []) {
            if (item.status !== "rejected") continue;
            handlePreloadError(item.reason);
          }
          return baseModule().catch(handlePreloadError);
        });
      };
      const mpegParserLoader = {
        parserType: "mpeg",
        extensions: [".mp2", ".mp3", ".m2a", ".aac", "aacp"],
        mimeTypes: ["audio/mpeg", "audio/mp3", "audio/aacs", "audio/aacp"],
        async load() {
          return (await __vitePreload(async () => {
            const { MpegParser } = await module.import('./MpegParser-BMBmvP9Z-CHeEGubd.js');
            return { MpegParser };
          }, void 0 )).MpegParser;
        }
      };
      const apeParserLoader = {
        parserType: "apev2",
        extensions: [".ape"],
        mimeTypes: ["audio/ape", "audio/monkeys-audio"],
        async load() {
          return (await __vitePreload(async () => {
            const { APEv2Parser: APEv2Parser2 } = await Promise.resolve().then(() => APEv2Parser$1);
            return { APEv2Parser: APEv2Parser2 };
          }, void 0 )).APEv2Parser;
        }
      };
      const asfParserLoader = {
        parserType: "asf",
        extensions: [".asf"],
        mimeTypes: ["audio/ms-wma", "video/ms-wmv", "audio/ms-asf", "video/ms-asf", "application/vnd.ms-asf"],
        async load() {
          return (await __vitePreload(async () => {
            const { AsfParser } = await module.import('./AsfParser-BKSZNp_1-zO0gX5bz.js');
            return { AsfParser };
          }, void 0 )).AsfParser;
        }
      };
      const dsdiffParserLoader = {
        parserType: "dsdiff",
        extensions: [".dff"],
        mimeTypes: ["audio/dsf", "audio/dsd"],
        async load() {
          return (await __vitePreload(async () => {
            const { DsdiffParser } = await module.import('./DsdiffParser-CHjTZSpt-Bplvt7ms.js');
            return { DsdiffParser };
          }, void 0 )).DsdiffParser;
        }
      };
      const aiffParserLoader = {
        parserType: "aiff",
        extensions: [".aif", "aiff", "aifc"],
        mimeTypes: ["audio/aiff", "audio/aif", "audio/aifc", "application/aiff"],
        async load() {
          return (await __vitePreload(async () => {
            const { AIFFParser } = await module.import('./AiffParser-MlFVZ_c0-Bn78UYfD.js');
            return { AIFFParser };
          }, void 0 )).AIFFParser;
        }
      };
      const dsfParserLoader = {
        parserType: "dsf",
        extensions: [".dsf"],
        mimeTypes: ["audio/dsf"],
        async load() {
          return (await __vitePreload(async () => {
            const { DsfParser } = await module.import('./DsfParser-CtAKOhgc-CKUZVLlA.js');
            return { DsfParser };
          }, void 0 )).DsfParser;
        }
      };
      const flacParserLoader = {
        parserType: "flac",
        extensions: [".flac"],
        mimeTypes: ["audio/flac"],
        async load() {
          return (await __vitePreload(async () => {
            const { FlacParser } = await module.import('./FlacParser-CDXQvU-n-BHThkOqb.js');
            return { FlacParser };
          }, void 0 )).FlacParser;
        }
      };
      const matroskaParserLoader = {
        parserType: "matroska",
        extensions: [".mka", ".mkv", ".mk3d", ".mks", "webm"],
        mimeTypes: ["audio/matroska", "video/matroska", "audio/webm", "video/webm"],
        async load() {
          return (await __vitePreload(async () => {
            const { MatroskaParser } = await module.import('./MatroskaParser-DZIRNedW-DfvIL0R_.js');
            return { MatroskaParser };
          }, void 0 )).MatroskaParser;
        }
      };
      const mp4ParserLoader = {
        parserType: "mp4",
        extensions: [".mp4", ".m4a", ".m4b", ".m4pa", "m4v", "m4r", "3gp"],
        mimeTypes: ["audio/mp4", "audio/m4a", "video/m4v", "video/mp4"],
        async load() {
          return (await __vitePreload(async () => {
            const { MP4Parser } = await module.import('./MP4Parser-CWip5UUj-B4R5O7d5.js');
            return { MP4Parser };
          }, void 0 )).MP4Parser;
        }
      };
      const musepackParserLoader = {
        parserType: "musepack",
        extensions: [".mpc"],
        mimeTypes: ["audio/musepack"],
        async load() {
          return (await __vitePreload(async () => {
            const { MusepackParser } = await module.import('./MusepackParser-CH73a0C_-C0L_t5L8.js');
            return { MusepackParser };
          }, void 0 )).MusepackParser;
        }
      };
      const oggParserLoader = {
        parserType: "ogg",
        extensions: [".ogg", ".ogv", ".oga", ".ogm", ".ogx", ".opus", ".spx"],
        mimeTypes: ["audio/ogg", "audio/opus", "audio/speex", "video/ogg"],
async load() {
          return (await __vitePreload(async () => {
            const { OggParser } = await module.import('./OggParser-BylYP5pO-BC5AeNrm.js');
            return { OggParser };
          }, void 0 )).OggParser;
        }
      };
      const wavpackParserLoader = {
        parserType: "wavpack",
        extensions: [".wv", ".wvp"],
        mimeTypes: ["audio/wavpack"],
        async load() {
          return (await __vitePreload(async () => {
            const { WavPackParser } = await module.import('./WavPackParser-COdXYliS-Cq5Wc3fD.js');
            return { WavPackParser };
          }, void 0 )).WavPackParser;
        }
      };
      const riffParserLoader = {
        parserType: "riff",
        extensions: [".wav", "wave", ".bwf"],
        mimeTypes: ["audio/vnd.wave", "audio/wav", "audio/wave"],
        async load() {
          return (await __vitePreload(async () => {
            const { WaveParser } = await module.import('./WaveParser-_IoaL05V-BBzBiDCR.js');
            return { WaveParser };
          }, void 0 )).WaveParser;
        }
      };
      const debug$2 = initDebug("music-metadata:parser:factory");
      function parseHttpContentType(contentType2) {
        const type = ContentType.parse(contentType2);
        const mime = mediaTyperExports.parse(type.type);
        return {
          type: mime.type,
          subtype: mime.subtype,
          suffix: mime.suffix,
          parameters: type.parameters
        };
      }
      class ParserFactory {
        constructor() {
          this.parsers = [];
          [
            flacParserLoader,
            mpegParserLoader,
            apeParserLoader,
            mp4ParserLoader,
            matroskaParserLoader,
            riffParserLoader,
            oggParserLoader,
            asfParserLoader,
            aiffParserLoader,
            wavpackParserLoader,
            musepackParserLoader,
            dsfParserLoader,
            dsdiffParserLoader
          ].forEach((parser) => this.registerParser(parser));
        }
        registerParser(parser) {
          this.parsers.push(parser);
        }
        async parse(tokenizer, parserLoader, opts) {
          if (tokenizer.supportsRandomAccess()) {
            debug$2("tokenizer supports random-access, scanning for appending headers");
            await scanAppendingHeaders(tokenizer, opts);
          } else {
            debug$2("tokenizer does not support random-access, cannot scan for appending headers");
          }
          if (!parserLoader) {
            const buf = new Uint8Array(4100);
            if (tokenizer.fileInfo.mimeType) {
              parserLoader = this.findLoaderForContentType(tokenizer.fileInfo.mimeType);
            }
            if (!parserLoader && tokenizer.fileInfo.path) {
              parserLoader = this.findLoaderForExtension(tokenizer.fileInfo.path);
            }
            if (!parserLoader) {
              debug$2("Guess parser on content...");
              await tokenizer.peekBuffer(buf, { mayBeLess: true });
              const guessedType = await fileTypeFromBuffer(buf);
              if (!guessedType || !guessedType.mime) {
                throw new CouldNotDetermineFileTypeError("Failed to determine audio format");
              }
              debug$2(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);
              parserLoader = this.findLoaderForContentType(guessedType.mime);
              if (!parserLoader) {
                throw new UnsupportedFileTypeError(`Guessed MIME-type not supported: ${guessedType.mime}`);
              }
            }
          }
          debug$2(`Loading ${parserLoader.parserType} parser...`);
          const metadata = new MetadataCollector(opts);
          const ParserImpl = await parserLoader.load();
          const parser = new ParserImpl(metadata, tokenizer, opts ?? {});
          debug$2(`Parser ${parserLoader.parserType} loaded`);
          await parser.parse();
          return metadata.toCommonMetadata();
        }
findLoaderForExtension(filePath) {
          if (!filePath)
            return;
          const extension = getExtension(filePath).toLocaleLowerCase() || filePath;
          return this.parsers.find((parser) => parser.extensions.indexOf(extension) !== -1);
        }
        findLoaderForContentType(httpContentType) {
          let mime;
          if (!httpContentType)
            return;
          try {
            mime = parseHttpContentType(httpContentType);
          } catch (err2) {
            debug$2(`Invalid HTTP Content-Type header value: ${httpContentType}`);
            return;
          }
          const subType = mime.subtype.indexOf("x-") === 0 ? mime.subtype.substring(2) : mime.subtype;
          return this.parsers.find((parser) => parser.mimeTypes.find((loader) => loader.indexOf(`${mime.type}/${subType}`) !== -1));
        }
        getSupportedMimeTypes() {
          const mimeTypeSet = new Set();
          this.parsers.forEach((loader) => {
            loader.mimeTypes.forEach((mimeType) => {
              mimeTypeSet.add(mimeType);
              mimeTypeSet.add(mimeType.replace("/", "/x-"));
            });
          });
          return Array.from(mimeTypeSet);
        }
      }
      function getExtension(fname) {
        const i = fname.lastIndexOf(".");
        return i === -1 ? "" : fname.slice(i);
      }
      class BasicParser {
constructor(metadata, tokenizer, options) {
          this.metadata = metadata;
          this.tokenizer = tokenizer;
          this.options = options;
        }
      } exports("B", BasicParser);
      const validFourCC = /^[\x21-\x7e©][\x20-\x7e\x00()]{3}/;
      const FourCcToken = exports("F", {
        len: 4,
        get: (buf, off2) => {
          const id = uint8ArrayToString(buf.slice(off2, off2 + FourCcToken.len), "latin1");
          if (!id.match(validFourCC)) {
            throw new FieldDecodingError(`FourCC contains invalid characters: ${a2hex(id)} "${id}"`);
          }
          return id;
        },
        put: (buffer, offset, id) => {
          const str = stringToUint8Array(id);
          if (str.length !== 4)
            throw new InternalParserError("Invalid length");
          buffer.set(str, offset);
          return offset + 4;
        }
      });
      const DataType = {
        text_utf8: 0,
        binary: 1,
        external_info: 2,
        reserved: 3
      };
      const DescriptorParser = {
        len: 52,
        get: (buf, off2) => {
          return {
ID: FourCcToken.get(buf, off2),
version: UINT32_LE.get(buf, off2 + 4) / 1e3,
descriptorBytes: UINT32_LE.get(buf, off2 + 8),
headerBytes: UINT32_LE.get(buf, off2 + 12),
seekTableBytes: UINT32_LE.get(buf, off2 + 16),
headerDataBytes: UINT32_LE.get(buf, off2 + 20),
apeFrameDataBytes: UINT32_LE.get(buf, off2 + 24),
apeFrameDataBytesHigh: UINT32_LE.get(buf, off2 + 28),
terminatingDataBytes: UINT32_LE.get(buf, off2 + 32),
fileMD5: new Uint8ArrayType(16).get(buf, off2 + 36)
          };
        }
      };
      const Header = {
        len: 24,
        get: (buf, off2) => {
          return {
compressionLevel: UINT16_LE.get(buf, off2),
formatFlags: UINT16_LE.get(buf, off2 + 2),
blocksPerFrame: UINT32_LE.get(buf, off2 + 4),
finalFrameBlocks: UINT32_LE.get(buf, off2 + 8),
totalFrames: UINT32_LE.get(buf, off2 + 12),
bitsPerSample: UINT16_LE.get(buf, off2 + 16),
channel: UINT16_LE.get(buf, off2 + 18),
sampleRate: UINT32_LE.get(buf, off2 + 20)
          };
        }
      };
      const TagFooter = {
        len: 32,
        get: (buf, off2) => {
          return {
ID: new StringType(8, "ascii").get(buf, off2),
version: UINT32_LE.get(buf, off2 + 8),
size: UINT32_LE.get(buf, off2 + 12),
fields: UINT32_LE.get(buf, off2 + 16),
flags: parseTagFlags(UINT32_LE.get(buf, off2 + 20))
          };
        }
      };
      const TagItemHeader = {
        len: 8,
        get: (buf, off2) => {
          return {
size: UINT32_LE.get(buf, off2),
flags: parseTagFlags(UINT32_LE.get(buf, off2 + 4))
          };
        }
      };
      function parseTagFlags(flags) {
        return {
          containsHeader: isBitSet(flags, 31),
          containsFooter: isBitSet(flags, 30),
          isHeader: isBitSet(flags, 29),
          readOnly: isBitSet(flags, 0),
          dataType: (flags & 6) >> 1
        };
      }
      function isBitSet(num, bit) {
        return (num & 1 << bit) !== 0;
      }
      const debug$1 = initDebug("music-metadata:parser:APEv2");
      const tagFormat = "APEv2";
      const preamble = "APETAGEX";
      class ApeContentError extends makeUnexpectedFileContentError("APEv2") {
      }
      class APEv2Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.ape = {};
        }
        static tryParseApeHeader(metadata, tokenizer, options) {
          const apeParser = new APEv2Parser(metadata, tokenizer, options);
          return apeParser.tryParseApeHeader();
        }
static calculateDuration(ah) {
          let duration2 = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;
          duration2 += ah.finalFrameBlocks;
          return duration2 / ah.sampleRate;
        }
static async findApeFooterOffset(tokenizer, offset) {
          const apeBuf = new Uint8Array(TagFooter.len);
          const position = tokenizer.position;
          if (offset <= TagFooter.len) {
            debug$1(`Offset is too small to read APE footer: offset=${offset}`);
            return void 0;
          }
          if (offset > TagFooter.len) {
            await tokenizer.readBuffer(apeBuf, { position: offset - TagFooter.len });
            tokenizer.setPosition(position);
            const tagFooter = TagFooter.get(apeBuf, 0);
            if (tagFooter.ID === "APETAGEX") {
              if (tagFooter.flags.isHeader) {
                debug$1(`APE Header found at offset=${offset - TagFooter.len}`);
              } else {
                debug$1(`APE Footer found at offset=${offset - TagFooter.len}`);
                offset -= tagFooter.size;
              }
              return { footer: tagFooter, offset };
            }
          }
        }
        static parseTagFooter(metadata, buffer, options) {
          const footer2 = TagFooter.get(buffer, buffer.length - TagFooter.len);
          if (footer2.ID !== preamble)
            throw new ApeContentError("Unexpected APEv2 Footer ID preamble value");
          fromBuffer(buffer);
          const apeParser = new APEv2Parser(metadata, fromBuffer(buffer), options);
          return apeParser.parseTags(footer2);
        }
async tryParseApeHeader() {
          if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < TagFooter.len) {
            debug$1("No APEv2 header found, end-of-file reached");
            return;
          }
          const footer2 = await this.tokenizer.peekToken(TagFooter);
          if (footer2.ID === preamble) {
            await this.tokenizer.ignore(TagFooter.len);
            return this.parseTags(footer2);
          }
          debug$1(`APEv2 header not found at offset=${this.tokenizer.position}`);
          if (this.tokenizer.fileInfo.size) {
            const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position;
            const buffer = new Uint8Array(remaining);
            await this.tokenizer.readBuffer(buffer);
            return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);
          }
        }
        async parse() {
          const descriptor = await this.tokenizer.readToken(DescriptorParser);
          if (descriptor.ID !== "MAC ")
            throw new ApeContentError("Unexpected descriptor ID");
          this.ape.descriptor = descriptor;
          const lenExp = descriptor.descriptorBytes - DescriptorParser.len;
          const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());
          await this.tokenizer.ignore(header.forwardBytes);
          return this.tryParseApeHeader();
        }
        async parseTags(footer2) {
          const keyBuffer = new Uint8Array(256);
          let bytesRemaining = footer2.size - TagFooter.len;
          debug$1(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);
          for (let i = 0; i < footer2.fields; i++) {
            if (bytesRemaining < TagItemHeader.len) {
              this.metadata.addWarning(`APEv2 Tag-header: ${footer2.fields - i} items remaining, but no more tag data to read.`);
              break;
            }
            const tagItemHeader = await this.tokenizer.readToken(TagItemHeader);
            bytesRemaining -= TagItemHeader.len + tagItemHeader.size;
            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });
            let zero = findZero(keyBuffer, 0, keyBuffer.length);
            const key = await this.tokenizer.readToken(new StringType(zero, "ascii"));
            await this.tokenizer.ignore(1);
            bytesRemaining -= key.length + 1;
            switch (tagItemHeader.flags.dataType) {
              case DataType.text_utf8: {
                const value2 = await this.tokenizer.readToken(new StringType(tagItemHeader.size, "utf8"));
                const values = value2.split(/\x00/g);
                await Promise.all(values.map((val) => this.metadata.addTag(tagFormat, key, val)));
                break;
              }
              case DataType.binary:
                if (this.options.skipCovers) {
                  await this.tokenizer.ignore(tagItemHeader.size);
                } else {
                  const picData = new Uint8Array(tagItemHeader.size);
                  await this.tokenizer.readBuffer(picData);
                  zero = findZero(picData, 0, picData.length);
                  const description = uint8ArrayToString(picData.slice(0, zero));
                  const data = picData.slice(zero + 1);
                  await this.metadata.addTag(tagFormat, key, {
                    description,
                    data
                  });
                }
                break;
              case DataType.external_info:
                debug$1(`Ignore external info ${key}`);
                await this.tokenizer.ignore(tagItemHeader.size);
                break;
              case DataType.reserved:
                debug$1(`Ignore external info ${key}`);
                this.metadata.addWarning(`APEv2 header declares a reserved datatype for "${key}"`);
                await this.tokenizer.ignore(tagItemHeader.size);
                break;
            }
          }
        }
        async parseDescriptorExpansion(lenExp) {
          await this.tokenizer.ignore(lenExp);
          return this.parseHeader();
        }
        async parseHeader() {
          const header = await this.tokenizer.readToken(Header);
          this.metadata.setFormat("lossless", true);
          this.metadata.setFormat("container", "Monkey's Audio");
          this.metadata.setFormat("bitsPerSample", header.bitsPerSample);
          this.metadata.setFormat("sampleRate", header.sampleRate);
          this.metadata.setFormat("numberOfChannels", header.channel);
          this.metadata.setFormat("duration", APEv2Parser.calculateDuration(header));
          if (!this.ape.descriptor) {
            throw new ApeContentError("Missing APE descriptor");
          }
          return {
            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes
          };
        }
      } exports("J", APEv2Parser);
      const APEv2Parser$1 = Object.freeze( Object.defineProperty({
        __proto__: null,
        APEv2Parser,
        ApeContentError
      }, Symbol.toStringTag, { value: "Module" }));
      const debug = initDebug("music-metadata:parser:ID3v1");
      const Genres = exports("G", [
        "Blues",
        "Classic Rock",
        "Country",
        "Dance",
        "Disco",
        "Funk",
        "Grunge",
        "Hip-Hop",
        "Jazz",
        "Metal",
        "New Age",
        "Oldies",
        "Other",
        "Pop",
        "R&B",
        "Rap",
        "Reggae",
        "Rock",
        "Techno",
        "Industrial",
        "Alternative",
        "Ska",
        "Death Metal",
        "Pranks",
        "Soundtrack",
        "Euro-Techno",
        "Ambient",
        "Trip-Hop",
        "Vocal",
        "Jazz+Funk",
        "Fusion",
        "Trance",
        "Classical",
        "Instrumental",
        "Acid",
        "House",
        "Game",
        "Sound Clip",
        "Gospel",
        "Noise",
        "Alt. Rock",
        "Bass",
        "Soul",
        "Punk",
        "Space",
        "Meditative",
        "Instrumental Pop",
        "Instrumental Rock",
        "Ethnic",
        "Gothic",
        "Darkwave",
        "Techno-Industrial",
        "Electronic",
        "Pop-Folk",
        "Eurodance",
        "Dream",
        "Southern Rock",
        "Comedy",
        "Cult",
        "Gangsta Rap",
        "Top 40",
        "Christian Rap",
        "Pop/Funk",
        "Jungle",
        "Native American",
        "Cabaret",
        "New Wave",
        "Psychedelic",
        "Rave",
        "Showtunes",
        "Trailer",
        "Lo-Fi",
        "Tribal",
        "Acid Punk",
        "Acid Jazz",
        "Polka",
        "Retro",
        "Musical",
        "Rock & Roll",
        "Hard Rock",
        "Folk",
        "Folk/Rock",
        "National Folk",
        "Swing",
        "Fast-Fusion",
        "Bebob",
        "Latin",
        "Revival",
        "Celtic",
        "Bluegrass",
        "Avantgarde",
        "Gothic Rock",
        "Progressive Rock",
        "Psychedelic Rock",
        "Symphonic Rock",
        "Slow Rock",
        "Big Band",
        "Chorus",
        "Easy Listening",
        "Acoustic",
        "Humour",
        "Speech",
        "Chanson",
        "Opera",
        "Chamber Music",
        "Sonata",
        "Symphony",
        "Booty Bass",
        "Primus",
        "Porn Groove",
        "Satire",
        "Slow Jam",
        "Club",
        "Tango",
        "Samba",
        "Folklore",
        "Ballad",
        "Power Ballad",
        "Rhythmic Soul",
        "Freestyle",
        "Duet",
        "Punk Rock",
        "Drum Solo",
        "A Cappella",
        "Euro-House",
        "Dance Hall",
        "Goa",
        "Drum & Bass",
        "Club-House",
        "Hardcore",
        "Terror",
        "Indie",
        "BritPop",
        "Negerpunk",
        "Polsk Punk",
        "Beat",
        "Christian Gangsta Rap",
        "Heavy Metal",
        "Black Metal",
        "Crossover",
        "Contemporary Christian",
        "Christian Rock",
        "Merengue",
        "Salsa",
        "Thrash Metal",
        "Anime",
        "JPop",
        "Synthpop",
        "Abstract",
        "Art Rock",
        "Baroque",
        "Bhangra",
        "Big Beat",
        "Breakbeat",
        "Chillout",
        "Downtempo",
        "Dub",
        "EBM",
        "Eclectic",
        "Electro",
        "Electroclash",
        "Emo",
        "Experimental",
        "Garage",
        "Global",
        "IDM",
        "Illbient",
        "Industro-Goth",
        "Jam Band",
        "Krautrock",
        "Leftfield",
        "Lounge",
        "Math Rock",
        "New Romantic",
        "Nu-Breakz",
        "Post-Punk",
        "Post-Rock",
        "Psytrance",
        "Shoegaze",
        "Space Rock",
        "Trop Rock",
        "World Music",
        "Neoclassical",
        "Audiobook",
        "Audio Theatre",
        "Neue Deutsche Welle",
        "Podcast",
        "Indie Rock",
        "G-Funk",
        "Dubstep",
        "Garage Rock",
        "Psybient"
      ]);
      const Iid3v1Token = {
        len: 128,
get: (buf, off2) => {
          const header = new Id3v1StringType(3).get(buf, off2);
          return header === "TAG" ? {
            header,
            title: new Id3v1StringType(30).get(buf, off2 + 3),
            artist: new Id3v1StringType(30).get(buf, off2 + 33),
            album: new Id3v1StringType(30).get(buf, off2 + 63),
            year: new Id3v1StringType(4).get(buf, off2 + 93),
            comment: new Id3v1StringType(28).get(buf, off2 + 97),
zeroByte: UINT8.get(buf, off2 + 127),
track: UINT8.get(buf, off2 + 126),
            genre: UINT8.get(buf, off2 + 127)
          } : null;
        }
      };
      class Id3v1StringType {
        constructor(len) {
          this.len = len;
          this.stringType = new StringType(len, "latin1");
        }
        get(buf, off2) {
          let value2 = this.stringType.get(buf, off2);
          value2 = trimRightNull(value2);
          value2 = value2.trim();
          return value2.length > 0 ? value2 : void 0;
        }
      }
      class ID3v1Parser extends BasicParser {
        constructor(metadata, tokenizer, options) {
          super(metadata, tokenizer, options);
          this.apeHeader = options.apeHeader;
        }
        static getGenre(genreIndex) {
          if (genreIndex < Genres.length) {
            return Genres[genreIndex];
          }
          return void 0;
        }
        async parse() {
          if (!this.tokenizer.fileInfo.size) {
            debug("Skip checking for ID3v1 because the file-size is unknown");
            return;
          }
          if (this.apeHeader) {
            this.tokenizer.ignore(this.apeHeader.offset - this.tokenizer.position);
            const apeParser = new APEv2Parser(this.metadata, this.tokenizer, this.options);
            await apeParser.parseTags(this.apeHeader.footer);
          }
          const offset = this.tokenizer.fileInfo.size - Iid3v1Token.len;
          if (this.tokenizer.position > offset) {
            debug("Already consumed the last 128 bytes");
            return;
          }
          const header = await this.tokenizer.readToken(Iid3v1Token, offset);
          if (header) {
            debug("ID3v1 header found at: pos=%s", this.tokenizer.fileInfo.size - Iid3v1Token.len);
            const props = ["title", "artist", "album", "comment", "track", "year"];
            for (const id of props) {
              if (header[id] && header[id] !== "")
                await this.addTag(id, header[id]);
            }
            const genre = ID3v1Parser.getGenre(header.genre);
            if (genre)
              await this.addTag("genre", genre);
          } else {
            debug("ID3v1 header not found at: pos=%s", this.tokenizer.fileInfo.size - Iid3v1Token.len);
          }
        }
        async addTag(id, value2) {
          await this.metadata.addTag("ID3v1", id, value2);
        }
      } exports("L", ID3v1Parser);
      async function hasID3v1Header(tokenizer) {
        if (tokenizer.fileInfo.size >= 128) {
          const tag2 = new Uint8Array(3);
          const position = tokenizer.position;
          await tokenizer.readBuffer(tag2, { position: tokenizer.fileInfo.size - 128 });
          tokenizer.setPosition(position);
          return new TextDecoder("latin1").decode(tag2) === "TAG";
        }
        return false;
      }
      const endTag2 = "LYRICS200";
      async function getLyricsHeaderLength(tokenizer) {
        const fileSize = tokenizer.fileInfo.size;
        if (fileSize >= 143) {
          const buf = new Uint8Array(15);
          const position = tokenizer.position;
          await tokenizer.readBuffer(buf, { position: fileSize - 143 });
          tokenizer.setPosition(position);
          const txt = new TextDecoder("latin1").decode(buf);
          const tag2 = txt.slice(6);
          if (tag2 === endTag2) {
            return Number.parseInt(txt.slice(0, 6), 10) + 15;
          }
        }
        return 0;
      }
      async function parseBlob(blob, options = {}) {
        const fileInfo = { mimeType: blob.type, size: blob.size };
        if (blob instanceof File) {
          fileInfo.path = blob.name;
        }
        return parseWebStream(blob.stream(), fileInfo, options);
      }
      async function parseWebStream(webStream, fileInfo, options = {}) {
        const tokenizer = fromWebStream(webStream, { fileInfo: typeof fileInfo === "string" ? { mimeType: fileInfo } : fileInfo });
        try {
          return await parseFromTokenizer(tokenizer, options);
        } finally {
          await tokenizer.close();
        }
      }
      function parseFromTokenizer(tokenizer, options) {
        const parserFactory = new ParserFactory();
        return parserFactory.parse(tokenizer, void 0, options);
      }
      async function scanAppendingHeaders(tokenizer, options = {}) {
        let apeOffset = tokenizer.fileInfo.size;
        if (await hasID3v1Header(tokenizer)) {
          apeOffset -= 128;
          const lyricsLen = await getLyricsHeaderLength(tokenizer);
          apeOffset -= lyricsLen;
        }
        options.apeHeader = await APEv2Parser.findApeFooterOffset(tokenizer, apeOffset);
      }
      const QUALITY_LEVELS = {
        "Hi-Res": "hires",
        无损: "lossless",
        较高: "higher"
      };
      const BASE_CDN_URL = "https://fastly.jsdelivr.net/gh/520Qiuyu/cdn@latest/artist/";
      const formatFileSize = (size2) => {
        if (!size2 || isNaN(size2)) return "0 B";
        const units = ["B", "KB", "MB", "GB", "TB"];
        size2 = Math.abs(Number(size2));
        let index = 0;
        while (size2 >= 1024 && index < units.length - 1) {
          size2 /= 1024;
          index++;
        }
        return `${size2.toFixed(index > 0 ? 1 : 0)} ${units[index]}`;
      };
      const formatDuration$1 = (ms2) => {
        const totalSeconds = Math.floor(ms2 / 1e3);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
      };
      const normalizeString = (str) => {
        if (!str) return "";
        return str.toLowerCase().replace(/[\s-_，,\.…—]/g, "");
      };
      function chunkArray(array, size2) {
        const result = [];
        for (let i = 0; i < array.length; i += size2) {
          result.push(array.slice(i, i + size2));
        }
        return result;
      }
      const getArtistTextInSongDetail = (song) => {
        return song.ar?.map((ar) => ar.name)?.filter(Boolean).join() || song.pc?.ar || song.artist || "";
      };
      const getAlbumTextInSongDetail = (song) => {
        return song.al?.name || song.pc?.alb || "";
      };
      const uniqueArrayByKey = (arr, key) => {
        if (!Array.isArray(arr)) return [];
        if (!key) return arr;
        const seen2 = new Map();
        return arr.filter((item) => {
          if (!item || typeof item !== "object") return false;
          const val = item[key];
          if (seen2.has(val)) return false;
          seen2.set(val, true);
          return true;
        });
      };
      const promiseLimit = (promiseArray, limit = 6) => {
        if (!Array.isArray(promiseArray)) {
          throw new Error("第一个参数必须是数组");
        }
        if (!Number.isInteger(limit) || limit < 1) {
          throw new Error("并发限制必须是正整数");
        }
        if (promiseArray.length === 0) {
          return Promise.resolve([]);
        }
        return new Promise((resolve, reject) => {
          const results = new Array(promiseArray.length);
          let completed = 0;
          let currentIndex = 0;
          const runTask = async () => {
            const index = currentIndex++;
            if (index >= promiseArray.length) {
              return;
            }
            try {
              const promise = promiseArray[index];
              if (typeof promise !== "function") {
                throw new Error(`数组中索引为 ${index} 的元素不是函数`);
              }
              results[index] = await promise();
            } catch (error) {
              results[index] = error;
            }
            completed++;
            if (currentIndex < promiseArray.length) {
              runTask();
            } else if (completed === promiseArray.length) {
              resolve(results);
            }
          };
          const tasksToStart = Math.min(limit, promiseArray.length);
          for (let i = 0; i < tasksToStart; i++) {
            try {
              runTask();
            } catch (error) {
              reject(error);
            }
          }
        });
      };
      const getGlobalThis = () => {
        return typeof _unsafeWindow !== "undefined" ? _unsafeWindow : window;
      };
      const getUser = () => {
        const globalThis2 = getGlobalThis();
        return globalThis2.CustomUser || {};
      };
      const truncateString = (str, maxLength) => {
        let len = 0;
        let result = "";
        for (let char of str) {
          const charLen = char.charCodeAt(0) > 255 ? 2 : 1;
          if (len + charLen > maxLength) break;
          result += char;
          len += charLen;
        }
        return result;
      };
      const sleep = (ms2) => new Promise((resolve) => setTimeout(resolve, ms2));
      async function getFileMD5(file) {
        const arrayBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);
        return md5(uint8Array);
      }
      async function getAudioMetadata(file) {
        try {
          const metadata = await parseBlob(file);
          console.log("metadata.common", metadata, metadata.common);
          const { album: album2, artist: artist2, artists, title: title2 } = metadata.common || {};
          const { bitrate } = metadata.format || {};
          return {
            title: title2 || "",
            artist: artist2 || artists?.[0] || "",
            artists: artists || (artist2 ? [artist2] : []),
            album: album2 || "",
            duration: metadata.format?.duration || 0,
            bitrate: metadata.format?.bitrate || 0,
            sampleRate: metadata.format?.sampleRate || 0,
            format: metadata.format?.container || "",
            bitrate: Math.floor(bitrate / 1e3) || 0
          };
        } catch (error) {
          console.error("Failed to parse audio metadata:", error);
          return {
            title: "",
            artist: "",
            artists: [],
            album: "",
            duration: 0,
            bitrate: 0,
            sampleRate: 0,
            format: ""
          };
        }
      }
      const mergeObjects = (o1, ...objects) => {
        return objects.reduce((result, current) => {
          if (!current || typeof current !== "object") return result;
          Object.entries(current).forEach(([key, value2]) => {
            if (value2 !== null && value2 !== void 0 && value2 !== "") {
              result[key] = value2;
            }
          });
          return result;
        }, o1);
      };
      const styles$7 = {
        "search-form": "_search-form_1aabt_1"
      };
      const SearchForm = ({ onSearch, data = [], options = [] }) => {
        const [form] = Form.useForm();
        const getUniqueOptions = (key) => {
          const uniqueList = uniqueArrayByKey(data, key);
          const options2 = uniqueList.map((item) => ({
            label: item[key],
            value: item[key]
          }));
          return options2;
        };
        const handleSearch = () => {
          const values = form.getFieldsValue();
          onSearch(values);
        };
        const handleReset = () => {
          form.resetFields();
          onSearch({});
        };
        return jsxRuntimeExports.jsx(Form, { form, layout: "inline", className: styles$7["search-form"], children: jsxRuntimeExports.jsxs(Space, { wrap: true, children: [
          options.map((item) => {
            return jsxRuntimeExports.jsx(
              Form.Item,
              {
                name: item.value,
                label: item.label,
                style: { marginBottom: 0, minWidth: 200 },
                children: jsxRuntimeExports.jsx(
                  Select,
                  {
                    mode: "multiple",
                    allowClear: true,
                    showSearch: true,
                    placeholder: item.label,
                    maxTagCount: "responsive",
                    options: getUniqueOptions(item.value),
                    filterOption: (input, option) => (option?.label ?? "").toLowerCase().includes(input.toLowerCase())
                  }
                )
              },
              item.value
            );
          }),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleSearch, children: "搜索" }),
jsxRuntimeExports.jsx(Button, { onClick: handleReset, children: "重置" })
        ] }) });
      };
      message.config({
        top: 100
      });
      const msgSuccess = (content) => {
        message.success(content);
      };
      const msgWarning = (content) => {
        message.warning(content);
      };
      const msgError = (content) => {
        message.error(content);
      };
      const confirm = (content, title2, otherOptions = {}) => {
        return new Promise((resolve, reject) => {
          Modal.confirm({
            centered: true,
            content,
            icon: null,
            closable: true,
            title: title2 || "提示",
            width: 398,
            okButtonProps: {
              shape: "round",
              type: "primary"
            },
            cancelButtonProps: {
              shape: "round",
              type: "default"
            },
            okText: "确定",
            cancelText: "取消",
            onCancel: () => {
              reject(false);
            },
            onOk: () => {
              resolve(true);
            },
            ...otherOptions
          });
        });
      };
      const IV = "0102030405060708";
      const PRESET_KEY = "0CoJUm6Qyw8W8jud";
      const PUBLIC_KEY = "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDgtQn2JZ34ZC28NWYpAUd98iZ37BUrX/aKzmFbt7clFSs6sXqHauqKWqdtLkF2KexO40H1YTX8z2lSgBBOAxLsvaklV8k4cBFK9snQXE9/DDaFt6Rr7iVZMldczhC0JNgTz+SHXT6CBHuX3e9SdB1Ua44oncaTWz7OBGLbCiK45wIDAQAB\n-----END PUBLIC KEY-----";
      const BASE62 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      const aesEncrypt = (text2, key, iv) => {
        const cipher = forge.cipher.createCipher("AES-CBC", key);
        cipher.start({ iv });
        cipher.update(forge.util.createBuffer(text2, "utf8"));
        cipher.finish();
        return forge.util.encode64(cipher.output.getBytes());
      };
      const rsaEncrypt = (text2, key) => {
        const publicKey = forge.pki.publicKeyFromPem(key);
        const encrypted = publicKey.encrypt(text2, "NONE");
        return forge.util.bytesToHex(encrypted);
      };
      const weapi = (object) => {
        const text2 = JSON.stringify(object);
        const secretKey = Array.from(
          { length: 16 },
          () => BASE62.charAt(Math.floor(Math.random() * 62))
        ).join("");
        return {
          params: aesEncrypt(aesEncrypt(text2, PRESET_KEY, IV), secretKey, IV),
          encSecKey: rsaEncrypt(secretKey.split("").reverse().join(""), PUBLIC_KEY)
        };
      };
      const CLIENT_CONFIG = {
        web: {
          cookie: true,
          userAgent: void 0
        },
        android: {
          cookie: "os=android;appver=9.1.78;channel=netease;osver=14;buildver=241009150147;",
          userAgent: "NeteaseMusic/9.1.78.241009150147(9001078);Dalvik/2.1.0 (Linux; U; Android 14; V2318A Build/TP1A.220624.014)"
        },
        pc: {
          cookie: "os=pc;appver=3.0.18.203152;channel=netease;osver=Microsoft-Windows-10-Professional-build-19045-64bit;",
          userAgent: "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Safari/537.36 Chrome/91.0.4472.164 NeteaseMusicDesktop/3.0.18.203152"
        }
      };
      const weapiRequest = (url, config) => {
        const {
          data = {},
          clientType = "pc",
          ip,
          onerror,
          onload,
          originResponse = false,
          ...rest
        } = config;
        const csrfToken = document.cookie.match(/_csrf=([^(;|$)]+)/);
        data.csrf_token = csrfToken ? csrfToken[1] : "";
        const encryptedData = weapi(data);
        console.log({
          url,
          data,
          encryptedData
        });
        const headers = {
          "content-type": "application/x-www-form-urlencoded",
          "user-agent": CLIENT_CONFIG[clientType].userAgent
        };
        if (ip) {
          headers["X-Real-IP"] = ip;
          headers["X-Forwarded-For"] = ip;
        }
        const baseUrl = "https://music.163.com";
        const fullUrl = new URL(url.replace("api", "weapi"), baseUrl);
        return new Promise((resolve, reject) => {
          _GM_xmlhttpRequest({
            url: fullUrl.toString() + `?csrf_token=${data.csrf_token}`,
            method: "POST",
            responseType: "json",
            headers,
            cookie: CLIENT_CONFIG[clientType].cookie,
            data: `params=${encodeURIComponent(
        encryptedData.params
      )}&encSecKey=${encodeURIComponent(encryptedData.encSecKey)}`,
            onload: (res) => resolve(originResponse ? res : res.response),
            onerror: reject
          });
        });
      };
      const weapiFetch = async (url, config) => {
        const {
          data = {},
          clientType = "pc",
          ip,
          originResponse = false,
          ...rest
        } = config;
        const csrfToken = document.cookie.match(/_csrf=([^(;|$)]+)/);
        data.csrf_token = csrfToken ? csrfToken[1] : "";
        const encryptedData = weapi(data);
        console.log({
          url,
          data,
          encryptedData
        });
        const headers = {
          "content-type": "application/x-www-form-urlencoded",
          "user-agent": CLIENT_CONFIG[clientType].userAgent,
          accept: "application/json, text/plain, */*",
          "accept-language": "zh-CN,zh;q=0.9",
          origin: "https://music.163.com",
          referer: "https://music.163.com/"
        };
        if (ip) {
          headers["X-Real-IP"] = ip;
          headers["X-Forwarded-For"] = ip;
        }
        if (CLIENT_CONFIG[clientType].cookie) {
          headers.cookie = CLIENT_CONFIG[clientType].cookie;
        }
        try {
          const baseUrl = "https://music.163.com";
          const fullUrl = new URL(url.replace("api", "weapi"), baseUrl);
          fullUrl.searchParams.append("csrf_token", data.csrf_token);
          const response = await fetch(fullUrl.toString(), {
            method: "POST",
            headers,
            body: `params=${encodeURIComponent(
        encryptedData.params
      )}&encSecKey=${encodeURIComponent(encryptedData.encSecKey)}`,
            credentials: "include",
mode: "cors",
redirect: "follow"
});
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(
              `HTTP error! status: ${response.status}, message: ${errorText}`
            );
          }
          const result = await response.json();
          if (result.code !== 200 && !originResponse) {
            throw new Error(result.msg || result.message || "API请求失败");
          }
          return originResponse ? {
            headers: response.headers,
            ...result
          } : result;
        } catch (error) {
          console.error("请求失败:", error);
          throw new Error(`请求失败: ${error.message || "未知错误"}`);
        }
      };
      var browser = {};
      var canPromise;
      var hasRequiredCanPromise;
      function requireCanPromise() {
        if (hasRequiredCanPromise) return canPromise;
        hasRequiredCanPromise = 1;
        canPromise = function() {
          return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
        };
        return canPromise;
      }
      var qrcode = {};
      var utils$1 = {};
      var hasRequiredUtils$1;
      function requireUtils$1() {
        if (hasRequiredUtils$1) return utils$1;
        hasRequiredUtils$1 = 1;
        let toSJISFunction;
        const CODEWORDS_COUNT = [
          0,
26,
          44,
          70,
          100,
          134,
          172,
          196,
          242,
          292,
          346,
          404,
          466,
          532,
          581,
          655,
          733,
          815,
          901,
          991,
          1085,
          1156,
          1258,
          1364,
          1474,
          1588,
          1706,
          1828,
          1921,
          2051,
          2185,
          2323,
          2465,
          2611,
          2761,
          2876,
          3034,
          3196,
          3362,
          3532,
          3706
        ];
        utils$1.getSymbolSize = function getSymbolSize(version2) {
          if (!version2) throw new Error('"version" cannot be null or undefined');
          if (version2 < 1 || version2 > 40) throw new Error('"version" should be in range from 1 to 40');
          return version2 * 4 + 17;
        };
        utils$1.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
          return CODEWORDS_COUNT[version2];
        };
        utils$1.getBCHDigit = function(data) {
          let digit = 0;
          while (data !== 0) {
            digit++;
            data >>>= 1;
          }
          return digit;
        };
        utils$1.setToSJISFunction = function setToSJISFunction(f) {
          if (typeof f !== "function") {
            throw new Error('"toSJISFunc" is not a valid function.');
          }
          toSJISFunction = f;
        };
        utils$1.isKanjiModeEnabled = function() {
          return typeof toSJISFunction !== "undefined";
        };
        utils$1.toSJIS = function toSJIS(kanji) {
          return toSJISFunction(kanji);
        };
        return utils$1;
      }
      var errorCorrectionLevel = {};
      var hasRequiredErrorCorrectionLevel;
      function requireErrorCorrectionLevel() {
        if (hasRequiredErrorCorrectionLevel) return errorCorrectionLevel;
        hasRequiredErrorCorrectionLevel = 1;
        (function(exports) {
          exports.L = { bit: 1 };
          exports.M = { bit: 0 };
          exports.Q = { bit: 3 };
          exports.H = { bit: 2 };
          function fromString(string) {
            if (typeof string !== "string") {
              throw new Error("Param is not a string");
            }
            const lcStr = string.toLowerCase();
            switch (lcStr) {
              case "l":
              case "low":
                return exports.L;
              case "m":
              case "medium":
                return exports.M;
              case "q":
              case "quartile":
                return exports.Q;
              case "h":
              case "high":
                return exports.H;
              default:
                throw new Error("Unknown EC Level: " + string);
            }
          }
          exports.isValid = function isValid(level) {
            return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
          };
          exports.from = function from(value2, defaultValue) {
            if (exports.isValid(value2)) {
              return value2;
            }
            try {
              return fromString(value2);
            } catch (e) {
              return defaultValue;
            }
          };
        })(errorCorrectionLevel);
        return errorCorrectionLevel;
      }
      var bitBuffer;
      var hasRequiredBitBuffer;
      function requireBitBuffer() {
        if (hasRequiredBitBuffer) return bitBuffer;
        hasRequiredBitBuffer = 1;
        function BitBuffer() {
          this.buffer = [];
          this.length = 0;
        }
        BitBuffer.prototype = {
          get: function(index) {
            const bufIndex = Math.floor(index / 8);
            return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
          },
          put: function(num, length) {
            for (let i = 0; i < length; i++) {
              this.putBit((num >>> length - i - 1 & 1) === 1);
            }
          },
          getLengthInBits: function() {
            return this.length;
          },
          putBit: function(bit) {
            const bufIndex = Math.floor(this.length / 8);
            if (this.buffer.length <= bufIndex) {
              this.buffer.push(0);
            }
            if (bit) {
              this.buffer[bufIndex] |= 128 >>> this.length % 8;
            }
            this.length++;
          }
        };
        bitBuffer = BitBuffer;
        return bitBuffer;
      }
      var bitMatrix;
      var hasRequiredBitMatrix;
      function requireBitMatrix() {
        if (hasRequiredBitMatrix) return bitMatrix;
        hasRequiredBitMatrix = 1;
        function BitMatrix(size2) {
          if (!size2 || size2 < 1) {
            throw new Error("BitMatrix size must be defined and greater than 0");
          }
          this.size = size2;
          this.data = new Uint8Array(size2 * size2);
          this.reservedBit = new Uint8Array(size2 * size2);
        }
        BitMatrix.prototype.set = function(row, col, value2, reserved) {
          const index = row * this.size + col;
          this.data[index] = value2;
          if (reserved) this.reservedBit[index] = true;
        };
        BitMatrix.prototype.get = function(row, col) {
          return this.data[row * this.size + col];
        };
        BitMatrix.prototype.xor = function(row, col, value2) {
          this.data[row * this.size + col] ^= value2;
        };
        BitMatrix.prototype.isReserved = function(row, col) {
          return this.reservedBit[row * this.size + col];
        };
        bitMatrix = BitMatrix;
        return bitMatrix;
      }
      var alignmentPattern = {};
      var hasRequiredAlignmentPattern;
      function requireAlignmentPattern() {
        if (hasRequiredAlignmentPattern) return alignmentPattern;
        hasRequiredAlignmentPattern = 1;
        (function(exports) {
          const getSymbolSize = requireUtils$1().getSymbolSize;
          exports.getRowColCoords = function getRowColCoords(version2) {
            if (version2 === 1) return [];
            const posCount = Math.floor(version2 / 7) + 2;
            const size2 = getSymbolSize(version2);
            const intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
            const positions = [size2 - 7];
            for (let i = 1; i < posCount - 1; i++) {
              positions[i] = positions[i - 1] - intervals;
            }
            positions.push(6);
            return positions.reverse();
          };
          exports.getPositions = function getPositions(version2) {
            const coords = [];
            const pos = exports.getRowColCoords(version2);
            const posLength = pos.length;
            for (let i = 0; i < posLength; i++) {
              for (let j = 0; j < posLength; j++) {
                if (i === 0 && j === 0 ||
i === 0 && j === posLength - 1 ||
i === posLength - 1 && j === 0) {
                  continue;
                }
                coords.push([pos[i], pos[j]]);
              }
            }
            return coords;
          };
        })(alignmentPattern);
        return alignmentPattern;
      }
      var finderPattern = {};
      var hasRequiredFinderPattern;
      function requireFinderPattern() {
        if (hasRequiredFinderPattern) return finderPattern;
        hasRequiredFinderPattern = 1;
        const getSymbolSize = requireUtils$1().getSymbolSize;
        const FINDER_PATTERN_SIZE = 7;
        finderPattern.getPositions = function getPositions(version2) {
          const size2 = getSymbolSize(version2);
          return [
[0, 0],
[size2 - FINDER_PATTERN_SIZE, 0],
[0, size2 - FINDER_PATTERN_SIZE]
          ];
        };
        return finderPattern;
      }
      var maskPattern = {};
      var hasRequiredMaskPattern;
      function requireMaskPattern() {
        if (hasRequiredMaskPattern) return maskPattern;
        hasRequiredMaskPattern = 1;
        (function(exports) {
          exports.Patterns = {
            PATTERN000: 0,
            PATTERN001: 1,
            PATTERN010: 2,
            PATTERN011: 3,
            PATTERN100: 4,
            PATTERN101: 5,
            PATTERN110: 6,
            PATTERN111: 7
          };
          const PenaltyScores = {
            N1: 3,
            N2: 3,
            N3: 40,
            N4: 10
          };
          exports.isValid = function isValid(mask) {
            return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
          };
          exports.from = function from(value2) {
            return exports.isValid(value2) ? parseInt(value2, 10) : void 0;
          };
          exports.getPenaltyN1 = function getPenaltyN1(data) {
            const size2 = data.size;
            let points = 0;
            let sameCountCol = 0;
            let sameCountRow = 0;
            let lastCol = null;
            let lastRow = null;
            for (let row = 0; row < size2; row++) {
              sameCountCol = sameCountRow = 0;
              lastCol = lastRow = null;
              for (let col = 0; col < size2; col++) {
                let module = data.get(row, col);
                if (module === lastCol) {
                  sameCountCol++;
                } else {
                  if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
                  lastCol = module;
                  sameCountCol = 1;
                }
                module = data.get(col, row);
                if (module === lastRow) {
                  sameCountRow++;
                } else {
                  if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
                  lastRow = module;
                  sameCountRow = 1;
                }
              }
              if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
              if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            }
            return points;
          };
          exports.getPenaltyN2 = function getPenaltyN2(data) {
            const size2 = data.size;
            let points = 0;
            for (let row = 0; row < size2 - 1; row++) {
              for (let col = 0; col < size2 - 1; col++) {
                const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
                if (last === 4 || last === 0) points++;
              }
            }
            return points * PenaltyScores.N2;
          };
          exports.getPenaltyN3 = function getPenaltyN3(data) {
            const size2 = data.size;
            let points = 0;
            let bitsCol = 0;
            let bitsRow = 0;
            for (let row = 0; row < size2; row++) {
              bitsCol = bitsRow = 0;
              for (let col = 0; col < size2; col++) {
                bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
                if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
                bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
                if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
              }
            }
            return points * PenaltyScores.N3;
          };
          exports.getPenaltyN4 = function getPenaltyN4(data) {
            let darkCount = 0;
            const modulesCount = data.data.length;
            for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];
            const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
            return k * PenaltyScores.N4;
          };
          function getMaskAt(maskPattern2, i, j) {
            switch (maskPattern2) {
              case exports.Patterns.PATTERN000:
                return (i + j) % 2 === 0;
              case exports.Patterns.PATTERN001:
                return i % 2 === 0;
              case exports.Patterns.PATTERN010:
                return j % 3 === 0;
              case exports.Patterns.PATTERN011:
                return (i + j) % 3 === 0;
              case exports.Patterns.PATTERN100:
                return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
              case exports.Patterns.PATTERN101:
                return i * j % 2 + i * j % 3 === 0;
              case exports.Patterns.PATTERN110:
                return (i * j % 2 + i * j % 3) % 2 === 0;
              case exports.Patterns.PATTERN111:
                return (i * j % 3 + (i + j) % 2) % 2 === 0;
              default:
                throw new Error("bad maskPattern:" + maskPattern2);
            }
          }
          exports.applyMask = function applyMask(pattern, data) {
            const size2 = data.size;
            for (let col = 0; col < size2; col++) {
              for (let row = 0; row < size2; row++) {
                if (data.isReserved(row, col)) continue;
                data.xor(row, col, getMaskAt(pattern, row, col));
              }
            }
          };
          exports.getBestMask = function getBestMask(data, setupFormatFunc) {
            const numPatterns = Object.keys(exports.Patterns).length;
            let bestPattern = 0;
            let lowerPenalty = Infinity;
            for (let p = 0; p < numPatterns; p++) {
              setupFormatFunc(p);
              exports.applyMask(p, data);
              const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
              exports.applyMask(p, data);
              if (penalty < lowerPenalty) {
                lowerPenalty = penalty;
                bestPattern = p;
              }
            }
            return bestPattern;
          };
        })(maskPattern);
        return maskPattern;
      }
      var errorCorrectionCode = {};
      var hasRequiredErrorCorrectionCode;
      function requireErrorCorrectionCode() {
        if (hasRequiredErrorCorrectionCode) return errorCorrectionCode;
        hasRequiredErrorCorrectionCode = 1;
        const ECLevel = requireErrorCorrectionLevel();
        const EC_BLOCKS_TABLE = [
1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          1,
          2,
          2,
          1,
          2,
          2,
          4,
          1,
          2,
          4,
          4,
          2,
          4,
          4,
          4,
          2,
          4,
          6,
          5,
          2,
          4,
          6,
          6,
          2,
          5,
          8,
          8,
          4,
          5,
          8,
          8,
          4,
          5,
          8,
          11,
          4,
          8,
          10,
          11,
          4,
          9,
          12,
          16,
          4,
          9,
          16,
          16,
          6,
          10,
          12,
          18,
          6,
          10,
          17,
          16,
          6,
          11,
          16,
          19,
          6,
          13,
          18,
          21,
          7,
          14,
          21,
          25,
          8,
          16,
          20,
          25,
          8,
          17,
          23,
          25,
          9,
          17,
          23,
          34,
          9,
          18,
          25,
          30,
          10,
          20,
          27,
          32,
          12,
          21,
          29,
          35,
          12,
          23,
          34,
          37,
          12,
          25,
          34,
          40,
          13,
          26,
          35,
          42,
          14,
          28,
          38,
          45,
          15,
          29,
          40,
          48,
          16,
          31,
          43,
          51,
          17,
          33,
          45,
          54,
          18,
          35,
          48,
          57,
          19,
          37,
          51,
          60,
          19,
          38,
          53,
          63,
          20,
          40,
          56,
          66,
          21,
          43,
          59,
          70,
          22,
          45,
          62,
          74,
          24,
          47,
          65,
          77,
          25,
          49,
          68,
          81
        ];
        const EC_CODEWORDS_TABLE = [
7,
          10,
          13,
          17,
          10,
          16,
          22,
          28,
          15,
          26,
          36,
          44,
          20,
          36,
          52,
          64,
          26,
          48,
          72,
          88,
          36,
          64,
          96,
          112,
          40,
          72,
          108,
          130,
          48,
          88,
          132,
          156,
          60,
          110,
          160,
          192,
          72,
          130,
          192,
          224,
          80,
          150,
          224,
          264,
          96,
          176,
          260,
          308,
          104,
          198,
          288,
          352,
          120,
          216,
          320,
          384,
          132,
          240,
          360,
          432,
          144,
          280,
          408,
          480,
          168,
          308,
          448,
          532,
          180,
          338,
          504,
          588,
          196,
          364,
          546,
          650,
          224,
          416,
          600,
          700,
          224,
          442,
          644,
          750,
          252,
          476,
          690,
          816,
          270,
          504,
          750,
          900,
          300,
          560,
          810,
          960,
          312,
          588,
          870,
          1050,
          336,
          644,
          952,
          1110,
          360,
          700,
          1020,
          1200,
          390,
          728,
          1050,
          1260,
          420,
          784,
          1140,
          1350,
          450,
          812,
          1200,
          1440,
          480,
          868,
          1290,
          1530,
          510,
          924,
          1350,
          1620,
          540,
          980,
          1440,
          1710,
          570,
          1036,
          1530,
          1800,
          570,
          1064,
          1590,
          1890,
          600,
          1120,
          1680,
          1980,
          630,
          1204,
          1770,
          2100,
          660,
          1260,
          1860,
          2220,
          720,
          1316,
          1950,
          2310,
          750,
          1372,
          2040,
          2430
        ];
        errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
          switch (errorCorrectionLevel2) {
            case ECLevel.L:
              return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
            case ECLevel.M:
              return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
            case ECLevel.Q:
              return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
            case ECLevel.H:
              return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
            default:
              return void 0;
          }
        };
        errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
          switch (errorCorrectionLevel2) {
            case ECLevel.L:
              return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
            case ECLevel.M:
              return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
            case ECLevel.Q:
              return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
            case ECLevel.H:
              return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
            default:
              return void 0;
          }
        };
        return errorCorrectionCode;
      }
      var polynomial = {};
      var galoisField = {};
      var hasRequiredGaloisField;
      function requireGaloisField() {
        if (hasRequiredGaloisField) return galoisField;
        hasRequiredGaloisField = 1;
        const EXP_TABLE = new Uint8Array(512);
        const LOG_TABLE = new Uint8Array(256);
        (function initTables() {
          let x = 1;
          for (let i = 0; i < 255; i++) {
            EXP_TABLE[i] = x;
            LOG_TABLE[x] = i;
            x <<= 1;
            if (x & 256) {
              x ^= 285;
            }
          }
          for (let i = 255; i < 512; i++) {
            EXP_TABLE[i] = EXP_TABLE[i - 255];
          }
        })();
        galoisField.log = function log(n) {
          if (n < 1) throw new Error("log(" + n + ")");
          return LOG_TABLE[n];
        };
        galoisField.exp = function exp(n) {
          return EXP_TABLE[n];
        };
        galoisField.mul = function mul(x, y) {
          if (x === 0 || y === 0) return 0;
          return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
        };
        return galoisField;
      }
      var hasRequiredPolynomial;
      function requirePolynomial() {
        if (hasRequiredPolynomial) return polynomial;
        hasRequiredPolynomial = 1;
        (function(exports) {
          const GF = requireGaloisField();
          exports.mul = function mul(p1, p2) {
            const coeff = new Uint8Array(p1.length + p2.length - 1);
            for (let i = 0; i < p1.length; i++) {
              for (let j = 0; j < p2.length; j++) {
                coeff[i + j] ^= GF.mul(p1[i], p2[j]);
              }
            }
            return coeff;
          };
          exports.mod = function mod(divident, divisor) {
            let result = new Uint8Array(divident);
            while (result.length - divisor.length >= 0) {
              const coeff = result[0];
              for (let i = 0; i < divisor.length; i++) {
                result[i] ^= GF.mul(divisor[i], coeff);
              }
              let offset = 0;
              while (offset < result.length && result[offset] === 0) offset++;
              result = result.slice(offset);
            }
            return result;
          };
          exports.generateECPolynomial = function generateECPolynomial(degree) {
            let poly = new Uint8Array([1]);
            for (let i = 0; i < degree; i++) {
              poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
            }
            return poly;
          };
        })(polynomial);
        return polynomial;
      }
      var reedSolomonEncoder;
      var hasRequiredReedSolomonEncoder;
      function requireReedSolomonEncoder() {
        if (hasRequiredReedSolomonEncoder) return reedSolomonEncoder;
        hasRequiredReedSolomonEncoder = 1;
        const Polynomial = requirePolynomial();
        function ReedSolomonEncoder(degree) {
          this.genPoly = void 0;
          this.degree = degree;
          if (this.degree) this.initialize(this.degree);
        }
        ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
          this.degree = degree;
          this.genPoly = Polynomial.generateECPolynomial(this.degree);
        };
        ReedSolomonEncoder.prototype.encode = function encode(data) {
          if (!this.genPoly) {
            throw new Error("Encoder not initialized");
          }
          const paddedData = new Uint8Array(data.length + this.degree);
          paddedData.set(data);
          const remainder = Polynomial.mod(paddedData, this.genPoly);
          const start = this.degree - remainder.length;
          if (start > 0) {
            const buff = new Uint8Array(this.degree);
            buff.set(remainder, start);
            return buff;
          }
          return remainder;
        };
        reedSolomonEncoder = ReedSolomonEncoder;
        return reedSolomonEncoder;
      }
      var version = {};
      var mode = {};
      var versionCheck = {};
      var hasRequiredVersionCheck;
      function requireVersionCheck() {
        if (hasRequiredVersionCheck) return versionCheck;
        hasRequiredVersionCheck = 1;
        versionCheck.isValid = function isValid(version2) {
          return !isNaN(version2) && version2 >= 1 && version2 <= 40;
        };
        return versionCheck;
      }
      var regex = {};
      var hasRequiredRegex;
      function requireRegex() {
        if (hasRequiredRegex) return regex;
        hasRequiredRegex = 1;
        const numeric = "[0-9]+";
        const alphanumeric = "[A-Z $%*+\\-./:]+";
        let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
        kanji = kanji.replace(/u/g, "\\u");
        const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
        regex.KANJI = new RegExp(kanji, "g");
        regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
        regex.BYTE = new RegExp(byte, "g");
        regex.NUMERIC = new RegExp(numeric, "g");
        regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
        const TEST_KANJI = new RegExp("^" + kanji + "$");
        const TEST_NUMERIC = new RegExp("^" + numeric + "$");
        const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
        regex.testKanji = function testKanji(str) {
          return TEST_KANJI.test(str);
        };
        regex.testNumeric = function testNumeric(str) {
          return TEST_NUMERIC.test(str);
        };
        regex.testAlphanumeric = function testAlphanumeric(str) {
          return TEST_ALPHANUMERIC.test(str);
        };
        return regex;
      }
      var hasRequiredMode;
      function requireMode() {
        if (hasRequiredMode) return mode;
        hasRequiredMode = 1;
        (function(exports) {
          const VersionCheck = requireVersionCheck();
          const Regex = requireRegex();
          exports.NUMERIC = {
            id: "Numeric",
            bit: 1 << 0,
            ccBits: [10, 12, 14]
          };
          exports.ALPHANUMERIC = {
            id: "Alphanumeric",
            bit: 1 << 1,
            ccBits: [9, 11, 13]
          };
          exports.BYTE = {
            id: "Byte",
            bit: 1 << 2,
            ccBits: [8, 16, 16]
          };
          exports.KANJI = {
            id: "Kanji",
            bit: 1 << 3,
            ccBits: [8, 10, 12]
          };
          exports.MIXED = {
            bit: -1
          };
          exports.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
            if (!mode2.ccBits) throw new Error("Invalid mode: " + mode2);
            if (!VersionCheck.isValid(version2)) {
              throw new Error("Invalid version: " + version2);
            }
            if (version2 >= 1 && version2 < 10) return mode2.ccBits[0];
            else if (version2 < 27) return mode2.ccBits[1];
            return mode2.ccBits[2];
          };
          exports.getBestModeForData = function getBestModeForData(dataStr) {
            if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
            else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
            else if (Regex.testKanji(dataStr)) return exports.KANJI;
            else return exports.BYTE;
          };
          exports.toString = function toString(mode2) {
            if (mode2 && mode2.id) return mode2.id;
            throw new Error("Invalid mode");
          };
          exports.isValid = function isValid(mode2) {
            return mode2 && mode2.bit && mode2.ccBits;
          };
          function fromString(string) {
            if (typeof string !== "string") {
              throw new Error("Param is not a string");
            }
            const lcStr = string.toLowerCase();
            switch (lcStr) {
              case "numeric":
                return exports.NUMERIC;
              case "alphanumeric":
                return exports.ALPHANUMERIC;
              case "kanji":
                return exports.KANJI;
              case "byte":
                return exports.BYTE;
              default:
                throw new Error("Unknown mode: " + string);
            }
          }
          exports.from = function from(value2, defaultValue) {
            if (exports.isValid(value2)) {
              return value2;
            }
            try {
              return fromString(value2);
            } catch (e) {
              return defaultValue;
            }
          };
        })(mode);
        return mode;
      }
      var hasRequiredVersion;
      function requireVersion() {
        if (hasRequiredVersion) return version;
        hasRequiredVersion = 1;
        (function(exports) {
          const Utils = requireUtils$1();
          const ECCode = requireErrorCorrectionCode();
          const ECLevel = requireErrorCorrectionLevel();
          const Mode = requireMode();
          const VersionCheck = requireVersionCheck();
          const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
          const G18_BCH = Utils.getBCHDigit(G18);
          function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
            for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
              if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
                return currentVersion;
              }
            }
            return void 0;
          }
          function getReservedBitsCount(mode2, version2) {
            return Mode.getCharCountIndicator(mode2, version2) + 4;
          }
          function getTotalBitsFromDataArray(segments2, version2) {
            let totalBits = 0;
            segments2.forEach(function(data) {
              const reservedBits = getReservedBitsCount(data.mode, version2);
              totalBits += reservedBits + data.getBitsLength();
            });
            return totalBits;
          }
          function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
            for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
              const length = getTotalBitsFromDataArray(segments2, currentVersion);
              if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, Mode.MIXED)) {
                return currentVersion;
              }
            }
            return void 0;
          }
          exports.from = function from(value2, defaultValue) {
            if (VersionCheck.isValid(value2)) {
              return parseInt(value2, 10);
            }
            return defaultValue;
          };
          exports.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
            if (!VersionCheck.isValid(version2)) {
              throw new Error("Invalid QR Code version");
            }
            if (typeof mode2 === "undefined") mode2 = Mode.BYTE;
            const totalCodewords = Utils.getSymbolTotalCodewords(version2);
            const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
            const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
            if (mode2 === Mode.MIXED) return dataTotalCodewordsBits;
            const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
            switch (mode2) {
              case Mode.NUMERIC:
                return Math.floor(usableBits / 10 * 3);
              case Mode.ALPHANUMERIC:
                return Math.floor(usableBits / 11 * 2);
              case Mode.KANJI:
                return Math.floor(usableBits / 13);
              case Mode.BYTE:
              default:
                return Math.floor(usableBits / 8);
            }
          };
          exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel2) {
            let seg;
            const ecl = ECLevel.from(errorCorrectionLevel2, ECLevel.M);
            if (Array.isArray(data)) {
              if (data.length > 1) {
                return getBestVersionForMixedData(data, ecl);
              }
              if (data.length === 0) {
                return 1;
              }
              seg = data[0];
            } else {
              seg = data;
            }
            return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
          };
          exports.getEncodedBits = function getEncodedBits(version2) {
            if (!VersionCheck.isValid(version2) || version2 < 7) {
              throw new Error("Invalid QR Code version");
            }
            let d = version2 << 12;
            while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
              d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
            }
            return version2 << 12 | d;
          };
        })(version);
        return version;
      }
      var formatInfo = {};
      var hasRequiredFormatInfo;
      function requireFormatInfo() {
        if (hasRequiredFormatInfo) return formatInfo;
        hasRequiredFormatInfo = 1;
        const Utils = requireUtils$1();
        const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
        const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
        const G15_BCH = Utils.getBCHDigit(G15);
        formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask) {
          const data = errorCorrectionLevel2.bit << 3 | mask;
          let d = data << 10;
          while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
            d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
          }
          return (data << 10 | d) ^ G15_MASK;
        };
        return formatInfo;
      }
      var segments = {};
      var numericData;
      var hasRequiredNumericData;
      function requireNumericData() {
        if (hasRequiredNumericData) return numericData;
        hasRequiredNumericData = 1;
        const Mode = requireMode();
        function NumericData(data) {
          this.mode = Mode.NUMERIC;
          this.data = data.toString();
        }
        NumericData.getBitsLength = function getBitsLength(length) {
          return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
        };
        NumericData.prototype.getLength = function getLength() {
          return this.data.length;
        };
        NumericData.prototype.getBitsLength = function getBitsLength() {
          return NumericData.getBitsLength(this.data.length);
        };
        NumericData.prototype.write = function write(bitBuffer2) {
          let i, group, value2;
          for (i = 0; i + 3 <= this.data.length; i += 3) {
            group = this.data.substr(i, 3);
            value2 = parseInt(group, 10);
            bitBuffer2.put(value2, 10);
          }
          const remainingNum = this.data.length - i;
          if (remainingNum > 0) {
            group = this.data.substr(i);
            value2 = parseInt(group, 10);
            bitBuffer2.put(value2, remainingNum * 3 + 1);
          }
        };
        numericData = NumericData;
        return numericData;
      }
      var alphanumericData;
      var hasRequiredAlphanumericData;
      function requireAlphanumericData() {
        if (hasRequiredAlphanumericData) return alphanumericData;
        hasRequiredAlphanumericData = 1;
        const Mode = requireMode();
        const ALPHA_NUM_CHARS = [
          "0",
          "1",
          "2",
          "3",
          "4",
          "5",
          "6",
          "7",
          "8",
          "9",
          "A",
          "B",
          "C",
          "D",
          "E",
          "F",
          "G",
          "H",
          "I",
          "J",
          "K",
          "L",
          "M",
          "N",
          "O",
          "P",
          "Q",
          "R",
          "S",
          "T",
          "U",
          "V",
          "W",
          "X",
          "Y",
          "Z",
          " ",
          "$",
          "%",
          "*",
          "+",
          "-",
          ".",
          "/",
          ":"
        ];
        function AlphanumericData(data) {
          this.mode = Mode.ALPHANUMERIC;
          this.data = data;
        }
        AlphanumericData.getBitsLength = function getBitsLength(length) {
          return 11 * Math.floor(length / 2) + 6 * (length % 2);
        };
        AlphanumericData.prototype.getLength = function getLength() {
          return this.data.length;
        };
        AlphanumericData.prototype.getBitsLength = function getBitsLength() {
          return AlphanumericData.getBitsLength(this.data.length);
        };
        AlphanumericData.prototype.write = function write(bitBuffer2) {
          let i;
          for (i = 0; i + 2 <= this.data.length; i += 2) {
            let value2 = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
            value2 += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
            bitBuffer2.put(value2, 11);
          }
          if (this.data.length % 2) {
            bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
          }
        };
        alphanumericData = AlphanumericData;
        return alphanumericData;
      }
      var byteData;
      var hasRequiredByteData;
      function requireByteData() {
        if (hasRequiredByteData) return byteData;
        hasRequiredByteData = 1;
        const Mode = requireMode();
        function ByteData(data) {
          this.mode = Mode.BYTE;
          if (typeof data === "string") {
            this.data = new TextEncoder().encode(data);
          } else {
            this.data = new Uint8Array(data);
          }
        }
        ByteData.getBitsLength = function getBitsLength(length) {
          return length * 8;
        };
        ByteData.prototype.getLength = function getLength() {
          return this.data.length;
        };
        ByteData.prototype.getBitsLength = function getBitsLength() {
          return ByteData.getBitsLength(this.data.length);
        };
        ByteData.prototype.write = function(bitBuffer2) {
          for (let i = 0, l = this.data.length; i < l; i++) {
            bitBuffer2.put(this.data[i], 8);
          }
        };
        byteData = ByteData;
        return byteData;
      }
      var kanjiData;
      var hasRequiredKanjiData;
      function requireKanjiData() {
        if (hasRequiredKanjiData) return kanjiData;
        hasRequiredKanjiData = 1;
        const Mode = requireMode();
        const Utils = requireUtils$1();
        function KanjiData(data) {
          this.mode = Mode.KANJI;
          this.data = data;
        }
        KanjiData.getBitsLength = function getBitsLength(length) {
          return length * 13;
        };
        KanjiData.prototype.getLength = function getLength() {
          return this.data.length;
        };
        KanjiData.prototype.getBitsLength = function getBitsLength() {
          return KanjiData.getBitsLength(this.data.length);
        };
        KanjiData.prototype.write = function(bitBuffer2) {
          let i;
          for (i = 0; i < this.data.length; i++) {
            let value2 = Utils.toSJIS(this.data[i]);
            if (value2 >= 33088 && value2 <= 40956) {
              value2 -= 33088;
            } else if (value2 >= 57408 && value2 <= 60351) {
              value2 -= 49472;
            } else {
              throw new Error(
                "Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8"
              );
            }
            value2 = (value2 >>> 8 & 255) * 192 + (value2 & 255);
            bitBuffer2.put(value2, 13);
          }
        };
        kanjiData = KanjiData;
        return kanjiData;
      }
      var dijkstra = { exports: {} };
      var hasRequiredDijkstra;
      function requireDijkstra() {
        if (hasRequiredDijkstra) return dijkstra.exports;
        hasRequiredDijkstra = 1;
        (function(module) {
          var dijkstra2 = {
            single_source_shortest_paths: function(graph, s, d) {
              var predecessors = {};
              var costs = {};
              costs[s] = 0;
              var open = dijkstra2.PriorityQueue.make();
              open.push(s, 0);
              var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
              while (!open.empty()) {
                closest = open.pop();
                u = closest.value;
                cost_of_s_to_u = closest.cost;
                adjacent_nodes = graph[u] || {};
                for (v in adjacent_nodes) {
                  if (adjacent_nodes.hasOwnProperty(v)) {
                    cost_of_e = adjacent_nodes[v];
                    cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
                    cost_of_s_to_v = costs[v];
                    first_visit = typeof costs[v] === "undefined";
                    if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                      costs[v] = cost_of_s_to_u_plus_cost_of_e;
                      open.push(v, cost_of_s_to_u_plus_cost_of_e);
                      predecessors[v] = u;
                    }
                  }
                }
              }
              if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
                var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
                throw new Error(msg);
              }
              return predecessors;
            },
            extract_shortest_path_from_predecessor_list: function(predecessors, d) {
              var nodes = [];
              var u = d;
              while (u) {
                nodes.push(u);
                predecessors[u];
                u = predecessors[u];
              }
              nodes.reverse();
              return nodes;
            },
            find_path: function(graph, s, d) {
              var predecessors = dijkstra2.single_source_shortest_paths(graph, s, d);
              return dijkstra2.extract_shortest_path_from_predecessor_list(
                predecessors,
                d
              );
            },
PriorityQueue: {
              make: function(opts) {
                var T = dijkstra2.PriorityQueue, t = {}, key;
                opts = opts || {};
                for (key in T) {
                  if (T.hasOwnProperty(key)) {
                    t[key] = T[key];
                  }
                }
                t.queue = [];
                t.sorter = opts.sorter || T.default_sorter;
                return t;
              },
              default_sorter: function(a, b) {
                return a.cost - b.cost;
              },
push: function(value2, cost) {
                var item = { value: value2, cost };
                this.queue.push(item);
                this.queue.sort(this.sorter);
              },
pop: function() {
                return this.queue.shift();
              },
              empty: function() {
                return this.queue.length === 0;
              }
            }
          };
          {
            module.exports = dijkstra2;
          }
        })(dijkstra);
        return dijkstra.exports;
      }
      var hasRequiredSegments;
      function requireSegments() {
        if (hasRequiredSegments) return segments;
        hasRequiredSegments = 1;
        (function(exports) {
          const Mode = requireMode();
          const NumericData = requireNumericData();
          const AlphanumericData = requireAlphanumericData();
          const ByteData = requireByteData();
          const KanjiData = requireKanjiData();
          const Regex = requireRegex();
          const Utils = requireUtils$1();
          const dijkstra2 = requireDijkstra();
          function getStringByteLength(str) {
            return unescape(encodeURIComponent(str)).length;
          }
          function getSegments(regex2, mode2, str) {
            const segments2 = [];
            let result;
            while ((result = regex2.exec(str)) !== null) {
              segments2.push({
                data: result[0],
                index: result.index,
                mode: mode2,
                length: result[0].length
              });
            }
            return segments2;
          }
          function getSegmentsFromString(dataStr) {
            const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
            const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
            let byteSegs;
            let kanjiSegs;
            if (Utils.isKanjiModeEnabled()) {
              byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
              kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
            } else {
              byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
              kanjiSegs = [];
            }
            const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
            return segs.sort(function(s1, s2) {
              return s1.index - s2.index;
            }).map(function(obj) {
              return {
                data: obj.data,
                mode: obj.mode,
                length: obj.length
              };
            });
          }
          function getSegmentBitsLength(length, mode2) {
            switch (mode2) {
              case Mode.NUMERIC:
                return NumericData.getBitsLength(length);
              case Mode.ALPHANUMERIC:
                return AlphanumericData.getBitsLength(length);
              case Mode.KANJI:
                return KanjiData.getBitsLength(length);
              case Mode.BYTE:
                return ByteData.getBitsLength(length);
            }
          }
          function mergeSegments(segs) {
            return segs.reduce(function(acc, curr) {
              const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
              if (prevSeg && prevSeg.mode === curr.mode) {
                acc[acc.length - 1].data += curr.data;
                return acc;
              }
              acc.push(curr);
              return acc;
            }, []);
          }
          function buildNodes(segs) {
            const nodes = [];
            for (let i = 0; i < segs.length; i++) {
              const seg = segs[i];
              switch (seg.mode) {
                case Mode.NUMERIC:
                  nodes.push([
                    seg,
                    { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
                    { data: seg.data, mode: Mode.BYTE, length: seg.length }
                  ]);
                  break;
                case Mode.ALPHANUMERIC:
                  nodes.push([
                    seg,
                    { data: seg.data, mode: Mode.BYTE, length: seg.length }
                  ]);
                  break;
                case Mode.KANJI:
                  nodes.push([
                    seg,
                    { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
                  ]);
                  break;
                case Mode.BYTE:
                  nodes.push([
                    { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
                  ]);
              }
            }
            return nodes;
          }
          function buildGraph(nodes, version2) {
            const table = {};
            const graph = { start: {} };
            let prevNodeIds = ["start"];
            for (let i = 0; i < nodes.length; i++) {
              const nodeGroup = nodes[i];
              const currentNodeIds = [];
              for (let j = 0; j < nodeGroup.length; j++) {
                const node = nodeGroup[j];
                const key = "" + i + j;
                currentNodeIds.push(key);
                table[key] = { node, lastCount: 0 };
                graph[key] = {};
                for (let n = 0; n < prevNodeIds.length; n++) {
                  const prevNodeId = prevNodeIds[n];
                  if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
                    graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
                    table[prevNodeId].lastCount += node.length;
                  } else {
                    if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
                    graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version2);
                  }
                }
              }
              prevNodeIds = currentNodeIds;
            }
            for (let n = 0; n < prevNodeIds.length; n++) {
              graph[prevNodeIds[n]].end = 0;
            }
            return { map: graph, table };
          }
          function buildSingleSegment(data, modesHint) {
            let mode2;
            const bestMode = Mode.getBestModeForData(data);
            mode2 = Mode.from(modesHint, bestMode);
            if (mode2 !== Mode.BYTE && mode2.bit < bestMode.bit) {
              throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode2) + ".\n Suggested mode is: " + Mode.toString(bestMode));
            }
            if (mode2 === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
              mode2 = Mode.BYTE;
            }
            switch (mode2) {
              case Mode.NUMERIC:
                return new NumericData(data);
              case Mode.ALPHANUMERIC:
                return new AlphanumericData(data);
              case Mode.KANJI:
                return new KanjiData(data);
              case Mode.BYTE:
                return new ByteData(data);
            }
          }
          exports.fromArray = function fromArray(array) {
            return array.reduce(function(acc, seg) {
              if (typeof seg === "string") {
                acc.push(buildSingleSegment(seg, null));
              } else if (seg.data) {
                acc.push(buildSingleSegment(seg.data, seg.mode));
              }
              return acc;
            }, []);
          };
          exports.fromString = function fromString(data, version2) {
            const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
            const nodes = buildNodes(segs);
            const graph = buildGraph(nodes, version2);
            const path = dijkstra2.find_path(graph.map, "start", "end");
            const optimizedSegs = [];
            for (let i = 1; i < path.length - 1; i++) {
              optimizedSegs.push(graph.table[path[i]].node);
            }
            return exports.fromArray(mergeSegments(optimizedSegs));
          };
          exports.rawSplit = function rawSplit(data) {
            return exports.fromArray(
              getSegmentsFromString(data, Utils.isKanjiModeEnabled())
            );
          };
        })(segments);
        return segments;
      }
      var hasRequiredQrcode;
      function requireQrcode() {
        if (hasRequiredQrcode) return qrcode;
        hasRequiredQrcode = 1;
        const Utils = requireUtils$1();
        const ECLevel = requireErrorCorrectionLevel();
        const BitBuffer = requireBitBuffer();
        const BitMatrix = requireBitMatrix();
        const AlignmentPattern = requireAlignmentPattern();
        const FinderPattern = requireFinderPattern();
        const MaskPattern = requireMaskPattern();
        const ECCode = requireErrorCorrectionCode();
        const ReedSolomonEncoder = requireReedSolomonEncoder();
        const Version = requireVersion();
        const FormatInfo = requireFormatInfo();
        const Mode = requireMode();
        const Segments = requireSegments();
        function setupFinderPattern(matrix, version2) {
          const size2 = matrix.size;
          const pos = FinderPattern.getPositions(version2);
          for (let i = 0; i < pos.length; i++) {
            const row = pos[i][0];
            const col = pos[i][1];
            for (let r = -1; r <= 7; r++) {
              if (row + r <= -1 || size2 <= row + r) continue;
              for (let c = -1; c <= 7; c++) {
                if (col + c <= -1 || size2 <= col + c) continue;
                if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
                  matrix.set(row + r, col + c, true, true);
                } else {
                  matrix.set(row + r, col + c, false, true);
                }
              }
            }
          }
        }
        function setupTimingPattern(matrix) {
          const size2 = matrix.size;
          for (let r = 8; r < size2 - 8; r++) {
            const value2 = r % 2 === 0;
            matrix.set(r, 6, value2, true);
            matrix.set(6, r, value2, true);
          }
        }
        function setupAlignmentPattern(matrix, version2) {
          const pos = AlignmentPattern.getPositions(version2);
          for (let i = 0; i < pos.length; i++) {
            const row = pos[i][0];
            const col = pos[i][1];
            for (let r = -2; r <= 2; r++) {
              for (let c = -2; c <= 2; c++) {
                if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
                  matrix.set(row + r, col + c, true, true);
                } else {
                  matrix.set(row + r, col + c, false, true);
                }
              }
            }
          }
        }
        function setupVersionInfo(matrix, version2) {
          const size2 = matrix.size;
          const bits2 = Version.getEncodedBits(version2);
          let row, col, mod;
          for (let i = 0; i < 18; i++) {
            row = Math.floor(i / 3);
            col = i % 3 + size2 - 8 - 3;
            mod = (bits2 >> i & 1) === 1;
            matrix.set(row, col, mod, true);
            matrix.set(col, row, mod, true);
          }
        }
        function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
          const size2 = matrix.size;
          const bits2 = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
          let i, mod;
          for (i = 0; i < 15; i++) {
            mod = (bits2 >> i & 1) === 1;
            if (i < 6) {
              matrix.set(i, 8, mod, true);
            } else if (i < 8) {
              matrix.set(i + 1, 8, mod, true);
            } else {
              matrix.set(size2 - 15 + i, 8, mod, true);
            }
            if (i < 8) {
              matrix.set(8, size2 - i - 1, mod, true);
            } else if (i < 9) {
              matrix.set(8, 15 - i - 1 + 1, mod, true);
            } else {
              matrix.set(8, 15 - i - 1, mod, true);
            }
          }
          matrix.set(size2 - 8, 8, 1, true);
        }
        function setupData(matrix, data) {
          const size2 = matrix.size;
          let inc = -1;
          let row = size2 - 1;
          let bitIndex = 7;
          let byteIndex = 0;
          for (let col = size2 - 1; col > 0; col -= 2) {
            if (col === 6) col--;
            while (true) {
              for (let c = 0; c < 2; c++) {
                if (!matrix.isReserved(row, col - c)) {
                  let dark = false;
                  if (byteIndex < data.length) {
                    dark = (data[byteIndex] >>> bitIndex & 1) === 1;
                  }
                  matrix.set(row, col - c, dark);
                  bitIndex--;
                  if (bitIndex === -1) {
                    byteIndex++;
                    bitIndex = 7;
                  }
                }
              }
              row += inc;
              if (row < 0 || size2 <= row) {
                row -= inc;
                inc = -inc;
                break;
              }
            }
          }
        }
        function createData(version2, errorCorrectionLevel2, segments2) {
          const buffer = new BitBuffer();
          segments2.forEach(function(data) {
            buffer.put(data.mode.bit, 4);
            buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version2));
            data.write(buffer);
          });
          const totalCodewords = Utils.getSymbolTotalCodewords(version2);
          const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
          const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
          if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
            buffer.put(0, 4);
          }
          while (buffer.getLengthInBits() % 8 !== 0) {
            buffer.putBit(0);
          }
          const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
          for (let i = 0; i < remainingByte; i++) {
            buffer.put(i % 2 ? 17 : 236, 8);
          }
          return createCodewords(buffer, version2, errorCorrectionLevel2);
        }
        function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
          const totalCodewords = Utils.getSymbolTotalCodewords(version2);
          const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
          const dataTotalCodewords = totalCodewords - ecTotalCodewords;
          const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
          const blocksInGroup2 = totalCodewords % ecTotalBlocks;
          const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
          const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
          const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
          const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
          const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
          const rs = new ReedSolomonEncoder(ecCount);
          let offset = 0;
          const dcData = new Array(ecTotalBlocks);
          const ecData = new Array(ecTotalBlocks);
          let maxDataSize = 0;
          const buffer = new Uint8Array(bitBuffer2.buffer);
          for (let b = 0; b < ecTotalBlocks; b++) {
            const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
            dcData[b] = buffer.slice(offset, offset + dataSize);
            ecData[b] = rs.encode(dcData[b]);
            offset += dataSize;
            maxDataSize = Math.max(maxDataSize, dataSize);
          }
          const data = new Uint8Array(totalCodewords);
          let index = 0;
          let i, r;
          for (i = 0; i < maxDataSize; i++) {
            for (r = 0; r < ecTotalBlocks; r++) {
              if (i < dcData[r].length) {
                data[index++] = dcData[r][i];
              }
            }
          }
          for (i = 0; i < ecCount; i++) {
            for (r = 0; r < ecTotalBlocks; r++) {
              data[index++] = ecData[r][i];
            }
          }
          return data;
        }
        function createSymbol(data, version2, errorCorrectionLevel2, maskPattern2) {
          let segments2;
          if (Array.isArray(data)) {
            segments2 = Segments.fromArray(data);
          } else if (typeof data === "string") {
            let estimatedVersion = version2;
            if (!estimatedVersion) {
              const rawSegments = Segments.rawSplit(data);
              estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
            }
            segments2 = Segments.fromString(data, estimatedVersion || 40);
          } else {
            throw new Error("Invalid data");
          }
          const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
          if (!bestVersion) {
            throw new Error("The amount of data is too big to be stored in a QR Code");
          }
          if (!version2) {
            version2 = bestVersion;
          } else if (version2 < bestVersion) {
            throw new Error(
              "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
            );
          }
          const dataBits = createData(version2, errorCorrectionLevel2, segments2);
          const moduleCount = Utils.getSymbolSize(version2);
          const modules = new BitMatrix(moduleCount);
          setupFinderPattern(modules, version2);
          setupTimingPattern(modules);
          setupAlignmentPattern(modules, version2);
          setupFormatInfo(modules, errorCorrectionLevel2, 0);
          if (version2 >= 7) {
            setupVersionInfo(modules, version2);
          }
          setupData(modules, dataBits);
          if (isNaN(maskPattern2)) {
            maskPattern2 = MaskPattern.getBestMask(
              modules,
              setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
            );
          }
          MaskPattern.applyMask(maskPattern2, modules);
          setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
          return {
            modules,
            version: version2,
            errorCorrectionLevel: errorCorrectionLevel2,
            maskPattern: maskPattern2,
            segments: segments2
          };
        }
        qrcode.create = function create(data, options) {
          if (typeof data === "undefined" || data === "") {
            throw new Error("No input text");
          }
          let errorCorrectionLevel2 = ECLevel.M;
          let version2;
          let mask;
          if (typeof options !== "undefined") {
            errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
            version2 = Version.from(options.version);
            mask = MaskPattern.from(options.maskPattern);
            if (options.toSJISFunc) {
              Utils.setToSJISFunction(options.toSJISFunc);
            }
          }
          return createSymbol(data, version2, errorCorrectionLevel2, mask);
        };
        return qrcode;
      }
      var canvas = {};
      var utils = {};
      var hasRequiredUtils;
      function requireUtils() {
        if (hasRequiredUtils) return utils;
        hasRequiredUtils = 1;
        (function(exports) {
          function hex2rgba(hex) {
            if (typeof hex === "number") {
              hex = hex.toString();
            }
            if (typeof hex !== "string") {
              throw new Error("Color should be defined as hex string");
            }
            let hexCode = hex.slice().replace("#", "").split("");
            if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
              throw new Error("Invalid hex color: " + hex);
            }
            if (hexCode.length === 3 || hexCode.length === 4) {
              hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
                return [c, c];
              }));
            }
            if (hexCode.length === 6) hexCode.push("F", "F");
            const hexValue = parseInt(hexCode.join(""), 16);
            return {
              r: hexValue >> 24 & 255,
              g: hexValue >> 16 & 255,
              b: hexValue >> 8 & 255,
              a: hexValue & 255,
              hex: "#" + hexCode.slice(0, 6).join("")
            };
          }
          exports.getOptions = function getOptions(options) {
            if (!options) options = {};
            if (!options.color) options.color = {};
            const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
            const width = options.width && options.width >= 21 ? options.width : void 0;
            const scale = options.scale || 4;
            return {
              width,
              scale: width ? 4 : scale,
              margin,
              color: {
                dark: hex2rgba(options.color.dark || "#000000ff"),
                light: hex2rgba(options.color.light || "#ffffffff")
              },
              type: options.type,
              rendererOpts: options.rendererOpts || {}
            };
          };
          exports.getScale = function getScale(qrSize, opts) {
            return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
          };
          exports.getImageWidth = function getImageWidth(qrSize, opts) {
            const scale = exports.getScale(qrSize, opts);
            return Math.floor((qrSize + opts.margin * 2) * scale);
          };
          exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
            const size2 = qr.modules.size;
            const data = qr.modules.data;
            const scale = exports.getScale(size2, opts);
            const symbolSize = Math.floor((size2 + opts.margin * 2) * scale);
            const scaledMargin = opts.margin * scale;
            const palette = [opts.color.light, opts.color.dark];
            for (let i = 0; i < symbolSize; i++) {
              for (let j = 0; j < symbolSize; j++) {
                let posDst = (i * symbolSize + j) * 4;
                let pxColor = opts.color.light;
                if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
                  const iSrc = Math.floor((i - scaledMargin) / scale);
                  const jSrc = Math.floor((j - scaledMargin) / scale);
                  pxColor = palette[data[iSrc * size2 + jSrc] ? 1 : 0];
                }
                imgData[posDst++] = pxColor.r;
                imgData[posDst++] = pxColor.g;
                imgData[posDst++] = pxColor.b;
                imgData[posDst] = pxColor.a;
              }
            }
          };
        })(utils);
        return utils;
      }
      var hasRequiredCanvas;
      function requireCanvas() {
        if (hasRequiredCanvas) return canvas;
        hasRequiredCanvas = 1;
        (function(exports) {
          const Utils = requireUtils();
          function clearCanvas(ctx, canvas2, size2) {
            ctx.clearRect(0, 0, canvas2.width, canvas2.height);
            if (!canvas2.style) canvas2.style = {};
            canvas2.height = size2;
            canvas2.width = size2;
            canvas2.style.height = size2 + "px";
            canvas2.style.width = size2 + "px";
          }
          function getCanvasElement() {
            try {
              return document.createElement("canvas");
            } catch (e) {
              throw new Error("You need to specify a canvas element");
            }
          }
          exports.render = function render(qrData, canvas2, options) {
            let opts = options;
            let canvasEl = canvas2;
            if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
              opts = canvas2;
              canvas2 = void 0;
            }
            if (!canvas2) {
              canvasEl = getCanvasElement();
            }
            opts = Utils.getOptions(opts);
            const size2 = Utils.getImageWidth(qrData.modules.size, opts);
            const ctx = canvasEl.getContext("2d");
            const image = ctx.createImageData(size2, size2);
            Utils.qrToImageData(image.data, qrData, opts);
            clearCanvas(ctx, canvasEl, size2);
            ctx.putImageData(image, 0, 0);
            return canvasEl;
          };
          exports.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
            let opts = options;
            if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
              opts = canvas2;
              canvas2 = void 0;
            }
            if (!opts) opts = {};
            const canvasEl = exports.render(qrData, canvas2, opts);
            const type = opts.type || "image/png";
            const rendererOpts = opts.rendererOpts || {};
            return canvasEl.toDataURL(type, rendererOpts.quality);
          };
        })(canvas);
        return canvas;
      }
      var svgTag = {};
      var hasRequiredSvgTag;
      function requireSvgTag() {
        if (hasRequiredSvgTag) return svgTag;
        hasRequiredSvgTag = 1;
        const Utils = requireUtils();
        function getColorAttrib(color, attrib) {
          const alpha = color.a / 255;
          const str = attrib + '="' + color.hex + '"';
          return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
        }
        function svgCmd(cmd, x, y) {
          let str = cmd + x;
          if (typeof y !== "undefined") str += " " + y;
          return str;
        }
        function qrToPath(data, size2, margin) {
          let path = "";
          let moveBy = 0;
          let newRow = false;
          let lineLength = 0;
          for (let i = 0; i < data.length; i++) {
            const col = Math.floor(i % size2);
            const row = Math.floor(i / size2);
            if (!col && !newRow) newRow = true;
            if (data[i]) {
              lineLength++;
              if (!(i > 0 && col > 0 && data[i - 1])) {
                path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
                moveBy = 0;
                newRow = false;
              }
              if (!(col + 1 < size2 && data[i + 1])) {
                path += svgCmd("h", lineLength);
                lineLength = 0;
              }
            } else {
              moveBy++;
            }
          }
          return path;
        }
        svgTag.render = function render(qrData, options, cb) {
          const opts = Utils.getOptions(options);
          const size2 = qrData.modules.size;
          const data = qrData.modules.data;
          const qrcodesize = size2 + opts.margin * 2;
          const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
          const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size2, opts.margin) + '"/>';
          const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
          const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
          const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
          if (typeof cb === "function") {
            cb(null, svgTag2);
          }
          return svgTag2;
        };
        return svgTag;
      }
      var hasRequiredBrowser;
      function requireBrowser() {
        if (hasRequiredBrowser) return browser;
        hasRequiredBrowser = 1;
        const canPromise2 = requireCanPromise();
        const QRCode2 = requireQrcode();
        const CanvasRenderer = requireCanvas();
        const SvgRenderer = requireSvgTag();
        function renderCanvas(renderFunc, canvas2, text2, opts, cb) {
          const args = [].slice.call(arguments, 1);
          const argsNum = args.length;
          const isLastArgCb = typeof args[argsNum - 1] === "function";
          if (!isLastArgCb && !canPromise2()) {
            throw new Error("Callback required as last argument");
          }
          if (isLastArgCb) {
            if (argsNum < 2) {
              throw new Error("Too few arguments provided");
            }
            if (argsNum === 2) {
              cb = text2;
              text2 = canvas2;
              canvas2 = opts = void 0;
            } else if (argsNum === 3) {
              if (canvas2.getContext && typeof cb === "undefined") {
                cb = opts;
                opts = void 0;
              } else {
                cb = opts;
                opts = text2;
                text2 = canvas2;
                canvas2 = void 0;
              }
            }
          } else {
            if (argsNum < 1) {
              throw new Error("Too few arguments provided");
            }
            if (argsNum === 1) {
              text2 = canvas2;
              canvas2 = opts = void 0;
            } else if (argsNum === 2 && !canvas2.getContext) {
              opts = text2;
              text2 = canvas2;
              canvas2 = void 0;
            }
            return new Promise(function(resolve, reject) {
              try {
                const data = QRCode2.create(text2, opts);
                resolve(renderFunc(data, canvas2, opts));
              } catch (e) {
                reject(e);
              }
            });
          }
          try {
            const data = QRCode2.create(text2, opts);
            cb(null, renderFunc(data, canvas2, opts));
          } catch (e) {
            cb(e);
          }
        }
        browser.create = QRCode2.create;
        browser.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
        browser.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
        browser.toString = renderCanvas.bind(null, function(data, _, opts) {
          return SvgRenderer.render(data, opts);
        });
        return browser;
      }
      var browserExports = requireBrowser();
      const QRCode = getDefaultExportFromCjs(browserExports);
      const generateQRCode = async (text2, options = {}) => {
        try {
          const defaultOptions = {
            errorCorrectionLevel: "H",
            type: "image/png",
            quality: 0.92,
            margin: 1,
            width: 200,
            ...options
          };
          const qrcode2 = await QRCode.toDataURL(text2, defaultOptions);
          return qrcode2;
        } catch (error) {
          console.error("生成二维码失败:", error);
          throw error;
        }
      };
      const getQrKey = () => weapiRequest("/api/login/qrcode/unikey", {
        data: {
          noCheckToken: 1,
          type: 1
        }
      });
      const getQrCode = (key) => {
        const loginUrl = `https://music.163.com/login?codekey=${key}`;
        return generateQRCode(loginUrl);
      };
      const getQrStatus = (key) => weapiFetch("/api/login/qrcode/client/login", {
        data: {
          key,
          type: 1
        },
        originResponse: true
      });
      const getUserAccount = () => weapiRequest("/api/nuser/account/get", {
        data: {}
      });
      const getArtists = () => fetch(`${BASE_CDN_URL}top.json`).then((res) => res.json());
      const getArtists2 = () => fetch(`${BASE_CDN_URL}summary.json`).then((res) => res.json());
      const getCDNConfig = (artistId) => fetch(`${BASE_CDN_URL}${artistId}.json`).then((res) => res.json());
      const getSongInfoList = async (songIds) => {
        const chunkArr = chunkArray(songIds, 1e3);
        const proArr = chunkArr.map(async (chunk) => {
          return weapiRequest("/api/v3/song/detail", {
            data: {
              c: JSON.stringify(chunk.map((item) => ({ id: item })))
            }
          });
        });
        const allInfo = await Promise.all(proArr);
        console.log("allInfo", allInfo);
        return allInfo.flat();
      };
      const matchCloudSong = async (cloudSongId, id, song) => {
        if (cloudSongId != id) {
          const res = await weapiRequest("/api/cloud/user/song/match", {
            data: {
              songId: cloudSongId,
              adjustSongId: id
            }
          });
          if (res.code != 200 || res.data.length < 1) {
            msgError(`歌曲“${song?.name}” 匹配失败：${res.message || res.msg}`);
            throw new Error(res.message || res.msg || "歌曲匹配失败");
          }
          return res;
        }
        return;
      };
      const uploadSong = async (song) => {
        try {
          console.log("song", song);
          let res = await weapiRequest("/api/cloud/upload/check/v2", {
            data: {
              uploadType: 0,
              songs: JSON.stringify([
                {
                  md5: song.md5,
                  songId: song.id,
                  bitrate: song.bitrate,
                  fileSize: song.size
                }
              ])
            }
          });
          if (res.code != 200 || res.data.length < 1) {
            msgError(`资源检查失败,请检查歌曲：${song.name}是否已存在！`);
            throw new Error(res.message || res.msg || "资源检查失败");
          }
          console.log("res", res);
          const cloudId = res.data[0].songId;
          if (res.data[0].upload == 1) {
            const importRes = await weapiRequest("/api/cloud/user/song/import", {
              data: {
                uploadType: 0,
                songs: JSON.stringify([
                  {
                    songId: cloudId,
                    bitrate: song.bitrate,
                    song: song.filename,
                    artist: song.artists,
                    album: song.album,
                    fileName: song.filename
                  }
                ])
              }
            });
            console.log("importRes", importRes);
            if (importRes.code != 200 || importRes.data.successSongs.length < 1) {
              msgError(`歌曲： ${song.name} 上传失败`);
              throw new Error(importRes.message || importRes.msg || "歌曲上传失败");
            }
            const cloudSongId = importRes.data.successSongs[0].song.songId;
            await matchCloudSong(cloudSongId, song.id, song);
            return {
              code: 200,
              msg: "歌曲上传成功",
              data: { song }
            };
          } else {
            const tokenRes = await weapiRequest("/api/nos/token/alloc", {
              data: {
                filename: song.filename,
                length: song.size,
                ext: song.ext,
                md5: song.md5,
                type: "audio",
                bucket: "jd-musicrep-privatecloud-audio-public",
                local: false,
                nos_product: 3
              }
            });
            console.log("tokenRes", tokenRes);
            if (tokenRes.code != 200) {
              msgError("获取上传token失败");
              throw new Error(
                tokenRes.message || tokenRes.msg || "获取上传token失败"
              );
            }
            song.resourceId = tokenRes.result.resourceId;
            const uploadRes = await weapiRequest("/api/upload/cloud/info/v2", {
              data: {
                token: tokenRes.result.token,
                objectKey: tokenRes.result.objectKey,
                resourceId: tokenRes.result.resourceId,
expireTime: Date.now() + 6e4,
                fileSize: song.size,
                md5: song.md5,
                songid: cloudId,
                filename: song.filename,
                song: song.name,
                album: song.album,
                artist: song.artists,
                bitrate: String(song.bitrate || 128),
                resourceId: song.resourceId
              }
            });
            console.log("uploadRes", uploadRes);
            if (uploadRes.code != 200) {
              msgError(`歌曲： ${song.name} 上传失败`);
            }
            const pubRes = await weapiRequest("/api/cloud/pub/v2", {
              data: {
                songid: uploadRes.songId
              }
            });
            if (![200, 201].includes(pubRes.code)) {
              msgError(`歌曲： ${song.name} 发布失败`);
              throw new Error(pubRes.message || pubRes.msg || "歌曲发布失败");
            }
            const cloudSongId = pubRes.privateCloud.songId;
            await matchCloudSong(cloudSongId, song.id, song);
            return {
              code: 200,
              msg: "歌曲上传成功",
              data: { song }
            };
          }
        } catch (error) {
          console.log("error", error);
          throw error;
        }
      };
      const getCloudData = (limit = 200, offset = 0) => weapiRequest("/api/v1/cloud/get", {
        data: {
          limit,
          offset
        }
      });
      const deleteCloudSong = (songIds) => weapiRequest("/api/cloud/del", {
        data: {
          songIds
        }
      });
      const getPlaylistList = (uid = getUser().userId, limit = 1001, offset = 0) => weapiRequest("/api/user/playlist", {
        data: {
          limit,
          offset,
          uid
        }
      });
      const createPlaylist = (name2) => weapiRequest("/api/playlist/create", {
        data: {
          name: name2
        }
      });
      const deletePlaylist = (pid) => weapiRequest("/api/playlist/delete", {
        data: {
          pid
        }
      });
      const addSongToPlaylist = (pid, trackIds) => weapiRequest("/api/playlist/manipulate/tracks", {
        data: {
          pid,
trackIds,
op: "add"
}
      });
      const getAlbumSongList = (id) => weapiRequest(`/api/v1/album/${id}`, {
        data: {}
      });
      const getSongUrl = (ids, options) => {
        const { encodeType = "flac", level = QUALITY_LEVELS.无损 } = options || {};
        return weapiRequest("/api/song/enhance/player/url/v1", {
          data: { ids: JSON.stringify(ids), level, encodeType }
        });
      };
      const getArtistTopSongList = (id) => weapiRequest("/api/artist/top/song", {
        data: {
          id,
          limit: 1e3,
          offset: 0
        }
      });
      const getArtistAllSongList = async (id) => {
        try {
          let more = true;
          const songs2 = [];
          let offset = 0;
          while (more) {
            const res = await weapiRequest("/api/v1/artist/songs", {
              data: {
                id,
                limit: 200,
                private_cloud: "true",
                work_type: 1,
                order: "hot",
offset
              }
            });
            if (res.code != 200) {
              throw new Error(res.message || res.msg || "获取歌手全部歌曲失败");
            }
            songs2.push(...res.songs);
            more = res.more;
            offset += 200;
          }
          return {
            code: 200,
            msg: "获取歌手全部歌曲成功",
            songs: songs2
          };
        } catch (error) {
          console.log("error", error);
          throw error;
        }
      };
      const getArtistAlbumList = async (id) => {
        let more = true;
        let limit = 200;
        let offset = 0;
        const albumList = [];
        while (more) {
          const res = await weapiRequest(`/api/artist/albums/${id}`, {
            data: {
              id,
              limit,
              offset
            }
          });
          if (res.code != 200) {
            throw new Error(res.message || res.msg || "获取歌手专辑失败");
          }
          albumList.push(...res.hotAlbums);
          more = res.more;
          offset += limit;
        }
        return {
          code: 200,
          msg: "获取歌手专辑成功",
          data: albumList
        };
      };
      const uploadLocalSong = async (file) => {
        let defaultResult = {};
        try {
          const ext = file.name.split(".").pop() || "mp3";
          const fileMd5 = await getFileMD5(file);
          const bitrate = 999e3;
          const filename = file.name.replace("." + ext, "").replace(/\s/g, "").replace(/\./g, "_");
          const checkRes = await weapiRequest("/api/cloud/upload/check", {
            data: {
              ext: "",
              bitrate: String(bitrate),
              md5: fileMd5,
              length: file.size,
              songId: "0",
              version: 1
            }
          });
          console.log("checkRes", checkRes);
          if (checkRes.code != 200) {
            msgError("文件检查失败：" + checkRes.message || checkRes.msg || "");
            throw new Error(checkRes.message || checkRes.msg || "文件检查失败");
          }
          const { needUpload, songId } = checkRes;
          if (needUpload) {
            const bucket2 = "jd-musicrep-privatecloud-audio-public";
            const tokenRes2 = await weapiRequest("/api/nos/token/alloc", {
              data: {
                bucket: bucket2,
                ext,
                filename,
                local: false,
                nos_product: 3,
                type: "audio",
                md5: fileMd5
              }
            });
            const objectKey2 = tokenRes2.body.result.objectKey.replace("/", "%2F");
            const lbs = await (await fetch(
              `https://wanproxy.127.net/lbs?version=1.0&bucketname=${bucket2}`
            )).json();
            const formData = new FormData();
            formData.append("songFile", file);
            await fetch(
              `${lbs.upload[0]}/${bucket2}/${objectKey2}?offset=0&complete=true&version=1.0`,
              {
                method: "post",
                headers: {
                  "x-nos-token": tokenRes2.body.result.token,
                  "Content-MD5": fileMd5,
                  "Content-Type": "audio/mpeg",
                  "Content-Length": String(file.size)
                },
                data: formData,
                maxContentLength: Infinity,
                maxBodyLength: Infinity
              }
            );
          }
          const tokenRes = await weapiRequest("/api/nos/token/alloc", {
            data: {
              bucket: "",
              ext,
              filename,
              local: false,
              nos_product: 3,
              type: "audio",
              md5: fileMd5
            }
          });
          console.log("tokenRes", tokenRes);
          if (tokenRes.code != 200) {
            msgError("获取上传token失败");
            throw new Error(tokenRes.message || tokenRes.msg || "获取上传token失败");
          }
          const { bucket, docId, objectKey, outerUrl, resourceId, token } = tokenRes.result;
          const { album: album2, artist: artist2, artists, title: title2 } = await getAudioMetadata(file);
          defaultResult = {
            ...defaultResult,
            artist: artist2,
            artists,
            album: album2,
            md5: fileMd5,
            ext,
            bitrate
          };
          const uploadInfoRes = await weapiRequest("/api/upload/cloud/info/v2", {
            data: {
              md5: fileMd5,
              songid: songId,
              filename,
              song: title2 || filename,
              album: album2 || "未知专辑",
              artist: artist2 || artists.join(",") || "未知歌手",
              bitrate: String(bitrate),
              resourceId
            }
          });
          console.log("uploadInfoRes", uploadInfoRes);
          defaultResult = {
            ...defaultResult,
            id: uploadInfoRes.songId
          };
          if (uploadInfoRes.code != 200) {
            msgError("获取上传信息失败");
            throw new Error(
              uploadInfoRes.message || uploadInfoRes.msg || "获取上传信息失败"
            );
          }
          const pubRes = await weapiRequest("/api/cloud/pub/v2", {
            data: {
              songid: uploadInfoRes.songId
            }
          });
          console.log("pubRes", pubRes);
          if (![200, 201].includes(pubRes.code)) {
            msgError(`歌曲： ${file.name} 发布失败`);
            throw new Error(pubRes.message || pubRes.msg || "歌曲发布失败");
          }
          const { songName: songName2, bitrate: realBitrate, fileSize } = pubRes.privateCloud;
          defaultResult = {
            ...defaultResult,
            name: songName2,
            size: fileSize,
            bitrate: realBitrate
          };
          return defaultResult;
        } catch (error) {
          console.log("error", error);
          throw error;
        }
      };
      const searchArtist = (keyword) => weapiRequest("/api/rep/ugc/artist/search", {
        data: {
          keyword,
          limit: 40
        }
      });
      const matchLocalSong = async (files) => {
        const songs2 = await Promise.all(
          files.map(async (file) => {
            const { title: title2, album: album2, artist: artist2, duration: duration2 } = await getAudioMetadata(file);
            const md52 = await getFileMD5(file);
            return {
              title: title2,
              album: album2,
              artist: artist2,
              duration: duration2,
              persistId: md52
            };
          })
        );
        return weapiRequest("/api/search/match/new", {
          data: songs2
        });
      };
      const getPlaylistAllData = async (id) => {
        try {
          const detailRes = await weapiRequest("/api/v6/playlist/detail", {
            data: {
              id,
              offset: 0,
              total: true,
              n: 1e5,
              s: 8
            }
          });
          console.log("detailRes", detailRes);
          const trackIds = detailRes.playlist.trackIds.map((item) => item.id);
          const res = await getSongInfoList(trackIds);
          if (res[0]?.code != 200) {
            msgError(res[0]?.msg || "获取歌单数据失败");
            throw new Error(res[0]?.msg || "获取歌单数据失败");
          }
          return res[0].songs;
        } catch (error) {
          throw error;
        }
      };
      const getSongLyric = async (id) => {
        return weapiRequest("/api/song/lyric", {
          data: {
            id,
            tv: -1,
            lv: -1,
            rv: -1,
            kv: -1,
            _nmclfl: 1
          }
        });
      };
      const getAlbumDetail = async (id) => {
        return weapiRequest(`/api/album/${id}`, {
          data: {
            id
          }
        });
      };
      function useFilter(list, config) {
        const [filteredList, setFilteredList] = useState(list);
        useEffect(() => {
          setFilteredList(list);
        }, [list]);
        const handleFilter = (values) => {
          const filtered = list.filter((item) => {
            return Object.entries(config.fields).every(([field, fieldConfig]) => {
              const filterValue = values[field];
              if (!filterValue?.length) return true;
              const itemValue = fieldConfig.getValue(item);
              if (!itemValue) return false;
              return filterValue.some(
                (keyword) => itemValue.toLowerCase().includes(keyword.toLowerCase())
              );
            });
          });
          setFilteredList(filtered);
        };
        return { filteredList, setFilteredList, handleFilter };
      }
      const useVisible = (props = {}, ref) => {
        const {
          onOpen = NOOP,
          onClose = NOOP,
          onReset = NOOP,
          resetOnOpen = true,
          resetOnClose = false
        } = props;
        const [visible, setVisible] = useState(false);
        const resolve = useRef();
        const reject = useRef();
        const open = (value2) => {
          resetOnOpen && reset();
          setVisible(true);
          onOpen(value2);
        };
        const close = () => {
          resetOnClose && reset();
          setVisible(false);
          onClose();
        };
        const reset = () => {
          onReset();
        };
        const submit = () => {
          return new Promise((_resolve, _reject) => {
            resolve.current = _resolve;
            reject.current = _reject;
          });
        };
        ref && useImperativeHandle(ref, () => ({
          open,
          close,
          reset,
          submit,
          resolve: resolve.current,
          reject: reject.current
        }));
        return {
          visible,
          open,
          close,
          reset,
          submit,
          resolve: resolve.current,
          reject: reject.current
        };
      };
      const NOOP = () => {
      };
      const { Search } = Input;
      const CloudImport = forwardRef((props, ref) => {
        const { visible, close } = useVisible(
          {
            onOpen() {
            },
            onReset() {
              setSearchText("");
              setAudioFormat("all");
              setBitrate("all");
              setTableData([]);
              setSelectedRows([]);
              setLoading(false);
            }
          },
          ref
        );
        const [searchText, setSearchText] = useState("");
        const [audioFormat, setAudioFormat] = useState("all");
        const [bitrate, setBitrate] = useState("all");
        const [selectedRows, setSelectedRows] = useState([]);
        const [tableData, setTableData] = useState([]);
        const filterConfig = {
          fields: {
            name: {
              getValue: (song) => song.name
            },
            artist: {
              getValue: (song) => song.artist
            },
            album: {
              getValue: (song) => song.album
            }
          }
        };
        const { filteredList, handleFilter } = useFilter(
          tableData,
          filterConfig
        );
        const columns = [
          { title: "歌手", dataIndex: "artist", key: "artist" },
          { title: "歌曲名", dataIndex: "name", key: "name" },
          { title: "专辑", dataIndex: "album", key: "album" },
          {
            title: "格式",
            dataIndex: "ext",
            key: "ext",
            render: (ext) => ext.toUpperCase()
          },
          { title: "比特率", dataIndex: "bitrate", key: "bitrate" },
          {
            title: "大小",
            dataIndex: "size",
            key: "size",
            render: (size2) => formatFileSize(size2)
          }
        ];
        const [concurrent, setConcurrent] = useState(6);
        const [loading, setLoading] = useState(false);
        const handleOk = async () => {
          try {
            setLoading(true);
            const proArr = selectedRows.map(
              (item) => () => uploadSong({
                ...item,
                filename: item.name || "未知",
                artists: item.artists?.join?.(",")
              })
            );
            const res = await promiseLimit(proArr, concurrent);
            console.log("res", res);
            msgSuccess("导入成功");
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        const handleWatchJSON = () => {
          Modal.info({
            title: "JSON示例格式",
            width: 600,
            content: jsxRuntimeExports.jsx("pre", { style: { maxHeight: 400, overflow: "auto" }, children: `// 必填字段说明：
// - id: 匹配后的歌曲ID（必填）
// - size: 文件大小，单位字节（必填）
// - md5: 文件MD5值（必填）
// - ext: 文件扩展名（必填）
// - bitrate: 比特率（必填）
// - name: 歌曲名（选填）
// - artist: 歌手名（选填）
// - artists: 歌手名列表（选填）
// - album: 专辑名（选填）

${JSON.stringify(
        [
          {
            id: "1",
name: "晴天",
            artist: "周杰伦",
            album: "叶惠美",
            ext: "flac",
bitrate: "320",
size: 31457280,
md5: "b2c63499d0fe68aedd0323030c0965e5"
},
          {
            id: 1305990326,
name: "Call You Tonight",
            artist: "Johnta Austin",
            artists: ["Johnta Austin"],
            album: "Ocean Drive",
            size: 10325748,
md5: "b2c63499d0fe68aedd0323030c0965e5",
ext: "mp3",
bitrate: 321
}
        ],
        null,
        2
      )}` }),
            okText: "关闭",
            centered: true,
            okButtonProps: {
              type: "primary",
              style: { background: "#C20C0C", borderColor: "#C20C0C" }
            },
            cancelButtonProps: {
              style: { borderColor: "#d9d9d9" }
            }
          });
        };
        return jsxRuntimeExports.jsxs(
          Modal,
          {
            title: "云盘JSON导入",
            open: visible,
            onCancel: close,
            centered: true,
            width: 1e3,
            onOk: handleOk,
            onClose: close,
            confirmLoading: loading,
            children: [
jsxRuntimeExports.jsx(
                SearchForm,
                {
                  data: tableData,
                  options: [
                    { value: "artist", label: "歌手" },
                    { value: "name", label: "歌曲名" },
                    { value: "album", label: "专辑" }
                  ],
                  onSearch: handleFilter
                }
              ),
jsxRuntimeExports.jsx(
                Table,
                {
                  dataSource: filteredList,
                  columns,
                  rowKey: "id",
                  scroll: { y: 400 },
                  rowSelection: {
                    type: "checkbox",
                    fixed: true,
                    onChange: (selectedRowKeys, selectedRows2) => {
                      setSelectedRows(selectedRows2);
                    }
                  }
                }
              ),
jsxRuntimeExports.jsxs("div", { style: { marginTop: 16, textAlign: "left" }, children: [
jsxRuntimeExports.jsx(
                  Upload,
                  {
                    accept: ".json",
                    showUploadList: false,
                    beforeUpload: (file) => {
                      const reader = new FileReader();
                      reader.onload = (e) => {
                        try {
                          const jsonData = JSON.parse(e.target.result);
                          setTableData(jsonData);
                          message.success("JSON文件解析成功");
                        } catch (error) {
                          message.error("JSON文件解析失败");
                        }
                      };
                      reader.readAsText(file);
                      return false;
                    },
                    children: jsxRuntimeExports.jsx(Button, { icon: jsxRuntimeExports.jsx(UploadOutlined, {}), children: "选择JSON文件" })
                  }
                ),
jsxRuntimeExports.jsx(
                  Button,
                  {
                    style: { marginLeft: 6, color: "#C20C0C" },
                    onClick: handleWatchJSON,
                    type: "link",
                    children: "查看JSON示例"
                  }
                )
              ] })
            ]
          }
        );
      });
      const downloadJsonFile = (data, filename) => {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
          type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        link.click();
        URL.revokeObjectURL(url);
      };
      const downloadFile = async (url, filename) => {
        try {
          if (!url || !filename) {
            throw new Error("URL和文件名不能为空");
          }
          const response = await fetch(url.replace("http://", "https://"));
          if (!response.ok) {
            throw new Error(`下载失败: ${response.statusText}`);
          }
          const blob = await response.blob();
          const objectUrl = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = objectUrl;
          link.download = filename;
          link.click();
          URL.revokeObjectURL(objectUrl);
        } catch (error) {
          console.error("文件下载出错:", error);
          throw error;
        }
      };
      const getFileBlob = async (url) => {
        const response = await fetch(url);
        const blob = await response.blob();
        return { blob, response };
      };
      const downloadFileWithBlob = (file, name2) => {
        const blobUrl = window.URL.createObjectURL(file);
        const a = document.createElement("a");
        a.href = blobUrl;
        a.download = name2;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(blobUrl);
      };
      function mitt(n) {
        return { all: n = n || new Map(), on: function(t, e) {
          var i = n.get(t);
          i ? i.push(e) : n.set(t, [e]);
        }, off: function(t, e) {
          var i = n.get(t);
          i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
        }, emit: function(t, e) {
          var i = n.get(t);
          i && i.slice().map(function(n2) {
            n2(e);
          }), (i = n.get("*")) && i.slice().map(function(n2) {
            n2(t, e);
          });
        } };
      }
      const eventBus = mitt();
      const EVENT_TYPES = {
CLOUD_MUSIC_MATCH_ALL: "cloud_music_match_all"
      };
      const emit = (event, data) => {
        eventBus.emit(event, data);
      };
      const on = (event, handler) => {
        eventBus.on(event, handler);
      };
      const off = (event, handler) => {
        eventBus.off(event, handler);
      };
      const singerKeywordsMap = {};
      const useSearchSinger = (options) => {
        const {
keywords
        } = options || {};
        const [singerList, setSingerList] = useState([]);
        const [loading, setLoading] = useState(false);
        const searchSingerList = async (keywords2) => {
          try {
            setLoading(true);
            if (singerKeywordsMap[keywords2]) {
              const res2 = await singerKeywordsMap[keywords2];
              const list = (res2.data.list || []).sort(
                (a, b) => a.artistId - b.artistId
              );
              setSingerList(list);
              return;
            }
            singerKeywordsMap[keywords2] = searchArtist(keywords2);
            const res = await singerKeywordsMap[keywords2];
            if (res.code === 200) {
              const list = (res.data.list || []).sort(
                (a, b) => a.artistId - b.artistId
              );
              setSingerList(list);
            }
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        useEffect(() => {
          if (!keywords) return;
          searchSingerList(keywords);
        }, [keywords]);
        return {
          singerList,
          loading,
          searchSingerList
        };
      };
      const useGetSingerList = () => {
        const [singerList, setSingerList] = useState([]);
        const [loading, setLoading] = useState(false);
        const getSingerList = async () => {
          try {
            setLoading(true);
            const res = await getArtists();
            const res2 = await getArtists2();
            const list = [
              ...new Map([...res2, ...res].map((item) => [item.id, item])).values()
            ];
            setSingerList(list);
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        const resetSingerList = () => {
          setSingerList([]);
        };
        useEffect(() => {
          getSingerList();
        }, []);
        return {
          singerList,
          loading,
          getSingerList,
          resetSingerList
        };
      };
      function useGetSingerSongs(options) {
        const {
singerIds
        } = options || {};
        useGetSingerList();
        const [singerMap, setSingerMap] = useState({});
        const [loading, setLoading] = useState(false);
        const getSingerInfoById = async (singerId) => {
          try {
            if (singerMap[singerId]?.singerInfo)
              return singerMap[singerId]?.singerInfo;
            const res = await searchArtist(singerId);
            if (res.code === 200) {
              console.log("res", res);
              const singerInfo = res.data.list[0];
              setSingerMap((prv) => ({
                ...prv,
                [singerId]: {
                  ...prv[singerId],
                  singerInfo
                }
              }));
              return singerInfo;
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        const getSingerAllSongListById = async (singerId) => {
          try {
            setLoading(true);
            if (singerMap[singerId]?.songList) return singerMap[singerId]?.songList;
            const res = await getArtistAllSongList(singerId);
            if (res.code === 200) {
              const songList2 = res.songs;
              setSingerMap((prv) => ({
                ...prv,
                [singerId]: {
                  ...prv[singerId],
                  songList: songList2
                }
              }));
              return songList2;
            }
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        const getSingerAlbumListById = async (singerId) => {
          try {
            if (singerMap[singerId]?.albumList) return singerMap[singerId]?.albumList;
            const res = await getArtistAlbumList(singerId);
            if (res.code === 200) {
              const albumList = res.data;
              setSingerMap((prv) => ({
                ...prv,
                [singerId]: {
                  ...prv[singerId],
                  albumList,
                  albumMap: Object.fromEntries(
                    albumList.map((item) => [item.id, item])
                  )
                }
              }));
              return albumList;
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        useEffect(() => {
          if (!singerIds) return;
          const ids = (singerIds + "").split(",");
          ids.forEach((singerId) => {
            getSingerInfoById(singerId);
            getSingerAllSongListById(singerId);
            getSingerAlbumListById(singerId);
          });
        }, [singerIds]);
        const reset = () => {
          setSingerMap({});
        };
        return {
          singerMap,
          getSingerInfoById,
          getSingerAllSongListById,
          reset,
          loading
        };
      }
      const songInfoColumn = "_songInfoColumn_flki2_1";
      const songIndex = "_songIndex_flki2_7";
      const songCover = "_songCover_flki2_16";
      const btnWrapper = "_btnWrapper_flki2_28";
      const songCoverImg = "_songCoverImg_flki2_33";
      const songInfo$1 = "_songInfo_flki2_1";
      const songName$1 = "_songName_flki2_67";
      const subInfo = "_subInfo_flki2_76";
      const artist = "_artist_flki2_84";
      const album = "_album_flki2_85";
      const currentSong = "_currentSong_flki2_102";
      const matchError = "_matchError_flki2_121";
      const footer = "_footer_flki2_128";
      const actions = "_actions_flki2_136";
      const stats = "_stats_flki2_141";
      const size$1 = "_size_flki2_146";
      const divider$2 = "_divider_flki2_149";
      const autoAddContent = "_autoAddContent_flki2_161";
      const title = "_title_flki2_161";
      const statsWrapper = "_statsWrapper_flki2_165";
      const statsContent = "_statsContent_flki2_168";
      const label$1 = "_label_flki2_175";
      const value$1 = "_value_flki2_178";
      const listHeader = "_listHeader_flki2_183";
      const listWrapper = "_listWrapper_flki2_189";
      const listItem = "_listItem_flki2_210";
      const itemName = "_itemName_flki2_226";
      const itemCount = "_itemCount_flki2_232";
      const deleteConfirmation = "_deleteConfirmation_flki2_237";
      const count$1 = "_count_flki2_245";
      const songs = "_songs_flki2_248";
      const songItem$1 = "_songItem_flki2_259";
      const warning = "_warning_flki2_270";
      const text = "_text_flki2_277";
      const icon = "_icon_flki2_284";
      const styles$6 = {
        songInfoColumn,
        songIndex,
        songCover,
        btnWrapper,
        songCoverImg,
        songInfo: songInfo$1,
        songName: songName$1,
        subInfo,
        artist,
        album,
        currentSong,
        matchError,
        footer,
        actions,
        stats,
        size: size$1,
        divider: divider$2,
        autoAddContent,
        title,
        statsWrapper,
        statsContent,
        label: label$1,
        value: value$1,
        listHeader,
        listWrapper,
        listItem,
        itemName,
        itemCount,
        deleteConfirmation,
        count: count$1,
        songs,
        songItem: songItem$1,
        warning,
        text,
        icon,
        "singer-option": "_singer-option_flki2_298",
        "singer-option-content": "_singer-option-content_flki2_311",
        "singer-option-name": "_singer-option-name_flki2_326",
        "singer-option-id": "_singer-option-id_flki2_329",
        "song-name": "_song-name_flki2_343",
        "tag-group": "_tag-group_flki2_348",
        "song-option": "_song-option_flki2_354",
        "song-info": "_song-info_flki2_367",
        "album-cover": "_album-cover_flki2_396",
        "original-album": "_original-album_flki2_412",
        "album-info": "_album-info_flki2_436"
      };
      const CustomMatch = ({ data, onUpdate }) => {
        const [keywords, setKeywords] = useState(getArtistName(data));
        const [currentSelectSinger, setCurrentSelectSinger] = useState();
        const [currentSelectSong, setCurrentSelectSong] = useState();
        const [songSearchValue, setSongSearchValue] = useState(data.name);
        const [currentSelectSongId, setCurrentSelectSongId] = useState();
        const { loading: searchSingerLoading, singerList } = useSearchSinger({
          keywords
        });
        const { singerMap, loading: getSongLoading } = useGetSingerSongs({
          singerIds: currentSelectSinger
        });
        const [updateLoading, setUpdateLoading] = useState(false);
        const [autoMatchLoading, setAutoMatchLoading] = useState(false);
        const songOptions = useMemo(() => {
          if (!singerMap[currentSelectSinger]?.songList) return [];
          const allOptions = singerMap[currentSelectSinger]?.songList?.map(
            (item) => ({
              ...item,
              label: item.name,
              value: item.id
            })
          );
          const mostMatch = allOptions.find((item) => {
            const itemAlbumName = normalizeString(item.al?.name);
            const itemSongName = normalizeString(item.name);
            const dataAlbumName = normalizeString(
              data.album || data.simpleSong?.al?.name
            );
            const dataSongName = normalizeString(data.songName);
            return itemSongName.includes(dataSongName) && itemAlbumName.includes(dataAlbumName);
          });
          console.log("找到最匹配，放置到第一 mostMatch", mostMatch);
          return mostMatch ? [mostMatch, ...allOptions.filter((item) => item.id !== mostMatch.id)] : allOptions;
        }, [singerMap, currentSelectSinger, data]);
        useEffect(() => {
          const handleMatchAll = async (eventData) => {
            console.log("CustomMatch 收到全部匹配事件", eventData);
            if (!currentSelectSinger || !currentSelectSongId) {
              console.log("当前组件未选择歌手或歌曲，跳过自动匹配");
              return;
            }
            handleUpdate();
          };
          on(EVENT_TYPES.CLOUD_MUSIC_MATCH_ALL, handleMatchAll);
          return () => {
            off(EVENT_TYPES.CLOUD_MUSIC_MATCH_ALL, handleMatchAll);
          };
        }, [currentSelectSinger, currentSelectSongId, data, onUpdate]);
        const handleUpdate = async () => {
          try {
            setUpdateLoading(true);
            if (!currentSelectSinger || !currentSelectSongId) {
              msgError("请选择歌手和歌曲");
              return;
            }
            const res = await matchCloudSong(
              data.songId,
              currentSelectSongId,
              currentSelectSong
            );
            console.log("res", res);
            if (res.code === 200) {
              msgSuccess("更新成功");
            }
          } catch (error) {
            console.log("error", error);
          } finally {
            setUpdateLoading(false);
          }
        };
        return jsxRuntimeExports.jsxs(
          "div",
          {
            style: { display: "flex", alignItems: "center", gap: 8 },
            onClick: () => console.log(data),
            children: [
jsxRuntimeExports.jsx(
                Input,
                {
                  style: {
                    width: 120
                  },
                  defaultValue: keywords,
                  placeholder: "请输入歌手名",
                  onPressEnter: (e) => {
                    console.log("e", e);
                    setKeywords(e.target.value);
                  }
                }
              ),
jsxRuntimeExports.jsx(
                Select,
                {
                  style: { width: 200 },
                  value: currentSelectSinger,
                  onChange: (value2) => {
                    setCurrentSelectSinger(value2);
                  },
                  popupMatchSelectWidth: 300,
                  showSearch: true,
                  placeholder: "请选择歌手",
                  filterOption: (input, option) => option?.label?.indexOf(input) >= 0,
                  loading: searchSingerLoading,
                  options: singerList.map((item) => ({
                    ...item,
                    label: item.artistName,
                    value: item.artistId
                  })),
                  onFocus: () => {
                    setCurrentSelectSinger(singerList?.[0]?.artistId);
                  },
                  optionRender: (option) => {
                    const { artistAvatarPicUrl, artistName: artistName2, artistId } = option.data;
                    return jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: styles$6["singer-option"],
                        style: {
                          "--avatar-url": `url(${artistAvatarPicUrl})`
                        },
                        children: jsxRuntimeExports.jsxs("div", { className: styles$6["singer-option-content"], children: [
jsxRuntimeExports.jsx("div", { className: styles$6["singer-option-name"], children: artistName2 }),
jsxRuntimeExports.jsx("div", { className: styles$6["singer-option-id"], children: artistId })
                        ] })
                      }
                    );
                  },
                  dropdownRender: (originNode) => {
                    return searchSingerLoading ? jsxRuntimeExports.jsx(
                      Spin,
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          height: 100
                        }
                      }
                    ) : originNode;
                  }
                }
              ),
jsxRuntimeExports.jsx(
                Select,
                {
                  style: { width: 200 },
                  value: currentSelectSongId,
                  onChange: (value2, option) => {
                    console.log("value", value2, option);
                    setCurrentSelectSongId(value2);
                    setCurrentSelectSong(option);
                  },
                  showSearch: true,
                  searchValue: songSearchValue,
                  onFocus: () => {
                    console.log("data", data);
                    setSongSearchValue(data.songName);
                  },
                  onSearch: (value2) => {
                    setSongSearchValue(value2);
                  },
                  placeholder: "请选择歌曲",
                  filterOption: (input, option) => option?.label?.toLowerCase().indexOf(input.toLowerCase()) >= 0,
                  loading: getSongLoading,
                  options: songOptions,
                  popupMatchSelectWidth: 500,
                  optionRender: (option) => {
                    const data2 = option.data;
                    return jsxRuntimeExports.jsxs(
                      "div",
                      {
                        className: styles$6["song-option"],
                        onClick: () => console.log("option", data2, option, singerMap),
                        children: [
jsxRuntimeExports.jsxs("div", { className: styles$6["song-info"], children: [
jsxRuntimeExports.jsx("span", { className: styles$6["song-name"], children: option.label }),
jsxRuntimeExports.jsxs("div", { className: styles$6["tag-group"], children: [
                              data2.al?.name && jsxRuntimeExports.jsx(Tag, { color: "blue", children: data2.al?.name }),
                              data2.ar?.length && data2.ar?.map((artist2, index) => jsxRuntimeExports.jsx(Tag, { color: "green", children: artist2.name }, index))
                            ] })
                          ] }),
                          singerMap[currentSelectSinger]?.albumMap?.[data2.al?.id]?.picUrl && jsxRuntimeExports.jsx(
                            "img",
                            {
                              className: styles$6["album-cover"],
                              src: singerMap[currentSelectSinger]?.albumMap[data2.al?.id]?.picUrl,
                              alt: data2.al?.name
                            }
                          )
                        ]
                      }
                    );
                  },
                  dropdownRender: (originNode) => {
                    return getSongLoading ? jsxRuntimeExports.jsx(
                      Spin,
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          height: 100
                        }
                      }
                    ) : originNode;
                  }
                }
              ),
jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  size: "small",
                  loading: updateLoading || autoMatchLoading,
                  disabled: !currentSelectSinger || !currentSelectSongId,
                  onClick: handleUpdate,
                  children: autoMatchLoading ? "自动匹配中..." : "匹配"
                }
              )
            ]
          }
        );
      };
      const IdMatch = ({ data, onUpdate }) => {
        const { matchType, songId } = data;
        const isMatched = matchType === "matched";
        const [value2, setValue] = useState(songId);
        const [loading, setLoading] = useState(false);
        const [autoMatchLoading, setAutoMatchLoading] = useState(false);
        useEffect(() => {
          const handleMatchAll = async (eventData) => {
            console.log("IdMatch 收到全部匹配事件", eventData);
            if (!value2 || value2 === songId) {
              console.log("当前组件未设置匹配ID，跳过自动匹配");
              return;
            }
            try {
              setAutoMatchLoading(true);
              console.log("开始自动ID匹配歌曲:", data.songName);
              const res = await matchCloudSong(songId, value2);
              if (res.code === 200) {
                console.log("自动ID匹配成功:", data.songName);
                onUpdate?.();
              } else {
                console.log("自动ID匹配失败:", data.songName, res.message);
              }
            } catch (error) {
              console.log("自动ID匹配出错:", data.songName, error);
            } finally {
              setAutoMatchLoading(false);
            }
          };
          on(EVENT_TYPES.CLOUD_MUSIC_MATCH_ALL, handleMatchAll);
          return () => {
            off(EVENT_TYPES.CLOUD_MUSIC_MATCH_ALL, handleMatchAll);
          };
        }, [value2, songId, data, onUpdate]);
        const handleUpdate = async () => {
          try {
            setLoading(true);
            const res = await matchCloudSong(songId, value2);
            console.log("res", res);
            if (res.code === 200) {
              msgSuccess("更新成功");
              onUpdate?.();
            }
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        return jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
jsxRuntimeExports.jsx(Tag, { color: isMatched ? "green" : "red", children: isMatched ? "已匹配" : "未匹配" }),
jsxRuntimeExports.jsx(
            Input,
            {
              value: value2,
              onChange: (e) => {
                setValue(e.target.value);
              },
              size: "small",
              onKeyDown: (e) => {
                if (e.key === "Enter") {
                  handleUpdate();
                }
              },
              style: { flex: 1, marginRight: 8 }
            }
          ),
jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              onClick: handleUpdate,
              loading: loading || autoMatchLoading,
              size: "small",
              children: autoMatchLoading ? "自动匹配中..." : "更新"
            }
          )
        ] });
      };
      const playlistCreationStrategies = {
        周杰伦: {
          name: "周杰伦的歌单",
          color: "blue",
          description: "创建周杰伦专属歌单",
          getPlaylistName: () => "周杰伦"
        },
        林俊杰: {
          name: "林俊杰的歌单",
          color: "green",
          description: "创建林俊杰专属歌单",
          getPlaylistName: () => "林俊杰"
        },
        陈奕迅: {
          name: "陈奕迅的歌单",
          color: "purple",
          description: "创建陈奕迅专属歌单",
          getPlaylistName: () => "陈奕迅"
        },
        张学友: {
          name: "张学友的歌单",
          color: "orange",
          description: "创建张学友专属歌单",
          getPlaylistName: () => "张学友"
        }
      };
      const PlayList$2 = (props, ref) => {
        const [visible, setVisible] = useState(false);
        const [mode2, setMode] = useState("edit");
        const isSelect = mode2 === "select";
        const open = (mode22) => {
          reset();
          if (mode22) {
            setMode(mode22);
          }
          setVisible(true);
          handleGetPlayList();
        };
        const close = () => {
          setVisible(false);
          setPlayList([]);
        };
        const reset = () => {
          setPlayList([]);
          res.current = null;
          setMode("add");
          setSelectedRows([]);
          setName("");
          setCreateModalVisible(false);
        };
        const res = useRef(null);
        const submit = () => {
          return new Promise((resolve, reject) => {
            res.current = resolve;
          });
        };
        useImperativeHandle(ref, () => ({
          open,
          close,
          submit
        }));
        const [loading, setLoading] = useState(false);
        const [playList, setPlayList] = useState([]);
        const handleGetPlayList = async () => {
          setLoading(true);
          try {
            const user = getUser();
            if (!user) return message.error("请先登录");
            const res2 = await getPlaylistList();
            console.log("res", res2);
            if (res2.code === 200) {
              setPlayList(res2.playlist);
            }
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        const { filteredList, handleFilter } = useFilter(playList, {
          fields: {
            name: {
              getValue: (item) => item.name
            },
            creator: {
              getValue: (item) => item.creator.nickname
            }
          }
        });
        const columns = [
          {
            title: "歌单",
            dataIndex: "name",
            key: "name",
            width: 220,
            ellipsis: true,
            render: (text2, record) => jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
jsxRuntimeExports.jsx(
                Image,
                {
                  src: record.coverImgUrl,
                  width: 40,
                  height: 40,
                  style: { borderRadius: "4px" },
                  preview: false
                }
              ),
jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    fontWeight: 500,
                    flex: 1,
                    minWidth: 0,
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap"
                  },
                  children: text2
                }
              )
            ] })
          },
          {
            title: "歌曲数",
            dataIndex: "trackCount",
            key: "trackCount",
            width: 100,
            align: "right",
            sorter: (a, b) => a.trackCount - b.trackCount,
            sortDirections: ["descend", "ascend"],
            render: (text2) => jsxRuntimeExports.jsxs(
              "span",
              {
                style: {
                  color: "#666",
                  fontSize: "13px"
                },
                children: [
                  text2,
                  " 首"
                ]
              }
            )
          },
          {
            title: "创建者",
            dataIndex: ["creator", "nickname"],
            key: "creator",
            width: 150,
            ellipsis: true
          },
          {
            title: "更新时间",
            dataIndex: "updateTime",
            key: "updateTime",
            width: 200,
            render: (text2) => new Date(text2).toLocaleString(),
            sorter: (a, b) => a.updateTime - b.updateTime,
            sortDirections: ["descend", "ascend"]
          },
          {
            title: "播放量",
            dataIndex: "playCount",
            key: "playCount",
            width: 100,
            render: (text2) => {
              const count2 = text2 > 1e4 ? `${(text2 / 1e4).toFixed(1)}万` : text2;
              return jsxRuntimeExports.jsx("span", { children: count2 });
            },
            sorter: (a, b) => a.playCount - b.playCount,
            sortDirections: ["descend", "ascend"]
          }
        ];
        const [selectedRows, setSelectedRows] = useState([]);
        const rowSelection = {
          type: isSelect ? "radio" : "checkbox",
          selectedRowKeys: selectedRows.map((item) => item.id),
          onSelectAll: () => {
            setTimeout(() => {
              setSelectedRows(playList);
            }, 0);
          },
          onChange: (_, selectedRows2) => {
            setSelectedRows(selectedRows2);
          }
        };
        const handleConfirm = () => {
          if (!selectedRows.length) {
            msgWarning("请选择歌单");
            return;
          }
          if (selectedRows.length !== 1) return msgWarning("只能选择一个歌单");
          res.current?.(selectedRows[0]);
          close();
        };
        const [name2, setName] = useState("");
        const [createModalVisible, setCreateModalVisible] = useState(false);
        const handleCreate = async () => {
          if (!name2.trim()) {
            msgWarning("请输入歌单名称");
            return;
          }
          try {
            const res2 = await createPlaylist(name2.trim());
            if (res2.code === 200) {
              msgSuccess("新建成功");
              handleGetPlayList();
              setName("");
              setCreateModalVisible(false);
            } else {
              msgError("新建失败");
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleCreateCommonPlaylist = async (artistName2) => {
          const strategy = playlistCreationStrategies[artistName2];
          if (!strategy) {
            msgError("不支持的歌手类型");
            return;
          }
          try {
            const playlistName = strategy.getPlaylistName();
            const res2 = await createPlaylist(playlistName);
            if (res2.code === 200) {
              msgSuccess(`成功创建"${playlistName}"`);
              handleGetPlayList();
              setCreateModalVisible(false);
            } else {
              msgError("创建失败");
            }
          } catch (error) {
            console.log("error", error);
            msgError("创建失败");
          }
        };
        const handleDelete = async () => {
          if (!selectedRows.length) {
            msgWarning("请选择要删除的歌单");
            return;
          }
          try {
            await confirm(
jsxRuntimeExports.jsx(DeleteConfirmContent, { playlists: selectedRows }),
              "删除歌单"
            );
            const proArr = selectedRows.map((item) => deletePlaylist(item.id));
            const res2 = await Promise.all(proArr);
            console.log("res", res2);
            msgSuccess("删除成功");
            handleGetPlayList();
            setSelectedRows([]);
          } catch (error) {
            console.log("error", error);
            msgError("删除失败");
          }
        };
        return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
jsxRuntimeExports.jsxs(
            Modal,
            {
              title: "歌单列表",
              open: visible,
              onCancel: close,
              footer: null,
              centered: true,
              width: 900,
              children: [
jsxRuntimeExports.jsx(
                  SearchForm,
                  {
                    data: playList.map((item) => ({
                      ...item,
                      creator: item.creator.nickname
                    })),
                    options: [
                      {
                        label: "歌单名字",
                        value: "name"
                      },
                      {
                        label: "创建者",
                        value: "creator"
                      }
                    ],
                    onSearch: handleFilter
                  }
                ),
jsxRuntimeExports.jsx(
                  Table,
                  {
                    dataSource: filteredList,
                    columns,
                    rowKey: "id",
                    size: "small",
                    loading,
                    scroll: { y: 400 },
                    rowSelection
                  }
                ),
jsxRuntimeExports.jsxs("div", { className: styles$6.footer, children: [
jsxRuntimeExports.jsxs("div", { children: [
                    "已选择 ",
                    selectedRows.length,
                    " 个歌单"
                  ] }),
jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(Button, { onClick: () => setCreateModalVisible(true), children: "新建歌单" }),
jsxRuntimeExports.jsx(
                      Button,
                      {
                        danger: true,
                        disabled: !selectedRows.length,
                        onClick: handleDelete,
                        children: "删除歌单"
                      }
                    ),
                    isSelect && jsxRuntimeExports.jsxs(
                      Button,
                      {
                        type: "primary",
                        onClick: handleConfirm,
                        disabled: selectedRows.length !== 1,
                        children: [
                          "选择(",
                          selectedRows.length,
                          ")"
                        ]
                      }
                    )
                  ] })
                ] })
              ]
            }
          ),
jsxRuntimeExports.jsxs(
            Modal,
            {
              title: "新建歌单",
              open: createModalVisible,
              onCancel: () => {
                setCreateModalVisible(false);
                setName("");
              },
              onOk: handleCreate,
              okText: "确定",
              cancelText: "取消",
              centered: true,
              children: [
jsxRuntimeExports.jsx(
                  Input,
                  {
                    placeholder: "请输入歌单名称",
                    value: name2,
                    onChange: (e) => setName(e.target.value),
                    onPressEnter: handleCreate,
                    autoFocus: true,
                    style: { marginBottom: 16, padding: "4px 8px" }
                  }
                ),
jsxRuntimeExports.jsx(Space, { wrap: true, children: Object.entries(playlistCreationStrategies).map(
                  ([artistName2, strategy]) => jsxRuntimeExports.jsx(
                    Tag,
                    {
                      color: strategy.color,
                      style: {
                        cursor: "pointer",
                        marginBottom: 8,
                        borderRadius: "4px",
                        border: "1px solid #d9d9d9",
                        transition: "all 0.3s"
                      },
                      onClick: () => handleCreateCommonPlaylist(artistName2),
                      title: strategy.description,
                      children: artistName2
                    },
                    artistName2
                  )
                ) })
              ]
            }
          )
        ] });
      };
      const DeleteConfirmContent = ({ playlists }) => {
        return jsxRuntimeExports.jsxs("div", { className: styles$6.autoAddContent, children: [
jsxRuntimeExports.jsxs("div", { className: styles$6.statsWrapper, children: [
jsxRuntimeExports.jsx("div", { className: styles$6.title, children: "总计：" }),
jsxRuntimeExports.jsx("div", { className: styles$6.statsContent, children: jsxRuntimeExports.jsxs("div", { children: [
jsxRuntimeExports.jsx("span", { className: styles$6.label, children: "删除数量：" }),
jsxRuntimeExports.jsx("span", { className: styles$6.value, children: playlists.length }),
jsxRuntimeExports.jsx("span", { className: styles$6.label, children: " 个歌单" })
            ] }) })
          ] }),
jsxRuntimeExports.jsxs("div", { children: [
jsxRuntimeExports.jsx("div", { className: styles$6.listHeader, children: jsxRuntimeExports.jsx("div", { className: styles$6.title, children: "即将删除的歌单：" }) }),
jsxRuntimeExports.jsx("ul", { className: styles$6.listWrapper, children: playlists.map((item) => jsxRuntimeExports.jsxs("li", { className: styles$6.listItem, children: [
jsxRuntimeExports.jsx("span", { className: styles$6.itemName, children: item.name }),
              item.trackCount > 0 && jsxRuntimeExports.jsxs("span", { className: styles$6.itemCount, children: [
                item.trackCount,
                "首"
              ] })
            ] }, item.id)) })
          ] })
        ] });
      };
      const PlayList$3 = forwardRef(PlayList$2);
      const Stats = memo(({ selectedRows = [], filteredSongList = [] }) => {
        return jsxRuntimeExports.jsxs("div", { className: styles$6.stats, children: [
          "已选择 ",
jsxRuntimeExports.jsxs(Tag, { color: "blue", children: [
            selectedRows.length,
            " 首"
          ] }),
          " ",
jsxRuntimeExports.jsx("span", { className: styles$6.size, children: selectedRows.length > 0 && `${(selectedRows.reduce((acc, cur) => acc + cur.fileSize, 0) / 1024 / 1024).toFixed(2)}MB` }),
jsxRuntimeExports.jsx("span", { className: styles$6.divider, children: "/" }),
          "共",
          " ",
jsxRuntimeExports.jsxs(Tag, { color: "green", children: [
            filteredSongList.length,
            " 首"
          ] }),
          " ",
jsxRuntimeExports.jsx("span", { className: styles$6.size, children: filteredSongList.length > 0 && `${(filteredSongList.reduce((acc, cur) => acc + cur.fileSize, 0) / 1024 / 1024).toFixed(2)}MB` })
        ] });
      });
      Stats.displayName = "Stats";
      var dayjs_min$1 = { exports: {} };
      var dayjs_min = dayjs_min$1.exports;
      var hasRequiredDayjs_min;
      function requireDayjs_min() {
        if (hasRequiredDayjs_min) return dayjs_min$1.exports;
        hasRequiredDayjs_min = 1;
        (function(module, exports) {
          !(function(t, e) {
            module.exports = e();
          })(dayjs_min, (function() {
            var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
              var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
              return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
            } }, m = function(t2, e2, n2) {
              var r2 = String(t2);
              return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
            }, v = { s: m, z: function(t2) {
              var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
              return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
            }, m: function t2(e2, n2) {
              if (e2.date() < n2.date()) return -t2(n2, e2);
              var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
              return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
            }, a: function(t2) {
              return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
            }, p: function(t2) {
              return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
            }, u: function(t2) {
              return void 0 === t2;
            } }, g = "en", D = {};
            D[g] = M;
            var p = "$isDayjsObject", S = function(t2) {
              return t2 instanceof _ || !(!t2 || !t2[p]);
            }, w = function t2(e2, n2, r2) {
              var i2;
              if (!e2) return g;
              if ("string" == typeof e2) {
                var s2 = e2.toLowerCase();
                D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
                var u2 = e2.split("-");
                if (!i2 && u2.length > 1) return t2(u2[0]);
              } else {
                var a2 = e2.name;
                D[a2] = e2, i2 = a2;
              }
              return !r2 && i2 && (g = i2), i2 || !r2 && g;
            }, O = function(t2, e2) {
              if (S(t2)) return t2.clone();
              var n2 = "object" == typeof e2 ? e2 : {};
              return n2.date = t2, n2.args = arguments, new _(n2);
            }, b = v;
            b.l = w, b.i = S, b.w = function(t2, e2) {
              return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
            };
            var _ = (function() {
              function M2(t2) {
                this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
              }
              var m2 = M2.prototype;
              return m2.parse = function(t2) {
                this.$d = (function(t3) {
                  var e2 = t3.date, n2 = t3.utc;
                  if (null === e2) return new Date(NaN);
                  if (b.u(e2)) return new Date();
                  if (e2 instanceof Date) return new Date(e2);
                  if ("string" == typeof e2 && !/Z$/i.test(e2)) {
                    var r2 = e2.match($);
                    if (r2) {
                      var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                      return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
                    }
                  }
                  return new Date(e2);
                })(t2), this.init();
              }, m2.init = function() {
                var t2 = this.$d;
                this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
              }, m2.$utils = function() {
                return b;
              }, m2.isValid = function() {
                return !(this.$d.toString() === l);
              }, m2.isSame = function(t2, e2) {
                var n2 = O(t2);
                return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
              }, m2.isAfter = function(t2, e2) {
                return O(t2) < this.startOf(e2);
              }, m2.isBefore = function(t2, e2) {
                return this.endOf(e2) < O(t2);
              }, m2.$g = function(t2, e2, n2) {
                return b.u(t2) ? this[e2] : this.set(n2, t2);
              }, m2.unix = function() {
                return Math.floor(this.valueOf() / 1e3);
              }, m2.valueOf = function() {
                return this.$d.getTime();
              }, m2.startOf = function(t2, e2) {
                var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
                  var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
                  return r2 ? i2 : i2.endOf(a);
                }, $2 = function(t3, e3) {
                  return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
                }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
                switch (f2) {
                  case h:
                    return r2 ? l2(1, 0) : l2(31, 11);
                  case c:
                    return r2 ? l2(1, M3) : l2(0, M3 + 1);
                  case o:
                    var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
                    return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
                  case a:
                  case d:
                    return $2(v2 + "Hours", 0);
                  case u:
                    return $2(v2 + "Minutes", 1);
                  case s:
                    return $2(v2 + "Seconds", 2);
                  case i:
                    return $2(v2 + "Milliseconds", 3);
                  default:
                    return this.clone();
                }
              }, m2.endOf = function(t2) {
                return this.startOf(t2, false);
              }, m2.$set = function(t2, e2) {
                var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
                if (o2 === c || o2 === h) {
                  var y2 = this.clone().set(d, 1);
                  y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
                } else l2 && this.$d[l2]($2);
                return this.init(), this;
              }, m2.set = function(t2, e2) {
                return this.clone().$set(t2, e2);
              }, m2.get = function(t2) {
                return this[b.p(t2)]();
              }, m2.add = function(r2, f2) {
                var d2, l2 = this;
                r2 = Number(r2);
                var $2 = b.p(f2), y2 = function(t2) {
                  var e2 = O(l2);
                  return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
                };
                if ($2 === c) return this.set(c, this.$M + r2);
                if ($2 === h) return this.set(h, this.$y + r2);
                if ($2 === a) return y2(1);
                if ($2 === o) return y2(7);
                var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
                return b.w(m3, this);
              }, m2.subtract = function(t2, e2) {
                return this.add(-1 * t2, e2);
              }, m2.format = function(t2) {
                var e2 = this, n2 = this.$locale();
                if (!this.isValid()) return n2.invalidDate || l;
                var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
                  return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
                }, d2 = function(t3) {
                  return b.s(s2 % 12 || 12, t3, "0");
                }, $2 = f2 || function(t3, e3, n3) {
                  var r3 = t3 < 12 ? "AM" : "PM";
                  return n3 ? r3.toLowerCase() : r3;
                };
                return r2.replace(y, (function(t3, r3) {
                  return r3 || (function(t4) {
                    switch (t4) {
                      case "YY":
                        return String(e2.$y).slice(-2);
                      case "YYYY":
                        return b.s(e2.$y, 4, "0");
                      case "M":
                        return a2 + 1;
                      case "MM":
                        return b.s(a2 + 1, 2, "0");
                      case "MMM":
                        return h2(n2.monthsShort, a2, c2, 3);
                      case "MMMM":
                        return h2(c2, a2);
                      case "D":
                        return e2.$D;
                      case "DD":
                        return b.s(e2.$D, 2, "0");
                      case "d":
                        return String(e2.$W);
                      case "dd":
                        return h2(n2.weekdaysMin, e2.$W, o2, 2);
                      case "ddd":
                        return h2(n2.weekdaysShort, e2.$W, o2, 3);
                      case "dddd":
                        return o2[e2.$W];
                      case "H":
                        return String(s2);
                      case "HH":
                        return b.s(s2, 2, "0");
                      case "h":
                        return d2(1);
                      case "hh":
                        return d2(2);
                      case "a":
                        return $2(s2, u2, true);
                      case "A":
                        return $2(s2, u2, false);
                      case "m":
                        return String(u2);
                      case "mm":
                        return b.s(u2, 2, "0");
                      case "s":
                        return String(e2.$s);
                      case "ss":
                        return b.s(e2.$s, 2, "0");
                      case "SSS":
                        return b.s(e2.$ms, 3, "0");
                      case "Z":
                        return i2;
                    }
                    return null;
                  })(t3) || i2.replace(":", "");
                }));
              }, m2.utcOffset = function() {
                return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
              }, m2.diff = function(r2, d2, l2) {
                var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
                  return b.m(y2, m3);
                };
                switch (M3) {
                  case h:
                    $2 = D2() / 12;
                    break;
                  case c:
                    $2 = D2();
                    break;
                  case f:
                    $2 = D2() / 3;
                    break;
                  case o:
                    $2 = (g2 - v2) / 6048e5;
                    break;
                  case a:
                    $2 = (g2 - v2) / 864e5;
                    break;
                  case u:
                    $2 = g2 / n;
                    break;
                  case s:
                    $2 = g2 / e;
                    break;
                  case i:
                    $2 = g2 / t;
                    break;
                  default:
                    $2 = g2;
                }
                return l2 ? $2 : b.a($2);
              }, m2.daysInMonth = function() {
                return this.endOf(c).$D;
              }, m2.$locale = function() {
                return D[this.$L];
              }, m2.locale = function(t2, e2) {
                if (!t2) return this.$L;
                var n2 = this.clone(), r2 = w(t2, e2, true);
                return r2 && (n2.$L = r2), n2;
              }, m2.clone = function() {
                return b.w(this.$d, this);
              }, m2.toDate = function() {
                return new Date(this.valueOf());
              }, m2.toJSON = function() {
                return this.isValid() ? this.toISOString() : null;
              }, m2.toISOString = function() {
                return this.$d.toISOString();
              }, m2.toString = function() {
                return this.$d.toUTCString();
              }, M2;
            })(), k = _.prototype;
            return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach((function(t2) {
              k[t2[1]] = function(e2) {
                return this.$g(e2, t2[0], t2[1]);
              };
            })), O.extend = function(t2, e2) {
              return t2.$i || (t2(e2, _, O), t2.$i = true), O;
            }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
              return O(1e3 * t2);
            }, O.en = D[g], O.Ls = D, O.p = {}, O;
          }));
        })(dayjs_min$1);
        return dayjs_min$1.exports;
      }
      var dayjs_minExports = requireDayjs_min();
      const dayjs = getDefaultExportFromCjs(dayjs_minExports);
      const CloudMusicManager = forwardRef((props, ref) => {
        const { visible, close, reset } = useVisible(
          {
            onOpen() {
              getCloudDataList();
            }
          },
          ref
        );
        const [songList2, setSongList] = useState([]);
        const [loading, setLoading] = useState(false);
        const getCloudDataList = async () => {
          try {
            setLoading(true);
            const res = await getCloudData(1e4, 0);
            if (res.code === 200) {
              console.log("songList", res.data);
              setSongList(res.data);
              setFilteredSongList(res.data);
            }
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        const handleMatch = () => {
          console.log("触发全部匹配事件");
          emit(EVENT_TYPES.CLOUD_MUSIC_MATCH_ALL, {
            songList: filteredSongList,
            timestamp: Date.now()
          });
        };
        const [cancelMatchLoading, setCancelMatchLoading] = useState(false);
        const handleCancelMatch = async () => {
          try {
            setCancelMatchLoading(true);
            const promises = selectedRowKeys.map((songId) => {
              return () => matchCloudSong(songId, "0");
            });
            const res = await promiseLimit(promises, 6);
            console.log("res", res);
            getCloudDataList();
          } catch (error) {
            console.log("error", error);
          } finally {
            setCancelMatchLoading(false);
          }
        };
        const filterConfig = {
          fields: {
            name: {
              getValue: (song) => song?.simpleSong?.name
            },
            artist: {
              getValue: getArtistName
            },
            album: {
              getValue: getAlbumName
            }
          }
        };
        const [searchParams, setSearchParams] = useState({});
        const {
          filteredList: filteredSongList,
          setFilteredList: setFilteredSongList,
          handleFilter: handleSearch
        } = useFilter(songList2, filterConfig);
        useEffect(() => {
          handleSearch(searchParams);
        }, [songList2]);
        const [selectedRows, setSelectedRows] = useState([]);
        const selectedRowKeys = useMemo(
          () => selectedRows.map((item) => item.songId),
          [selectedRows]
        );
        const rowSelection = {
          type: "checkbox",
          fixed: true,
          selectedRowKeys,
          getCheckboxProps: (record) => ({
            disabled: record.uploaded
          }),
          onChange: (selectedRowKeys2, selectedRows2) => {
            setSelectedRows(selectedRows2);
          }
        };
        const handleTableChange = (pagination, filters, sorter) => {
          console.log("sorter", sorter);
          setFilteredSongList((songList22) => {
            return [...songList22].sort((a, b) => {
              const order = sorter.order === "ascend" ? 1 : -1;
              return order * sorter.column?.sorter?.(a, b);
            });
          });
        };
        const AudioRef = useRef(new Audio());
        const [playSong, setPlaySong] = useState(null);
        const [playing, setPlaying] = useState(false);
        const handlePlaySong = (record) => {
          if (playSong?.id === record.id) {
            const audio2 = AudioRef.current;
            playing ? audio2.pause() : audio2.play();
            setPlaying(!playing);
            return;
          }
          setPlaySong(record);
          setPlaying(true);
        };
        const play = async () => {
          try {
            const res = await getSongUrl([playSong.id]);
            console.log("res", res);
            if (res.code !== 200) return msgError("获取歌曲链接失败");
            const audio2 = AudioRef.current;
            audio2.src = res.data[0].url;
            audio2.addEventListener("ended", () => {
              setPlaySong(null);
            });
            audio2.addEventListener("error", () => {
              setPlaySong(null);
            });
            audio2.play();
          } catch (error) {
            console.log("error", error);
          }
        };
        useEffect(() => {
          if (!playSong) return;
          play();
        }, [playSong]);
        const [pageParams, setPageParams] = useState({
          page: 1,
          pageSize: 20
        });
        const renderSongInfo = (_, record, index) => {
          const isCurrentSong = record.simpleSong?.id === playSong?.id;
          const artistName2 = getArtistName(record);
          const albumName = getAlbumName(record);
          const songName2 = record.simpleSong?.name;
          const albumPic = record.simpleSong?.al?.picUrl;
          return jsxRuntimeExports.jsxs("div", { className: styles$6.songInfoColumn, children: [
jsxRuntimeExports.jsx("div", { className: styles$6.songIndex, children: (pageParams.page - 1) * pageParams.pageSize + index + 1 }),
jsxRuntimeExports.jsxs(
              "div",
              {
                className: `${styles$6.songCover} ${isCurrentSong ? styles$6.playing : ""}`,
                onClick: () => handlePlaySong(record.simpleSong),
                children: [
jsxRuntimeExports.jsx("img", { src: albumPic, alt: albumName, className: styles$6.songCoverImg }),
jsxRuntimeExports.jsx("div", { className: styles$6.btnWrapper, children: isCurrentSong && playing ? jsxRuntimeExports.jsx(PauseCircleFilled, { style: { fontSize: "24px", color: "#fff" } }) : jsxRuntimeExports.jsx(PlayCircleFilled, { style: { fontSize: "24px", color: "#fff" } }) })
                ]
              }
            ),
jsxRuntimeExports.jsxs("div", { className: styles$6.songInfo, children: [
jsxRuntimeExports.jsx("div", { className: styles$6.songName, children: songName2 }),
jsxRuntimeExports.jsxs("div", { className: styles$6.subInfo, children: [
jsxRuntimeExports.jsx("div", { className: styles$6.artist, children: artistName2 }),
jsxRuntimeExports.jsxs("div", { className: styles$6.album, children: [
                  albumName && " - ",
                  albumName
                ] })
              ] })
            ] })
          ] });
        };
        const columns = [
          {
            title: "歌名",
            dataIndex: "simpleSong",
            key: "name",
            width: 300,
            fixed: "left",
            sorter: (a, b) => a.simpleSong.name?.localeCompare(b.simpleSong.name),
            sortDirections: ["ascend", "descend"],
            render: renderSongInfo
          },
          {
            title: "歌手",
            dataIndex: "simpleSong",
            key: "artists",
            width: 60,
            sorter: (a, b) => {
              const aArtists = a.simpleSong.ar?.map((a2) => a2.name).join(",");
              const bArtists = b.simpleSong.ar?.map((a2) => a2.name).join(",");
              return aArtists?.localeCompare(bArtists);
            },
            fixed: "left",
            sortDirections: ["ascend", "descend"],
            ellipsis: true,
            render: null
          },
          {
            title: "专辑",
            dataIndex: "simpleSong",
            key: "album",
            width: 60,
            fixed: "left",
            sorter: (a, b) => a.simpleSong.al?.name?.localeCompare(b.simpleSong.al?.name),
            sortDirections: ["ascend", "descend"],
            defaultSortOrder: "ascend",
            ellipsis: true,
            render: null
          },
{
            title: "原始专辑",
            dataIndex: "simpleSong.al.name",
            width: 160,
            fixed: "left",
            ellipsis: true,
            sorter: (a, b) => {
              const aOriginalInfo = getOriginalInfo(a);
              const bOriginalInfo = getOriginalInfo(b);
              return aOriginalInfo.album?.localeCompare(bOriginalInfo.album);
            },
            sortDirections: ["ascend", "descend"],
            render: (_, record) => {
              const { song, album: album2, artist: artist2 } = getOriginalInfo(record);
              return jsxRuntimeExports.jsxs("div", { className: styles$6["original-album"], children: [
jsxRuntimeExports.jsxs("div", { className: styles$6["song-info"], title: song, children: [
                  song,
                  " ",
                  artist2 && `· ${artist2}`
                ] }),
jsxRuntimeExports.jsx("div", { className: styles$6["album-info"], title: album2, children: album2 })
              ] });
            }
          },
{
            title: "手动id匹配",
            dataIndex: "matchType",
            key: "matchType",
            width: 300,
            sorter: (a, b) => {
              const isAMatched = a.matchType === "matched";
              const isBMatched = b.matchType === "matched";
              if (!isAMatched && !isBMatched) {
                return 0;
              }
              if (!isAMatched && isBMatched) {
                return 1;
              }
              if (isAMatched && !isBMatched) {
                return -1;
              }
              const aAlbum = getAlbumName(a);
              const bAlbum = getAlbumName(b);
              const aOriginalAlbum = getOriginalInfo(a).album;
              const bOriginalAlbum = getOriginalInfo(b).album;
              const aMatchError = aAlbum !== aOriginalAlbum;
              const bMatchError = bAlbum !== bOriginalAlbum;
              if (aMatchError && !bMatchError) {
                return 1;
              }
              if (!aMatchError && bMatchError) {
                return -1;
              }
              return 0;
            },
            sortDirections: ["ascend", "descend"],
            render: (matchType, r) => jsxRuntimeExports.jsx(IdMatch, { data: r, onUpdate: getCloudDataList })
          },
{
            title: "自定义匹配",
            dataIndex: "customMatch",
            key: "customMatch",
            width: 500,
            render: (_, record) => jsxRuntimeExports.jsx(CustomMatch, { data: record, onUpdate: getCloudDataList })
          },
          {
            title: "大小",
            dataIndex: "fileSize",
            key: "fileSize",
            width: 100,
            sorter: (a, b) => a.fileSize - b.fileSize,
            sortDirections: ["ascend", "descend"],
            render: (size2) => `${(size2 / 1024 / 1024).toFixed(2)}MB`
          },
          {
            title: "比特率",
            dataIndex: "bitrate",
            key: "bitrate",
            width: 100,
            sorter: (a, b) => a.bitrate - b.bitrate,
            sortDirections: ["ascend", "descend"],
            render: (bitrate) => jsxRuntimeExports.jsxs(Tag, { color: "blue", children: [
              bitrate,
              "kbps"
            ] })
          },
          {
            title: "上传时间",
            dataIndex: "addTime",
            key: "addTime",
            width: 150,
            sorter: (a, b) => a.addTime - b.addTime,
            sortDirections: ["ascend", "descend"],
            render: (time) => dayjs(time).format("YYYY-MM-DD HH:mm:ss")
          }
        ];
        const [range, setRange] = useState([]);
        const handleRangeChoose = () => {
          console.log("range", range);
          if (!range[0] || !range[1]) return msgWarning("请输入区间");
          if (range[0] > range[1]) return msgWarning("区间错误");
          console.log(
            "filteredSongList.slice(range[0] - 1, range[1])",
            filteredSongList,
            filteredSongList.slice(range[0] - 1, range[1])
          );
          setSelectedRows(filteredSongList.slice(range[0] - 1, range[1]));
        };
        const [addToPlayListByAlbumLoading, setAddToPlayListByAlbumLoading] = useState(false);
        const handleAddToPlaylistByAlbum = async () => {
          try {
            setAddToPlayListByAlbumLoading(true);
            console.log("自动按专辑添加");
            const albumMap = new Map();
            filteredSongList.forEach((song) => {
              const { simpleSong } = song;
              const album2 = `${simpleSong.ar?.[0]?.name || ""}-${simpleSong.al?.name}`;
              if (!albumMap.has(album2)) {
                albumMap.set(album2, []);
              }
              albumMap.get(album2).push(song);
            });
            const totalSongs = filteredSongList.length;
            const albums = Array.from(albumMap.entries()).sort(
              ([, songsA], [, songsB]) => songsB.length - songsA.length
            );
            await confirm(
jsxRuntimeExports.jsx(AutoAddContent, { totalSongs, albums }),
              "自动按专辑添加",
              {
                width: "auto"
              }
            );
            const res = await getPlaylistList();
            console.log("res", res);
            if (res.code !== 200) return msgError("获取歌单失败");
            const playlist = res.playlist;
            for (const [album2, songs2] of albums) {
              try {
                const playlistName = album2;
                console.log("playlistName", playlistName, "songs", songs2);
                let playlistId = playlist.find((p) => p.name === playlistName)?.id;
                if (!playlistId) {
                  const truncatedName = truncateString(playlistName, 40);
                  const res3 = await createPlaylist(truncatedName);
                  if (res3.code === 200) {
                    playlistId = res3.id;
                  } else {
                    console.log("res", res3);
                    debugger;
                  }
                  await sleep(1e3);
                }
                const songIds = songs2.map((song) => song.songId);
                const res2 = await addSongToPlaylist(playlistId, songIds);
                console.log("res", res2);
                if (res2.code !== 200) {
                  console.log("添加歌曲失败", res2.message || res2.msg);
                }
                await sleep(500);
              } catch (error) {
                console.log("error", error);
              }
            }
            setSelectedRows([]);
            msgSuccess("添加成功");
          } catch (error) {
            console.log("error", error);
          } finally {
            setAddToPlayListByAlbumLoading(false);
          }
        };
        const handleStoleSong = async () => {
          console.log("selectedRows", selectedRows);
          const stolenList = selectedRows.map((item) => {
            const {
              artist: artist2,
              album: album2,
              ar,
              simpleSong,
              privateCloud,
              songId,
              fileSize,
              songName: songName2,
              fileName,
              bitrate
            } = item;
            return {
              artist: artist2,
              artists: ar?.map((a) => a.name) || [artist2],
              album: album2 || getAlbumName(item),
              id: songId,
              size: fileSize,
              md5: privateCloud.md5,
              name: songName2,
              ext: fileName.split(".")[1] || "mp3",
              bitrate
            };
          });
          downloadJsonFile(stolenList, "stolenList.json");
        };
        const playListRef = useRef(null);
        const handleAddToPlaylist = async () => {
          try {
            console.log("添加到歌单");
            playListRef.current.open("select");
            const playlist = await playListRef.current.submit();
            if (!playlist) return;
            const songIds = selectedRows.map((item) => item.songId);
            const res = await addSongToPlaylist(playlist.id, songIds);
            console.log("res", res);
            if (res.code === 200) {
              setSelectedRows([]);
              msgSuccess("添加成功");
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleCreatePlaylist = () => {
          playListRef.current.open();
        };
        const handleDeleteSong = async () => {
          try {
            const confirmContent = jsxRuntimeExports.jsx(
              DeleteConfirmation,
              {
                selectedCount: selectedRows.length,
                songNames: selectedRows.map((item) => item.simpleSong.name)
              }
            );
            await confirm(confirmContent, "删除确认");
            const songIds = selectedRows.map((item) => item.songId);
            const res = await deleteCloudSong(songIds);
            console.log("res", res);
            if (res.code === 200) {
              msgSuccess("删除成功");
              reset();
              getCloudDataList();
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        return jsxRuntimeExports.jsxs(
          Modal,
          {
            title: "云盘音乐管理",
            open: visible,
            onCancel: close,
            footer: null,
            centered: true,
            width: 1700,
            children: [
jsxRuntimeExports.jsx(
                SearchForm,
                {
                  onSearch: (values) => {
                    console.log("values", values);
                    setSearchParams(values);
                    handleSearch(values);
                  },
                  data: songList2.map((item) => {
                    return {
                      ...item,
                      name: item.simpleSong.name,
                      artists: getArtistName(item),
                      album: getAlbumName(item)
                    };
                  }),
                  options: [
                    { label: "歌曲", value: "name" },
                    { label: "歌手", value: "artist" },
                    { label: "专辑", value: "album" }
                  ]
                }
              ),
jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    display: "flex",
                    justifyContent: "flex-end",
                    gap: 16,
                    marginBottom: 16
                  },
                  children: [
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleMatch, children: "全部匹配" }),
jsxRuntimeExports.jsx(
                      Button,
                      {
                        type: "primary",
                        disabled: !selectedRows.length,
                        loading: cancelMatchLoading,
                        onClick: handleCancelMatch,
                        children: "全部取消匹配"
                      }
                    ),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: getCloudDataList, children: "刷新" })
                  ]
                }
              ),
jsxRuntimeExports.jsx(
                Table,
                {
                  rowSelection,
                  dataSource: filteredSongList,
                  columns,
                  scroll: { y: 500, x: 1e3 },
                  size: "small",
                  loading,
                  rowKey: ({ songId }) => songId,
                  rowClassName: (record) => {
                    const { songId } = record;
                    const classNames = [];
                    if (songId === playSong?.id) {
                      classNames.push(styles$6.currentSong);
                    }
                    const isMatch = record.matchType === "matched";
                    const album2 = normalizeString(getAlbumName(record));
                    const originalAlbum = normalizeString(getOriginalInfo(record)?.album);
                    if (isMatch && !album2.includes(originalAlbum.slice(0, 3))) {
                      classNames.push(styles$6.matchError);
                    }
                    return classNames.join(" ");
                  },
                  onChange: handleTableChange,
                  pagination: {
                    defaultPageSize: 20,
                    showQuickJumper: true,
                    showSizeChanger: true,
                    onChange: (page, pageSize) => setPageParams({ page, pageSize })
                  }
                }
              ),
jsxRuntimeExports.jsxs("div", { className: styles$6.footer, children: [
jsxRuntimeExports.jsx(
                  Stats,
                  {
                    selectedRows,
                    filteredSongList
                  }
                ),
jsxRuntimeExports.jsxs("div", { className: styles$6.actions, children: [
jsxRuntimeExports.jsx(
                    Input,
                    {
                      value: range[0],
                      onChange: (e) => {
                        setRange([+e.target.value || void 0, range[1]]);
                      },
                      placeholder: "起始位置"
                    }
                  ),
jsxRuntimeExports.jsx(
                    Input,
                    {
                      value: range[1],
                      onChange: (e) => setRange([range[0], +e.target.value || void 0]),
                      placeholder: "结束位置"
                    }
                  ),
jsxRuntimeExports.jsx(Button, { onClick: handleRangeChoose, style: { marginRight: 10 }, children: "区间选择" }),
                  filteredSongList?.length > selectedRows?.length ? jsxRuntimeExports.jsx(Button, { onClick: () => setSelectedRows(filteredSongList), children: "全部选择" }) : jsxRuntimeExports.jsx(Button, { onClick: () => setSelectedRows([]), children: "全部取消" }),
jsxRuntimeExports.jsx(
                    Button,
                    {
                      onClick: () => setSelectedRows(
                        filteredSongList.filter((item) => !selectedRows.includes(item))
                      ),
                      children: "反选"
                    }
                  ),
jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      onClick: handleAddToPlaylistByAlbum,
                      loading: addToPlayListByAlbumLoading,
                      children: "自动按专辑添加"
                    }
                  ),
jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      disabled: !selectedRows.length,
                      onClick: handleStoleSong,
                      children: "偷取资源"
                    }
                  ),
jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      disabled: !selectedRows.length,
                      onClick: handleAddToPlaylist,
                      children: "添加到歌单"
                    }
                  ),
jsxRuntimeExports.jsx(Button, { onClick: handleCreatePlaylist, children: "新建歌单" }),
jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      danger: true,
                      disabled: !selectedRows.length,
                      onClick: handleDeleteSong,
                      children: "删除歌曲"
                    }
                  )
                ] })
              ] }),
jsxRuntimeExports.jsx(PlayList$3, { ref: playListRef })
            ]
          }
        );
      });
      const AutoAddContent = ({ totalSongs, albums }) => {
        const handleCopy = () => {
          const text2 = albums.map(([name2, songs2]) => `${name2}（${songs2.length}首）`).join("\n");
          navigator.clipboard.writeText(text2).then(() => {
            message.success("复制成功");
          });
        };
        return jsxRuntimeExports.jsxs("div", { className: styles$6.autoAddContent, children: [
jsxRuntimeExports.jsxs("div", { className: styles$6.statsWrapper, children: [
jsxRuntimeExports.jsx("div", { className: styles$6.title, children: "总计：" }),
jsxRuntimeExports.jsxs("div", { className: styles$6.statsContent, children: [
jsxRuntimeExports.jsxs("div", { children: [
jsxRuntimeExports.jsx("span", { className: styles$6.label, children: "歌曲数：" }),
jsxRuntimeExports.jsx("span", { className: styles$6.value, children: totalSongs }),
jsxRuntimeExports.jsx("span", { className: styles$6.label, children: " 首" })
              ] }),
jsxRuntimeExports.jsxs("div", { children: [
jsxRuntimeExports.jsx("span", { className: styles$6.label, children: "歌单数：" }),
jsxRuntimeExports.jsx("span", { className: styles$6.value, children: albums.length }),
jsxRuntimeExports.jsx("span", { className: styles$6.label, children: " 个" })
              ] })
            ] })
          ] }),
jsxRuntimeExports.jsxs("div", { children: [
jsxRuntimeExports.jsxs("div", { className: styles$6.listHeader, children: [
jsxRuntimeExports.jsx("div", { className: styles$6.title, children: "即将创建的歌单：" }),
jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  size: "small",
                  icon: jsxRuntimeExports.jsx(CopyrightOutlined, {}),
                  onClick: handleCopy,
                  children: "复制列表"
                }
              )
            ] }),
jsxRuntimeExports.jsx("ul", { className: styles$6.listWrapper, children: albums.map(([name2, songs2]) => jsxRuntimeExports.jsxs("li", { className: styles$6.listItem, children: [
jsxRuntimeExports.jsx("span", { className: styles$6.itemName, children: name2 }),
jsxRuntimeExports.jsxs("span", { className: styles$6.itemCount, children: [
                songs2.length,
                "首"
              ] })
            ] }, name2)) })
          ] })
        ] });
      };
      const DeleteConfirmation = ({ selectedCount, songNames }) => {
        return jsxRuntimeExports.jsxs("div", { className: styles$6.deleteConfirmation, children: [
jsxRuntimeExports.jsxs("p", { className: styles$6.title, children: [
            "您确定要删除以下 ",
jsxRuntimeExports.jsx("span", { className: styles$6.count, children: selectedCount }),
            " ",
            "首歌曲吗？"
          ] }),
jsxRuntimeExports.jsx("div", { className: styles$6.songs, children: songNames.map((name2, index) => jsxRuntimeExports.jsx("div", { className: styles$6.songItem, children: name2 }, index)) }),
jsxRuntimeExports.jsx("div", { className: styles$6.warning, children: jsxRuntimeExports.jsxs("p", { className: styles$6.text, children: [
jsxRuntimeExports.jsx("span", { className: styles$6.icon, children: "!" }),
            "注意：此操作不可恢复，删除后歌曲将从您的网易云音乐云盘中永久移除。"
          ] }) })
        ] });
      };
      const getArtistName = (song) => {
        return song.simpleSong.ar?.map((a) => a.name).filter(Boolean).join(",") || song.artist || "";
      };
      const getAlbumName = (song) => {
        return song.simpleSong.al?.name || song.album || "";
      };
      const getOriginalInfo = (record) => {
        const { simpleSong } = record;
        const { song, album: album2, artist: artist2 } = simpleSong.privilege?.pc || {};
        return { song, album: album2, artist: artist2 };
      };
      const githubContainer = "_githubContainer_b3krt_2";
      const userInfo = "_userInfo_b3krt_9";
      const username = "_username_b3krt_15";
      const starCount = "_starCount_b3krt_18";
      const bio = "_bio_b3krt_24";
      const features = "_features_b3krt_28";
      const featureList = "_featureList_b3krt_37";
      const profileButton = "_profileButton_b3krt_61";
      const styles$5 = {
        githubContainer,
        userInfo,
        username,
        starCount,
        bio,
        features,
        featureList,
        profileButton
      };
      const fetchGithubData = async () => {
        try {
          const owner = "520Qiuyu";
          const repo = "CloudMusic";
          const token = "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";
          const [userResponse, repoResponse] = await Promise.all([
            fetch(`https://api.github.com/users/${owner}`, {
              headers: {
                Accept: "application/vnd.github.v3+json",
                Authorization: `token ${token}`
              }
            }),
            fetch(`https://api.github.com/repos/${owner}/${repo}`, {
              headers: {
                Accept: "application/vnd.github.v3+json",
                Authorization: `token ${token}`
              }
            })
          ]);
          if (!userResponse.ok || !repoResponse.ok) {
            throw new Error("API请求失败");
          }
          const userData = await userResponse.json();
          const repoData = await repoResponse.json();
          return {
            avatar_url: userData.avatar_url,
            stargazers_count: repoData.stargazers_count
          };
        } catch (error) {
          console.error("获取GitHub数据失败:", error);
          return {
            avatar_url: "",
            stargazers_count: 0
          };
        }
      };
      const { Title, Text } = Typography;
      const GithubInfo = forwardRef((props, ref) => {
        const { visible, close } = useVisible({}, ref);
        const [starCount2, setStarCount] = useState(0);
        const [avatarUrl, setAvatarUrl] = useState("");
        useEffect(() => {
          fetchGithubData().then((data) => {
            setStarCount(data.stargazers_count);
            setAvatarUrl(data.avatar_url);
          });
        }, []);
        const githubInfo = {
          avatar: avatarUrl || "https://avatars.githubusercontent.com/u/520Qiuyu",
          username: "520Qiuyu",
          bio: "网易云音乐快速上传助手",
          profileUrl: "https://github.com/520Qiuyu/CloudMusic",
          starCount: `⭐ ${starCount2}`,
          features: [
            "🚀 云盘快速上传：支持同时选择多个歌手的音乐资源文件按专辑顺序进行上传",
            "📊 进度显示：实时展示上传进度和状态",
            "🔍 智能匹配：自动匹配歌曲信息，包括歌手、专辑等",
            "🎵 文件管理：支持查看已上传文件列表",
            "🔄 并发控制：智能控制上传并发数，避免服务器压力",
            "🎵 云盘音乐管理：支持手动将添加的歌曲添加到歌单中",
            "🔄 偷取资源：支持从其他用户的云盘偷取资源，获得导入JSON文件",
            "🎯 手动匹配纠正：支持手动匹配纠正歌曲信息",
            "📤 云盘本地上传：支持将本地音乐文件上传",
            "📥 云盘JSON文件导入：支持通过JSON文件（偷取资源的JSON）导入到云盘，实现云盘音乐的批量导入"
          ]
        };
        const handleProfileClick = () => {
          window.open(githubInfo.profileUrl, "_blank");
        };
        return jsxRuntimeExports.jsx(
          Modal,
          {
            title: "GitHub 信息",
            open: visible,
            onCancel: close,
            footer: null,
            centered: true,
            width: 700,
            zIndex: 99999,
            children: jsxRuntimeExports.jsxs("div", { className: styles$5.githubContainer, children: [
jsxRuntimeExports.jsxs("div", { className: styles$5.userInfo, children: [
jsxRuntimeExports.jsx(
                  Avatar,
                  {
                    size: 100,
                    src: githubInfo.avatar,
                    icon: jsxRuntimeExports.jsx(GithubOutlined, {})
                  }
                ),
jsxRuntimeExports.jsxs("div", { children: [
jsxRuntimeExports.jsx(Title, { level: 4, className: styles$5.username, children: githubInfo.username }),
jsxRuntimeExports.jsx(Text, { className: styles$5.starCount, children: githubInfo.starCount })
                ] })
              ] }),
jsxRuntimeExports.jsx(Title, { level: 5, className: styles$5.bio, children: githubInfo.bio }),
jsxRuntimeExports.jsxs("div", { className: styles$5.features, children: [
jsxRuntimeExports.jsx(Title, { level: 5, children: "✨ 功能特性" }),
jsxRuntimeExports.jsx("ul", { className: styles$5.featureList, children: githubInfo.features.map((feature, index) => jsxRuntimeExports.jsx("li", { children: feature }, index)) })
              ] }),
jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  icon: jsxRuntimeExports.jsx(GithubOutlined, {}),
                  onClick: handleProfileClick,
                  className: styles$5.profileButton,
                  children: "查看 GitHub 主页"
                }
              )
            ] })
          }
        );
      });
      const dragger = "_dragger_1latm_12";
      const divider$1 = "_divider_1latm_58";
      const styles$4 = {
        "local-upload": "_local-upload_1latm_1",
        "upload-section": "_upload-section_1latm_6",
        dragger,
        "upload-icon": "_upload-icon_1latm_26",
        "upload-text": "_upload-text_1latm_30",
        "upload-hint": "_upload-hint_1latm_34",
        "file-list": "_file-list_1latm_39",
        "upload-stats": "_upload-stats_1latm_49",
        "size-text": "_size-text_1latm_55",
        divider: divider$1
      };
      const { Dragger } = Upload;
      const LocalUpload = forwardRef((props, ref) => {
        const { visible, close } = useVisible(
          {
            onReset() {
              setLoading(false);
              setFileList([]);
            }
          },
          ref
        );
        const [fileList, setFileList] = useState([]);
        const [loading, setLoading] = useState(false);
        const [concurrency, setConcurrency] = useState(1);
        const handleUpload = async () => {
          try {
            setLoading(true);
            const uploadPromises = fileList.map((file) => async () => {
              try {
                if (file.status === "done") {
                  return;
                }
                file.status = "uploading";
                const res2 = await uploadLocalSong(file);
                console.log("res", res2);
                file.status = "done";
                return res2;
              } catch (e) {
                file.status = "error";
                return null;
              } finally {
                setFileList((prev) => [...prev]);
              }
            });
            const res = await promiseLimit(uploadPromises, concurrency);
            console.log("res", res);
            msgSuccess("上传成功");
            const size2 = res.filter(Boolean).reduce((acc, file) => acc + file.size, 0);
            const info2 = {
              list: res.filter(Boolean),
              count: res.filter(Boolean).length,
              size: size2,
              sizeDesc: formatFileSize(size2),
              artist: res.filter(Boolean)?.[0].artist || ""
            };
            downloadJsonFile(info2, info2.artist + ".json");
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        const handleFilter = async () => {
          setFileList((prev) => prev.filter((file) => file.status === "error"));
        };
        const [getJsonLoading, setGetJsonLoading] = useState(false);
        const handleGetJson = async () => {
          try {
            setGetJsonLoading(true);
            const proArr = fileList.map(async (file) => {
              const ext = file.name.split(".").pop() || "mp3";
              const bitrate = 999e3;
              const name2 = file.name.replace("." + ext, "").replace(/\s/g, "").replace(/\./g, "_");
              const size2 = file.size;
              const md52 = await getFileMD5(file);
              const { album: album2, artist: artist2, artists, title: title2 } = await getAudioMetadata(file);
              return {
                size: size2,
                md5: md52,
                bitrate,
                ext,
                album: album2,
                artist: artist2,
                artists,
                name: title2
              };
            });
            const data = await Promise.all(proArr);
            console.log("data", data);
            downloadJsonFile(data, data[0].artist + ".json");
          } catch (e) {
            console.log("error", e);
          } finally {
            setGetJsonLoading(false);
          }
        };
        const columns = [
          {
            title: "文件名",
            dataIndex: "name",
            key: "name"
          },
          {
            title: "大小",
            dataIndex: "size",
            key: "size",
            render: (size2) => `${(size2 / 1024 / 1024).toFixed(2)} MB`
          },
          {
            title: "状态",
            dataIndex: "status",
            key: "status",
            render: (status, record) => {
              if (status === "done") {
                return jsxRuntimeExports.jsx(Progress, { percent: 100, size: "small", status: "success" });
              }
              if (status === "error") {
                return jsxRuntimeExports.jsx(Progress, { percent: 100, size: "small", status: "exception" });
              }
              if (status === "uploading") {
                return jsxRuntimeExports.jsx(
                  Progress,
                  {
                    percent: record.progress || 0,
                    size: "small",
                    status: "active"
                  }
                );
              }
              return jsxRuntimeExports.jsx(Progress, { percent: 0, size: "small" });
            }
          }
        ];
        return jsxRuntimeExports.jsx(
          Modal,
          {
            title: "云盘本地上传",
            open: visible,
            onCancel: close,
            onOk: handleUpload,
            confirmLoading: loading,
            centered: true,
            width: 1e3,
            children: jsxRuntimeExports.jsxs("div", { className: styles$4["local-upload"], children: [
jsxRuntimeExports.jsxs("div", { className: styles$4["upload-section"], children: [
jsxRuntimeExports.jsxs("div", { className: styles$4["concurrency-control"], children: [
jsxRuntimeExports.jsx("span", { children: "并发数量：" }),
jsxRuntimeExports.jsx(
                    Input,
                    {
                      type: "number",
                      min: 1,
                      max: 6,
                      value: concurrency,
                      onChange: (e) => setConcurrency(parseInt(e.target.value) || 1),
                      style: { width: 80 }
                    }
                  )
                ] }),
jsxRuntimeExports.jsxs(
                  Dragger,
                  {
                    className: styles$4.dragger,
                    multiple: true,
                    fileList,
                    beforeUpload: (file) => {
                      setFileList((prev) => [...prev, file]);
                      return false;
                    },
                    showUploadList: false,
                    accept: ".mp3,.flac,.wav,.m4a,.ogg",
                    children: [
jsxRuntimeExports.jsx("p", { className: styles$4["upload-icon"], children: jsxRuntimeExports.jsx(InboxOutlined, {}) }),
jsxRuntimeExports.jsx("p", { className: styles$4["upload-text"], children: "点击或拖拽文件到此区域上传" }),
jsxRuntimeExports.jsx("p", { className: styles$4["upload-hint"], children: "支持 mp3, flac, wav, m4a, ogg 格式的音频文件" })
                    ]
                  }
                )
              ] }),
jsxRuntimeExports.jsxs("div", { className: styles$4["file-list"], children: [
jsxRuntimeExports.jsx(
                  Table,
                  {
                    columns,
                    dataSource: fileList,
                    rowKey: (file) => file.uid || file.name,
                    scroll: { y: 300 },
                    pagination: false
                  }
                ),
jsxRuntimeExports.jsxs("div", { className: styles$4["upload-stats"], children: [
jsxRuntimeExports.jsxs("span", { children: [
                    "共 ",
                    fileList.length,
                    " 个文件"
                  ] }),
jsxRuntimeExports.jsx("span", { className: styles$4.divider, children: "|" }),
jsxRuntimeExports.jsxs("span", { className: styles$4["size-text"], children: [
                    "总大小：",
                    formatFileSize(
                      fileList.reduce((acc, file) => acc + file.size, 0)
                    )
                  ] }),
jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      size: "small",
                      onClick: () => setFileList([]),
                      style: { marginLeft: "auto" },
                      children: "清空列表"
                    }
                  ),
jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      size: "small",
                      onClick: handleFilter,
                      disabled: !fileList.some((file) => file.status !== "error"),
                      children: "失败过滤"
                    }
                  ),
jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      size: "small",
                      onClick: handleGetJson,
                      loading: getJsonLoading,
                      children: "直接获取JSON"
                    }
                  )
                ] })
              ] })
            ] })
          }
        );
      });
      var Module = (() => {
        var _scriptName = module.meta.url;
        return (function(moduleArg = {}) {
          var moduleRtn;
          var Module2 = moduleArg;
          var readyPromiseResolve, readyPromiseReject;
          var readyPromise = new Promise((resolve, reject) => {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
          });
          var moduleOverrides = Object.assign({}, Module2);
          var arguments_ = [];
          var thisProgram = "./this.program";
          var quit_ = (status, toThrow) => {
            throw toThrow;
          };
          var scriptDirectory = "";
          function locateFile(path) {
            if (Module2["locateFile"]) {
              return Module2["locateFile"](path, scriptDirectory);
            }
            return scriptDirectory + path;
          }
          var readAsync, readBinary;
          {
            {
              scriptDirectory = self.location.href;
            }
            if (_scriptName) {
              scriptDirectory = _scriptName;
            }
            if (scriptDirectory.startsWith("blob:")) {
              scriptDirectory = "";
            } else {
              scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            }
            {
              {
                readBinary = (url) => {
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", url, false);
                  xhr.responseType = "arraybuffer";
                  xhr.send(null);
                  return new Uint8Array(xhr.response);
                };
              }
              readAsync = (url) => fetch(url, { credentials: "same-origin" }).then((response) => {
                if (response.ok) {
                  return response.arrayBuffer();
                }
                return Promise.reject(new Error(response.status + " : " + response.url));
              });
            }
          }
          var out = Module2["print"] || console.log.bind(console);
          var err2 = Module2["printErr"] || console.error.bind(console);
          Object.assign(Module2, moduleOverrides);
          moduleOverrides = null;
          if (Module2["arguments"]) arguments_ = Module2["arguments"];
          if (Module2["thisProgram"]) thisProgram = Module2["thisProgram"];
          var wasmBinary2 = Module2["wasmBinary"];
          var wasmMemory;
          var ABORT = false;
          var EXITSTATUS;
          var HEAP8, HEAPU8, HEAP16, HEAP32, HEAPU32;
          function updateMemoryViews() {
            var b = wasmMemory.buffer;
            Module2["HEAP8"] = HEAP8 = new Int8Array(b);
            Module2["HEAP16"] = HEAP16 = new Int16Array(b);
            Module2["HEAPU8"] = HEAPU8 = new Uint8Array(b);
            Module2["HEAPU16"] = new Uint16Array(b);
            Module2["HEAP32"] = HEAP32 = new Int32Array(b);
            Module2["HEAPU32"] = HEAPU32 = new Uint32Array(b);
            Module2["HEAPF32"] = new Float32Array(b);
            Module2["HEAPF64"] = new Float64Array(b);
          }
          var __ATPRERUN__ = [];
          var __ATINIT__ = [];
          var __ATMAIN__ = [];
          var __ATPOSTRUN__ = [];
          function preRun() {
            if (Module2["preRun"]) {
              if (typeof Module2["preRun"] == "function") Module2["preRun"] = [Module2["preRun"]];
              while (Module2["preRun"].length) {
                addOnPreRun(Module2["preRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPRERUN__);
          }
          function initRuntime() {
            if (!Module2["noFSInit"] && !FS.initialized) FS.init();
            FS.ignorePermissions = false;
            callRuntimeCallbacks(__ATINIT__);
          }
          function preMain() {
            callRuntimeCallbacks(__ATMAIN__);
          }
          function postRun() {
            if (Module2["postRun"]) {
              if (typeof Module2["postRun"] == "function") Module2["postRun"] = [Module2["postRun"]];
              while (Module2["postRun"].length) {
                addOnPostRun(Module2["postRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
          }
          function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
          }
          function addOnInit(cb) {
            __ATINIT__.unshift(cb);
          }
          function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
          }
          var runDependencies = 0;
          var dependenciesFulfilled = null;
          function getUniqueRunDependency(id) {
            return id;
          }
          function addRunDependency(id) {
            runDependencies++;
            Module2["monitorRunDependencies"]?.(runDependencies);
          }
          function removeRunDependency(id) {
            runDependencies--;
            Module2["monitorRunDependencies"]?.(runDependencies);
            if (runDependencies == 0) {
              if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback();
              }
            }
          }
          function abort(what) {
            Module2["onAbort"]?.(what);
            what = "Aborted(" + what + ")";
            err2(what);
            ABORT = true;
            what += ". Build with -sASSERTIONS for more info.";
            var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            throw e;
          }
          var dataURIPrefix = "data:application/octet-stream;base64,";
          var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
          function findWasmBinary() {
            if (Module2["locateFile"]) {
              var f = "metaflac.wasm";
              if (!isDataURI(f)) {
                return locateFile(f);
              }
              return f;
            }
            return new URL("data:application/wasm;base64,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AAsLIAAL8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAALWgIBfwF+AkACf0EAIABFDQAaIACtIAGtfiIDpyICIAAgAXJBgIAESQ0AGkF/IAIgA0IgiKcbCyICEBsiAEUNACAAQQRrLQAAQQNxRQ0AIABBACACEB8aCyAAC34BAX8jAEFAaiICJAAgAkIANwM4IAJCADcDMCACQgA3AyggAkIANwMIIAJCADcDECACQgA3AxggAkIANwMgIAIgATYCICACIAIpAyA3AwAgACACEDYgACAAKAI0QQFqNgI0IAAoAiwhASAAKAIoIAJBQGskACABQQV0akEgawu7CgIFfw9+IwBB4ABrIgUkACAEQv///////z+DIQwgAiAEhUKAgICAgICAgIB/gyEKIAJC////////P4MiDUIgiCEOIARCMIinQf//AXEhBwJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAdB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiC0KAgICAgIDA//8AVCALQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQoMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhCiADIQEMAgsgASALQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhCkIAIQEM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BEAgASACIAAQkgEaCwt1AQF+IAAgASAEfiACIAN+fCADQiCIIgIgAUIgiCIEfnwgA0L/////D4MiAyABQv////8PgyIBfiIFQiCIIAMgBH58IgNCIIh8IAEgAn4gA0L/////D4N8IgFCIIh8NwMIIAAgBUL/////D4MgAUIghoQ3AwALawEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABIAIgA2siA0GAAiADQYACSSIBGxAfGiABRQRAA0AgACAFQYACECsgA0GAAmsiA0H/AUsNAAsLIAAgBSADECsLIAVBgAJqJAALIAECfyAAEBxBAWoiARAbIgJFBEBBAA8LIAIgACABEB4LUAEBfgJAIANBwABxBEAgASADQUBqrYYhAkIAIQEMAQsgA0UNACACIAOtIgSGIAFBwAAgA2utiIQhAiABIASGIQELIAAgATcDACAAIAI3AwgLyAkCBH8EfiMAQfAAayIGJAAgBEL///////////8AgyEJAkACQCABUCIFIAJC////////////AIMiCkKAgICAgIDA//8AfUKAgICAgIDAgIB/VCAKUBtFBEAgA0IAUiAJQoCAgICAgMD//wB9IgtCgICAgICAwICAf1YgC0KAgICAgIDAgIB/URsNAQsgBSAKQoCAgICAgMD//wBUIApCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhBCABIQMMAgsgA1AgCUKAgICAgIDA//8AVCAJQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQQMAgsgASAKQoCAgICAgMD//wCFhFAEQEKAgICAgIDg//8AIAIgASADhSACIASFQoCAgICAgICAgH+FhFAiBRshBEIAIAEgBRshAwwCCyADIAlCgICAgICAwP//AIWEUA0BIAEgCoRQBEAgAyAJhEIAUg0CIAEgA4MhAyACIASDIQQMAgsgAyAJhEIAUg0AIAEhAyACIQQMAQsgAyABIAEgA1QgCSAKViAJIApRGyIIGyEKIAQgAiAIGyIMQv///////z+DIQkgAiAEIAgbIgtCMIinQf//AXEhByAMQjCIp0H//wFxIgVFBEAgBkHgAGogCiAJIAogCSAJUCIFG3kgBUEGdK18pyIFQQ9rEC8gBikDaCEJIAYpA2AhCkEQIAVrIQULIAEgAyAIGyEDIAtC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fiMAQeAAayIBJABBnH8gACABQQAQXCEAIAEpAxghAiABQeAAaiQAQn8gAiAAGwvPAQEFfyAAKAIAIgJFBEBBAA8LAkAgAi0AACIBRQ0AAkADQCABQf8BcUE/Sw0BQgEgAa2GQoHMgIAQg1ANASAAIAJBAWoiAzYCACACLQABIQEgAyECIAENAAsMAQsgAiEDAkACQANAAkAgAUH/AXFBP0sNAEIBIAGthkKBzICAEINQDQAgAiEBDAILIAAgA0EBaiIENgIAIAMtAAEhASAEIQMgAQ0ACwwBCyADQQA6AAAgACgCAEEBaiEFCyAAIAU2AgAgAg8LIABBADYCAEEAC/MDAgJ+BX8jAEEgayIFJAAgAUL///////8/gyECAn4gAUIwiEL//wGDIgOnIgRBgfgAa0H9D00EQCACQgSGIABCPIiEIQIgBEGA+ABrrSEDAkAgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAAQoCAgICAgICACFINACACQgGDIAJ8IQILQgAgAiACQv////////8HViIEGyEAIAStIAN8DAELAkAgACAChFANACADQv//AVINACACQgSGIABCPIiEQoCAgICAgIAEhCEAQv8PDAELIARB/ocBSwRAQgAhAEL/DwwBC0GA+ABBgfgAIANQIgcbIgggBGsiBkHwAEoEQEIAIQBCAAwBCyAFQRBqIAAgAiACQoCAgICAgMAAhCAHGyICQYABIAZrEC8gBSAAIAIgBhBNIAUpAwhCBIYgBSkDACICQjyIhCEAAkAgBCAIRyAFKQMQIAUpAxiEQgBSca0gAkL//////////w+DhCICQoGAgICAgICACFoEQCAAQgF8IQAMAQsgAkKAgICAgICAgAhSDQAgAEIBgyAAfCEACyAAQoCAgICAgIAIhSAAIABC/////////wdWIgQbIQAgBK0LIQIgBUEgaiQAIAFCgICAgICAgICAf4MgAkI0hoQgAIS/C4gBAQR/IwBBEGsiByQAAkAgAUUEQCADRQ0BA0AgACACIAZBA3RqIAQgBRBDIAZBAWoiBiADRw0ACwwBCyABEBwhCCADRQ0AA0AgByACIAZBA3RqIgkpAgA3AwggB0EIaiABIAgQmwEEQCAAIAkgBCAFEEMLIAZBAWoiBiADRw0ACwsgB0EQaiQAC6kPAgV/D34jAEHQAmsiBSQAIARC////////P4MhCiACQv///////z+DIQsgAiAEhUKAgICAgICAgIB/gyEMIARCMIinQf//AXEhCAJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAhB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiDUKAgICAgIDA//8AVCANQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQwMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhDCADIQEMAgsgASANQoCAgICAgMD//wCFhFAEQCADIAJCgICAgICAwP//AIWEUARAQgAhAUKAgICAgIDg//8AIQwMAwsgDEKAgICAgIDA//8AhCEMQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAQgAhAQwCCyABIA2EUARAQoCAgICAgOD//wAgDCACIAOEUBshDEIAIQEMAgsgAiADhFAEQCAMQoCAgICAgMD//wCEIQxCACEBDAILIA1C////////P1gEQCAFQcACaiABIAsgASALIAtQIgYbeSAGQQZ0rXynIgZBD2sQL0EQIAZrIQYgBSkDyAIhCyAFKQPAAiEBCyACQv///////z9WDQAgBUGwAmogAyAKIAMgCiAKUCIHG3kgB0EGdK18pyIHQQ9rEC8gBiAHakEQayEGIAUpA7gCIQogBSkDsAIhAwsgBUGgAmogCkKAgICAgIDAAIQiEkIPhiADQjGIhCICQgBCgICAgLDmvIL1ACACfSIEQgAQLCAFQZACakIAIAUpA6gCfUIAIARCABAsIAVBgAJqIAUpA5gCQgGGIAUpA5ACQj+IhCIEQgAgAkIAECwgBUHwAWogBEIAQgAgBSkDiAJ9QgAQLCAFQeABaiAFKQP4AUIBhiAFKQPwAUI/iIQiBEIAIAJCABAsIAVB0AFqIARCAEIAIAUpA+gBfUIAECwgBUHAAWogBSkD2AFCAYYgBSkD0AFCP4iEIgRCACACQgAQLCAFQbABaiAEQgBCACAFKQPIAX1CABAsIAVBoAFqIAJCACAFKQO4AUIBhiAFKQOwAUI/iIRCAX0iAkIAECwgBUGQAWogA0IPhkIAIAJCABAsIAVB8ABqIAJCAEIAIAUpA6gBIAUpA6ABIg0gBSkDmAF8IgQgDVStfCAEQgFWrXx9QgAQLCAFQYABakIBIAR9QgAgAkIAECwgBiAJIAhraiEGAn8gBSkDcCITQgGGIg4gBSkDiAEiD0IBhiAFKQOAAUI/iIR8IhBC5+wAfSIUQiCIIgIgC0KAgICAgIDAAIQiFUIBhiIWQiCIIgR+IhEgAUIBhiINQiCIIgogECAUVq0gDiAQVq0gBSkDeEIBhiATQj+IhCAPQj+IfHx8QgF9IhNCIIgiEH58Ig4gEVStIA4gDiATQv////8PgyITIAFCP4giFyALQgGGhEL/////D4MiC358Ig5WrXwgBCAQfnwgBCATfiIRIAsgEH58Ig8gEVStQiCGIA9CIIiEfCAOIA4gD0IghnwiDlatfCAOIA4gFEL/////D4MiFCALfiIRIAIgCn58Ig8gEVStIA8gDyATIA1C/v///w+DIhF+fCIPVq18fCIOVq18IA4gBCAUfiIYIBAgEX58IgQgAiALfnwiCyAKIBN+fCIQQiCIIAsgEFatIAQgGFStIAQgC1atfHxCIIaEfCIEIA5UrXwgBCAPIAIgEX4iAiAKIBR+fCIKQiCIIAIgClatQiCGhHwiAiAPVK0gAiAQQiCGfCACVK18fCICIARUrXwiBEL/////////AFgEQCAWIBeEIRUgBUHQAGogAiAEIAMgEhAsIAFCMYYgBSkDWH0gBSkDUCIBQgBSrX0hCkIAIAF9IQsgBkH+/wBqDAELIAVB4ABqIARCP4YgAkIBiIQiAiAEQgGIIgQgAyASECwgAUIwhiAFKQNofSAFKQNgIg1CAFKtfSEKQgAgDX0hCyABIQ0gBkH//wBqCyIGQf//AU4EQCAMQoCAgICAgMD//wCEIQxCACEBDAELAn4gBkEASgRAIApCAYYgC0I/iIQhASAEQv///////z+DIAatQjCGhCEKIAtCAYYMAQsgBkGPf0wEQEIAIQEMAgsgBUFAayACIARBASAGaxBNIAVBMGogDSAVIAZB8ABqEC8gBUEgaiADIBIgBSkDQCICIAUpA0giChAsIAUpAzggBSkDKEIBhiAFKQMgIgFCP4iEfSAFKQMwIgQgAUIBhiINVK19IQEgBCANfQshBCAFQRBqIAMgEkIDQgAQLCAFIAMgEkIFQgAQLCAKIAIgAiADIAQgAkIBgyIEfCIDVCABIAMgBFStfCIBIBJWIAEgElEbrXwiAlatfCIEIAIgAiAEQoCAgICAgMD//wBUIAMgBSkDEFYgASAFKQMYIgRWIAEgBFEbca18IgJWrXwiBCACIARCgICAgICAwP//AFQgAyAFKQMAViABIAUpAwgiA1YgASADURtxrXwiASACVK18IAyEIQwLIAAgATcDACAAIAw3AwggBUHQAmokAAvAAQIBfwJ+QX8hAwJAIABCAFIgAUL///////////8AgyIEQoCAgICAgMD//wBWIARCgICAgICAwP//AFEbDQAgAkL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFJxDQAgACAEIAWEhFAEQEEADwsgASACg0IAWQRAIAEgAlIgASACU3ENASAAIAEgAoWEQgBSDwsgAEIAUiABIAJVIAEgAlEbDQAgACABIAKFhEIAUiEDCyADC5wLAQZ/IAAgAWohBQJAAkAgACgCBCICQQFxDQAgAkECcUUNASAAKAIAIgIgAWohAQJAAkACQCAAIAJrIgBBxKESKAIARwRAIAAoAgwhAyACQf8BTQRAIAMgACgCCCIERw0CQbChEkGwoRIoAgBBfiACQQN2d3E2AgAMBQsgACgCGCEGIAAgA0cEQCAAKAIIIgIgAzYCDCADIAI2AggMBAsgACgCFCIEBH8gAEEUagUgACgCECIERQ0DIABBEGoLIQIDQCACIQcgBCIDQRRqIQIgAygCFCIEDQAgA0EQaiECIAMoAhAiBA0ACyAHQQA2AgAMAwsgBSgCBCICQQNxQQNHDQNBuKESIAE2AgAgBSACQX5xNgIEIAAgAUEBcjYCBCAFIAE2AgAPCyAEIAM2AgwgAyAENgIIDAILQQAhAwsgBkUNAAJAIAAoAhwiAkECdEHgoxJqIgQoAgAgAEYEQCAEIAM2AgAgAw0BQbShEkG0oRIoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECAARhtqIAM2AgAgA0UNAQsgAyAGNgIYIAAoAhAiAgRAIAMgAjYCECACIAM2AhgLIAAoAhQiAkUNACADIAI2AhQgAiADNgIYCwJAAkACQAJAIAUoAgQiAkECcUUEQEHIoRIoAgAgBUYEQEHIoRIgADYCAEG8oRJBvKESKAIAIAFqIgE2AgAgACABQQFyNgIEIABBxKESKAIA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IAEQlQECQAJAAkACQCABIABBAUEAQQIgCEGQAWoQlgEEQCAIIAEoAgAoAgBBAnRB4JkLaigCADYChAEgCCAANgKAAUHoswIoAgBBvM0BIAhBgAFqEBgMAQsgARB0RQRAIAggASgCACgCAEECdEHgmQtqKAIANgJEIAggADYCQEHoswIoAgBBjM0BIAhBQGsQGAwBCyABIAhBoAFqENIBDQEgCCAANgJQQeizAigCAEGwgAEgCEHQAGoQGAsgCCAIKQOgATcDqAEMAQsgCCAIKQOgATcDqAEgARDOAUUEQCAIIAEoAgAoAgBBAnRB4JkLaigCADYCZCAIIAA2AmBB6LMCKAIAQYzNASAIQeAAahAYDAELIAgoArQBRQ0BIAggADYCcCAIIAgoArgBIgA2AnQgCCAAQQJ0QZCaC2ooAgA2AnhB6LMCKAIAQfLLASAIQfAAahAYCyAEQQE2AgAgARAzDAELQQEhByAEQQE2AgAgARAzIAIQowEaCyAIQcABaiQADAMLIAMoAgghBUEBQQgQICIBRQRAQfIRECMLIAEgAjYCACABIAIoAgg2AgQDQEEAIQMCQCABKAIEIgZFDQAgBigCCCIGRQ0AIAEgBjYCBEEBIQMLIAMNAAtBARA9IgNFBEBBmxoQIwsgAyAFNgIIIAEgAxBGDQEgGyAANgIAIAJB7CQgGxBAIAMQJyABEBYLQQAhBwwBCyABEBYgBEEBNgIACyAbQRBqJAAgBws8ACAAIAFBA3EiAUEBc2otAABBEHQgACABai0AAEEYdHIgACABQQJzai0AAEEIdHIgACABQQNzai0AAHILDwAgACABIAJBAEEAEG0aC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRBgALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiAC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QeAAaiAQEDEgA0HQAGogAykDYCADKQNoQn9C////////v///ABAiIANBQGsgAykDUCADKQNYQn9C////////v///ABAiIAMpA0ghFyADKQNADAELIBRB4gFrrCAXVQRAQZyOEkHEADYCACADQZABaiAQEDEgA0GAAWogAykDkAEgAykDmAFCAEKAgICAgIDAABAiIANB8ABqIAMpA4ABIAMpA4gBQgBCgICAgICAwAAQIiADKQN4IRcgAykDcAwBCyALBEAgC0EITARAIANBkAZqIAlBAnRqIgIoAgAhCANAIAhBCmwhCCALQQFqIgtBCUcNAAsgAiAINgIACyAJQQFqIQkLIBenIQsCQCAOQQlODQAgF0IRVQ0AIAsgDkgNACAXQglRBEAgA0HAAWogEBAxIANBsAFqIAMoApAGEE4gA0GgAWogAykDwAEgAykDyAEgAykDsAEgAykDuAEQIiADKQOoASEXIAMpA6ABDAILIBdCCFcEQCADQZACaiAQEDEgA0GAAmogAygCkAYQTiADQfABaiADKQOQAiADKQOYAiADKQOAAiADKQOIAhAiIANB4AFqQQAgC2tBAnRB4MUCaigCABAxIANB0AFqIAMpA/ABIAMpA/gBIAMpA+ABIAMpA+gBELIBIAMpA9gBIRcgAykD0AEMAgsgEyALQX1sakEbaiIEQR5MQQAgAygCkAYiAiAEdhsNACADQeACaiAQEDEgA0HQAmogAhBOIANBwAJqIAMpA+ACIAMpA+gCIAMpA9ACIAMpA9gCECIgA0GwAmogC0ECdEGYxQJqKAIAEDEgA0GgAmogAykDwAIgAykDyAIgAykDsAIgAykDuAIQIiADKQOoAiEXIAMpA6ACDAELA0AgA0GQBmogCSICQQFrIglBAnRqKAIARQ0AC0EAIQ4CQCALQQlvIgRFBEBBACEEDAELIARBCWogBCAXQgBTGyEFAkAgAkUEQEEAIQRBACECDAELQYCU69wDQQAgBWtBAnRB4MUCaigCACIMbSESQQAhCkEAIQhBACEEA0AgA0GQBmoiDSAIQQJ0aiIGIAogBigCACIJIAxuIgdqIgY2AgAgBEEBakH/D3EgBCAGRSAEIAhGcSIGGyEEIAtBCWsgCyAGGyELIBIgCSAHIAxsa2whCiAIQQFqIgggAkcNAAsgCkUNACACQQJ0IA1qIAo2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EElBAEwEQCABIAogAyAJEEkEQCABIQQMAgsgBUHwAGogASACQgBCABAiIAUpA3ghAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEHIAYEfiABBSAFQeAAaiABIApCAEKAgICAgIDAu8AAECIgBSkDaCIKQjCIp0H4AGshBiAFKQNgCyEEIAdFBEAgBUHQAGogAyAJQgBCgICAgICAwLvAABAiIAUpA1giCUIwiKdB+ABrIQcgBSkDUCEDCyAJQv///////z+DQoCAgICAgMAAhCELIApC////////P4NCgICAgICAwACEIQogBiAHSgRAA0ACfiAKIAt9IAMgBFatfSIJQgBZBEAgCSAEIAN9IgSEUARAIAVBIGogASACQgBCABAiIAUpAyghAiAFKQMgIQQMBQsgCUIBhiAEQj+IhAwBCyAKQgGGIARCP4iECyEKIARCAYYhBCAGQQFrIgYgB0oNAAsgByEGCwJAIAogC30gAyAEVq19IglCAFMEQCAKIQkMAQsgCSAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAECIgBSkDOCECIAUpAzAhBAwBCyAJQv///////z9YBEADQCAEQj+IIAZBAWshBiAEQgGGIQQgCUIBhoQiCUKAgICAgIDAAFQNAAsLIAhBgIACcSEHIAZBAEwEQCAFQUBrIAQgCUL///////8/gyAGQfgAaiAHcq1CMIaEQgBCgICAgICAwMM/ECIgBSkDSCECIAUpA0AhBAwBCyAJQv///////z+DIAYgB3KtQjCGhCECCyAAIAQ3AwAgACACNwMIIAVBgAFqJAALvwIBAX8jAEHQAGsiBCQAAkAgA0GAgAFOBEAgBEEgaiABIAJCAEKAgICAgICA//8AECIgBCkDKCECIAQpAyAhASADQf//AUkEQCADQf//AGshAwwCCyAEQRBqIAEgAkIAQoCAgICAgID//wAQIkH9/wIgAyADQf3/Ak8bQf7/AWshAyAEKQMYIQIgBCkDECEBDAELIANBgYB/Sg0AIARBQGsgASACQgBCgICAgICAgDkQIiAEKQNIIQIgBCkDQCEBIANB9IB+SwRAIANBjf8AaiEDDAELIARBMGogASACQgBCgICAgICAgDkQIkHogX0gAyADQeiBfU0bQZr+AWohAyAEKQM4IQIgBCkDMCEBCyAEIAEgAkIAIANB//8A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A0AgASACQQJ0aiIGKAIMIgwgDEEfdSIMcyAMayAEIAYoAgAiDCAMQR91IgxzIAxraiAGKAIEIgQgBEEfdSIEcyAEa2ogBigCCCIEIARBH3UiBHMgBGtqaiEEIAJBBGohAiAOQQRqIg4gA0cNAAsLIAdBA3EiBkUNAANAIAQgASACQQJ0aigCACIDIANBH3UiA3MgA2tqIQQgAkEBaiECIApBAWoiCiAGRw0ACwtBASAEIARBAU0brRCpASAFakEgSw0AIAAoAgQiAiALQQJ0aiIEKAJQIQwgAigC6AggB2shCiANKAIUIQ0gBCgCMCAHQQJ0aiEDQQAhBkEAIQQCQCAHQQ1PBEAgCkEATA0BIANBOGshDiADQTxrIQ8gA0FAaiEQIANBxABrIREgA0HIAGshEiADQcwAayETIANB0ABrIRUgA0HUAGshFiADQdgAayEXIANB3ABrIRggA0HgAGshGSADQeQAayEbIANB6ABrIRwgA0HsAGshHSADQfAAayEeIANB9ABrIR8gA0H4AGshICADQfwAayEiIANBgAFrISMgB0ENayEHA0BBACEEQQAhAgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAHDhQTEhEQDw4NDAsKCQgHBgUEAwIBABQLICMgBkECdGooAgAgASgCfGwhAgsgIiAGQQJ0aigCACABKAJ4bCACaiECCyAgIAZBAnRqKAIAIAEoAnRsIAJqIQILIB8gBkECdGooAgAgASgCcGwgAmohAgsgHiAGQQJ0aigCACABKAJsbCACaiECCyAdIAZBAnRqKAIAIAEoAmhsIAJqIQILIBwgBkECdGooAgAgASgCZGwgAmohAgsgGyAGQQJ0aigCACABKAJgbCACaiECCyAZIAZBAnRqKAIAIAEoAlxsIAJqIQILIBggBkECdGooAgAgASgCWGwgAmohAgsgFyAGQQJ0aigCACABKAJUbCACaiECCyAWIAZBAnRqKAIAIAEoAlBsIAJqIQILIBUgBkECdGooAgAgASgCTGwgAmohAgsgEyAGQQJ0aigCACABKAJIbCACaiECCyASIAZBAnRqKAIAIAEoAkRsIAJqIQILIBEgBkECdGooAgAgASgCQGwgAmohAgsgECAGQQJ0aigCACABKAI8bCACaiEECyAPIAZBAnRqKAIAIAEoAjhsIARqIQQLIA4gBkECdGooAgAgASgCNGwgBGohAgsgAiADIAZBAnRqIgRBNGsoAgAgASgCMGxqIARBMGsoAgAgASgCLGxqIARBLGsoAgAgASgCKGxqIARBKGsoAgAgASgCJGxqIARBJGsoAgAgASgCIGxqIARBIGsoAgAgASgCHGxqIARBHGsoAgAgASgCGGxqIARBGGsoAgAgASgCFGxqIARBFGsoAgAgASgCEGxqIARBEGsoAgAgASgCDGxqIARBDGsoAgAgASgCCGxqIARBCGsoAgAgASgCBGxqIARBBGsoAgAgASgCAGxqIQILIAMgBkECdCIEaiAEIAxqKAIAIAIgDXVqNgIAIAZBAWoiBiAKRw0ACwwBCyAHQQlPBEAgB0ELTwRAIAdBDEcEQCAKQQBMDQMgA0EEaygCACECIAEoAgAhBCABKAIEIQcgASgCCCEOIAEoAgwhDyABKAIQIRAgASgCFCERIAEoAhghEiABKAIcIRMgASgCICEVIAEoAiQhFiABKAIoIRcDQCADIAZBAnQiGGoiASAMIBhqKAIAIAFBKGsoAgAgFmwgAUEsaygCACAXbGogAUEkaygCACAVbGogAUEgaygCACATbGogAUEcaygCACASbGogAUEYaygCACARbGogAUEUaygCACAQbGogAUEQaygCACAPbGogAUEMaygCACAObGogAUEIaygCACAHbGogAiAEbGogDXVqIgI2AgAgBkEBaiIGIApHDQALDAMLIApBAEwNAiADQQRrKAIAIQIgASgCACEEIAEoAgQhByABKAIIIQ4gASgCDCEPIAEoAhAhECABKAIUIREgASgCGCESIAEoAhwhEyABKAIgIRUgASgCJCEWIAEoAighFyABKAIsIRgDQCADIAZBAnQiGWoiASAMIBlqKAIAIAFBLGsoAgAgF2wgAUEwaygCACAYbGogAUEoaygCACAWbGogAUEkaygCACAVbGogAUEgaygCACATbGogAUEcaygCACASbGogAUEYaygCACARbGogAUEUaygCACAQbGogAUEQaygCACAPbGogAUEMaygCACAObGogAUEIaygCACAHbGogAiAEbGogDXVqIgI2AgAgBkEBaiIGIApHDQALDAILIAdBCkcEQCAKQQBMDQIgA0EEaygCACECIAEoAgAhBCABKAIEIQcg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ATQCGH58IAZBGGs0AgAgATQCFH58IAZBFGs0AgAgATQCEH58IAZBEGs0AgAgATQCDH58IAZBDGs0AgAgATQCCH58IAZBCGs0AgAgATQCBH58IAZBBGs0AgAgATQCAH58ITALIAIgBEECdCIGaiAGIAxqKAIAIDAgMYenajYCACAEQQFqIgQgA0cNAAsMAQsgB0EJTwRAIAdBC08EQCAHQQxHBEAgA0EATA0DIAJBBGsoAgAhBiAErSEwIAE0AgAhMSABNAIEITIgATQCCCEzIAE0AgwhNCABNAIQITUgATQCFCE2IAE0AhghNyABNAIcITggATQCICE5IAE0AiQhOiABNAIoITtBACEEA0AgAiAEQQJ0IgdqIgEgByAMaigCACABQShrNAIAIDp+IAFBLGs0AgAgO358IAFBJGs0AgAgOX58IAFBIGs0AgAgOH58IAFBHGs0AgAgN358IAFBGGs0AgAgNn58IAFBFGs0AgAgNX58IAFBEGs0AgAgNH58IAFBDGs0AgAgM358IAFBCGs0AgAgMn58IAasIDF+fCAwh6dqIgY2AgAgBEEBaiIEIANHDQALDAMLIANBAEwNAiACQQRrKAIAIQYgBK0hMCABNAIAITEgATQCBCEyIAE0AgghMyABNAIMITQgATQCECE1IAE0AhQhNiABNAIYITcgATQCHCE4IAE0AiAhOSABNAIkITogATQCKCE7IAE0AiwhPEEAIQQDQCACIARBAnQiB2oiASAHIAxqKAIAIAFBLGs0AgAgO34gAUEwazQCACA8fnwgAUEoazQCACA6fnwgAUEkazQCACA5fnwgAUEgazQCACA4fnwgAUEcazQCACA3fnwgAUEYazQCACA2fnwgAUEUazQCACA1fnwgAUEQazQCACA0fnwgAUEMazQCACAzfnwgAUEIazQCACAyfnwgBqwgMX58IDCHp2oiBjYCACAEQQFqIgQgA0cNAAsMAgsgB0EKRwRAIANBAEwNAiACQQRrKAIAIQYgBK0hMCABNAIAITEgATQCBCEyIAE0AgghMyABNAIMITQgATQCECE1IAE0AhQhNiABNAIYITcgATQCHCE4IAE0AiAhOUEAIQQDQCACIARBAnQiB2oiASAHIAxqKAIAIAFBIGs0AgAgOH4gAUEkazQCACA5fnwgAUEcazQCACA3fnwgAUEYazQCACA2fnwgAUEUazQCACA1fnwgAUEQazQCACA0fnwgAUEMazQCACAzfnwgAUEIazQCACAyfnwgBqwgMX58IDCHp2oiBjYCACAEQQFqIgQgA0cNAAsMAgsgA0EATA0BIAJBBGsoAgAhBiAErSEwIAE0AgAhMSABNAIEITIgATQCCCEzIAE0AgwhNCABNAIQITUgATQCFCE2IAE0AhghNyABNAIcITggATQCICE5IAE0AiQhOkEAIQQDQCACIARBAnQiB2oiASAHIAxqKAIAIAFBJGs0AgAgOX4gAUEoazQCACA6fnwgAUEgazQCACA4fnwgAUEcazQCACA3fnwgAUEYazQCACA2fnwgAUEUazQCACA1fnwgAUEQazQCACA0fnwgAUEMazQCACAzfnwgAUEIazQCACAyfnwgBqwgMX58IDCHp2oiBjYCACAEQQFqIgQgA0cNAAsMAQsgB0EFTwRAIAdBB08EQCAHQQhHBEAgA0EATA0DIAJBBGsoAgAhBiAErSEwIAE0AgAhMSABNAIEITIgATQCCCEzIAE0AgwhNCABNAIQITUgATQCFCE2IAE0AhghN0EAIQQDQCACIARBAnQiB2oiASAHIAxqKAIAIAFBGGs0AgAgNn4gAUEcazQCACA3fnwgAUEUazQCACA1fnwgAUEQazQCACA0fnwgAUEMazQCACAzfnwgAUEIazQCACAyfnwgBqwgMX58IDCHp2oiBjYCACAEQQFqIgQgA0cNAAsMAwsgA0EATA0CIAJBBGsoAgAhBiAErSEwIAE0AgAhMSABNAIEITIgATQCCCEzIAE0AgwhNCABNAIQITUgATQCFCE2IAE0AhghNyABNAIcIThBACEEA0AgAiAEQQJ0IgdqIgEgByAMaigCACABQRxrNAIAIDd+IAFBIGs0AgAgOH58IAFBGGs0AgAgNn58IAFBFGs0AgAgNX58IAFBEGs0AgAgNH58IAFBDGs0AgAgM358IAFBCGs0AgAgMn58IAasIDF+fCAwh6dqIgY2AgAgBEEBaiIEIANHDQALDAILIAdBBkcEQCADQQBMDQIgAkEEaygCACEGIAStITAgATQCACExIAE0AgQhMiABNAIIITMgATQCDCE0IAE0AhAhNUEAIQQDQCACIARBAnQiB2oiASAHIAxqKAIAIAFBEGs0AgAgNH4gAUEUazQCACA1fnwgAUEMazQCACAzfnwgAUEIazQCACAyfnwgBqwgMX58IDCHp2oiBjYCACAEQQFqIgQgA0cNAAsMAgsgA0EATA0BIAJBBGsoAgAhBiAErSEwIAE0AgAhMSABNAIEITIgATQCCCEzIAE0AgwhNCABNAIQITUgATQCFCE2QQAhBANAIAIgBEECdCIHaiIBIAcgDGooAgAgAUEUazQCACA1fiABQRhrNAIAIDZ+fCABQRBrNAIAIDR+fCABQQxrNAIAIDN+fCABQQhrNAIAIDJ+fCAGrCAxfnwgMIenaiIGNgIAIARBAWoiBCADRw0ACwwBCyAHQQNPBEAgB0EERwRAIANBAEwNAiACQQRrKAIAIQYgBK0hMCABNAIAITEgATQCBCEyIAE0AgghM0EAIQoDQCACIApBAnQiBGoiASAEIAxqKAIAIAFBCGs0AgAgMn4gAUEMazQCACAzfnwgBqwgMX58IDCHp2oiBjYCACAKQQFqIgogA0cNAAsMAgsgA0EATA0BIAJBBGsoAgAhBiAErSEwIAE0AgAhMSABNAIEITIgATQCCCEzIAE0AgwhNEEAIQQDQCACIARBAnQiB2oiASAHIAxqKAIAIAFBDGs0AgAgM34gAUEQazQCACA0fnwgAUEIazQCACAyfnwgBqwgMX58IDCHp2oiBjYCACAEQQFqIgQgA0cNAAsMAQsgB0ECRwRAIANBAEwNASACQQRrKAIAIQYgBK0hMCABNAIAITFBACEKIANBAUcEQCADQf7///8HcSEEQQAhDgNAIAIgCkECdCIBaiABIAxqKAIAIAasIDF+IDCHp2oiBjYCACACIAFBBHIiAWogASAMaigCACAGrCAxfiAwh6dqIgY2AgAgCkECaiEKIA5BAmoiDiAERw0ACwsgA0EBcUUNASACIApBAnQiAWogASAMaigCACAGrCAxfiAwh6dqNgIADAELIANBAEwNACACQQRrKAIAIQYgBK0hMCABNAIAITEgATQCBCEyQQAhCiADQQFHBEAgA0H+////B3EhBEEAIQ4DQCACIApBAnQiAWoiByABIAxqKAIAIAasIDF+IAdBCGs0AgAgMn58IDCHp2oiBjYCACACIAFBBHIiAWoiByABIAxqKAIAIAasIDF+IAdBCGs0AgAgMn58IDCHp2oiBjYCACAKQQJqIQogDkECaiIOIARHDQALCyADQQFxRQ0AIAIgCkECdCIBaiICIAEgDGooAgAgBqwgMX4gAkEIazQCACAyfnwgMIenajYCAAsMAQsgAkEBNgJ0IAIoAnAgBCAHQQN0IgQQHhogACgCBCICIAtBAnRqKAJQIQYgDSgCFCEDIAIoAnAgBGohBCACKALoCCAHayIKQQBKBEAgBEEIayEMIARBEGshDSAEQRhrIQ4gBEEgayEPIARBKGshECAEQTBrIREgBEE4ayESIARBQGohEyAEQcgAayEVIARB0ABrIRYgBEHYAGshFyAEQeAAayEYIARB6ABrIRkgBEHwAGshGyAEQfgAayEcIARBgAFrIR0gBEGIAWshHiAEQZABayEfIARBmAFrISAgBEGgAWshIiAEQagBayEjIARBsAFrISUgBEG4AWshJiAEQcABayEnIARByAFrISggBEHQAWshKSAEQdgBayEqIARB4AFrISsgBEHoAWshLCAEQfABayEtIARB+AFrIS4gBEGAAmshLyADrSExQQAhAiAHQQFrIQMDQEIAITACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAw4gHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAgCyAvIAJBA3RqKQMAIAE0Anx+ITALIC4gAkEDdGopAwAgATQCeH4gMHwhMAsgLSACQQN0aikDACABNAJ0fiAwfCEwCyAsIAJBA3RqKQMAIAE0AnB+IDB8ITALICsgAkEDdGopAwAgATQCbH4gMHwhMAsgKiACQQN0aikDACABNAJofiAwfCEwCyApIAJBA3RqKQMAIAE0AmR+IDB8ITALICggAkEDdGopAwAgATQCYH4gMHwhMAsgJyACQQN0aikDACABNAJcfiAwfCEwCyAmIAJBA3RqKQMAIAE0Alh+IDB8ITALICUgAkEDdGopAwAgATQCVH4gMHwhMAsgIyACQQN0aikDACABNAJQfiAwfCEwCyAiIAJBA3RqKQMAIAE0Akx+IDB8ITALICAgAkEDdGopAwAgATQCSH4gMHwhMAsgHyACQQN0aikDACABNAJEfiAwfCEwCyAeIAJBA3RqKQMAIAE0AkB+IDB8ITALIB0gAkEDdGopAwAgATQCPH4gMHwhMAsgHCACQQN0aikD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AvAGQZXLACADQfAGahAXIAMgBTYC4AZBkCsgA0HgBmoQFyADIAIoAhQ2AtAGQfTKACADQdAGahAXIAMgBTYCwAZBkCsgA0HABmoQFyADIAIoAhg2ArAGQdrJACADQbAGahAXIAMgBTYCoAZBkCsgA0GgBmoQFyADIAIoAhw2ApAGQbvJACADQZAGahAXIAMgBTYCgAZBkCsgA0GABmoQFyADIAIoAiA2AvAFQYYwIANB8AVqEBcgAyAFNgLgBUGQKyADQeAFahAXIAMgAigCJDYC0AVB7DcgA0HQBWoQFyADIAU2AsAFQZArIANBwAVqEBcgAyACKAIoNgKwBUHlOCADQbAFahAXIAMgBTYCoAVBkCsgA0GgBWoQFyADIAIpAzA3A5AFQe8zIANBkAVqEBcgAyAFNgKABUGQKyADQYAFahAXDAELIAMgAigCEDYC8ARBlcsAIANB8ARqEBcgAyACKAIUNgLgBEH0ygAgA0HgBGoQFyADIAIoAhg2AtAEQdrJACADQdAEahAXIAMgAigCHDYCwARBu8kAIANBwARqEBcgAyACKAIgNgKwBEGGMCADQbAEahAXIAMgAigCJDYCoARB7DcgA0GgBGoQFyADIAIoAig2ApAEQeU4IANBkARqEBcgAyACKQMwNwOABEHvMyADQYAEahAXC0H6LkEAEBcgAyACLQA4NgLwA0GpCiADQfADahAXIAMgAi0AOTYC4ANBqQogA0HgA2oQFyADIAItADo2AtADQakKIANB0ANqEBcgAyACLQA7NgLAA0GpCiADQcADahAXIAMgAi0APDYCsANBqQogA0GwA2oQFyADIAItAD02AqADQakKIANBoANqEBcgAyACLQA+NgKQA0GpCiADQZADahAXIAMgAi0APzYCgANBqQogA0GAA2oQFyADIAItAEA2AvACQakKIANB8AJqEBcgAyACLQBBNgLgAkGpCiADQeACahAXIAMgAi0AQjYC0AJBqQogA0HQAmoQFyADIAItAEM2AsACQakKIANBwAJqEBcgAyACLQBENgKwAkGpCiADQbACahAXIAMgAi0ARTYCoAJBqQogA0GgAmoQFyADIAItAEY2ApACQakKIANBkAJqEBcgAyACLQBHNgKAAkGpCiADQYACahAXEIUBDAcLIAUEQCADIAU2AuAHQZArIANB4AdqEBcLQZ4v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ZXh0cmFjdCByZXNvbHV0aW9uIGFuZCBjb2xvciBpbmZvIGZyb20gZmlsZSwgdXNlciBtdXN0IHNldCBleHBsaWNpdGx5AHVuYWJsZSB0byBndWVzcyBNSU1FIHR5cGUgZnJvbSBmaWxlLCB1c2VyIG11c3Qgc2V0IGV4cGxpY2l0bHkAdW5hYmxlIHRvIGV4dHJhY3QgcmVzb2x1dGlvbiBhbmQgY29sb3IgaW5mbyBmcm9tIFVSTCwgdXNlciBtdXN0IHNldCBleHBsaWNpdGx5ADAxMjM0NTY3ODkuWHN4ACUwMngAMHgAdwB0ZXh0AEZMQUNfX2xlYWQtb3V0AFRSQUNLIG51bWJlciAyNTUgaXMgcmVzZXJ2ZWQgZm9yIHRoZSBsZWFkLW91dABvdXQgb2YgbWVtb3J5IGFsbG9jYXRpbmcgc3BhY2UgZm9yIGZpbGUgbmFtZXMgbGlzdABvdXQgb2YgbWVtb3J5IGFsbG9jYXRpbmcgc3BhY2UgZm9yIG9wdGlvbiBsaXN0AG5vLXV0ZjgtY29udmVydABpbnZhbGlkIHBpY3R1cmUgc3BlY2lmaWNhdGlvbjogY2FuJ3QgcGFyc2UgcmVzb2x1dGlvbi9jb2xvciBwYXJ0AHJlbW92ZS1hbGwtdGFncy1leGNlcHQAYWRkLXNlZWtwb2ludABpbGxlZ2FsIEZMQUNfX2xlYWQtb3V0IG9mZnNldABpbGxlZ2FsIEZMQUNfX2xlYWQtaW4gb2Zmc2V0AEZMQUNfX2xlYWQtb3V0IG9mZnNldCBkb2VzIG5vdCBtYXRjaCBlbmQtb2Ytc3RyZWFtIG9mZnNldABGTEFDX19sZWFkLW91dCBpcyBtaXNzaW5nIG9mZnNldABGTEFDX19sZWFkLWluIGlzIG1pc3Npbmcgb2Zmc2V0AGlsbGVnYWwgSU5ERVggb2Zmc2V0AGFwcGxpY2F0aW9uLWRhdGEtZm9ybWF0AG5vLWN1ZWQtc2Vla3BvaW50cwBDRC1EQSBDQVRBTE9HIG51bWJlciBtdXN0IGJlIDEzIGRlY2ltYWwgZGlnaXRzAGJpbmFyeS1oZWFkZXJsZXNzAHNob3ctYnBzAHNldC1icHMAc2hvdy1jaGFubmVscwBzZXQtY2hhbm5lbHMAb3V0IG9mIG1lbW9yeSBhbGxvY2F0aW5nIHNwYWNlIGZvciB0aXRsZSBnYWlucy9wZWFrcwBzaG93LWFsbC10YWdzAHJlbW92ZS1hbGwtdGFncwBzaG93LXRvdGFsLXNhbXBsZXMAc2V0LXRvdGFsLXNhbXBsZXMAaWxsZWdhbCBDRC1EQSBGTEFDX19sZWFkLWluIG9mZnNldCwgbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDU4OCBzYW1wbGVzAG11bHRpcGxlIEZMQUNfX2xlYWQtb3V0IGNvbW1hbmRzAGZvdW5kIG11bHRpcGxlIEZMQUdTIGNvbW1hbmRzAGZvdW5kIG11bHRpcGxlIENBVEFMT0cgY29tbWFuZHMAZm91bmQgbXVsdGlwbGUgSVNSQyBjb21tYW5kcwAlcyVzAG91dCBvZiBtZW1vcnkgYWxsb2NhdGluZyBpdGVyYXRvcgBtZW1vcnkgYWxsb2NhdGlvbiBlcnJvcgByZWFkIGVycm9yAHNwZWNpZmljYXRpb24gY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXIAZmllbGQgbmFtZSBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcgBmaWVsZCBjb250YWlucyBubyAnPScgY2hhcmFjdGVyAG91dCBvZiBtZW1vcnkgYWxsb2NhdGluZyByZWFkIGJ1ZmZlcgBpbml0aWFsaXppbmcgZGVjb2RlcgBibG9jay1udW1iZXIASU5ERVggaXMgbWlzc2luZyBpbmRleCBudW1iZXIASU5ERVggaXMgbWlzc2luZyBhbiBvZmZzZXQgYWZ0ZXIgdGhlIGluZGV4IG51bWJlcgBJTkRFWCBoYXMgaW52YWxpZCBpbmRleCBudW1iZXIAaWxsZWdhbCBGTEFDX19sZWFkLW91dCB0cmFjayBudW1iZXIARkxBQ19fbGVhZC1vdXQgaXMgbWlzc2luZyB0cmFjayBudW1iZXIAVFJBQ0sgaXMgbWlzc2luZyB0cmFjayBudW1iZXIAVFJBQ0sgaXMgbWlzc2luZyBhIHRyYWNrIHR5cGUgYWZ0ZXIgdGhlIHRyYWNrIG51bWJlcgBUUkFDSyBoYXMgaW52YWxpZCB0cmFjayBudW1iZXIAQ0FUQUxPRyBpcyBtaXNzaW5nIGNhdGFsb2cgbnVtYmVyAElTUkMgaXMgbWlzc2luZyBJU1JDIG51bWJlcgBpbnZhbGlkIElTUkMgbnVtYmVyAGhleGR1bXAAaGVscABleHBvcnQtY3Vlc2hlZXQtdG8AZXhwb3J0LXRhZ3MtdG8AZXhwb3J0LXBpY3R1cmUtdG8AaW52YWxpZCBwaWN0dXJlIHNwZWNpZmljYXRpb24AZ2FyYmxlZCBzcGVjaWZpY2F0aW9uAHZlcnNpb24Ab3V0IG9mIG1lbW9yeSBhbGxvY2F0aW5nIGNoYWluAHNjYW4tcmVwbGF5LWdhaW4AcmVtb3ZlLXJlcGxheS1nYWluAGFkZC1yZXBsYXktZ2FpbgBGTEFDX19sZWFkLWluAHNob3ctbWQ1c3VtAHNldC1tZDVzdW0AaW1wb3J0LWN1ZXNoZWV0LWZyb20AaW1wb3J0LXRhZ3MtZnJvbQBpbXBvcnQtcGljdHVyZS1mcm9tAHJlbW92ZS1hbGwASU5ERVggbnVtYmVycyBtdXN0IGJlIHNlcXVlbnRpYWwAQ0QtREEgVFJBQ0sgbnVtYmVycyBtdXN0IGJlIHNlcXVlbnRpYWwAb3V0IG9mIG1lbW9yeSBhbGxvY2F0aW5nIFZPUkJJU19DT01NRU5UIGJsb2NrAG91dCBvZiBtZW1vcnkgYWxsb2NhdGluZyBQQURESU5HIGJsb2NrACVzOiBFUlJPUjogRkxBQyBzdHJlYW0gY2FuIG9ubHkgaGF2ZSBvbmUgaWNvbiAodHlwZT0yKSBQSUNUVVJFIGJsb2NrACVzOiBFUlJPUjogRkxBQyBzdHJlYW0gY2FuIG9ubHkgaGF2ZSBvbmUgMzJ4MzIgc3RhbmRhcmQgaWNvbiAodHlwZT0xKSBQSUNUVVJFIGJsb2NrAG91dCBvZiBtZW1vcnkgYWxsb2NhdGluZyBTRUVLVEFCTEUgYmxvY2sAaW1hZ2UvcG5nAENBVEFMT0cgbnVtYmVyIGlzIHRvbyBsb25nAGxpbmUgdG9vIGxvbmcAb3V0IG9mIG1lbW9yeSBncm93aW5nIHN0cmluZwBzb3J0LXBhZGRpbmcAZG9udC11c2UtcGFkZGluZwBtZXJnZS1wYWRkaW5nAGFkZC1wYWRkaW5nAC5vZ2cAaW1hZ2UvanBlZwBzaG93LXRhZwByZW1vdmUtZmlyc3QtdGFnAHNldC10YWcAc2hvdy12ZW5kb3ItdGFnAHJlbW92ZS10YWcAaW1hZ2UvZ2lmADAxMjM0NTY3ODlBQkNERUZhYmNkZWYAJXM9JTEuOGYAc2hvdy1tYXgtYmxvY2tzaXplAHNldC1tYXgtYmxvY2tzaXplAHNob3ctbWluLWJsb2Nrc2l6ZQBzZXQtbWluLWJsb2Nrc2l6ZQBzaG93LW1heC1mcmFtZXNpemUAc2V0LW1heC1mcmFtZXNpemUAc2hvdy1taW4tZnJhbWVzaXplAHNldC1taW4tZnJhbWVzaXplAHJlbW92ZQBDRC1EQSBUUkFDSyBudW1iZXIgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDk5LCBpbmNsdXNpdmUAQ0QtREEgSU5ERVggbnVtYmVyIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA5OSwgaW5jbHVzaXZlAFRSQUNLIG51bWJlciBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMjU0LCBpbmNsdXNpdmUAdHJ1ZQBvdXQgb2YgbWVtb3J5IGFsbG9jYXRpbmcgdGFnIHZhbHVlAHNob3ctc2FtcGxlLXJhdGUAc2V0LXNhbXBsZS1yYXRlAENELURBIGN1ZXNoZWV0IG9ubHkgYWxsb3dlZCB3aXRoIDQ0LjFrSHogc2FtcGxlIHJhdGUAZmFsc2UAZXhjZXB0LWJsb2NrLXR5cGUAaW52YWxpZCBwaWN0dXJlIHR5cGUAcHJlc2VydmUtbW9kdGltZQBDRC1EQSBJTkRFWCBvZmZzZXRzIG11c3QgaW5jcmVhc2UgaW4gdGltZQBuby1maWxlbmFtZQB3aXRoLWZpbGVuYW1lAHNldC10YWctZnJvbS1maWxlAGVtcHR5IGZpbGUAZGVjb2RpbmcgZmlsZQBlcnJvciBvcGVuaW5nIHBpY3R1cmUgZmlsZQBlcnJvciByZWFkaW5nIHBpY3R1cmUgZmlsZQAlczogRVJST1I6IHdyaXRpbmcgRkxBQyBmaWxlAGZpbGUgaXMgdG9vIGxhcmdlAGFwcGVuZAB0aGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBUUkFDSyBjb21tYW5kAHdiAHJiACVzOiBFUlJPUjogYWRkaW5nIG5ldyBWT1JCSVNfQ09NTUVOVCBibG9jayB0byBtZXRhZGF0YQAlczogRVJST1I6IGFkZGluZyBuZXcgQ1VFU0hFRVQgYmxvY2sgdG8gbWV0YWRhdGEAJXM6IEVSUk9SOiBhZGRpbmcgbmV3IFBBRERJTkcgYmxvY2sgdG8gbWV0YWRhdGEAJXM6IEVSUk9SOiBhZGRpbmcgbmV3IFBJQ1RVUkUgYmxvY2sgdG8gbWV0YWRhdGEAJXM6IEVSUk9SOiBhZGRpbmcgbmV3IFNFRUtUQUJMRSBibG9jayB0byBtZXRhZGF0YQAlczogRVJST1I6IHJlYWRpbmcgbWV0YWRhdGEALm9nYQBHSUY4OWEAR0lGODdhAFBPU0lYAEZMQUdTIGNvbW1hbmQgbXVzdCBjb21lIGFmdGVyIFRSQUNLIGJ1dCBiZWZvcmUgSU5ERVgASVNSQyBjb21tYW5kIG11c3QgY29tZSBhZnRlciBUUkFDSyBidXQgYmVmb3JlIElOREVYAHByZXZpb3VzIFRSQUNLIG11c3Qgc3BlY2lmeSBhdCBsZWFzdCBvbmUgSU5ERVgATEVBRC1PVVQAVk9SQklTX0NPTU1FTlQAJXMvL1RSQU5TTElUAENIQVJTRVQAQ1VFU0hFRVQAUE9TSVhMWV9DT1JSRUNUAFJFUExBWUdBSU5fUkVGRVJFTkNFX0xPVURORVNTAEZMQUdTAEFVRElPAFNUUkVBTUlORk8AVU5LTk9XTgBBUFBMSUNBVElPTgBSRVBMQVlHQUlOX0FMQlVNX0dBSU4AUkVQTEFZR0FJTl9UUkFDS19HQUlOAFJFTQBMQ19BTEwAZm91bmQgSU5ERVggYmVmb3JlIGFueSBUUkFDSwBSRVBMQVlHQUlOX0FMQlVNX1BFQUsAUkVQTEFZR0FJTl9UUkFDS19QRUFLAFVTLUFTQ0lJAENBVEFMT0cAdHlwZSAxIGljb24gbXVzdCBiZSBhIDMyeDMyIHBpeGVsIFBORwBQQURESU5HAExBTkcAUElDVFVSRQBQUkUAU0VFS1RBQkxFAElOVkFMSUQAVU5ERUZJTkVEAElTUkMAIiVzIiBGTEFDACVzPSUrMi4yZiBkQgAlcz0lMi4xZiBkQgBEQVRBAD8ALS0+ACVsbHU7ACAgZGF0YSBjb250ZW50czoAJXM6ACAgZGF0YToAQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5AHV0ZjgAQy5VVEYtOABwcmV2aW91cyBUUkFDSyBtdXN0IHNwZWNpZnkgYXQgbGVhc3Qgb25lIElOREVYIDAxAGZpcnN0IElOREVYIG51bWJlciBvZiBhIFRSQUNLIG11c3QgYmUgMCBvciAxADEyMzQ1Njc4OTAAZmlyc3QgSU5ERVggb2YgZmlyc3QgVFJBQ0sgbXVzdCBoYXZlIGFuIG9mZnNldCBvZiAwMDowMDowMABUUkFDSyBudW1iZXIgbXVzdCBiZSBncmVhdGVyIHRoYW4gMAAwMTIzNDU2Nzg5LgAtACAodW5pbmRleGVkKQBpbGxlZ2FsIElOREVYIG9mZnNldCAobm90IG9mIHRoZSBmb3JtIE1NOlNTOkZGKQBpbGxlZ2FsIElOREVYIG9mZnNldCAoTU06U1M6RkYgZm9ybSBub3QgYWxsb3dlZCBpZiBzYW1wbGUgcmF0ZSBpcyBub3QgYSBtdWx0aXBsZSBvZiA3NSkAb3V0IG9mIG1lbW9yeSBkdXJpbmcgc3RyZHVwKCkAICAgIElOREVYICUwMnUgACAgdmVuZG9yIHN0cmluZzogACAgTUQ1IHNpZ25hdHVyZTogACAgICBjb21tZW50WyV1XTogACAgYXBwbGljYXRpb24gSUQ6IAAgICAgACAgICAgICAgICAgICAgICAgICAgICBTUEVDSUZJQ0FUSU9OIGlzIGEgc3RyaW5nIHdob3NlIHBhcnRzIGFyZSBzZXBhcmF0ZWQgYnkgfAoAICBzYW1wbGVfcmF0ZTogJXUgSHoKACVzOiBFUlJPUjogc2FtcGxlIHJhdGUgb2YgJXUgSHogZG9lcyBub3QgbWF0Y2ggcHJldmlvdXMgZmlsZXMnICV1IEh6CgAgICAgICAgICAgICAgICAgICAgICAgLS1zZXQtdGFnLWZyb20tZmlsZT0iQ1VFU0hFRVQ9aW1hZ2UuY3VlIikuICBEbyBub3QgdHJ5CgAlczogRVJST1I6IGFsbG9jYXRpbmcgbWVtb3J5CgAgICAgICAgICAgICAgICAgICAgICAgc3BlYywgb2YgdGhlIGZvcm0gIk5BTUU9VkFMVUUiLiAgSWYgdGhlcmUgaXMgY3VycmVudGx5CgAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBvZiB0aGUgZm9ybSBOQU1FPVZBTFVFLiAgU3BlY2lmeQoAICAgICAgICAgICAgICAgICAgICAgIGFsbCBzdWNoIHZhbHVlcy4gIEV4YW1wbGU6IC0tYWRkLXNlZWtwb2ludD0xMDB4CgBSRU0gRkxBQ19fbGVhZC1vdXQgJXUgJWxsdQoAUkVNIEZMQUNfX2xlYWQtaW4gJWxsdQoAICAgICAgICAgIG9mZnNldDogJWxsdQoAICB0b3RhbCBzYW1wbGVzOiAlbGx1CgAgIGxlYWQtaW46ICVsbHUKACUwMnU6JTAydTolMDJ1CgBFUlJPUiAoLS0lcyk6IGlsbGVnYWwgbGVuZ3RoICIlcyIsIGxlbmd0aCBtdXN0IGJlID49IDAgYW5kIDwgMl4ldQoAICAgIHBvaW50ICV1OiBzYW1wbGVfbnVtYmVyPSVsbHUsIHN0cmVhbV9vZmZzZXQ9JWxsdSwgZnJhbWVfc2FtcGxlcz0ldQoARVJST1I6IGNvdWxkbid0IHBhcnNlIHN1cHBsaWVkIG1ldGFkYXRhIGJsb2NrICMldQoATUVUQURBVEEgYmxvY2sgIyV1CgAlczogRVJST1I6IHJlc29sdXRpb24gKCV1KSBpcyBub3Qgc3VwcG9ydGVkLCBtdXN0IGJlIGJldHdlZW4gJXUgYW5kICV1CgBFUlJPUiAoLS0lcyk6IHZhbHVlIG11c3QgYmUgPj0gJXUgYW5kIDw9ICV1CgBFUlJPUiAoLS0lcyk6IHZhbHVlIG11c3QgYmUgPiAwIGFuZCA8PSAldQoAICBoZWlnaHQ6ICV1CgAgICAgICBudW1iZXIgb2YgaW5kZXggcG9pbnRzOiAldQoAICBzZWVrIHBvaW50czogJXUKACAgY29tbWVudHM6ICV1CgAgIGNoYW5uZWxzOiAldQoAICBudW1iZXIgb2YgdHJhY2tzOiAldQoAICAgICAgICAgIG51bWJlcjogJXUKACAgZGVwdGg6ICV1CgAgIGRhdGEgbGVuZ3RoOiAldQoAICBsZW5ndGg6ICV1CgAgIHdpZHRoOiAldQoAICBiaXRzLXBlci1zYW1wbGU6ICV1CgAgICAgLS1kYXRhLWZvcm1hdD1iaW5hcnl8YmluYXJ5LWhlYWRlcmxlc3N8dGV4dAoAICAgIC0tYXBwbGljYXRpb24tZGF0YS1mb3JtYXQ9aGV4ZHVtcHx0ZXh0CgBFUlJPUjogdW5hYmxlIHRvIGZpbmQgYSBtZXRhZGF0YSBibG9jayBpbiB0aGUgc3VwcGxpZWQgaW5wdXQKACAgICBBbiBvcHRpb25hbCBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBibG9jayBudW1iZXJzIHRvIGRpc3BsYXkuICBUaGUgZmlyc3QKACAgICAgICAgICAgICAgNzogTGVhZCBhcnRpc3QvbGVhZCBwZXJmb3JtZXIvc29sb2lzdAoALS1saXN0CgAgICAgICAgIyAgOiBhIHNwZWNpZmljIHNhbXBsZSBudW1iZXIgZm9yIGEgc2VlayBwb2ludAoAJXM6IG9wdGlvbiBgJWMlcycgZG9lc24ndCBhbGxvdyBhbiBhcmd1bWVudAoAJXM6IG9wdGlvbiBgLS0lcycgZG9lc24ndCBhbGxvdyBhbiBhcmd1bWVudAoAJXM6IG9wdGlvbiBgLVcgJXMnIGRvZXNuJ3QgYWxsb3cgYW4gYXJndW1lbnQKACVzOiBvcHRpb24gYCVzJyByZXF1aXJlcyBhbiBhcmd1bWVudAoALS1zZXQtdGFnPUZJRUxEICAgICAgIEFkZCBhIHRhZy4gIFRoZSBGSUVMRCBtdXN0IGNvbXBseSB3aXRoIHRoZSBWb3JiaXMgY29tbWVudAoAJXM6IEVSUk9SOiBGTEFDIGZpbGUgbXVzdCBoYXZlIHRvdGFsX3NhbXBsZXMgc2V0IGluIFNUUkVBTUlORk8gaW4gb3JkZXIgdG8gaW1wb3J0L2V4cG9ydCBjdWVzaGVldAoAICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVkIGJ5IGEgLS1ibG9jay1udW1iZXI9IyBvcHRpb24gdG8gc3BlY2lmeSB0aGUgZXhhY3QKACAgICAgICAgICAgICAgICAgICAgICBTaW5jZSB0aGlzIG9wZXJhdGlvbiByZXF1aXJlcyB0d28gcGFzc2VzLCBpdCBpcyBhbHdheXMKACVzOiBvcHRpb24gYCVzJyBpcyBhbWJpZ3VvdXMKACVzOiBvcHRpb24gYC1XICVzJyBpcyBhbWJpZ3VvdXMKACVzOiBFUlJPUiAoaW50ZXJuYWwpIHByZXBhcmluZyBzZWVrdGFibGUgd2l0aCBzZWVrcG9pbnRzCgAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIGJlIG9mIHRoZSBmb3JtIE5BTUU9VkFMVUUuICBNdWx0aS1saW5lIGNvbW1lbnRzCgAtLXByZXNlcnZlLW1vZHRpbWUgICAgUHJlc2VydmUgdGhlIG9yaWdpbmFsIG1vZGlmaWNhdGlvbiB0aW1lIGluIHNwaXRlIG9mIGVkaXRzCgAgICAgUmVtb3ZlIG9uZSBvciBtb3JlIG1ldGFkYXRhIGJsb2NrcyBmcm9tIHRoZSBtZXRhZGF0YS4gIFVubGVzcwoAICAgICAgICAgICAgIGFuZCBjb2xvciBkZXB0aCBpbiBiaXRzLXBlci1waXhlbC4gIElmIHRoZSBpbWFnZSBoYXMgaW5kZXhlZCBjb2xvcnMKACVzOiBFUlJPUjogcmVzb2x1dGlvbiBvZiAldSBicHMgZG9lcyBub3QgbWF0Y2ggcHJldmlvdXMgZmlsZXMnICV1IGJwcwoAICAgIGFsbCBtZXRhZGF0YSBibG9ja3MgYXJlIGxpc3RlZCBpbiB0ZXh0IGZvcm1hdC4gIFVzZSB0aGUgZm9sbG93aW5nIG9wdGlvbnMKAEVSUk9SOiB5b3UgbWF5IG5vdCBtaXggc2hvcnRoYW5kIGFuZCBtYWpvciBvcGVyYXRpb25zCgAgICAgVk9SQklTX0NPTU1FTlQuICBZb3UgbWF5IG5hcnJvdyBkb3duIHRoZSB0eXBlcyBvZiBBUFBMSUNBVElPTiBibG9ja3MKACAgICBleHBvcnRlZCB3aXRoIC0tbGlzdCAtLWRhdGEtZm9ybWF0PWJpbmFyeS4gVGhlIGluc2VydGlvbiBwb2ludCBpcwoAICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhIGJsb2NrIHRvIGV4dHJhY3QuICBOb3RlIHRoYXQgdGhlIGJsb2NrIG51bWJlciBpcwoAICAgICAgICAgICAgICAgICAgICAgIGJsb2NrIHdpbGwgYmUgZXhwb3J0ZWQgdW5sZXNzIC0tZXhwb3J0LXBpY3R1cmUtdG8gaXMKACAgICAgICAgICAgICBtZWFuIHRoYXQgRklMRSBpcyBhY3R1YWxseSBhIFVSTCB0byBhbiBpbWFnZSwgdGhvdWdoIHRoaXMgdXNlIGlzCgAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZGlhbiByZXByZXNlbnRhdGlvbiBvZiB0aGUgNC1ieXRlIElEIGlzCgAgICAgICAgICAgICAgICAgICAgICAgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLiAgU3BlY2lmeSAtLXJlbW92ZS1hbGwtdGFncwoAICAgICAgICAgICAgICAgICAgICAgIHRoZW4gc3RvcmVzIHRoZW0gaW4gdGhlIFZPUkJJU19DT01NRU5UIGJsb2NrLiAgVGhlIHRhZ3MKACAgbWF4aW11bSBmcmFtZXNpemU6ICV1IGJ5dGVzCgAgIG1pbmltdW0gZnJhbWVzaXplOiAldSBieXRlcwoAJXM6IEVSUk9SOiB0b28gbWFueSBmaWVsZCBuYW1lcwoAJXM6IEVSUk9SOiBjYW5ub3QgYWRkIHNlZWtwb2ludHMgYmVjYXVzZSBTVFJFQU1JTkZPIGJsb2NrIGRvZXMgbm90IHNwZWNpZnkgdG90YWxfc2FtcGxlcwoAICBtYXhpbXVtIGJsb2Nrc2l6ZTogJXUgc2FtcGxlcwoAICBtaW5pbXVtIGJsb2Nrc2l6ZTogJXUgc2FtcGxlcwoALS1zY2FuLXJlcGxheS1nYWluICAgIExpa2UgLS1hZGQtcmVwbGF5LWdhaW4sIGJ1dCBvbmx5IGFuYWx5emVzIHRoZSBmaWxlcwoAICAgIEluc2VydCBhIG1ldGFkYXRhIGJsb2NrIGZyb20gYSBmaWxlLiBUaGlzIG11c3QgYmUgYSBiaW5hcnkgYmxvY2sgYXMKACVzOiBFUlJPUjogZmlsZSAnJXMnIGZvciAnJXMnIHRhZyB2YWx1ZSBoYXMgZW1iZWRkZWQgTlVMcwoAICBjb2xvcnM6ICV1JXMKACAgVFJBQ0sgJTAydSAlcwoAbWV0YWZsYWMgLSBDb21tYW5kLWxpbmUgRkxBQyBtZXRhZGF0YSBlZGl0b3IgdmVyc2lvbiAlcwoAbWV0YWZsYWMgJXMKAENBVEFMT0cgJXMKAEZJTEUgJXMKACAgICBJU1JDICVzCgAlczogRVJST1I6IHdoaWxlIHBhcnNpbmcgY3Vlc2hlZXQgIiVzIiBvbiBsaW5lICV1OiAlcwoAICBpcyBsYXN0OiAlcwoAJXM6IFdBUk5JTkcgY3Vlc2hlZXQgIiVzIiBpcyBub3QgYXVkaW8gQ0QgY29tcGxpYW50OiAlcwoAICAgICAgcHJlLWVtcGhhc2lzOiAlcwoAJXM6IEVSUk9SOiBjYW4ndCBvcGVuIGV4cG9ydCBmaWxlICVzOiAlcwoAJXM6IEVSUk9SOiBjYW4ndCBvcGVuIGltcG9ydCBmaWxlICVzOiAlcwoAICBtZWRpYSBjYXRhbG9nIG51bWJlcjogJXMKACAgZGVzY3JpcHRpb246ICVzCgAlczogRVJST1I6IG5ldyBQSUNUVVJFIGJsb2NrIGZvciAiJXMiIGlzIGlsbGVnYWw6ICVzCgAlczogRVJST1I6IHdoaWxlIHJlYWRpbmcgZmlsZSAnJXMnIGZvciAnJXMnIHRhZyB2YWx1ZTogJXMKACAgTUlNRSB0eXBlOiAlcwoAICAgICAgdHlwZTogJXMKAEVSUk9SOiAlcwoAICBpcyBDRDogJXMKACAgICAgIElTUkM6ICVzCgAlczogRVJST1IgcGFyc2luZyBjdWVzaGVldCAiJXMiOiAlcwoAJXM6IEVSUk9SOiB3aGlsZSBwYXJzaW5nIHBpY3R1cmUgc3BlY2lmaWNhdGlvbiAiJXMiOiAlcwoARVJST1IgKC0tJXMpOiBtYWxmb3JtZWQgc2Vla3BvaW50IHNwZWNpZmljYXRpb24gIiVzIiwKICAgICAgICVzCgBFUlJPUiAoLS0lcyk6IG1hbGZvcm1lZCB2b3JiaXMgY29tbWVudCBmaWVsZCBuYW1lICIlcyIsCiAgICAgICAlcwoAJXM6IEVSUk9SOiBtYWxmb3JtZWQgdm9yYmlzIGNvbW1lbnQgZmllbGQgIiVzIiwKICAgICAgICVzCgBFUlJPUiAoLS0lcyk6IG1hbGZvcm1lZCB2b3JiaXMgY29tbWVudCBmaWVsZCAiJXMiLAogICAgICAgJXMKACAgICBJZiB0aGUgYXBwbGljYXRpb24gYmxvY2sgeW91IGFyZSBkaXNwbGF5aW5nIGNvbnRhaW5zIGJpbmFyeSBkYXRhIGJ1dCB5b3VyCgAgICAgICAgICAgICAgIDk6IENvbmR1Y3RvcgoAaW50ZXJuYWwgZXJyb3IKACAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IHZhbHVlcy4gIEZJTEVOQU1FIGlzIGp1c3Qgc2hvcnRoYW5kIGZvcgoALS1yZW1vdmUtYWxsLXRhZ3MtZXhjZXB0PU5BTUUxWz1OQU1FMls9Li4uXV0gUmVtb3ZlIGFsbCB0YWdzLCBleGNlcHQgdGhlIHZlbmRvcgoAVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vcgoAICAgICAgICAgICAgICAgICAgICAgIFBJQ1RVUkUgYmxvY2suICBFaXRoZXIgYSBmaWxlbmFtZSBmb3IgdGhlIHBpY3R1cmUgZmlsZSBvcgoAICAgICAgICAgICAgIDEyOiBMeXJpY2lzdC90ZXh0IHdyaXRlcgoAICAgICAgICAgICAgIDExOiBDb21wb3NlcgoAICAgICAgICAgICAgICA4OiBBcnRpc3QvcGVyZm9ybWVyCgAgICAgb2YgYSBibG9jayBiZWZvcmUgdGhlIGZpcnN0IFNUUkVBTUlORk8gYmxvY2suICBZb3UgbWF5IG5vdCAtLWFwcGVuZCBhbm90aGVyCgAgICAgYmVmb3JlIHRoZSBmaXJzdCBTVFJFQU1JTkZPIGJsb2NrLiAgWW91IG1heSBub3QgLS1hcHBlbmQgYW5vdGhlcgoAICAgICAgICAgICAgICAwOiBPdGhlcgoARVJST1IgKC0tJXMpOiB2YWx1ZSBtdXN0IGJlIGEgJXUtYml0IHVuc2lnbmVkIGludGVnZXIKACAgICAgICAgICAgICAgICAgICAgICB0YWJsZSwgYW5kIGFueSBkdXBsaWNhdGVzIHdpbGwgYmUgdHVybmVkIGludG8gcGxhY2Vob2xkZXIKACAgICAgICAjcyA6IGEgc2Vla3BvaW50IGV2ZXJ5ICMgc2Vjb25kczsgIyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgd2hvbGUgbnVtYmVyCgAgICAgICAgICAgICAgICAgICAgICAgbXVzdCBoYXZlIHRoZSBzYW1lIHJlc29sdXRpb24sIHNhbXBsZSByYXRlLCBhbmQgbnVtYmVyCgAgICAgY29udGVudHMgaW5zdGVhZCB1c2luZyAtLWFwcGxpY2F0aW9uLWRhdGEtZm9ybWF0PWhleGR1bXAKACAgICBUaGUgb3V0cHV0IGNhbiBiZSByZWFkIGluIHVzaW5nIGEgc3Vic2VxdWVudCBjYWxsIHRvCgAgICAgICAgICAgICAgdHlwZSBpbWFnZS9qcGVnIG9yIGltYWdlL3BuZy4gIFRoZSBNSU1FIHR5cGUgY2FuIGFsc28gYmUgLS0+IHRvCgAlczogRVJST1I6IGNhbm5vdCBwYXJzZSBjdWVzaGVldCB3aGVuIHNhbXBsZSByYXRlIGlzIHVua25vd24KAENvcHlyaWdodCAoQykgMjAwMS0yMDA5ICBKb3NoIENvYWxzb24KACAgICBiZSBhZGRlZCBhZnRlciB0aGUgZ2l2ZW4gYmxvY2sgbnVtYmVyLiAgVGhpcyBwcmV2ZW50cyB0aGUgaWxsZWdhbCBpbnNlcnRpb24KACAgICAgICAgICAgICAxODogSWxsdXN0cmF0aW9uCgBDb3B5cmlnaHQgKEMpIDIwMTEtMjAyMyAgWGlwaC5PcmcgRm91bmRhdGlvbgoAICAgICAgICAgICAgIDEzOiBSZWNvcmRpbmcgTG9jYXRpb24KAEVSUk9SICgtLSVzKTogbWlzc2luZyBzcGVjaWZpY2F0aW9uCgAlczogRVJST1I6IGVtcHR5IHBpY3R1cmUgc3BlY2lmaWNhdGlvbgoALS12ZXJzaW9uCgAgICAgICAgICAgICAgIDI6IE90aGVyIGZpbGUgaWNvbgoARVJST1I6IGNvdWxkbid0IHJlYWQgbWV0YWRhdGEgYmxvY2sgIyV1IGZyb20gc3RkaW4KACVzOiBFUlJPUjogY291bGRuJ3QgZ2V0IGJsb2NrIGZyb20gY2hhaW4KAC0tYWRkLXJlcGxheS1nYWluICAgICBDYWxjdWxhdGVzIHRoZSB0aXRsZSBhbmQgYWxidW0gZ2FpbnMvcGVha3Mgb2YgdGhlIGdpdmVuCgAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZWQgbGFzdCwgYWZ0ZXIgYWxsIG90aGVyIG9wZXJhdGlvbnMgaGF2ZSBiZWVuCgAgICAgICAgICAgICAgdGhlIE1JTUUtVFlQRSBpcyBpbWFnZS9qcGVnLCBpbWFnZS9wbmcsIG9yIGltYWdlL2dpZiwgeW91IGNhbgoAICAgICAgICAgICAgICAgICAgICAgIGJlIGNvbnZlcnRlZCB0byBVVEYtOCBmcm9tIHRoZSBsb2NhbCBjaGFyc2V0LiAgVGhpcyBjYW4KAEVSUk9SICgtLSVzKTogYmFkIE1ENSBzdW0KACVzOiBFUlJPUjogY291bGRuJ3QgZ2V0IGJsb2NrIGluIHJhdyBmb3JtCgAgICAgICAgICAgICAgICAgICAgICAgVW5sZXNzIC0tbm8tdXRmOC1jb252ZXJ0IGlzIHNwZWNpZmllZCwgdGhlIGNvbnRlbnRzIHdpbGwKACAgICBTcGVjaWZ5IHRoZSBpbnNlcnRpb24gcG9pbnQgKGRlZmF1bHRzIHRvIGxhc3QgYmxvY2spLiAgVGhlIG5ldyBibG9jayB3aWxsCgAtLXJlbW92ZS1hbGwKACAgICBnaXZlbiBibG9jayBudW1iZXIuICBUaGlzIHByZXZlbnRzIHRoZSBpbGxlZ2FsIGluc2VydGlvbiBvZiBhIGJsb2NrCgAlczogRVJST1I6IEZMQUMgZmlsZSBhbHJlYWR5IGhhcyBDVUVTSEVFVCBibG9jawoAJXM6IEVSUk9SOiBGTEFDIGZpbGUgaGFzIG5vIENVRVNIRUVUIGJsb2NrCgAlczogRVJST1I6IGNhbid0IG9wZW4gZmlsZSBvciBnZXQgU1RSRUFNSU5GTyBibG9jawoAJXM6IEVSUk9SOiBGTEFDIHN0cmVhbSBoYXMgbm8gU1RSRUFNSU5GTyBibG9jawoAV0FSTklORzogdW5kb2N1bWVudGVkIG9wdGlvbiAtLSVzIHNob3VsZCBiZSB1c2VkIHdpdGggY2F1dGlvbiwKICAgICAgICAgb25seSBmb3IgcmVwYWlyaW5nIGEgZGFtYWdlZCBTVFJFQU1JTkZPIGJsb2NrCgAlczogRVJST1I6IEZMQUMgZmlsZSBoYXMgbm8gUElDVFVSRSBibG9jawoALS1hZGQtc2Vla3BvaW50PXsjfFh8I3h8I3N9ICBBZGQgc2VlayBwb2ludHMgdG8gYSBTRUVLVEFCTEUgYmxvY2sKACAgICBtZXRhZmxhYyAtLWxpc3QgLS1kYXRhLWZvcm1hdD1iaW5hcnkgLS1ibG9jay1udW1iZXI9NiBmaWxlLmZsYWMgPiBibG9jawoAICAgIG1ldGFmbGFjIC0tYXBwZW5kIGFub3RoZXJmaWxlLmZsYWMgPCBibG9jawoAICAgIHRvIGV4cG9ydCB0aGUgYmxvY2ssIGFuZCB0aGVuIGltcG9ydCBpdCB3aXRoCgAgICAgICAgICAgICAgMTc6IEEgYnJpZ2h0IGNvbG91cmVkIGZpc2gKACAgICBZb3UgbWF5IHNwZWNpZnkgLS1kYXRhLWZvcm1hdD1iaW5hcnkgdG8gZHVtcCB0aGUgcmF3IGJpbmFyeSBmb3JtIG9mIGVhY2gKACAgICAgICAgICAgICBUaGUgZGVmYXVsdCBpcyAzIChmcm9udCBjb3ZlcikuICBUaGVyZSBtYXkgb25seSBiZSBvbmUgcGljdHVyZSBlYWNoCgBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZwoAICAgICAgICAgICAgICAgICAgICAgIG9yIHZpY2UgdmVyc2EuICBUaGlzIGlzIHVzZWZ1bCBmb3Igc2NyaXB0cywgYW5kIHNldHRpbmcKACAgICAgICAgICAgICAgICAgICAgICBvbmUgYWxyZWFkeSBleGlzdHMsIHBvaW50cyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBleGlzdGluZwoAICAgICAgICAgICAgICAgICAgICAgIGFyZSB0aGUgc2FtZSBhcyB0aG9zZSB1c2VkIGJ5IHZvcmJpc2dhaW4uICBFeGlzdGluZwoAJXM6IEVSUk9SOiBsaW5lIHRvbyBsb25nLCBhYm9ydGluZwoAICAgICAgICAgICBERVNDUklQVElPTiBpcyBvcHRpb25hbDsgdGhlIGRlZmF1bHQgaXMgYW4gZW1wdHkgc3RyaW5nCgAgICAgICAgICAgICAgMTQ6IER1cmluZyByZWNvcmRpbmcKAC0tc29ydC1wYWRkaW5nCgAtLW1lcmdlLXBhZGRpbmcKAGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mCgAgICAgbWV0YWRhdGEgYmxvY2suIFNwZWNpZnkgLS1kYXRhLWZvcm1hdD1iaW5hcnktaGVhZGVybGVzcyB0byBvbWl0IG91dHB1dCBvZgoAICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZyBTRUVLVEFCTEUgd2lsbCBiZSB0aGUgdW5pcXVlLWlmaWVkIHVuaW9uIG9mCgAgICAgICAgICAgICAgICAgICAgICAgYW5kL29yIC0tbm8tdXRmOC1jb252ZXJ0IGJlZm9yZSAtLWltcG9ydC10YWdzLWZyb20gaWYKACAgICAgICAgICAgRklMRSBpcyB0aGUgcGF0aCB0byB0aGUgcGljdHVyZSBmaWxlIHRvIGJlIGltcG9ydGVkLCBvciB0aGUgVVJMIGlmCgAgICAgICAgICAgIFRoZSBuZXh0IHBhcnQgc3BlY2lmaWVzIHRoZSByZXNvbHV0aW9uIGFuZCBjb2xvciBpbmZvcm1hdGlvbi4gIElmCgAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gU0VFS1RBQkxFIGJsb2NrIGV4aXN0cywgb25lIHdpbGwgYmUgY3JlYXRlZC4gIElmCgAlczogJWYgJWYgJWYgJWYKACAgICAgICAgICAgICAgICAgICAgICB0byBhdm9pZCByZXdyaXRpbmcgdGhlIGVudGlyZSBmaWxlIGlmIHRoZSBtZXRhZGF0YSBzaXplCgAtLXJlbW92ZQoAJXM6IEVSUk9SOiBjb252ZXJ0aW5nIGZpbGUgJyVzJyBjb250ZW50cyB0byBVVEYtOCBmb3IgdGFnIHZhbHVlCgAlczogRVJST1I6IGNhbid0IG9wZW4gZmlsZSAnJXMnIGZvciAnJXMnIHRhZyB2YWx1ZQoARVJST1IgKC0tJXMpOiBpbnZhbGlkIHNhbXBsZSByYXRlCgAgICAgZmlsZSB0byBhbm90aGVyIHdpdGggdGhpcyBvcHRpb24uIEZvciBleGFtcGxlIHVzZQoAbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UKACAgICAgICAgICAgICAxNjogTW92aWUvdmlkZW8gc2NyZWVuIGNhcHR1cmUKACVzOiBFUlJPUjogbWVtb3J5IGFsbG9jYXRpb24gZmFpbHVyZQoAICAgICAgICAgICAgIDE5OiBCYW5kL2FydGlzdCBsb2dvdHlwZQoAICAgICAgICAgICAgIDIwOiBQdWJsaXNoZXIvU3R1ZGlvIGxvZ290eXBlCgAgICAgICAgbWV0YWZsYWMgY2Fubm90IGJlIHVzZWQgYXMgYSBwaXBlCgBFUlJPUjogY2FuJ3QgYWRkIGFub3RoZXIgdm9yYmlzIGNvbW1lbnQgYmxvY2sgdG8gZmlsZSwgaXQgYWxyZWFkeSBoYXMgb25lCgAgICAgU1RSRUFNSU5GTyBibG9jay4gSXQgaXMgcG9zc2libGUgdG8gY29weSBhIG1ldGFkYXRhIGJsb2NrIGZyb20gb25lCgAtLWV4cG9ydC10YWdzLXRvPUZJTEUgRXhwb3J0IHRhZ3MgdG8gYSBmaWxlLiAgVXNlICctJyBmb3Igc3Rkb3V0LiAgRWFjaCBsaW5lCgAtLWltcG9ydC10YWdzLWZyb209RklMRSBJbXBvcnQgdGFncyBmcm9tIGEgZmlsZS4gIFVzZSAnLScgZm9yIHN0ZGluLiAgRWFjaCBsaW5lCgBFUlJPUjogeW91IG1heSBvbmx5IHNwZWNpZnkgb25lIG1ham9yIG9wZXJhdGlvbiBhdCBhIHRpbWUKACAgICBJbnNlcnQgYSBtZXRhZGF0YSBibG9jayBmcm9tIGEgZmlsZS4gIFRoZSBpbnB1dCBmaWxlIG11c3QgYmUgaW4gdGhlIHNhbWUKAEVSUk9SICgtLSVzKTogbWlzc2luZyBmaWxlbmFtZQoALS1zZXQtdGFnLWZyb20tZmlsZT1GSUVMRCAgIExpa2UgLS1zZXQtdGFnLCBleGNlcHQgdGhlIFZBTFVFIGlzIGEgZmlsZW5hbWUKACVzOiBFUlJPUjogZW1wdHkgZXhwb3J0IGZpbGUgbmFtZQoAJXM6IEVSUk9SOiBlbXB0eSBpbXBvcnQgZmlsZSBuYW1lCgAtLW5vLWZpbGVuYW1lICAgICAgICAgRG8gbm90IHByZWZpeCBlYWNoIG91dHB1dCBsaW5lIHdpdGggdGhlIEZMQUMgZmlsZSBuYW1lCgAtLXdpdGgtZmlsZW5hbWUgICAgICAgUHJlZml4IGVhY2ggb3V0cHV0IGxpbmUgd2l0aCB0aGUgRkxBQyBmaWxlIG5hbWUKAEVSUk9SOiBjb3VsZG4ndCBhZGQgc3VwcGxpZWQgbWV0YWRhdGEgYmxvY2sgIyV1IHRvIGZpbGUKAEVSUk9SOiBjYW4ndCBhZGQgc3RyZWFtaW5mbyB0byBmaWxlCgAlczogRVJST1I6IHdyaXRpbmcgUElDVFVSRSBkYXRhIHRvIGZpbGUKACVzOiBFUlJPUiAoLS1hZGQtc2Vla3BvaW50KSBkZWNvZGluZyBmaWxlCgAgICAgICAgICAgICAgICAgICAgICAgUmVwbGF5R2FpbiB0YWdzIHdpbGwgYmUgcmVwbGFjZWQuICBJZiBvbmx5IG9uZSBGTEFDIGZpbGUKACAgICAgICAgICAgICAgICAgICAgICBuZWNlc3NhcnkuICBJZiBGSUxFIGlzICctJyAoc3RkaW4pLCBvbmx5IG9uZSBGTEFDIGZpbGUKAC0tZG9udC11c2UtcGFkZGluZyAgICBCeSBkZWZhdWx0IG1ldGFmbGFjIHRyaWVzIHRvIHVzZSBwYWRkaW5nIHdoZXJlIHBvc3NpYmxlCgAtLWV4cG9ydC1jdWVzaGVldC10bz1GSUxFICBFeHBvcnQgQ1VFU0hFRVQgYmxvY2sgdG8gYSBjdWVzaGVldCBmaWxlLCBzdWl0YWJsZQoAICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcnMuICBTb21lIHBhcnRzIG1heSBiZSBsZWZ0IGVtcHR5IHRvIGludm9rZQoAICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMuICBVc2UgdGhpcyBvcHRpb24gdG8gdGVsbCBtZXRhZmxhYyB0byBub3QgdGFrZQoAICAgIGRlZmluZWQgd2l0aCAtLWJsb2NrLW51bWJlcj0jLiAgVGhlIG5ldyBibG9jayB3aWxsIGJlIGFkZGVkIGFmdGVyIHRoZQoAICAgICAgICAgICAgICAgICAgICAgIGFkZGVkIGZvciBlYWNoIGluZGV4IHBvaW50IGluIHRoZSBjdWVzaGVldCB0byB0aGUKACAgICAgICAgICAgTUlNRS1UWVBFIGlzIG9wdGlvbmFsOyBpZiBsZWZ0IGJsYW5rLCBpdCB3aWxsIGJlIGRldGVjdGVkIGZyb20gdGhlCgAgICAgUmVtb3ZlIGFsbCBtZXRhZGF0YSBibG9ja3MgKGV4Y2VwdCB0aGUgU1RSRUFNSU5GTyBibG9jaykgZnJvbSB0aGUKACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjB4WFhYWFhYWFgiLiAgRm9yIHRoZSBleGFtcGxlICJhYmNkIiBhYm92ZSB0aGUKAE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUKACAgICAgICAgICAgICAgICAgICAgICBwb2ludHMuICBZb3UgbWF5IHVzZSBtYW55IC0tYWRkLXNlZWtwb2ludCBvcHRpb25zOyB0aGUKACAgICAgICAgICAgICAgICAgICAgICBhIG1vcmUgY29tcGxldGUgc3BlY2lmaWNhdGlvbiBmb3JtIGNhbiBiZSB1c2VkLiAgVGhlCgAlczogRVJST1I6IGZpbGUgJyVzJyBmb3IgJyVzJyB0YWcgdmFsdWUgaXMgdG9vIGxhcmdlCgAgICAgICAgICAgICAgIDU6IExlYWZsZXQgcGFnZQoARVJST1IgKC0tJXMpOiBtYXkgYmUgc3BlY2lmaWVkIG9ubHkgb25jZQoAJXM6IEVSUk9SICgtLWFkZC1zZWVrcG9pbnQpIGNyZWF0aW5nIHRoZSBkZWNvZGVyIGluc3RhbmNlCgAgICAgICAgICAgICAgMTU6IER1cmluZyBwZXJmb3JtYW5jZQoAICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyBhbmQgdGhlIHRhZyBuYW1lcyBzcGVjaWZpZWQuIFRhZyBuYW1lcyBtdXN0IGJlCgAgICAgICAgICAgICAgICAgICAgICAgT25seSBvbmUgRkxBQyBmaWxlIG1heSBiZSBzcGVjaWZpZWQuICBBIHNlZWtwb2ludCB3aWxsIGJlCgAgICAgbWV0YWRhdGEuICBVbmxlc3MgLS1kb250LXVzZS1wYWRkaW5nIGlzIHNwZWNpZmllZCwgdGhlIGJsb2NrcyB3aWxsIGJlCgBFUlJPUjogbW9yZSB0aGFuIG9uZSBibG9jayBudW1iZXIgc3BlY2lmaWVkIHdpdGggLS1hcHBlbmQKACVzOiBFUlJPUjogc2FtcGxlIHJhdGUgb2YgJXUgSHogaXMgbm90IHN1cHBvcnRlZAoAICAgIEFuIG9wdGlvbmFsIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGJsb2NrIHR5cGVzIHRvIGJlIGluY2x1ZGVkIG9yIGlnbm9yZWQKACAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgYW5kIHdyaXR0ZW4gdG8gZGlzay4gIEFsbCBGTEFDIGZpbGVzIHNwZWNpZmllZAoAICAgICAgICAgICAgICAgICAgICAgIC0tYWRkLXNlZWtwb2ludD0zLjVzIHdpbGwgYWRkIDEwMCBldmVubHkgc3BhY2VkCgBFUlJPUjogY2FuJ3QgYWRkIHNlZWt0YWJsZSB0byBmaWxlLCBwbGVhc2UgdXNlIC0tYWRkLXNlZWtwb2ludCBpbnN0ZWFkCgAlczogRVJST1I6IEZMQUMgZmlsZSBoYXMgbm8gUElDVFVSRSBibG9jayBhdCBibG9jayAjJWQKACVzJTA4WDogJTAyWCAlMDJYICUwMlggJTAyWCAlMDJYICUwMlggJTAyWCAlMDJYICUwMlggJTAyWCAlMDJYICUwMlggJTAyWCAlMDJYICUwMlggJTAyWCAlYyVjJWMlYyVjJWMlYyVjJWMlYyVjJWMlYyVjJWMlYwoAJXM6IG9wdGlvbiByZXF1aXJlcyBhbiBhcmd1bWVudCAtLSAlYwoAJXM6IGlsbGVnYWwgb3B0aW9uIC0tICVjCgAlczogaW52YWxpZCBvcHRpb24gLS0gJWMKACAgICAtLWRhdGEtZm9ybWF0PXRleHQsIHlvdSBjYW4gZGlzcGxheSBhIGhleCBkdW1wIG9mIHRoZSBhcHBsaWNhdGlvbiBkYXRhCgAgICAgICAgICAgICAgMTA6IEJhbmQvT3JjaGVzdHJhCgAgICAgTW92ZSBhbGwgUEFERElORyBibG9ja3MgdG8gdGhlIGVuZCBvZiB0aGUgbWV0YWRhdGEgYW5kIG1lcmdlIHRoZW0gaW50byBhCgAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvcHRpb24gaGFzIG5vIGVmZmVjdCBmb3Igb3B0aW9ucyBleHBvcnRpbmcgdG8gYQoALS1pbXBvcnQtcGljdHVyZS1mcm9tPUZJTEVOQU1FfFNQRUNJRklDQVRJT04gIEltcG9ydCBhIHBpY3R1cmUgYW5kIHN0b3JlIGl0IGluIGEKACAgICAgICAgaW5kZXhbJXVdCgAgICAgdHJhY2tbJXVdCgAgICAgLS1leGNlcHQtYmxvY2stdHlwZT10eXBlWyx0eXBlWy4uLl1dCgAgICAgLS1ibG9jay10eXBlPXR5cGVbLHR5cGVbLi4uXV0KACAgICAtLWJsb2NrLW51bWJlcj0jWywjWy4uLl1dCgAgIG1ldGFmbGFjIFtvcHRpb25zXSBbb3BlcmF0aW9uc10gRkxBQ2ZpbGUgW0ZMQUNmaWxlIC4uLl0KACAgICBwb2ludCAldTogUExBQ0VIT0xERVIKACAgICAgICAgICAgICAgICAgICAgICB0byBzdG9yZSBiaW5hcnkgZGF0YSBpbiB0YWcgZmllbGRzISAgVXNlIEFQUExJQ0FUSU9OCgAgICAgICAgICAgICAgICAgICAgICAgT25seSBvbmUgRkxBQyBmaWxlIG1heSBiZSBzcGVjaWZpZWQuICBUaGUgZmlyc3QgUElDVFVSRQoAICAgIEZMQUdTIFBSRQoAICAgICAgICAgICAgIGZpbGUuICBGb3IgYmVzdCBjb21wYXRpYmlsaXR5IHdpdGggcGxheWVycywgdXNlIHBpY3R1cmVzIHdpdGggTUlNRQoAICAgICAgICAgW1RZUEVdfFtNSU1FLVRZUEVdfFtERVNDUklQVElPTl18W1dJRFRIeEhFSUdIVHhERVBUSFsvQ09MT1JTXV18RklMRQoAICAgICAgICAgICAgIE1JTUUgdHlwZSBpcyAtLT4KAD09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQoAICAgICAgICAgICAgICAgICAgICAgIFRoZSBvdmVyYWxsIGxlbmd0aCBvZiB0aGUgbmV3IGJsb2NrIHdpbGwgYmUgNCArIGxlbmd0aDsKAEVSUk9SOiB5b3UgbXVzdCBzcGVjaWZ5IGF0IGxlYXN0IG9uZSBGTEFDIGZpbGU7CgAgICAgZGlzcGxheWVkIGFzIGZvbGxvd3M6CgBPcHRpb25zOgoATWFqb3Igb3BlcmF0aW9uczoKAFNob3J0aGFuZCBvcGVyYXRpb25zOgoAICAgICAgICAgICAgICAgICAgICAgICJ8fHx8RklMRU5BTUUiLiAgVGhlIGZvcm1hdCBvZiBTUEVDSUZJQ0FUSU9OIGlzOgoAICAgIHRvIGNoYW5nZSB0aGlzIGJlaGF2aW9yOgoAICAgICAgICAgICBUWVBFIGlzIG9wdGlvbmFsOyBpdCBpcyBhIG51bWJlciBmcm9tIG9uZSBvZjoKAFVzYWdlOgoAJXM6IEVSUk9SOiBjb252ZXJ0aW5nIGNvbW1lbnQgJyVzJyB0byBVVEYtOAoAJXM6IEVSUk9SOiBmaWxlICclcycgZm9yICclcycgdGFnIHZhbHVlIGlzIG5vdCB2YWxpZCBVVEYtOAoAJXM6IEVSUk9SOiB0YWcgdmFsdWUgZm9yICclcycgaXMgbm90IHZhbGlkIFVURi04CgAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleGFkZWNpbWFsIGVxdWl2YWxhbGVudCBpcyAweDYxNjI2MzY0CgAlczogRVJST1I6ICMgb2YgY2hhbm5lbHMgKCV1KSBpcyBub3Qgc3VwcG9ydGVkLCBtdXN0IGJlIDEgb3IgMgoAYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlciB2ZXJzaW9uIDIKACAgICAgICAjeCA6ICMgZXZlbmx5IHNwYWNlZCBzZWVrcG9pbnRzLCB0aGUgZmlyc3QgYmVpbmcgYXQgc2FtcGxlIDAKACAgICAgICAgICAgICAgICAgICAgICAyODgsIDMwMi40LCAzNTIuOCwgMzg0LCA0NDgsIDUxMiwgNTc2LCBvciA2MDQuOCBrSHouCgAgICAgICAgICAgICAgICAgICAgICAgLS1uby11dGY4LWNvbnZlcnQgaWYgbmVjZXNzYXJ5LgoAICAgICAgICAgICAgICAgICAgICAgIGFkdmFudGFnZSBvZiBwYWRkaW5nIHRoaXMgd2F5LgoAICAgICAgICAgICAgICAgICAgICAgIGZvciB1c2UgYnkgQ0QgYXV0aG9yaW5nIHNvZnR3YXJlLiAgVXNlICctJyBmb3Igc3Rkb3V0LgoALS1leHBvcnQtcGljdHVyZS10bz1GSUxFICBFeHBvcnQgUElDVFVSRSBibG9jayB0byBhIGZpbGUuICBVc2UgJy0nIGZvciBzdGRvdXQuCgAgICAgICAgICAgICAgICAgICAgICAgdGhlIG9uZSBzaG93biBieSAtLWxpc3QuCgAgICAgZm9ybWF0IGFzIGdlbmVyYXRlZCB3aXRoIC0tbGlzdC4KACAgICAgICAgICAgICAgICAgICAgICBibG9ja3MgZm9yIHRoYXQuCgAgICAgICAgICAgdGhlIHJlc3VsdCBpcyB0aGUgbG9naWNhbCBBTkQgb2YgYm90aCBhcmd1bWVudHMuCgAKVGhlIG1ldGFkYXRhIHRvIGJlIHdyaXR0ZW4gZG9lcyBub3QgY29uZm9ybSB0byB0aGUgRkxBQyBtZXRhZGF0YQpzcGVjaWZpY2F0aW9ucy4KAApUaGUgRkxBQyBmaWxlIGRvZXMgbm90IGhhdmUgd3JpdGUgcGVybWlzc2lvbnMuCgBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLgoAICAgIE1lcmdlIGFkamFjZW50IFBBRERJTkcgYmxvY2tzIGludG8gc2luZ2xlIGJsb2Nrcy4KACAgICBtZXRhZGF0YSBibG9jayBoZWFkZXJzLCBpbmNsdWRpbmcgdGhlIGlkIG9mIEFQUExJQ0FUSU9OIG1ldGFkYXRhIGJsb2Nrcy4KACAgICAgICAgICAgICAgICAgICAgICByYXRoZXIgdGhhbiB3cml0aW5nIHRoZW0gdG8gdGFncy4KAC0tcmVtb3ZlLXJlcGxheS1nYWluICBSZW1vdmVzIHRoZSBSZXBsYXlHYWluIHRhZ3MuCgBVc2UgbWV0YWZsYWMgdG8gbGlzdCwgYWRkLCByZW1vdmUsIG9yIGVkaXQgbWV0YWRhdGEgaW4gb25lIG9yIG1vcmUgRkxBQyBmaWxlcy4KACAgICAgICAgICAgICAgICAgICAgICBzZWVrcG9pbnRzIGFuZCBhIHNlZWtwb2ludCBldmVyeSAzLjUgc2Vjb25kcy4KACAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgYW4gPSBjaGFyYWN0ZXIuCgAgICAgICAgICAgICAgICAgICAgICAgdGhlIGV4dHJhIDQgYnl0ZXMgaXMgZm9yIHRoZSBtZXRhZGF0YSBibG9jayBoZWFkZXIuCgAgICAgU2hvdyB0aGUgbWV0YWZsYWMgdmVyc2lvbiBudW1iZXIuCgAgICAgICAgICAgICAgICAgICAgICAgZmlsZSwgbGlrZSAtLWV4cG9ydC10YWdzLXRvLgoAb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uCgAtLWltcG9ydC1jdWVzaGVldC1mcm9tPUZJTEUgIEltcG9ydCBhIGN1ZXNoZWV0IGZyb20gYSBmaWxlLiAgVXNlICctJyBmb3Igc3RkaW4uCgAKVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHdyaXRpbmcgRkxBQyBmaWxlOyBtb3N0IHByb2JhYmx5IHRoZSBkaXNrIGlzCmZ1bGwuCgAgICAgc2luZ2xlIGJsb2NrLgoALS1zaG93LXZlbmRvci10YWcgICAgIFNob3cgdGhlIHZlbmRvciBzdHJpbmcgZnJvbSB0aGUgVk9SQklTX0NPTU1FTlQgYmxvY2suCgAtLXNob3ctY2hhbm5lbHMgICAgICAgU2hvdyB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctdG90YWwtc2FtcGxlcyAgU2hvdyB0aGUgdG90YWwgIyBvZiBzYW1wbGVzIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctbWF4LWJsb2Nrc2l6ZSAgU2hvdyB0aGUgbWF4aW11bSBibG9jayBzaXplIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctbWluLWJsb2Nrc2l6ZSAgU2hvdyB0aGUgbWluaW11bSBibG9jayBzaXplIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctbWF4LWZyYW1lc2l6ZSAgU2hvdyB0aGUgbWF4aW11bSBmcmFtZSBzaXplIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctbWluLWZyYW1lc2l6ZSAgU2hvdyB0aGUgbWluaW11bSBmcmFtZSBzaXplIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctc2FtcGxlLXJhdGUgICAgU2hvdyB0aGUgc2FtcGxlIHJhdGUgZnJvbSB0aGUgU1RSRUFNSU5GTyBibG9jay4KAC0tc2hvdy1tZDVzdW0gICAgICAgICBTaG93IHRoZSBNRDUgc2lnbmF0dXJlIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctYnBzICAgICAgICAgICAgU2hvdyB0aGUgIyBvZiBiaXRzIHBlciBzYW1wbGUgZnJvbSB0aGUgU1RSRUFNSU5GTyBibG9jay4KACAgICBZb3UgbWF5IG5vdCByZW1vdmUgdGhlIFNUUkVBTUlORk8gYmxvY2suCgAgICAgU1RSRUFNSU5GTyBibG9jay4KACAgICAgICAgICAgICAgICAgICAgICB0YWdzIGluIHNpdHVhdGlvbnMgd2hlcmUgdGhlIGxvY2FsZSBpcyB3cm9uZy4KAC0tcmVtb3ZlLWFsbC10YWdzICAgICBSZW1vdmUgYWxsIHRhZ3MsIGxlYXZpbmcgb25seSB0aGUgdmVuZG9yIHN0cmluZy4KACAgICAtLWRvbnQtdXNlLXBhZGRpbmcgaXMgc3BlY2lmaWVkLCB0aGUgYmxvY2tzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBwYWRkaW5nLgoAICAgIHJlcGxhY2VkIHdpdGggcGFkZGluZy4KACAgICAgICAgICAgICAgICAgICAgICBiZSB1c2VkIHRvIHN0b3JlIGEgY3Vlc2hlZXQgaW4gYSB0YWcgKGUuZy4KACAgICAgICAgICAgICAgICAgICAgICB3aG9zZSBjb250ZW50cyB3aWxsIGJlIHJlYWQgdmVyYmF0aW0gdG8gc2V0IHRoZSB0YWcgdmFsdWUuCgAgICAgd2l0aCB0aGlzIG9wdGlvbi4gIFVzZSBvbmx5IG9uZSBvZiAtLWJsb2NrLXR5cGUgb3IgLS1leGNlcHQtYmxvY2stdHlwZS4KACAgICAgICAgICAgICAgICAgICAgICBPbmx5IG9uZSBGTEFDIGZpbGUgbWF5IGJlIHNwZWNpZmllZCBvbiB0aGUgY29tbWFuZCBsaW5lLgoAWW91IG1heSBwZXJmb3JtIG9uZSBtYWpvciBvcGVyYXRpb24sIG9yIG1hbnkgc2hvcnRoYW5kIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgoAICAgICAgICAgICAgICAgICAgICAgIGlzIGdpdmVuLCB0aGUgYWxidW0gYW5kIHRpdGxlIGdhaW5zIHdpbGwgYmUgdGhlIHNhbWUuCgAgICAgICAgICAgICAgdXN1YWxseSBsZWF2ZSB0aGlzIGVtcHR5IGFuZCB0aGV5IGNhbiBiZSBkZXRlY3RlZCBmcm9tIHRoZSBmaWxlLgoAICAgICAgICAgICAgIG9mIHR5cGUgMSBhbmQgMiBpbiBhIGZpbGUuCgAKVGhlcmUgd2FzIGFuIGVycm9yIHJlbW92aW5nIHRoZSB0ZW1wb3JhcnkgRkxBQyBmaWxlLgoAClRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSByZWFkaW5nIHRoZSBGTEFDIGZpbGUuCgAKVGhlIGZpbGUgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgRkxBQyBmaWxlLgoAClRoZSBGTEFDIGZpbGUgY291bGQgbm90IGJlIG9wZW5lZC4gIE1vc3QgbGlrZWx5IHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0Cm9yIGlzIG5vdCByZWFkYWJsZS4KACAgICBTZWUgLS1saXN0IGFib3ZlIGZvciB1c2FnZS4KACAgICBCeSBkZWZhdWx0IGEgaHVtYW4tcmVhZGFibGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF0YSBpcyBkaXNwbGF5ZWQuCgAgICAgICAgICAgICAgICAgICAgICAgbm8gdGFnIGJsb2NrLCBvbmUgd2lsbCBiZSBjcmVhdGVkLgoAICAgICAgICAgICAgIHlvdSBzaG91bGQgYWxzbyBzcGVjaWZ5IHRoZSBudW1iZXIgb2YgY29sb3JzIHVzZWQuCgAgICAgICAgICAgICAgICAgICAgICAgU0VFS1RBQkxFIHVubGVzcyAtLW5vLWN1ZWQtc2Vla3BvaW50cyBpcyBzcGVjaWZpZWQuCgAgICAgICAgICAgICAgICAgICAgICAgbWF5IGJlIHNwZWNpZmllZC4KACAgICAgICAgICAgICBkaXNjb3VyYWdlZC4KADUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0EuCgAgICAgYmxvY2ssIHRoZSBTVFJFQU1JTkZPIGJsb2NrLCBpcyBibG9jayAwLgoALS1zaG93LWFsbC10YWdzICAgICAgIFNob3cgYWxsIHRhZ3MuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIC0tZXhwb3J0LXRhZ3MtdG89LS4KAC0tYWRkLXBhZGRpbmc9bGVuZ3RoICBBZGQgYSBwYWRkaW5nIGJsb2NrIG9mIHRoZSBnaXZlbiBsZW5ndGggKGluIGJ5dGVzKS4KACAgICAgICAgICAgICAgICAgICAgICAodGhlIGRlZmF1bHQgaWYgbW9yZSB0aGFuIG9uZSBGTEFDIGZpbGUgaXMgc3BlY2lmaWVkKS4KAC0tcmVtb3ZlLXRhZz1OQU1FICAgICBSZW1vdmUgYWxsIHRhZ3Mgd2hvc2UgZmllbGQgbmFtZSBpcyAnTkFNRScuCgAtLXJlbW92ZS1maXJzdC10YWc9TkFNRSAgUmVtb3ZlIGZpcnN0IHRhZyB3aG9zZSBmaWVsZCBuYW1lIGlzICdOQU1FJy4KAC0tc2hvdy10YWc9TkFNRSAgICAgICBTaG93IGFsbCB0YWdzIHdoZXJlIHRoZSBmaWVsZCBuYW1lIG1hdGNoZXMgJ05BTUUnLgoAICAgICAgICBBUFBMSUNBVElPTjoweFhYWFhYWFhYICBUaGUgQVBQTElDQVRJT04gYmxvY2socykgd2hvc2UgaGV4YWRlY2ltYWwgYmlnLQoAICAgICAgICBBUFBMSUNBVElPTjphYmNkICAgICAgICBUaGUgQVBQTElDQVRJT04gYmxvY2socykgd2hvc2UgdGV4dHVhbCByZXByZS0KACAgICBMaXN0IHRoZSBjb250ZW50cyBvZiBvbmUgb3IgbW9yZSBtZXRhZGF0YSBibG9ja3MgdG8gc3Rkb3V0LiAgQnkgZGVmYXVsdCwKAC0tbm8tdXRmOC1jb252ZXJ0ICAgICBEbyBub3QgY29udmVydCB0YWdzIGZyb20gVVRGLTggdG8gbG9jYWwgY2hhcnNldCwKACAgICAgICAgICAgICBPdGhlcndpc2UsIHlvdSBtdXN0IHNwZWNpZnkgdGhlIHdpZHRoIGluIHBpeGVscywgaGVpZ2h0IGluIHBpeGVscywKACAgICAgICAgICAgICAgICAgICAgICBGTEFDIGZpbGVzIGFzIGlmIGFsbCB0aGUgZmlsZXMgd2VyZSBwYXJ0IG9mIG9uZSBhbGJ1bSwKAFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLAoAICAgICAgICAgICAgICAgICAgICAgIG9mIGNoYW5uZWxzLiAgT25seSBtb25vIGFuZCBzdGVyZW8gZmlsZXMgYXJlIGFsbG93ZWQsCgAgICAgTk9URTogaWYgYm90aCAtLWJsb2NrLW51bWJlciBhbmQgLS1bZXhjZXB0LV1ibG9jay10eXBlIGFyZSBzcGVjaWZpZWQsCgAgICAgVGhlIHZhbGlkIGJsb2NrIHR5cGVzIGFyZTogU1RSRUFNSU5GTywgUEFERElORywgQVBQTElDQVRJT04sIFNFRUtUQUJMRSwKACAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIHNhbXBsZSByYXRlIG11c3QgYmUgOCwgMTEuMDI1LCAxMiwgMTYsIDE4LjksCgAgICAgICAgICAgICAgICAgICAgICAgODguMiwgOTYsIDExMiwgMTI4LCAxNDQsIDE1MS4yLCAxNzYuNCwgMTkyLCAyMjQsIDI1NiwKACAgICAgICAgICAgICAgICAgICAgICAyMi4wNSwgMjQsIDI4LCAzMiwgMzYsIDM3LjgsIDQ0LjEsIDQ4LCA1NiwgNjQsIDcyLCA3NS42LAoAd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgSW5jLiwKACAgICAgICAgICAgICAgMTogMzJ4MzIgcGl4ZWxzICdmaWxlIGljb24nIChQTkcgb25seSkKACVzOiBFUlJPUjogIyBjaGFubmVscyAoJXUpIGRvZXMgbm90IG1hdGNoIHByZXZpb3VzIGZpbGVzJyAoJXUpCgAgICAgICAgICAgICAgIDM6IENvdmVyIChmcm9udCkKACVzOiBFUlJPUiAoLS1hZGQtc2Vla3BvaW50KSBkZWNvZGluZyBmaWxlICgldTolcykKACAgICAgIG51bWJlcjogJXUgKCVzKQoAICB0eXBlOiAldSAoJXMpCgAlczogRVJST1I6IGR1cmluZyBhbmFseXNpcyAoJXMpCgAlczogRVJST1I6IHdyaXRpbmcgdGFncyAoJXMpCgAlczogRVJST1IgKC0tYWRkLXNlZWtwb2ludCkgZGVjb2RpbmcgZmlsZSAoJXMpCgAlczogRVJST1IgKC0tYWRkLXNlZWtwb2ludCkgaW5pdGlhbGl6aW5nIHRoZSBkZWNvZGVyIGluc3RhbmNlICglcykKACAgICAgICAgICAgICAgNDogQ292ZXIgKGJhY2spCgAgICAgICAgICAgICAgICAgICAgICAgKHRoZSBkZWZhdWx0IGlmIG9ubHkgb25lIEZMQUMgZmlsZSBpcyBzcGVjaWZpZWQpCgAgICAgICAgWCAgOiBhIHBsYWNlaG9sZGVyIHBvaW50IChhbHdheXMgZ29lcyBhdCB0aGUgZW5kIG9mIHRoZSBTRUVLVEFCTEUpCgAgICAgICAgICAgICAgIDY6IE1lZGlhIChlLmcuIGxhYmVsIHNpZGUgb2YgQ0QpCgAlczogdW5yZWNvZ25pemVkIG9wdGlvbiBgJWMlcycKACVzOiB1bnJlY29nbml6ZWQgb3B0aW9uIGAtLSVzJwoAVGhpcyBpcyB0aGUgc2hvcnQgaGVscDsgZm9yIGZ1bGwgaGVscCB1c2UgJ21ldGFmbGFjIC0taGVscCcKAEVSUk9SOiB5b3UgbWF5IG9ubHkgc3BlY2lmeSBvbmUgRkxBQyBmaWxlIHdoZW4gdXNpbmcgJy0tZXhwb3J0LWN1ZXNoZWV0LXRvJwoARVJST1I6IHlvdSBtYXkgb25seSBzcGVjaWZ5IG9uZSBGTEFDIGZpbGUgd2hlbiB1c2luZyAnLS1leHBvcnQtcGljdHVyZS10bycKAEVSUk9SOiB5b3UgbWF5IG9ubHkgc3BlY2lmeSBvbmUgRkxBQyBmaWxlIHdoZW4gdXNpbmcgJy0taW1wb3J0LWN1ZXNoZWV0LWZyb20nCgBFUlJPUjogeW91IG1heSBub3Qgc3BlY2lmeSBib3RoICctLWJsb2NrLXR5cGUnIGFuZCAnLS1leGNlcHQtYmxvY2stdHlwZScKAEVSUk9SOiB5b3UgbWF5IG9ubHkgc3BlY2lmeSBvbmUgRkxBQyBmaWxlIHdoZW4gdXNpbmcgJy0taW1wb3J0LXRhZ3MtZnJvbT0tJwoAICAgIC0tYmxvY2stbnVtYmVyPSMKAEVSUk9SICgtLSVzKTogaWxsZWdhbCBhcHBsaWNhdGlvbiBkYXRhIGZvcm1hdCAiJXMiCgBFUlJPUiAoLS0lcyk6IGlsbGVn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YW4ARkxBQ19fTUVUQURBVEFfU0lNUExFX0lURVJBVE9SX1NUQVRVU19JTExFR0FMX0lOUFVUAEZMQUNfX1NUUkVBTV9FTkNPREVSX1VOSU5JVElBTElaRUQARkxBQ19fU1RSRUFNX0RFQ09ERVJfUkVBRF9NRVRBREFUQQByZWZlcmVuY2UgbGliRkxBQyAxLjQuMyAyMDIzMDYyMwAobnVsbCkAZkxhQwAAABAAAAAQAAAAGAAAABgAAAAUAAAAAwAAAAUAAAAkAAAAIAAAAEAAAABAAAAAEAAAAAAAAAD//////////yAAAAAgAAAAQAAAAAgAAAAYAAAAQAAAAAgAAABgAAAAAQAAAAEAAABuAAAACAAAAAAEAABAAAAAAQAAABcIAAAIAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAABAAAABwAAABgAAAAQAAAAAgAAAAQAAAAEAAAABQAAAAUAAAAPAAAAHwAAAEZMQUNfX1NUUkVBTV9FTkNPREVSX09HR19FUlJPUgBGTEFDX19NRVRBREFUQV9TSU1QTEVfSVRFUkFUT1JfU1RBVFVTX0VSUk9SX09QRU5JTkdfRklMRQBQQVJUSVRJT05FRF9SSUNFAEZMQUNfX1NUUkVBTV9ERUNPREVSX1NFQVJDSF9GT1JfRlJBTUVfU1lOQwAtMFgrMFggMFgtMHgrMHggMHgARkxBQ19fU1RSRUFNX0VOQ09ERVJfVkVSSUZZX0RFQ09ERVJfRVJST1IARkxBQ19fU1RSRUFNX0RFQ09ERVJfUkVBRF9GUkFNRQBGTEFDX19NRVRBREFUQV9TSU1QTEVfSVRFUkFUT1JfU1RBVFVTX05PVF9BX0ZMQUNfRklMRQBQQVJUSVRJT05FRF9SSUNFMgAAAAAEAAAABQAAAGluZgBDT05TVEFOVABGTEFDX19TVFJFQU1fREVDT0RFUl9FTkRfT0ZfU1RSRUFNAEZMQUNfX01FVEFEQVRBX1NJTVBMRV9JVEVSQVRPUl9TVEFUVVNfTk9UX1dSSVRBQkxFAEZMQUNfX1NUUkVBTV9FTkNPREVSX1ZFUklGWV9NSVNNQVRDSF9JTl9BVURJT19EQVRBAEZMQUNfX1NUUkVBTV9FTkNPREVSX0NMSUVOVF9FUlJPUgBGTEFDX19TVFJFQU1fREVDT0RFUl9PR0dfRVJST1IAVkVSQkFUSU0ASU5GAEZMQUNfX01FVEFEQVRBX1NJTVBMRV9JVEVSQVRPUl9TVEFUVVNfQkFEX01FVEFEQVRBAG5hbgBGTEFDX19TVFJFQU1fRU5DT0RFUl9JT19FUlJPUgBGTEFDX19TVFJFQU1fREVDT0RFUl9TRUVLX0VSUk9SAEZMQUNfX01FVEFEQVRBX1NJTVBMRV9JVEVSQVRPUl9TVEFUVVNfUkVBRF9FUlJPUgBGSVhFRABGTEFDX19NRVRBREFUQV9TSU1QTEVfSVRFUkFUT1JfU1RBVFVTX1NFRUtfRVJST1IARkxBQ19fU1RSRUFNX0VOQ09ERVJfRlJBTUlOR19FUlJPUgBOQU4ARkxBQ19fU1RSRUFNX0RFQ09ERVJfQUJPUlRFRABMUEMASU5ERVBFTkRFTlQARkxBQ19fU1RSRUFNX0VOQ09ERVJfTUVNT1JZX0FMTE9DQVRJT05fRVJST1IARkxBQ19fU1RSRUFNX0RFQ09ERVJfTUVNT1JZX0FMTE9DQVRJT05fRVJST1IARkxBQ19fTUVUQURBVEFfU0lNUExFX0lURVJBVE9SX1NUQVRVU19XUklURV9FUlJPUgAuAEZMQUNfX01FVEFEQVRBX1NJTVBMRV9JVEVSQVRPUl9TVEFUVVNfUkVOQU1FX0VSUk9SAEZMQUNfX1NUUkVBTV9FTkNPREVSX0lOSVRfU1RBVFVTX09LAExFRlRfU0lERQBGTEFDX19TVFJFQU1fREVDT0RFUl9VTklOSVRJQUxJWkVEAEZMQUNfX1NUUkVBTV9FTkNPREVSX0lOSVRfU1RBVFVTX0lOVkFMSURfTlVNQkVSX09GX0NIQU5ORUxTAEZMQUNfX1NUUkVBTV9ERUNPREVSX0lOSVRfU1RBVFVTX01FTU9SWV9BTExPQ0FUSU9OX0VSUk9SAEZSQU1FX05VTUJFUl9UWVBFX1NBTVBMRV9OVU1CRVIARkxBQ19fTUVUQURBVEFfQ0hBSU5fU1RBVFVTX09LAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19JTExFR0FMX0lOUFVUAFNUUkVBTUlORk8ARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfSU5WQUxJRF9CSVRTX1BFUl9TQU1QTEUARkxBQ19fU1RSRUFNX0RFQ09ERVJfSU5JVF9TVEFUVVNfRVJST1JfT1BFTklOR19GSUxFAFBBRERJTkcARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfSU5WQUxJRF9TQU1QTEVfUkFURQBGTEFDX19NRVRBREFUQV9DSEFJTl9TVEFUVVNfRVJST1JfT1BFTklOR19GSUxFAEZMQUNfX1NUUkVBTV9ERUNPREVSX0lOSVRfU1RBVFVTX0FMUkVBRFlfSU5JVElBTElaRUQAQVBQTElDQVRJT04ARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfSU5WQUxJRF9CTE9DS19TSVpFAEZMQUNfX1NUUkVBTV9ERUNPREVSX1JFQURfU1RBVFVTX0NPTlRJTlVFAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19OT1RfQV9GTEFDX0ZJTEUARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfSU5WQUxJRF9NQVhfTFBDX09SREVSAEZMQUNfX1NUUkVBTV9ERUNPREVSX1JFQURfU1RBVFVTX0VORF9PRl9TVFJFQU0AU0VFS1RBQkxFAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19OT1RfV1JJVEFCTEUARkxBQ19fU1RSRUFNX0RFQ09ERVJfUkVBRF9TVEFUVVNfQUJPUlQAVk9SQklTX0NPTU1FTlQARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfSU5WQUxJRF9RTFBfQ09FRkZfUFJFQ0lTSU9OAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19CQURfTUVUQURBVEEAQ1VFU0hFRVQARkxBQ19fTUVUQURBVEFfQ0hBSU5fU1RBVFVTX1JFQURfRVJST1IARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfQkxPQ0tfU0laRV9UT09fU01BTExfRk9SX0xQQ19PUkRFUgBGTEFDX19TVFJFQU1fREVDT0RFUl9TRUVLX1NUQVRVU19PSwBGTEFDX19TVFJFQU1fREVDT0RFUl9TRUVLX1NUQVRVU19FUlJPUgBGTEFDX19NRVRBREFUQV9DSEFJTl9TVEFUVVNfU0VFS19FUlJPUgBQSUNUVVJFAEZMQUNfX1NUUkVBTV9FTkNPREVSX0lOSVRfU1RBVFVTX05PVF9TVFJFQU1BQkxFAE90aGVyAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19XUklURV9FUlJPUgBGTEFDX19TVFJFQU1fREVDT0RFUl9TRUVLX1NUQVRVU19VTlNVUFBPUlRFRABGTEFDX19TVFJFQU1fRU5DT0RFUl9JTklUX1NUQVRVU19JTlZBTElEX01FVEFEQVRBAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19SRU5BTUVfRVJST1IARkxBQ19fU1RSRUFNX0RFQ09ERVJfVEVMTF9TVEFUVVNfT0sARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfQUxSRUFEWV9JTklUSUFMSVpFRAAzMngzMiBwaXhlbHMgJ2ZpbGUgaWNvbicgKFBORyBvbmx5KQBPdGhlciBmaWxlIGljb24ARkxBQ19fU1RSRUFNX0RFQ09ERVJfVEVMTF9TVEFUVVNfRVJST1IARkxBQ19fTUVUQURBVEFfQ0hBSU5fU1RBVFVTX1VOTElOS19FUlJPUgBGTEFDX19TVFJFQU1fRU5DT0RFUl9SRUFEX1NUQVRVU19DT05USU5VRQBGTEFDX19NRVRBREFUQV9DSEFJTl9TVEFUVVNfTUVNT1JZX0FMTE9DQVRJT05fRVJST1IARkxBQ19fU1RSRUFNX0VOQ09ERVJfUkVBRF9TVEFUVVNfRU5EX09GX1NUUkVBTQBGTEFDX19TVFJFQU1fREVDT0RFUl9URUxMX1NUQVRVU19VTlNVUFBPUlRFRABDb3ZlciAoZnJvbnQpAEZMQUNfX1NUUkVBTV9FTkNPREVSX1JFQURfU1RBVFVTX0FCT1JUAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19JTlRFUk5BTF9FUlJPUgBGTEFDX19TVFJFQU1fREVDT0RFUl9MRU5HVEhfU1RBVFVTX09LAENvdmVyIChiYWNrKQBMZWFmbGV0IHBhZ2UARkxBQ19fTUVUQURBVEFfQ0hBSU5fU1RBVFVTX0lOVkFMSURfQ0FMTEJBQ0tTAEZMQUNfX1NUUkVBTV9ERUNPREVSX0xFTkdUSF9TVEFUVVNfRVJST1IARkxBQ19fU1RSRUFNX0VOQ09ERVJfUkVBRF9TVEFUVVNfVU5TVVBQT1JURUQARkxBQ19fU1RSRUFNX0VOQ09ERVJfV1JJVEVfU1RBVFVTX09LAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19SRUFEX1dSSVRFX01JU01BVENIAEZMQUNfX1NUUkVBTV9ERUNPREVSX0xFTkdUSF9TVEFUVVNfVU5TVVBQT1JURUQATWVkaWEgKGUuZy4gbGFiZWwgc2lkZSBvZiBDRCkATGVhZCBhcnRpc3QvbGVhZCBwZXJmb3JtZXIvc29sb2lzdABGTEFDX19TVFJFQU1fRU5DT0RFUl9XUklURV9TVEFUVVNfRkFUQUxfRVJST1IARkxBQ19fTUVUQURBVEFfQ0hBSU5fU1RBVFVTX1dST05HX1dSSVRFX0NBTEwARkxBQ19fU1RSRUFNX0RFQ09ERVJfV1JJVEVfU1RBVFVTX0NPTlRJTlVFAEFydGlzdC9wZXJmb3JtZXIAcitiAEZMQUNfX1NUUkVBTV9ERUNPREVSX1dSSVRFX1NUQVRVU19BQk9SVABGTEFDX19TVFJFQU1fRU5DT0RFUl9TRUVLX1NUQVRVU19PSwBDb25kdWN0b3IAcmIARkxBQ19fU1RSRUFNX0VOQ09ERVJfU0VFS19TVEFUVVNfRVJST1IARkxBQ19fU1RSRUFNX0RFQ09ERVJfRVJST1JfU1RBVFVTX0xPU1RfU1lOQwBCYW5kL09yY2hlc3RyYQBGTEFDX19TVFJFQU1fREVDT0RFUl9FUlJPUl9TVEFUVVNfQkFEX0hFQURFUgBGTEFDX19TVFJFQU1fRU5DT0RFUl9TRUVLX1NUQVRVU19VTlNVUFBPUlRFRABJRDMALm1ldGFkYXRhX2VkaXQAQ29tcG9zZXIARkxBQ19fU1RSRUFNX0VOQ09ERVJfVEVMTF9TVEFUVVNfT0sARkxBQ19fU1RSRUFNX0RFQ09ERVJfRVJST1JfU1RBVFVTX0ZSQU1FX0NSQ19NSVNNQVRDSAAlcyVzAEx5cmljaXN0L3RleHQgd3JpdGVyAEZMQUNfX1NUUkVBTV9FTkNPREVSX1RFTExfU1RBVFVTX0VSUk9SAEZMQUNfX1NUUkVBTV9ERUNPREVSX0VSUk9SX1NUQVRVU19VTlBBUlNFQUJMRV9TVFJFQU0AJXMvJXMlcwBSZWNvcmRpbmcgTG9jYXRpb24ARkxBQ19fU1RSRUFNX0VOQ09ERVJfVEVMTF9TVEFUVVNfVU5TVVBQT1JURUQARkxBQ19fU1RSRUFNX0RFQ09ERVJfRVJST1JfU1RBVFVTX0JBRF9NRVRBREFUQQBiYXJ0bGV0dABEdXJpbmcgcmVjb3JkaW5nAHJiAHcrYgBiYXJ0bGV0dF9oYW5uAER1cmluZyBwZXJmb3JtYW5jZQAlcyA6ICVzCgBBv6oCC8kZYmxhY2ttYW4ATW92aWUvdmlkZW8gc2NyZWVuIGNhcHR1cmUAY2hvd24oZmlsZW5hbWUsIHN0YXRzLT5zdF91aWQsIC0xKQBBIGJyaWdodCBjb2xvdXJlZCBmaXNoAGJsYWNrbWFuX2hhcnJpc180dGVybV85MmRiAGNob3duKGZpbGVuYW1lLCAtMSwgc3RhdHMtPnN0X2dpZCkAY29ubmVzAElsbHVzdHJhdGlvbgBmbGF0dG9wAEJhbmQvYXJ0aXN0IGxvZ290eXBlAFB1Ymxpc2hlci9TdHVkaW8gbG9nb3R5cGUAZ2F1c3MoAENELURBIGN1ZSBzaGVldCBtdXN0IGhhdmUgYSBsZWFkLWluIGxlbmd0aCBvZiBhdCBsZWFzdCAyIHNlY29uZHMAaGFtbWluZwBDRC1EQSBjdWUgc2hlZXQgbGVhZC1pbiBsZW5ndGggbXVzdCBiZSBldmVubHkgZGl2aXNpYmxlIGJ5IDU4OCBzYW1wbGVzAGhhbm4Aa2Fpc2VyX2Jlc3NlbABjdWUgc2hlZXQgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSB0cmFjayAodGhlIGxlYWQtb3V0KQBudXR0YWxsAENELURBIGN1ZSBzaGVldCBtdXN0IGhhdmUgYSBsZWFkLW91dCB0cmFjayBudW1iZXIgMTcwICgweEFBKQByZWN0YW5nbGUAY3VlIHNoZWV0IG1heSBub3QgaGF2ZSBhIHRyYWNrIG51bWJlciAwAHRyaWFuZ2xlAENELURBIGN1ZSBzaGVldCB0cmFjayBudW1iZXIgbXVzdCBiZSAxLTk5IG9yIDE3MABDRC1EQSBjdWUgc2hlZXQgbGVhZC1vdXQgb2Zmc2V0IG11c3QgYmUgZXZlbmx5IGRpdmlzaWJsZSBieSA1ODggc2FtcGxlcwB0dWtleSgAQ0QtREEgY3VlIHNoZWV0IHRyYWNrIG9mZnNldCBtdXN0IGJlIGV2ZW5seSBkaXZpc2libGUgYnkgNTg4IHNhbXBsZXMAcGFydGlhbF90dWtleSgAY3VlIHNoZWV0IHRyYWNrIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgaW5kZXggcG9pbnQAcHVuY2hvdXRfdHVrZXkoAGN1ZSBzaGVldCB0cmFjaydzIGZpcnN0IGluZGV4IG51bWJlciBtdXN0IGJlIDAgb3IgMQBzdWJkaXZpZGVfdHVrZXkoAENELURBIGN1ZSBzaGVldCB0cmFjayBpbmRleCBvZmZzZXQgbXVzdCBiZSBldmVubHkgZGl2aXNpYmxlIGJ5IDU4OCBzYW1wbGVzAHdlbGNoAGltYWdlL3BuZwBjdWUgc2hlZXQgdHJhY2sgaW5kZXggbnVtYmVycyBtdXN0IGluY3JlYXNlIGJ5IDEALS0+AE1JTUUgdHlwZSBzdHJpbmcgbXVzdCBjb250YWluIG9ubHkgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcnMgKDB4MjAtMHg3ZSkAdytiAGRlc2NyaXB0aW9uIHN0cmluZyBtdXN0IGJlIHZhbGlkIFVURi04AAAozQIAwM0CAFDOAgBObyBlcnJvciBpbmZvcm1hdGlvbgBJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBNdWx0aWhvcCBhdHRlbXB0ZWQAUmVxdWlyZWQga2V5IG5vdCBhdmFpbGFibGUAS2V5IGhhcyBleHBpcmVkAEtleSBoYXMgYmVlbiByZXZva2VkAEtleSB3YXMgcmVqZWN0ZWQgYnkgc2VydmljZQAAAAAApQJbAPABtQWMBSUBgwYdA5QE/wDHAzEDCwa8AY8BfwPKBCsA2gavAEIDTgPcAQ4EFQChBg0BlAILAjgGZAK8Av8CXQPnBAsHzwLLBe8F2wXhAh4GRQKFAIICbANvBPEA8wMYBdkA2gNMBlQCewGdA70EAABRABUCuwCzA20A/wGFBC8F+QQ4AGUBRgGfALcGqAFzAlMBAEG4xAILDCEEAAAAAAAAAAAvAgBB2MQCCwY1BEcEVgQAQe7EAgsCoAQAQYLFAgsiRgVgBW4FYQYAAM8BAAAAAAAAAADJBukG+QYeBzkHSQdeBwBBsMUCC5EB0XSeAFedvSqAcFIP//8+JwoAAABkAAAA6AMAABAnAACghgEAQEIPAICWmAAA4fUFGAAAADUAAABxAAAAa////877//+Sv///AAAAAAAAAAAZAAsAGRkZAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABkACgoZGRkDCgcAAQAJCxgAAAkGCwAACwAGGQAAABkZGQBB0cYCCyEOAAAAAAAAAAAZAAsNGRkZAA0AAAIACQ4AAAAJAA4AAA4AQYvHAgsBDABBl8cCCxUTAAAAABMAAAAACQwAAAAAAAwAAAwAQcXHAgsBEABB0ccCCxUPAAAABA8AAAAACRAAAAAAABAAABAAQf/HAgsBEgBBi8gCCx4RAAAAABEAAAAACRIAAAAAABIAABIAABoAAAAaGhoAQcLIAgsOGgAAABoaGgAAAAAAAAkAQfPIAgsBFABB/8gCCxUXAAAAABcAAAAACRQAAAAAABQAABQAQa3JAgsBFgBBuckCC0oVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUbeEgSVAAAAAP///////////////+CkAAAUAAAAQy5VVEYtOABBmMoCCwL0pABBsMoCC8gGdXRmOABjaGFyAADId2NoYXJ0AADGdWNzMmJlAADEdWNzMmxlAADFdXRmMTZiZQAAwnV0ZjE2bGUAAMF1Y3M0YmUAdXRmMzJiZQAAwHVjczRsZQB1dGYzMmxlAADDYXNjaWkAdXNhc2NpaQBpc282NDYAaXNvNjQ2dXMAAMd1dGYxNgAAynVjczQAdXRmMzIAAMt1Y3MyAADMZXVjanAAANBzaGlmdGppcwBzamlzAGNwOTMyAADRaXNvMjAyMmpwAADSZ2IxODAzMAAA2GdiawAA2WdiMjMxMgAA2mJpZzUAYmlnZml2ZQBjcDk1MABiaWc1aGtzY3MAAOBldWNrcgBrc2M1NjAxAGtzeDEwMDEAY3A5NDkAAOhpc284ODU5MQBsYXRpbjEAAEBpc284ODU5MgAAKKAQ9FdOpNz01CmoVDVVVm61IhdcsBQUmE604ASVX7hYRZVWbw02V1xJBSOMQMTMZNAxDCVj0TIYNeOMQxDt9NM01BRlzTVNjaVNWdx0c9U3SoUjzkDk0HTQOQ2lc9E6GbXjzkMR8QTUPPQYZc89TpGlj1n89IMVYGlzbzg4NTkzAAAooJD01yikACDSKaiwNBVHLrUCAFywlCTLLLTUMtItuLREVUcv9QJAXMAEIwwAxCiE0DHIJKPMMsw048wzAEQjzTTUeGTNNRplo8023IQV1TfghCMOAOQslNA56KSjzjrstOPOOwDEI8889Hxkzz0b5aPPPvyIJRVgaXNvODg1OTQAACigECTTUqSYVNMpqFQlEUhbtSLXK7AUFBhTtJxkk1+4WDVRSFwFNZdQAAUjzDDEFGOMSgwlY9EyFDXjDEoQ9TQUTNRUY8012JylzTbcdPXVNwGFI8445JRjzkoNpXPROhW1405KEflEVEz01GPPPfigpc8+/HgFFmBpc284ODU5NQAAKKBEJ9101FVn3XXYZafddty10p1334EXnnjjkVeeeeehl55667HXnnvvwReffPPRV5999+GXn3778deff/8BGKCAAxJYoIEHIpigggsy2KCDD0IYoYQTUlihhRdimKGGG3LYoYcmfwhiiCKOSGKJJp6IYooqnrIii2lzbzg4NTk2AAAooAAAAACkAEGB0QILA2K2AgBBk9ECC0fAmAAAAACZAJRp5plopqnmmmy26eabcMYp55x01mnnnXjmqeeefPbpJwAAAAAAAH8CGqiggxJaqKGHIpqooosy2qijj0IaKQBB6tECC7UBaXNvODg1OTcAACigTEzxKCSXbMopqKSS2CqstAJAxLDEIsssii3G2C2NOfbYLpD1Eplkk1FWmWWXYZaZZptx1plnn4EWmmijkQZAaaadhlpqqq3GWmuuvQZbbLLNRltttt2GW2667cZbb779Blxwwg1HXHHGHYdccsotx1xzzj0HHQBpc284ODU5OAAAKKAAIMoopJRiyimopHLNKqy04sorsMQiyyy01GLLLbjkcs8uvPTiCwBBxtMCC5aVA4DEQg5JZJFGHolkkkouyWSTTj4JZZRSTklllVZeiWWWWm7JJQAANOwwAGlzbzg4NTk5AAA0HEUjzTTUVGPNNdhko8023LA01TfghCPOOOSUY8456KSjzjrstOPOOx3FI8889NRjzz345KPPPvy0RNU/aXNvODg1OTEwAAAooBAkEUgomQTTKTVBVNVWcrXyVVCwFDRRSCmdFNMtNkVkFVdzRQyWUAAFI8wwxBRjjEoMJWPRMhQ148wz0PQ01DTUVGNNV9icpc023HTjzTcBhSPOOOSUY85KDaVz0ToVtePOO/D4RNQ89NRjj1f4oKXPPvz0449MaXNvODg1OTExAHRpczYyMAAAKKB4+imooYo6Kqmlmnoqqqmquiqrrbr6KqyxyjorrbXaeiuuueq6K6+9+vorsMEKOyyxxRp7LLLJKrsss806+yy00Uo7LbXVWnstAAAAAAC22Wq7LbfdevstuOGKOy655Zp7Lrrpqrsuu+26+y688co7L70AAAAAAGlzbzg4NTkxMwAAKKBcLMoopGBsyinYpLLUKqy04ooxsMQiyywW12LLLfjkwtQuvPTiizkEqQSQQcQUY5FEDCXjFkUgwYRSTVXt1NM0Q1VjzTVn5fTUV9zAJdc3Ba0U0EHklHPRRA2l81ZFIcWUkk1W8eTTPETVY889aOkEFVj8xDUXxWlzbzg4NTkxNAAAKKDUa+8oCi107ykDp1Iwvgm34kpb+err0Uf78mtLvwT7a/C/Ch+MMMDABCPMMMQUY8wxyCSjzDLMNOPMM2lFI8001FRjTcDYZKPNNtx0s9Y34IQjzjjklGPOOeiko8467LTjzjtqxSPPPPTUY4/A+OSjzz789MPWP2lzbzg4NTkxNQBsYXRpbjkAACkkl1LVKValosoqrLTiyiuwxCLLLHLVYsstc+Wiyy5HIdXWL8AEI8wwxBRjzDHIJKPMMsw048wz0EQjzTTUVGPNNdhko8023HTjzTfghCPOOOSUY8456KSjzjrstOPOO/DEI8889NRjzz345KPPPvz0488/aXNvODg1OTE2AAAooBBUUE4kY1zVKValktcqbrXyFlywxMKQTnJdbMstczWk1y5HIdVWXMAEI4xAxBhkzDHIJKPMMsw048wzEO0kzTTUFGXNU2Vlo8023Fi01zfghCPOQOQcZM456KSjzjrstOPOOxHxJM889BhlD1Rm5aPPPvxcxNc/Y3AxMjUwAHdpbmRvd3MxMjUwAAAgJANQMQAYc5yxxgB0XJXHT2Ull1sATEyxxRdv/DDEAJxs1cdQaTXXW6D49VdOpBBkyimopDLVKqy04gpcsMQSmE601GLLLbgURNUuNw2GU1xJBSOMQMTMZNAxDCVj0TIYNeOMQxDt9NM01BRlzTVNjaVNWdx0c9U3SoUjzkDk0HTQOQ2lc9E6GbXjzkMR8QTUPPQYZc89TpGlj1n89IMVYGNwMTI1MQB3aW5kb3dzMTI1MQAAINJNV3GIGHOcscYkd5ydx9pxt513IE5MscUXb/wwxACcfOLHKKqYIougdLcidqS0aMop0aVC3SqstOLKdbDEYh2JLtZiyy0fmiziLiZWN2KJ34EXnnjjkVeeeeehl55667HXnnvvwReffPPRV5999+GXn3778deff/8BGKCAAxJYoIEHIpigggsy2KCDD0IYoYQTUlihhRdimKGGG3LYoYdjcDEyNTIAd2luZG93czEyNTIAACAkA1AxXRhznLHGfXVclcdHASAXAABMTLHFF2/8MMSCnWzVx0gBMFdboIQiyiiklGLKKaikosoqrLTiyiuwxCLLLLTUYsstuOSiyy689OLLL8AEI8wwxBRjzDHIJKPMMsw048wz0EQjzTTUVGPNNdhko8023HTjzTfghCPOOOSUY8456KSjzjrstOPOO/DEI8889NRjzz345KPPPvz0488/Y3AxMjUzAHdpbmRvd3MxMjUzAAAgJANQMV0Yc5yxxgB0DIDHAAAAAAAATEyxxRdv/DDEAJwMwMcAAAAAAKAsxtgopJRiyimopALAKqy04krEsMQiyyyK1WLLLY059tgukPUSmWSTUVaZZZdhlplmm3HWmWefgRaaaKORBkBppp2GWmqqrcZaa669Bltsss1GW2223YZbbrrtxltvvv0GXHDCDUdcccYdh1xyyi3HXHPOPQcdAGNwMTI1NAB3aW5kb3dzMTI1NAAAICQDUDFdGHOcscZ9dVyVx0cBAAAAAExMscUXb/wwxIKdbNXHSAEAQFughCLKKKSUYsopqKSiyiqstOLKK7DEIssstNRiyy245KLLLrz04ssvwAQjzDDEFGPMMcgko8wyzDTjzDMcRSPNNNRUY8012GSjzTbcsDTVN+CEI8445JRjzjnopKPOOuy04847HcUjzzz01GPPPfjko88+/LRE1T9jcDEyNTUAd2luZG93czEyNTUAACAkA1AxXRhznLHGfXUMgMcAAAAAAABMTLHFF2/8MMSCnQzAxwAAAAAAoIQiyigil2LKKaikcs0qrLTiyiuwxCLLLLTUYsstuORyzy689OLLLy/CGKOMM9JYo4034ghAjjruyGOPPv4IZJBdevklmGECAAAAAAAAAABCDklkkUYeiWSSSi7JZJNOPglllFJOSWWVVl6JZZZabsklAAA07DAAY3AxMjU2AHdpbmRvd3MxMjU2AAAgJE9aMV0Yc5yxxn11LKnHR1F6aaWZTkyxxRdv/DDEmJ5s6cdILcywpqCIKcoopJRiyimopLLpKqy04sorsMQiyyy01GLLLbjkMuYuvPTiC5mclmnmmWimqeaabLbp5ptwxinnnHTWaeedeOap5zV78tmnn38CGqig4AwqDqGFGnroOeiko846iCbqzjuKLspoo/Q4+ug9kOYT6T78NOxwp2NwMTI1NwB3aW5kb3dzMTI1NwAAICQDUDEAGHOcscYAdAyAxwCg4hcuAExMscUXb/wwxACcDMDHALwSGACgACDKKKQAYMop2KSy1CqstOKKMbDEIssstNRiyy345MLULrz04os5BKkEkEHEFGORRAwl4xZFIMGEUk1V7dTTNENVY801Z+X01FfcwCXXNwWtFNBB5JRz0UQNpfNWRSHFlJJNVvHk0zxE1WPPPWjpBBVY/MQ1F2BjcDEyNTgAd2luZG93czEyNTgAACAkA1AxXRhznLHGfXUMgMdHAQAAAABMTLHFF2/8MMSCnQzAx0gBAEBboIQiyiiklGLKKaikosoqrLTiyiuwxCLLLLTUYsstuOSiyy689OLLL8AEI4xAxBRjzDHIJKPMMoQ148wzEEVz2DTU1GXNNdhko8023Nxl2DfghCPOQOSUY8456KSjzjqFtePOOxHFg9g89Nhlzz345KPPPvzgNfI/a29pOHIAACAz01yzzTfjnLPOO/Pc89Zcd+3112CHLXbMY6OcMssuvwyKzLDIcss9Pv8M9IdBCz000UUbfTTSSSu9NNNNO/10dFBHLfXUVFdt9dVYZ611Kh3+B2CFAxI4oYAUHohgggouyGCDDnr4IIQRSlhggBtqaOCFHGJoYYb9fQdefeORN5949J2HXnrqrcdee+759x588clXXnj76WfeffzhZ19+a29pOHUAACAz01yzzTfjnLPOO/Pc89Zcd+3112CHLXbMY6OcMssuvwyKzLDIcss9Pv8M9IciCk1iiUUbfTTSSbu4NNNNO/10dNRFbd11VFdt9dVYt6h1Kh3+B2CFAxI4oYAUHohgggouyGCDDnr4IIQRSlhggBtqaOCFHGJoYYb9fQdefeORN5949J2HXnrqrcdee+759x588clXXnj76WfeffzhZ19+Y3A0MzcAACDH8JOOOOSAU8456qyDzjvusENMMcmYYww99sizTz7/WMONKKOUEjJd4bQzjz7xRKOKLr/AzEovvISyyi5ghy02zTo/DTXRQ0f9c9FLK520zTfzvHPOM/fMdNNIC3011U77rHXVVks99dFGAx101ljjXHPXXHv99dazfWOZcKUVV4txqG22mm0qI3fbyi3H8rLLMct8D8uwoHxLyiDLMjYoY3A4NTAAACDH8JOOOOSAU8456qyDzjvusENMMcmYYww99sizTz7/WMMNPqNgcw1d4bQzjz7xRKOKLr+4wkovvISyyi5ghy02zToHIwwwqUT9c9FLi1KKzTfzvHPOM/c8zjBIC3011U77rDUp8ECjzDLItNSMM8/gXHPXXJvCzNbTfEONNPVUU4s/3mizTTb9dPMKLa3EIrEvtpxyDy6woHJLLrPIMjYoY3A4NjYAACDfgReeeOORV55556GXnnrrsdeee+/BF59889FXn3334Zeffvvx159//wEYoIADEliggQcimKCCCzLYoINghy02zTo/DTXRQ0f9c9FLK520zTfzvHPOM/fMdNNIC3011U77rHXVVks99dFGAx101ljjXHPXXHv99dYPQhihhBNSWKGFF2KYoYYbctihh9F9SJ2I15XY3YqwoHxLyiaTMjYoaWJtMTA0NwBjcDEwNDcAAAGcJGDIH5c04sgCDDTgwAMQRCDBBJ0UgsAhGGQgySMcdODBB4AEIsgghChwwQaIJKLIIowUYMABkERiwSSUVGIJAZhkoskmFFTgiQYggCIOOeCEM04558Qjigs8oLACHyako8466LTjzjvsfBMCCSqksIMXLbwgDDHABDNMMcdEYwoLJXzhww/4JKPMMsg048wzzIChwwhAnNCDCNiEIcYYZJRhxhlopLHKLvD0408ssKixBhttuPEGHHHIoYou5uBiDCm1+DEHHXXYcQceeegRyi/QbOGNK6yMUsotqZxiCy+9+NINKq90Qcs1ewQhxBBEFGHEEUgk0Qo99sgzTz19KLEEE0048QQUUUiRyz785KPPP1zcMwUVVVhxBRZZaCELNdZIM001MMQgwww01GDDDTjkMMs23GSjzScAAAAAAAAAAk4ETgVOBk4PThJOF04fTiBOIU4jTiZOKU4uTi9OMU4zTjVON048TkBOQU5CTkRORk5KTlFOVU5XTlpOW05iTmNOZE5lTmdOaE5qTmtObE5tTm5Ob05yTnROdU52TndOeE55TnpOe058Tn1Of06AToFOgk6DToROhU6HTopOkE6WTpdOmU6cTp1Onk6jTqpOr06wTrFOtE62TrdOuE65TrxOvU6+TshOzE7PTtBO0k7aTttO3E7gTuJO5k7nTulO7U7uTu9O8U70TvhO+U76TvxO/k4ATwJPA08ETwVPBk8HTwhPC08MTxJPE08UTxVPFk8cTx1PIU8jTyhPKU8sTy1PLk8xTzNPNU83TzlPO08+Tz9PQE9BT0JPRE9FT0dPSE9JT0pPS09MT1JPVE9WT2FPYk9mT2hPak9rT21Pbk9xT3JPdU93T3hPeU96T31PgE+BT4JPhU+GT4dPik+MT45PkE+ST5NPlU+WT5hPmU+aT5xPnk+fT6FPok+kT6tPrU+wT7FPsk+zT7RPtk+3T7hPuU+6T7tPvE+9T75PwE/BT8JPxk/HT8hPyU/LT8xPzU/ST9NP1E/VT9ZP2U/bT+BP4k/kT+VP50/rT+xP8E/yT/RP9U/2T/dP+U/7T/xP/U//TwBQAVACUANQBFAFUAZQB1AIUAlQClALUA5QEFARUBNQFVAWUBdQG1AdUB5QIFAiUCNQJFAnUCtQL1AwUDFQMlAzUDRQNVA2UDdQOFA5UDtQPVA/UEBQQVBCUERQRVBGUElQSlBLUE1QUFBRUFJQU1BUUFZQV1BYUFlQW1BdUF5QX1BgUGFQYlBjUGRQZlBnUGhQaVBqUGtQbVBuUG9QcFBxUHJQc1B0UHVQeFB5UHpQfFB9UIFQglCDUIRQhlCHUIlQilCLUIxQjlCPUJBQkVCSUJNQlFCVUJZQl1CYUJlQmlCbUJxQnVCeUJ9QoFChUKJQpFCmUKpQq1CtUK5Qr1CwULFQs1C0ULVQtlC3ULhQuVC8UL1QvlC/UMBQwVDCUMNQxFDFUMZQx1DIUMlQylDLUMxQzVDOUNBQ0VDSUNNQ1FDVUNdQ2FDZUNtQ3FDdUN5Q31DgUOFQ4lDjUORQ5VDoUOlQ6lDrUO9Q8FDxUPJQ9FD2UPdQ+FD5UPpQ/FD9UP5Q/1AAUQFRAlEDUQRRBVEIUQlRClEMUQ1RDlEPURBREVETURRRFVEWURdRGFEZURpRG1EcUR1RHlEfUSBRIlEjUSRRJVEmUSdRKFEpUSpRK1EsUS1RLlEvUTBRMVEyUTNRNFE1UTZRN1E4UTlROlE7UTxRPVE+UUJRR1FKUUxRTlFPUVBRUlFTUVdRWFFZUVtRXVFeUV9RYFFhUWNRZFFmUWdRaVFqUW9RclF6UX5Rf1GDUYRRhlGHUYpRi1GOUY9RkFGRUZNRlFGYUZpRnVGeUZ9RoVGjUaZRp1GoUalRqlGtUa5RtFG4UblRulG+Ub9RwVHCUcNRxVHIUcpRzVHOUdBR0lHTUdRR1VHWUddR2FHZUdpR3FHeUd9R4lHjUeVR5lHnUehR6VHqUexR7lHxUfJR9FH3Uf5RBFIFUglSC1IMUg9SEFITUhRSFVIcUh5SH1IhUiJSI1IlUiZSJ1IqUixSL1IxUjJSNFI1UjxSPlJEUkVSRlJHUkhSSVJLUk5ST1JSUlNSVVJXUlhSWVJaUltSXVJfUmBSYlJjUmRSZlJoUmtSbFJtUm5ScFJxUnNSdFJ1UnZSd1J4UnlSelJ7UnxSflKAUoNShFKFUoZSh1KJUopSi1KMUo1SjlKPUpFSklKUUpVSllKXUphSmVKaUpxSpFKlUqZSp1KuUq9SsFK0UrVStlK3UrhSuVK6UrtSvFK9UsBSwVLCUsRSxVLGUshSylLMUs1SzlLPUtFS01LUUtVS11LZUtpS21LcUt1S3lLgUuFS4lLjUuVS5lLnUuhS6VLqUutS7FLtUu5S71LxUvJS81L0UvVS9lL3UvhS+1L8Uv1SAVMCUwNTBFMHUwlTClMLUwxTDlMRUxJTE1MUUxhTG1McUx5TH1MiUyRTJVMnUyhTKVMrUyxTLVMvUzBTMVMyUzNTNFM1UzZTN1M4UzxTPVNAU0JTRFNGU0tTTFNNU1BTVFNYU1lTW1NdU2VTaFNqU2xTbVNyU3ZTeVN7U3xTfVN+U4BTgVODU4dTiFOKU45Tj1OQU5FTklOTU5RTllOXU5lTm1OcU55ToFOhU6RTp1OqU6tTrFOtU69TsFOxU7JTs1O0U7VTt1O4U7lTulO8U71TvlPAU8NTxFPFU8ZTx1POU89T0FPSU9NT1VPaU9xT3VPeU+FT4lPnU/RT+lP+U/9TAFQCVAVUB1QLVBRUGFQZVBpUHFQiVCRUJVQqVDBUM1Q2VDdUOlQ9VD9UQVRCVERURVRHVElUTFRNVE5UT1RRVFpUXVReVF9UYFRhVGNUZVRnVGlUalRrVGxUbVRuVG9UcFR0VHlUelR+VH9UgVSDVIVUh1SIVIlUilSNVJFUk1SXVJhUnFSeVJ9UoFShVKJUpVSuVLBUslS1VLZUt1S5VLpUvFS+VMNUxVTKVMtU1lTYVNtU4FThVOJU41TkVOtU7FTvVPBU8VT0VPVU9lT3VPhU+VT7VP5UAFUCVQNVBFUFVQhVClULVQxVDVUOVRJVE1UVVRZVF1UYVRlVGlUcVR1VHlUfVSFVJVUmVShVKVUrVS1VMlU0VTVVNlU4VTlVOlU7VT1VQFVCVUVVR1VIVUtVTFVNVU5VT1VRVVJVU1VUVVdVWFVZVVpVW1VdVV5VX1VgVWJVY1VoVWlVa1VvVXBVcVVyVXNVdFV5VXpVfVV/VYVVhlWMVY1VjlWQVZJVk1WVVZZVl1WaVZtVnlWgVaFVolWjVaRVpVWmVahVqVWqVatVrFWtVa5Vr1WwVbJVtFW2VbhVulW8Vb9VwFXBVcJVw1XGVcdVyFXKVctVzlXPVdBV1VXXVdhV2VXaVdtV3lXgVeJV51XpVe1V7lXwVfFV9FX2VfhV+VX6VftV/FX/VQJWA1YEVgVWBlYHVgpWC1YNVhBWEVYSVhNWFFYVVhZWF1YZVhpWHFYdViBWIVYiViVWJlYoVilWKlYrVi5WL1YwVjNWNVY3VjhWOlY8Vj1WPlZAVkFWQlZDVkRWRVZGVkdWSFZJVkpWS1ZPVlBWUVZSVlNWVVZWVlpWW1ZdVl5WX1ZgVmFWY1ZlVmZWZ1ZtVm5Wb1ZwVnJWc1Z0VnVWd1Z4VnlWelZ9Vn5Wf1aAVoFWglaDVoRWh1aIVolWilaLVoxWjVaQVpFWklaUVpVWllaXVphWmVaaVptWnFadVp5Wn1agVqFWolakVqVWplanVqhWqVaqVqtWrFatVq5WsFaxVrJWs1a0VrVWtla4VrlWula7Vr1Wvla/VsBWwVbCVsNWxFbFVsZWx1bIVslWy1bMVs1WzlbPVtBW0VbSVtNW1VbWVthW2VbcVuNW5VbmVudW6FbpVupW7FbuVu9W8lbzVvZW91b4VvtW/FYAVwFXAlcFVwdXC1cMVw1XDlcPVxBXEVcSVxNXFFcVVxZXF1cYVxlXGlcbVx1XHlcgVyFXIlckVyVXJlcnVytXMVcyVzRXNVc2VzdXOFc8Vz1XP1dBV0NXRFdFV0ZXSFdJV0tXUldTV1RXVVdWV1hXWVdiV2NXZVdnV2xXbldwV3FXcld0V3VXeFd5V3pXfVd+V39XgFeBV4dXiFeJV4pXjVeOV49XkFeRV5RXlVeWV5dXmFeZV5pXnFedV55Xn1elV6hXqlesV69XsFexV7NXtVe2V7dXuVe6V7tXvFe9V75Xv1fAV8FXxFfFV8ZXx1fIV8lXylfMV81X0FfRV9NX1lfXV9tX3FfeV+FX4lfjV+VX5lfnV+hX6VfqV+tX7FfuV/BX8VfyV/NX9Vf2V/dX+1f8V/5X/1cBWANYBFgFWAhYCVgKWAxYDlgPWBBYElgTWBRYFlgXWBhYGlgbWBxYHVgfWCJYI1glWCZYJ1goWClYK1gsWC1YLlgvWDFYMlgzWDRYNlg3WDhYOVg6WDtYPFg9WD5YP1hAWEFYQlhDWEVYRlhHWEhYSVhKWEtYTlhPWFBYUlhTWFVYVlhXWFlYWlhbWFxYXVhfWGBYYVhiWGNYZFhmWGdYaFhpWGpYbVhuWG9YcFhxWHJYc1h0WHVYdlh3WHhYeVh6WHtYfFh9WH9YgliEWIZYh1iIWIpYi1iMWI1YjliPWJBYkViUWJVYlliXWJhYm1icWJ1YoFihWKJYo1ikWKVYplinWKpYq1isWK1YrlivWLBYsViyWLNYtFi1WLZYt1i4WLlYuli7WL1Yvli/WMBYwljDWMRYxljHWMhYyVjKWMtYzFjNWM5Yz1jQWNJY01jUWNZY11jYWNlY2ljbWNxY3VjeWN9Y4FjhWOJY41jlWOZY51joWOlY6ljtWO9Y8VjyWPRY9Vj3WPhY+lj7WPxY/Vj+WP9YAFkBWQNZBVkGWQhZCVkKWQtZDFkOWRBZEVkSWRNZF1kYWRtZHVkeWSBZIVkiWSNZJlkoWSxZMFkyWTNZNVk2WTtZPVk+WT9ZQFlDWUVZRllKWUxZTVlQWVJZU1lZWVtZXFldWV5ZX1lhWWNZZFlmWWdZaFlpWWpZa1lsWW1ZbllvWXBZcVlyWXVZd1l6WXtZfFl+WX9ZgFmFWYlZi1mMWY5Zj1mQWZFZlFmVWZhZmlmbWZxZnVmfWaBZoVmiWaZZp1msWa1ZsFmxWbNZtFm1WbZZt1m4WbpZvFm9Wb9ZwFnBWcJZw1nEWcVZx1nIWclZzFnNWc5Zz1nVWdZZ2VnbWd5Z31ngWeFZ4lnkWeZZ51npWepZ61ntWe5Z71nwWfFZ8lnzWfRZ9Vn2WfdZ+Fn6WfxZ/Vn+WQBaAloKWgtaDVoOWg9aEFoSWhRaFVoWWhdaGVoaWhtaHVoeWiFaIlokWiZaJ1ooWipaK1osWi1aLlovWjBaM1o1WjdaOFo5WjpaO1o9Wj5aP1pBWkJaQ1pEWkVaR1pIWktaTFpNWk5aT1pQWlFaUlpTWlRaVlpXWlhaWVpbWlxaXVpeWl9aYFphWmNaZFplWmZaaFppWmtabFptWm5ab1pwWnFaclpzWnhaeVp7WnxafVp+WoBagVqCWoNahFqFWoZah1qIWolailqLWoxajVqOWo9akFqRWpNalFqVWpZal1qYWplanFqdWp5an1qgWqFaolqjWqRapVqmWqdaqFqpWqtarFqtWq5ar1qwWrFatFq2WrdauVq6WrtavFq9Wr9awFrDWsRaxVrGWsdayFrKWstazVrOWs9a0FrRWtNa1VrXWtla2lrbWt1a3lrfWuJa5FrlWuda6FrqWuxa7VruWu9a8FryWvNa9Fr1WvZa91r4Wvla+lr7Wvxa/Vr+Wv9aAFsBWwJbA1sEWwVbBlsHWwhbClsLWwxbDVsOWw9bEFsRWxJbE1sUWxVbGFsZWxpbG1scWx1bHlsfWyBbIVsiWyNbJFslWyZbJ1soWylbKlsrWyxbLVsuWy9bMFsxWzNbNVs2WzhbOVs6WztbPFs9Wz5bP1tBW0JbQ1tEW0VbRltHW0hbSVtKW0tbTFtNW05bT1tSW1ZbXltgW2FbZ1toW2tbbVtuW29bclt0W3Zbd1t4W3lbe1t8W35bf1uCW4ZbiluNW45bkFuRW5JblFuWW59bp1uoW6lbrFutW65br1uxW7Jbt1u6W7tbvFvAW8Fbw1vIW8lbylvLW81bzlvPW9Fb1FvVW9Zb11vYW9lb2lvbW9xb4FviW+Nb5lvnW+lb6lvrW+xb7VvvW/Fb8lvzW/Rb9Vv2W/db/Vv+WwBcAlwDXAVcB1wIXAtcDFwNXA5cEFwSXBNcF1wZXBtcHlwfXCBcIVwjXCZcKFwpXCpcK1wtXC5cL1wwXDJcM1w1XDZcN1xDXERcRlxHXExcTVxSXFNcVFxWXFdcWFxaXFtcXFxdXF9cYlxkXGdcaFxpXGpca1xsXG1ccFxyXHNcdFx1XHZcd1x4XHtcfFx9XH5cgFyDXIRchVyGXIdciVyKXItcjlyPXJJck1yVXJ1cnlyfXKBcoVykXKVcplynXKhcqlyuXK9csFyyXLRctly5XLpcu1y8XL5cwFzCXMNcxVzGXMdcyFzJXMpczFzNXM5cz1zQXNFc01zUXNVc1lzXXNhc2lzbXNxc3VzeXN9c4FziXONc51zpXOtc7FzuXO9c8VzyXPNc9Fz1XPZc91z4XPlc+lz8XP1c/lz/XABdAV0EXQVdCF0JXQpdC10MXQ1dD10QXRFdEl0TXRVdF10YXRldGl0cXR1dH10gXSFdIl0jXSVdKF0qXStdLF0vXTBdMV0yXTNdNV02XTddOF05XTpdO108XT9dQF1BXUJdQ11EXUVdRl1IXUldTV1OXU9dUF1RXVJdU11UXVVdVl1XXVldWl1cXV5dX11gXWFdYl1jXWRdZV1mXWddaF1qXW1dbl1wXXFdcl1zXXVddl13XXhdeV16XXtdfF19XX5df12AXYFdg12EXYVdhl2HXYhdiV2KXYtdjF2NXY5dj12QXZFdkl2TXZRdlV2WXZddmF2aXZtdnF2eXZ9doF2hXaJdo12kXaVdpl2nXahdqV2qXatdrF2tXa5dr12wXbFdsl2zXbRdtV22XbhduV26XbtdvF29Xb5dv13AXcFdwl3DXcRdxl3HXchdyV3KXctdzF3OXc9d0F3RXdJd013UXdVd1l3XXdhd2V3aXdxd313gXeNd5F3qXexd7V3wXfVd9l34Xfld+l37Xfxd/10AXgReB14JXgpeC14NXg5eEl4TXhdeHl4fXiBeIV4iXiNeJF4lXiheKV4qXiteLF4vXjBeMl4zXjReNV42XjleOl4+Xj9eQF5BXkNeRl5HXkheSV5KXkteTV5OXk9eUF5RXlJeU15WXldeWF5ZXlpeXF5dXl9eYF5jXmReZV5mXmdeaF5pXmpea15sXm1ebl5vXnBecV51XndeeV5+XoFegl6DXoVeiF6JXoxejV6OXpJemF6bXp1eoV6iXqNepF6oXqleql6rXqxerl6vXrBesV6yXrReul67XrxevV6/XsBewV7CXsNexF7FXsZex17IXstezF7NXs5ez17QXtRe1V7XXthe2V7aXtxe3V7eXt9e4F7hXuJe417kXuVe5l7nXule617sXu1e7l7vXvBe8V7yXvNe9V74Xvle+178Xv1eBV8GXwdfCV8MXw1fDl8QXxJfFF8WXxlfGl8cXx1fHl8hXyJfI18kXyhfK18sXy5fMF8yXzNfNF81XzZfN184XztfPV8+Xz9fQV9CX0NfRF9FX0ZfR19IX0lfSl9LX0xfTV9OX09fUV9UX1lfWl9bX1xfXl9fX2BfY19lX2dfaF9rX25fb19yX3RfdV92X3hfel99X35ff1+DX4ZfjV+OX49fkV+TX5Rfll+aX5tfnV+eX59foF+iX6NfpF+lX6Zfp1+pX6tfrF+vX7BfsV+yX7NftF+2X7hfuV+6X7tfvl+/X8BfwV/CX8dfyF/KX8tfzl/TX9Rf1V/aX9tf3F/eX99f4l/jX+Vf5l/oX+lf7F/vX/Bf8l/zX/Rf9l/3X/lf+l/8XwdgCGAJYAtgDGAQYBFgE2AXYBhgGmAeYB9gImAjYCRgLGAtYC5gMGAxYDJgM2A0YDZgN2A4YDlgOmA9YD5gQGBEYEVgRmBHYEhgSWBKYExgTmBPYFFgU2BUYFZgV2BYYFtgXGBeYF9gYGBhYGVgZmBuYHFgcmB0YHVgd2B+YIBggWCCYIVghmCHYIhgimCLYI5gj2CQYJFgk2CVYJdgmGCZYJxgnmChYKJgpGClYKdgqWCqYK5gsGCzYLVgtmC3YLlgumC9YL5gv2DAYMFgwmDDYMRgx2DIYMlgzGDNYM5gz2DQYNJg02DUYNZg12DZYNtg3mDhYOJg42DkYOVg6mDxYPJg9WD3YPhg+2D8YP1g/mD/YAJhA2EEYQVhB2EKYQthDGEQYRFhEmETYRRhFmEXYRhhGWEbYRxhHWEeYSFhImElYShhKWEqYSxhLWEuYS9hMGExYTJhM2E0YTVhNmE3YThhOWE6YTthPGE9YT5hQGFBYUJhQ2FEYUVhRmFHYUlhS2FNYU9hUGFSYVNhVGFWYVdhWGFZYVphW2FcYV5hX2FgYWFhY2FkYWVhZmFpYWpha2FsYW1hbmFvYXFhcmFzYXRhdmF4YXlhemF7YXxhfWF+YX9hgGGBYYJhg2GEYYVhhmGHYYhhiWGKYYxhjWGPYZBhkWGSYZNhlWGWYZdhmGGZYZphm2GcYZ5hn2GgYaFhomGjYaRhpWGmYaphq2GtYa5hr2GwYbFhsmGzYbRhtWG2YbhhuWG6YbthvGG9Yb9hwGHBYcNhxGHFYcZhx2HJYcxhzWHOYc9h0GHTYdVh1mHXYdhh2WHaYdth3GHdYd5h32HgYeFh4mHjYeRh5WHnYehh6WHqYeth7GHtYe5h72HwYfFh8mHzYfRh9mH3Yfhh+WH6Yfth/GH9Yf5hAGIBYgJiA2IEYgViB2IJYhNiFGIZYhxiHWIeYiBiI2ImYidiKGIpYitiLWIvYjBiMWIyYjViNmI4YjliOmI7YjxiQmJEYkViRmJKYk9iUGJVYlZiV2JZYlpiXGJdYl5iX2JgYmFiYmJkYmViaGJxYnJidGJ1YndieGJ6YntifWKBYoJig2KFYoZih2KIYotijGKNYo5ij2KQYpRimWKcYp1inmKjYqZip2KpYqpirWKuYq9isGKyYrNitGK2YrdiuGK6Yr5iwGLBYsNiy2LPYtFi1WLdYt5i4GLhYuRi6mLrYvBi8mL1Yvhi+WL6YvtiAGMDYwRjBWMGYwpjC2MMYw1jD2MQYxJjE2MUYxVjF2MYYxljHGMmYydjKWMsYy1jLmMwYzFjM2M0YzVjNmM3YzhjO2M8Yz5jP2NAY0FjRGNHY0hjSmNRY1JjU2NUY1ZjV2NYY1ljWmNbY1xjXWNgY2RjZWNmY2hjamNrY2xjb2NwY3Jjc2N0Y3VjeGN5Y3xjfWN+Y39jgWODY4RjhWOGY4tjjWORY5NjlGOVY5djmWOaY5tjnGOdY55jn2OhY6RjpmOrY69jsWOyY7VjtmO5Y7tjvWO/Y8BjwWPCY8NjxWPHY8hjymPLY8xj0WPTY9Rj1WPXY9hj2WPaY9tj3GPdY99j4mPkY+Vj5mPnY+hj62PsY+5j72PwY/Fj82P1Y/dj+WP6Y/tj/GP+YwNkBGQGZAdkCGQJZApkDWQOZBFkEmQVZBZkF2QYZBlkGmQdZB9kImQjZCRkJWQnZChkKWQrZC5kL2QwZDFkMmQzZDVkNmQ3ZDhkOWQ7ZDxkPmRAZEJkQ2RJZEtkTGRNZE5kT2RQZFFkU2RVZFZkV2RZZFpkW2RcZF1kX2RgZGFkYmRjZGRkZWRmZGhkamRrZGxkbmRvZHBkcWRyZHNkdGR1ZHZkd2R7ZHxkfWR+ZH9kgGSBZINkhmSIZIlkimSLZIxkjWSOZI9kkGSTZJRkl2SYZJpkm2ScZJ1kn2SgZKFkomSjZKVkpmSnZKhkqmSrZK9ksWSyZLNktGS2ZLlku2S9ZL5kv2TBZMNkxGTGZMdkyGTJZMpky2TMZM9k0WTTZNRk1WTWZNlk2mTbZNxk3WTfZOBk4WTjZOVk52ToZOlk6mTrZOxk7WTuZO9k8GTxZPJk82T0ZPVk9mT3ZPhk+WT6ZPtk/GT9ZP5k/2QBZQJlA2UEZQVlBmUHZQhlCmULZQxlDWUOZQ9lEGURZRNlFGUVZRZlF2UZZRplG2UcZR1lHmUfZSBlIWUiZSNlJGUmZSdlKGUpZSplLGUtZTBlMWUyZTNlN2U6ZTxlPWVAZUFlQmVDZURlRmVHZUplS2VNZU5lUGVSZVNlVGVXZVhlWmVcZV9lYGVhZWRlZWVnZWhlaWVqZW1lbmVvZXFlc2V1ZXZleGV5ZXple2V8ZX1lfmV/ZYBlgWWCZYNlhGWFZYZliGWJZYpljWWOZY9lkmWUZZVllmWYZZplnWWeZaBlomWjZaZlqGWqZaxlrmWxZbJls2W0ZbVltmW3ZbhlumW7Zb5lv2XAZcJlx2XIZcllymXNZdBl0WXTZdRl1WXYZdll2mXbZdxl3WXeZd9l4WXjZeRl6mXrZfJl82X0ZfVl+GX5Zftl/GX9Zf5l/2UBZgRmBWYHZghmCWYLZg1mEGYRZhJmFmYXZhhmGmYbZhxmHmYhZiJmI2YkZiZmKWYqZitmLGYuZjBmMmYzZjdmOGY5ZjpmO2Y9Zj9mQGZCZkRmRWZGZkdmSGZJZkpmTWZOZlBmUWZYZllmW2ZcZl1mXmZgZmJmY2ZlZmdmaWZqZmtmbGZtZnFmcmZzZnVmeGZ5ZntmfGZ9Zn9mgGaBZoNmhWaGZohmiWaKZotmjWaOZo9mkGaSZpNmlGaVZphmmWaaZptmnGaeZp9moGahZqJmo2akZqVmpmapZqpmq2asZq1mr2awZrFmsmazZrVmtma3Zrhmuma7ZrxmvWa/ZsBmwWbCZsNmxGbFZsZmx2bIZslmymbLZsxmzWbOZs9m0GbRZtJm02bUZtVm1mbXZthm2mbeZt9m4GbhZuJm42bkZuVm52boZupm62bsZu1m7mbvZvFm9Wb2Zvhm+mb7Zv1mAWcCZwNnBGcFZwZnB2cMZw5nD2cRZxJnE2cWZxhnGWcaZxxnHmcgZyFnImcjZyRnJWcnZylnLmcwZzJnM2c2ZzdnOGc5ZztnPGc+Zz9nQWdEZ0VnR2dKZ0tnTWdSZ1RnVWdXZ1hnWWdaZ1tnXWdiZ2NnZGdmZ2dna2dsZ25ncWd0Z3ZneGd5Z3pne2d9Z4BngmeDZ4VnhmeIZ4pnjGeNZ45nj2eRZ5Jnk2eUZ5ZnmWebZ59noGehZ6RnpmepZ6xnrmexZ7JntGe5Z7pnu2e8Z71nvme/Z8BnwmfFZ8Znx2fIZ8lnymfLZ8xnzWfOZ9Vn1mfXZ9tn32fhZ+Nn5GfmZ+dn6GfqZ+tn7WfuZ/Jn9Wf2Z/dn+Gf5Z/pn+2f8Z/5nAWgCaANoBGgGaA1oEGgSaBRoFWgYaBloGmgbaBxoHmgfaCBoImgjaCRoJWgmaCdoKGgraCxoLWguaC9oMGgxaDRoNWg2aDpoO2g/aEdoS2hNaE9oUmhWaFdoWGhZaFpoW2hcaF1oXmhfaGpobGhtaG5ob2hwaHFocmhzaHVoeGh5aHpoe2h8aH1ofmh/aIBogmiEaIdoiGiJaIpoi2iMaI1ojmiQaJFokmiUaJVolmiYaJlommibaJxonWieaJ9ooGihaKNopGilaKloqmiraKxormixaLJotGi2aLdouGi5aLpou2i8aL1ovmi/aMFow2jEaMVoxmjHaMhoymjMaM5oz2jQaNFo02jUaNZo12jZaNto3GjdaN5o32jhaOJo5GjlaOZo52joaOlo6mjraOxo7WjvaPJo82j0aPZo92j4aPto/Wj+aP9oAGkCaQNpBGkGaQdpCGkJaQppDGkPaRFpE2kUaRVpFmkXaRhpGWkaaRtpHGkdaR5pIWkiaSNpJWkmaSdpKGkpaSppK2ksaS5pL2kxaTJpM2k1aTZpN2k4aTppO2k8aT5pQGlBaUNpRGlFaUZpR2lIaUlpSmlLaUxpTWlOaU9pUGlRaVJpU2lVaVZpWGlZaVtpXGlfaWFpYmlkaWVpZ2loaWlpamlsaW1pb2lwaXJpc2l0aXVpdml6aXtpfWl+aX9pgWmDaYVpimmLaYxpjmmPaZBpkWmSaZNplmmXaZlpmmmdaZ5pn2mgaaFpommjaaRppWmmaalpqmmsaa5pr2mwabJps2m1abZpuGm5abppvGm9ab5pv2nAacJpw2nEacVpxmnHachpyWnLac1pz2nRadJp02nVadZp12nYadlp2mncad1p3mnhaeJp42nkaeVp5mnnaehp6Wnqaetp7Gnuae9p8GnxafNp9Gn1afZp92n4aflp+mn7afxp/mkAagFqAmoDagRqBWoGagdqCGoJagtqDGoNag5qD2oQahFqEmoTahRqFWoWahlqGmobahxqHWoeaiBqImojaiRqJWomaidqKWoraixqLWouajBqMmozajRqNmo3ajhqOWo6ajtqPGo/akBqQWpCakNqRWpGakhqSWpKaktqTGpNak5qT2pRalJqU2pUalVqVmpXalpqXGpdal5qX2pgamJqY2pkamZqZ2poamlqampramxqbWpuam9qcGpyanNqdGp1anZqd2p4anpqe2p9an5qf2qBaoJqg2qFaoZqh2qIaolqimqLaoxqjWqPapJqk2qUapVqlmqYaplqmmqbapxqnWqeap9qoWqiaqNqpGqlaqZqp2qoaqpqrWquaq9qsGqxarJqs2q0arVqtmq3arhquWq6artqvGq9ar5qv2rAasFqwmrDasRqxWrGasdqyGrJaspqy2rMas1qzmrPatBq0WrSatNq1GrVatZq12rYatlq2mrbatxq3Wreat9q4GrhauJq42rkauVq5mrnauhq6Wrqautq7Grtau5q72rwavFq8mrzavRq9Wr2avdq+Gr5avpq+2r8av1q/mr/agBrAWsCawNrBGsFawZrB2sIawlrCmsLawxrDWsOaw9rEGsRaxJrE2sUaxVrFmsXaxhrGWsaaxtrHGsdax5rH2slayZrKGspayprK2ssay1rLmsvazBrMWszazRrNWs2azhrO2s8az1rP2tAa0FrQmtEa0VrSGtKa0trTWtOa09rUGtRa1JrU2tUa1VrVmtXa1hrWmtba1xrXWtea19rYGtha2hraWtra2xrbWtua29rcGtxa3Jrc2t0a3Vrdmt3a3hremt9a35rf2uAa4VriGuMa45rj2uQa5FrlGuVa5drmGuZa5xrnWuea59roGuia6NrpGula6Zrp2uoa6lrq2usa61rrmuva7BrsWuya7ZruGu5a7pru2u8a71rvmvAa8NrxGvGa8dryGvJa8przGvOa9Br0WvYa9pr3Gvda95r32vga+Jr42vka+Vr5mvna+hr6Wvsa+1r7mvwa/Fr8mv0a/Zr92v4a/pr+2v8a/5r/2sAbAFsAmwDbARsCGwJbApsC2wMbA5sEmwXbBxsHWwebCBsI2wlbCtsLGwtbDFsM2w2bDdsOWw6bDtsPGw+bD9sQ2xEbEVsSGxLbExsTWxObE9sUWxSbFNsVmxYbFlsWmxibGNsZWxmbGdsa2xsbG1sbmxvbHFsc2x1bHdseGx6bHtsfGx/bIBshGyHbIpsi2yNbI5skWySbJVslmyXbJhsmmycbJ1snmygbKJsqGysbK9ssGy0bLVstmy3bLpswGzBbMJsw2zGbMdsyGzLbM1szmzPbNFs0mzYbNls2mzcbN1s32zkbOZs52zpbOxs7WzybPRs+Wz/bABtAm0DbQVtBm0IbQltCm0NbQ9tEG0RbRNtFG0VbRZtGG0cbR1tH20gbSFtIm0jbSRtJm0obSltLG0tbS9tMG00bTZtN204bTptP21AbUJtRG1JbUxtUG1VbVZtV21YbVttXW1fbWFtYm1kbWVtZ21obWttbG1tbXBtcW1ybXNtdW12bXltem17bX1tfm1/bYBtgW2DbYRthm2HbYpti22NbY9tkG2SbZZtl22YbZltmm2cbaJtpW2sba1tsG2xbbNttG22bbdtuW26bbttvG29bb5twW3CbcNtyG3JbcptzW3Obc9t0G3SbdNt1G3Vbddt2m3bbdxt323ibeNt5W3nbeht6W3qbe1t723wbfJt9G31bfZt+G36bf1t/m3/bQBuAW4CbgNuBG4GbgduCG4JbgtuD24SbhNuFW4YbhluG24cbh5uH24ibiZuJ24obipuLG4ubjBuMW4zbjVuNm43bjluO248bj1uPm4/bkBuQW5CbkVuRm5HbkhuSW5KbktuTG5PblBuUW5SblVuV25ZblpuXG5dbl5uYG5hbmJuY25kbmVuZm5nbmhuaW5qbmxubW5vbnBucW5ybnNudG51bnZud254bnluem57bnxufW6AboFugm6EboduiG6KbotujG6Nbo5ukW6SbpNulG6VbpZul26Zbppum26dbp5uoG6hbqNupG6mbqhuqW6rbqxurW6ubrBus261brhuuW68br5uv27AbsNuxG7FbsZuyG7JbspuzG7Nbs5u0G7SbtZu2G7Zbttu3G7dbuNu527qbutu7G7tbu5u727wbvFu8m7zbvVu9m73bvhu+m77bvxu/W7+bv9uAG8BbwNvBG8FbwdvCG8KbwtvDG8Nbw5vEG8RbxJvFm8XbxhvGW8abxtvHG8dbx5vH28hbyJvI28lbyZvJ28obyxvLm8wbzJvNG81bzdvOG85bzpvO288bz1vP29Ab0FvQm9Db0RvRW9Ib0lvSm9Mb05vT29Qb1FvUm9Tb1RvVW9Wb1dvWW9ab1tvXW9fb2BvYW9jb2RvZW9nb2hvaW9qb2tvbG9vb3BvcW9zb3Vvdm93b3lve299b35vf2+Ab4Fvgm+Db4Vvhm+Hb4pvi2+Pb5BvkW+Sb5NvlG+Vb5Zvl2+Yb5lvmm+bb51vnm+fb6Bvom+jb6RvpW+mb6hvqW+qb6tvrG+tb65vr2+wb7Fvsm+0b7Vvt2+4b7pvu2+8b71vvm+/b8Fvw2/Eb8Vvxm/Hb8hvym/Lb8xvzW/Ob89v0G/Tb9Rv1W/Wb9dv2G/Zb9pv22/cb91v32/ib+Nv5G/lb+Zv52/ob+lv6m/rb+xv7W/wb/Fv8m/zb/Rv9W/2b/dv+G/5b/pv+2/8b/1v/m//bwBwAXACcANwBHAFcAZwB3AIcAlwCnALcAxwDXAOcA9wEHAScBNwFHAVcBZwF3AYcBlwHHAdcB5wH3AgcCFwInAkcCVwJnAncChwKXAqcCtwLHAtcC5wL3AwcDFwMnAzcDRwNnA3cDhwOnA7cDxwPXA+cD9wQHBBcEJwQ3BEcEVwRnBHcEhwSXBKcEtwTXBOcFBwUXBScFNwVHBVcFZwV3BYcFlwWnBbcFxwXXBfcGBwYXBicGNwZHBlcGZwZ3BocGlwanBucHFwcnBzcHRwd3B5cHpwe3B9cIFwgnCDcIRwhnCHcIhwi3CMcI1wj3CQcJFwk3CXcJhwmnCbcJ5wn3CgcKFwonCjcKRwpXCmcKdwqHCpcKpwsHCycLRwtXC2cLpwvnC/cMRwxXDGcMdwyXDLcMxwzXDOcM9w0HDRcNJw03DUcNVw1nDXcNpw3HDdcN5w4HDhcOJw43DlcOpw7nDwcPFw8nDzcPRw9XD2cPhw+nD7cPxw/nD/cABxAXECcQNxBHEFcQZxB3EIcQtxDHENcQ5xD3ERcRJxFHEXcRtxHHEdcR5xH3EgcSFxInEjcSRxJXEncShxKXEqcStxLHEtcS5xMnEzcTRxNXE3cThxOXE6cTtxPHE9cT5xP3FAcUFxQnFDcURxRnFHcUhxSXFLcU1xT3FQcVFxUnFTcVRxVXFWcVdxWHFZcVpxW3FdcV9xYHFhcWJxY3FlcWlxanFrcWxxbXFvcXBxcXF0cXVxdnF3cXlxe3F8cX5xf3GAcYFxgnGDcYVxhnGHcYhxiXGLcYxxjXGOcZBxkXGScZNxlXGWcZdxmnGbcZxxnXGecaFxonGjcaRxpXGmcadxqXGqcatxrXGuca9xsHGxcbJxtHG2cbdxuHG6cbtxvHG9cb5xv3HAccFxwnHEccVxxnHHcchxyXHKcctxzHHNcc9x0HHRcdJx03HWcddx2HHZcdpx23Hccd1x3nHfceFx4nHjceRx5nHocelx6nHrcexx7XHvcfBx8XHycfNx9HH1cfZx93H4cfpx+3H8cf1x/nH/cQByAXICcgNyBHIFcgdyCHIJcgpyC3IMcg1yDnIPchByEXISchNyFHIVchZyF3IYchlyGnIbchxyHnIfciByIXIiciNyJHIlciZyJ3IpcityLXIuci9yMnIzcjRyOnI8cj5yQHJBckJyQ3JEckVyRnJJckpyS3JOck9yUHJRclNyVHJVcldyWHJaclxyXnJgcmNyZHJlcmhyanJrcmxybXJwcnFyc3J0cnZyd3J4cntyfHJ9coJyg3KFcoZyh3KIcolyjHKOcpBykXKTcpRylXKWcpdymHKZcppym3Kccp1ynnKgcqFyonKjcqRypXKmcqdyqHKpcqpyq3KucrFysnKzcrVyunK7crxyvXK+cr9ywHLFcsZyx3LJcspyy3LMcs9y0XLTctRy1XLWcthy2nLbcsbkx+TI5MnkyuTL5MzkzeTO5M/k0OTR5NLk0+TU5NXk1uTX5Njk2eTa5Nvk3OTd5N7k3+Tg5OHk4uTj5OTk5eTm5Ofk6OTp5Ork6+Ts5O3k7uTv5PDk8eTy5PPk9OT15Pbk9+T45Pnk+uT75Pzk/eT+5P/kAOUB5QLlA+UE5QXlBuUH5QjlCeUK5QvlDOUN5Q7lD+UQ5RHlEuUT5RTlFeUW5RflGOUZ5RrlG+Uc5R3lHuUf5SDlIeUi5SPlJOUl5QAwATACMLcAyQLHAqgAAzAFMBQgXv8WICYgGCAZIBwgHSAUMBUwCDAJMAowCzAMMA0wDjAPMBYwFzAQMBEwsQDXAPcANiInIigiESIPIioiKSIIIjciGiKlIiUiICISI5kiKyIuImEiTCJIIj0iHSJgIm4ibyJkImUiHiI1IjQiQiZAJrAAMiAzIAMhBP+kAOD/4f8wIKcAFiEGJgUmyyXPJc4lxyXGJaEloCWzJbIlOyCSIZAhkSGTIRMwJuUn5SjlKeUq5SvlLOUt5S7lL+Uw5THlMuUz5TTlNeU25TflOOU55TrlO+U85T3lPuU/5UDlQeVC5UPlROVF5UblR+VI5UnlSuVL5UzlTeVO5U/lUOVR5VLlU+VU5VXlVuVX5VjlWeVa5VvlXOVd5V7lX+Vg5WHlYuVj5WTlZeVm5WflaOVp5Wrla+Vs5W3lbuVv5XDlceVy5XPldOV15Xbld+V45XnleuV75XzlfeV+5X/lgOWB5YLlg+WE5YXlcCFxIXIhcyF0IXUhdiF3IXgheSFm52fnaOdp52rna+eIJIkkiiSLJIwkjSSOJI8kkCSRJJIkkySUJJUkliSXJJgkmSSaJJskdCR1JHYkdyR4JHkkeiR7JHwkfSR+JH8kgCSBJIIkgySEJIUkhiSHJGAkYSRiJGMkZCRlJGYkZyRoJGkkrCBt5yAyITIiMiMyJDIlMiYyJzIoMikybudv52AhYSFiIWMhZCFlIWYhZyFoIWkhaiFrIXDnceeG5YfliOWJ5Yrli+WM5Y3ljuWP5ZDlkeWS5ZPllOWV5Zbll+WY5ZnlmuWb5ZzlneWe5Z/loOWh5aLlo+Wk5aXlpuWn5ajlqeWq5avlrOWt5a7lr+Ww5bHlsuWz5bTlteW25bfluOW55brlu+W85b3lvuW/5cDlweXC5cPlxOXF5cblx+XI5cnlyuXL5czlzeXO5c/l0OXR5dLl0+XU5dXl1uXX5djl2eXa5dvl3OXd5d7l3+Xg5eHl4uXj5eTl5eUB/wL/A//l/wX/Bv8H/wj/Cf8K/wv/DP8N/w7/D/8Q/xH/Ev8T/xT/Ff8W/xf/GP8Z/xr/G/8c/x3/Hv8f/yD/If8i/yP/JP8l/yb/J/8o/yn/Kv8r/yz/Lf8u/y//MP8x/zL/M/80/zX/Nv83/zj/Of86/zv/PP89/z7/P/9A/0H/Qv9D/0T/Rf9G/0f/SP9J/0r/S/9M/03/Tv9P/1D/Uf9S/1P/VP9V/1b/V/9Y/1n/Wv9b/1z/Xf/j/+bl5+Xo5enl6uXr5ezl7eXu5e/l8OXx5fLl8+X05fXl9uX35fjl+eX65fvl/OX95f7l/+UA5gHmAuYD5gTmBeYG5gfmCOYJ5grmC+YM5g3mDuYP5hDmEeYS5hPmFOYV5hbmF+YY5hnmGuYb5hzmHeYe5h/mIOYh5iLmI+Yk5iXmJuYn5ijmKeYq5ivmLOYt5i7mL+Yw5jHmMuYz5jTmNeY25jfmOOY55jrmO+Y85j3mPuY/5kDmQeZC5kPmROZF5kEwQjBDMEQwRTBGMEcwSDBJMEowSzBMME0wTjBPMFAwUTBSMFMwVDBVMFYwVzBYMFkwWjBbMFwwXTBeMF8wYDBhMGIwYzBkMGUwZjBnMGgwaTBqMGswbDBtMG4wbzBwMHEwcjBzMHQwdTB2MHcweDB5MHowezB8MH0wfjB/MIAwgTCCMIMwhDCFMIYwhzCIMIkwijCLMIwwjTCOMI8wkDCRMJIwkzBy53PndOd153bnd+d453nneud753znRuZH5kjmSeZK5kvmTOZN5k7mT+ZQ5lHmUuZT5lTmVeZW5lfmWOZZ5lrmW+Zc5l3mXuZf5mDmYeZi5mPmZOZl5mbmZ+Zo5mnmauZr5mzmbeZu5m/mcOZx5nLmc+Z05nXmduZ35njmeeZ65nvmfOZ95n7mf+aA5oHmguaD5oTmheaG5ofmiOaJ5ormi+aM5o3mjuaP5pDmkeaS5pPmlOaV5pbml+aY5pnmmuab5pzmneae5p/moOah5qLmo+ak5qXmoTCiMKMwpDClMKYwpzCoMKkwqjCrMKwwrTCuMK8wsDCxMLIwszC0MLUwtjC3MLgwuTC6MLswvDC9ML4wvzDAMMEwwjDDMMQwxTDGMMcwyDDJMMowyzDMMM0wzjDPMNAw0TDSMNMw1DDVMNYw1zDYMNkw2jDbMNww3TDeMN8w4DDhMOIw4zDkMOUw5jDnMOgw6TDqMOsw7DDtMO4w7zDwMPEw8jDzMPQw9TD2MH3nfud/54DngeeC54PnhOem5qfmqOap5qrmq+as5q3mruav5rDmseay5rPmtOa15rbmt+a45rnmuua75rzmvea+5r/mwObB5sLmw+bE5sXmxubH5sjmyebK5svmzObN5s7mz+bQ5tHm0ubT5tTm1ebW5tfm2ObZ5trm2+bc5t3m3ubf5uDm4ebi5uPm5Obl5ubm5+bo5unm6ubr5uzm7ebu5u/m8Obx5vLm8+b05vXm9ub35vjm+eb65vvm/Ob95v7m/+YA5wHnAucD5wTnBeeRA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdA54DnwOgA6EDowOkA6UDpgOnA6gDqQOF54bnh+eI54nniueL54znsQOyA7MDtAO1A7YDtwO4A7kDugO7A7wDvQO+A78DwAPBA8MDxAPFA8YDxwPIA8kDjeeO54/nkOeR55Lnk+c1/jb+Of46/j/+QP49/j7+Qf5C/kP+RP6U55XnO/48/jf+OP4x/pbnM/40/pfnmOeZ55rnm+ec553nnuef5wbnB+cI5wnnCucL5wznDecO5w/nEOcR5xLnE+cU5xXnFucX5xjnGeca5xvnHOcd5x7nH+cg5yHnIucj5yTnJecm5yfnKOcp5yrnK+cs5y3nLucv5zDnMecy5zPnNOc15zbnN+c45znnOuc75zznPec+5z/nQOdB50LnQ+dE50XnRudH50jnSedK50vnTOdN507nT+dQ51HnUudT51TnVedW51fnWOdZ51rnW+dc513nXudf52DnYedi52PnZOdl5xAEEQQSBBMEFAQVBAEEFgQXBBgEGQQaBBsEHAQdBB4EHwQgBCEEIgQjBCQEJQQmBCcEKAQpBCoEKwQsBC0ELgQvBKDnoeei56PnpOel56bnp+eo56nnquer56znreeu5zAEMQQyBDMENAQ1BFEENgQ3BDgEOQQ6BDsEPAQ9BD4EPwRABEEEQgRDBEQERQRGBEcESARJBEoESwRMBE0ETgRPBK/nsOex57Lns+e057Xntue357jnuee657vnygLLAtkCEyAVICUgNSAFIQkhliGXIZghmSEVIh8iIyJSImYiZyK/IlAlUSVSJVMlVCVVJVYlVyVYJVklWiVbJVwlXSVeJV8lYCVhJWIlYyVkJWUlZiVnJWglaSVqJWslbCVtJW4lbyVwJXElciVzJYElgiWDJYQlhSWGJYcliCWJJYoliyWMJY0ljiWPJZMllCWVJbwlvSXiJeMl5CXlJQkmlSISMB0wHjC8573nvue/58DnwefC58PnxOfF58bnAQHhAM4B4AATAekAGwHoACsB7QDQAewATQHzANIB8gBrAfoA1AH5ANYB2AHaAdwB/ADqAFECx+dEAUgB+QFhAsnnyufL58znBTEGMQcxCDEJMQoxCzEMMQ0xDjEPMRAxETESMRMxFDEVMRYxFzEYMRkxGjEbMRwxHTEeMR8xIDEhMSIxIzEkMSUxJjEnMSgxKTHN587nz+fQ59Hn0ufT59Tn1efW59fn2OfZ59rn2+fc593n3uff5+Dn4echMCIwIzAkMCUwJjAnMCgwKTCjMo4zjzOcM50znjOhM8QzzjPRM9Iz1TMw/uL/5P/i5yEhMTLj5xAg5Ofl5+bn/DCbMJww/TD+MAYwnTCeMEn+Sv5L/kz+Tf5O/k/+UP5R/lL+VP5V/lb+V/5Z/lr+W/5c/l3+Xv5f/mD+Yf5i/mP+ZP5l/mb+aP5p/mr+a/4+MPAv8S/yL/Mv9C/1L/Yv9y/4L/kv+i/7Lwcw9Of15/bn9+f45/nn+uf75/zn/ef+5//nAOgAJQElAiUDJQQlBSUGJQclCCUJJQolCyUMJQ0lDiUPJRAlESUSJRMlFCUVJRYlFyUYJRklGiUbJRwlHSUeJR8lICUhJSIlIyUkJSUlJiUnJSglKSUqJSslLCUtJS4lLyUwJTElMiUzJTQlNSU2JTclOCU5JTolOyU8JT0lPiU/JUAlQSVCJUMlRCVFJUYlRyVIJUklSiVLJQHoAugD6AToBegG6AfoCOgJ6AroC+gM6A3oDugP6Nxy3XLfcuJy43LkcuVy5nLncupy63L1cvZy+XL9cv5y/3IAcwJzBHMFcwZzB3MIcwlzC3MMcw1zD3MQcxFzEnMUcxhzGXMacx9zIHMjcyRzJnMncyhzLXMvczBzMnMzczVzNnM6cztzPHM9c0BzQXNCc0NzRHNFc0ZzR3NIc0lzSnNLc0xzTnNPc1FzU3NUc1VzVnNYc1lzWnNbc1xzXXNec19zYXNic2NzZHNlc2ZzZ3Noc2lzanNrc25zcHNxcwDgAeAC4APgBOAF4AbgB+AI4AngCuAL4AzgDeAO4A/gEOAR4BLgE+AU4BXgFuAX4BjgGeAa4BvgHOAd4B7gH+Ag4CHgIuAj4CTgJeAm4CfgKOAp4CrgK+As4C3gLuAv4DDgMeAy4DPgNOA14DbgN+A44DngOuA74DzgPeA+4D/gQOBB4ELgQ+BE4EXgRuBH4EjgSeBK4EvgTOBN4E7gT+BQ4FHgUuBT4FTgVeBW4FfgWOBZ4FrgW+Bc4F3gcnNzc3RzdXN2c3dzeHN5c3pze3N8c31zf3OAc4FzgnODc4VzhnOIc4pzjHONc49zkHOSc5NzlHOVc5dzmHOZc5pznHOdc55zoHOhc6NzpHOlc6Zzp3Ooc6pzrHOtc7FztHO1c7ZzuHO5c7xzvXO+c79zwXPDc8RzxXPGc8dzy3PMc85z0nPTc9Rz1XPWc9dz2HPac9tz3HPdc99z4XPic+Nz5HPmc+hz6nPrc+xz7nPvc/Bz8XPzc/Rz9XP2c/dzXuBf4GDgYeBi4GPgZOBl4GbgZ+Bo4GngauBr4GzgbeBu4G/gcOBx4HLgc+B04HXgduB34HjgeeB64HvgfOB94H7gf+CA4IHgguCD4ITgheCG4IfgiOCJ4Irgi+CM4I3gjuCP4JDgkeCS4JPglOCV4Jbgl+CY4JngmuCb4JzgneCe4J/goOCh4KLgo+Ck4KXgpuCn4KjgqeCq4KvgrOCt4K7gr+Cw4LHgsuCz4LTgteC24LfguOC54Lrgu+D4c/lz+nP7c/xz/XP+c/9zAHQBdAJ0BHQHdAh0C3QMdA10DnQRdBJ0E3QUdBV0FnQXdBh0GXQcdB10HnQfdCB0IXQjdCR0J3QpdCt0LXQvdDF0MnQ3dDh0OXQ6dDt0PXQ+dD90QHRCdEN0RHRFdEZ0R3RIdEl0SnRLdEx0TXROdE90UHRRdFJ0U3RUdFZ0WHRddGB0YXRidGN0ZHRldGZ0Z3RodGl0anRrdGx0bnRvdHF0cnRzdHR0dXR4dHl0enS84L3gvuC/4MDgweDC4MPgxODF4Mbgx+DI4MngyuDL4MzgzeDO4M/g0ODR4NLg0+DU4NXg1uDX4Njg2eDa4Nvg3ODd4N7g3+Dg4OHg4uDj4OTg5eDm4Ofg6ODp4Org6+Ds4O3g7uDv4PDg8eDy4PPg9OD14Pbg9+D44Png+uD74Pzg/eD+4P/gAOEB4QLhA+EE4QXhBuEH4QjhCeEK4QvhDOEN4Q7hD+EQ4RHhEuET4RThFeEW4RfhGOEZ4Xt0fHR9dH90gnSEdIV0hnSIdIl0inSMdI10j3SRdJJ0k3SUdJV0lnSXdJh0mXSadJt0nXSfdKB0oXSidKN0pHSldKZ0qnSrdKx0rXSudK90sHSxdLJ0s3S0dLV0tnS3dLh0uXS7dLx0vXS+dL90wHTBdMJ0w3TEdMV0xnTHdMh0yXTKdMt0zHTNdM50z3TQdNF003TUdNV01nTXdNh02XTadNt03XTfdOF05XTndOh06XTqdOt07HTtdPB08XTydBrhG+Ec4R3hHuEf4SDhIeEi4SPhJOEl4SbhJ+Eo4SnhKuEr4SzhLeEu4S/hMOEx4TLhM+E04TXhNuE34TjhOeE64TvhPOE94T7hP+FA4UHhQuFD4UThReFG4UfhSOFJ4UrhS+FM4U3hTuFP4VDhUeFS4VPhVOFV4VbhV+FY4VnhWuFb4VzhXeFe4V/hYOFh4WLhY+Fk4WXhZuFn4WjhaeFq4WvhbOFt4W7hb+Fw4XHhcuFz4XThdeF24Xfh83T1dPh0+XT6dPt0/HT9dP50AHUBdQJ1A3UFdQZ1B3UIdQl1CnULdQx1DnUQdRJ1FHUVdRZ1F3UbdR11HnUgdSF1InUjdSR1JnUndSp1LnU0dTZ1OXU8dT11P3VBdUJ1Q3VEdUZ1R3VJdUp1TXVQdVF1UnVTdVV1VnVXdVh1XXVedV91YHVhdWJ1Y3VkdWd1aHVpdWt1bHVtdW51b3VwdXF1c3V1dXZ1d3V6dXt1fHV9dX51gHWBdYJ1hHWFdYd1eOF54Xrhe+F84X3hfuF/4YDhgeGC4YPhhOGF4Ybhh+GI4YnhiuGL4YzhjeGO4Y/hkOGR4ZLhk+GU4ZXhluGX4ZjhmeGa4ZvhnOGd4Z7hn+Gg4aHhouGj4aThpeGm4afhqOGp4arhq+Gs4a3hruGv4bDhseGy4bPhtOG14bbht+G44bnhuuG74bzhveG+4b/hwOHB4cLhw+HE4cXhxuHH4cjhyeHK4cvhzOHN4c7hz+HQ4dHh0uHT4dTh1eGIdYl1inWMdY11jnWQdZN1lXWYdZt1nHWedaJ1pnWndah1qXWqda11tnW3dbp1u3W/dcB1wXXGdct1zHXOdc910HXRddN113XZddp13HXddd914HXhdeV16XXsde117nXvdfJ183X1dfZ193X4dfp1+3X9df51AnYEdgZ2B3YIdgl2C3YNdg52D3YRdhJ2E3YUdhZ2GnYcdh12HnYhdiN2J3Yodix2LnYvdjF2MnY2djd2OXY6djt2PXZBdkJ2RHbW4dfh2OHZ4drh2+Hc4d3h3uHf4eDh4eHi4ePh5OHl4ebh5+Ho4enh6uHr4ezh7eHu4e/h8OHx4fLh8+H04fXh9uH34fjh+eH64fvh/OH94f7h/+EA4gHiAuID4gTiBeIG4gfiCOIJ4griC+IM4g3iDuIP4hDiEeIS4hPiFOIV4hbiF+IY4hniGuIb4hziHeIe4h/iIOIh4iLiI+Ik4iXiJuIn4ijiKeIq4iviLOIt4i7iL+Iw4jHiMuIz4kV2RnZHdkh2SXZKdkt2TnZPdlB2UXZSdlN2VXZXdlh2WXZadlt2XXZfdmB2YXZidmR2ZXZmdmd2aHZpdmp2bHZtdm52cHZxdnJ2c3Z0dnV2dnZ3dnl2enZ8dn92gHaBdoN2hXaJdop2jHaNdo92kHaSdpR2lXaXdph2mnabdpx2nXaedp92oHahdqJ2o3aldqZ2p3aodql2qnardqx2rXavdrB2s3a1drZ2t3a4drl2una7drx2vXa+dsB2wXbDdkpVP5bDVyhjzlQJVcBUkXZMdjyF7nd+go14MXKYlo2XKGyJW/pPCWOXZrhc+oBIaK6AAmbOdvlRVmWscfF/hIiyUGVZymGzb62CTGNSYu1TJ1QGe2tRpHX0XdRiy412l4piGYBdVziXYn84cn12z2d+dkZkcE8ljdxiF3qRZe1zLGRzYiyCgZh/Z0hybmLMYjRP43RKU55Syn6mkC5ehmicaYCB0X7SaMV4jIZRlY1QJIzegt6ABVMSiWVSxHbHdsl2y3bMdtN21XbZdtp23Hbddt524HbhduJ243bkduZ253bodul26nbrdux27XbwdvN29Xb2dvd2+nb7dv12/3YAdwJ3A3cFdwZ3CncMdw53D3cQdxF3EncTdxR3FXcWdxd3GHcbdxx3HXcedyF3I3ckdyV3J3cqdyt3LHcudzB3MXcydzN3NHc5dzt3PXc+dz93QndEd0V3RndId0l3SndLd0x3TXdOd093UndTd1R3VXdWd1d3WHdZd1x3hIX5lt1PIVhxmZ1bsWKlYrRmeYyNnAZyb2eReLJgUVMXU4iPzIAdjaGUDVDIcgdZ62AZcauIVFnvgixnKHspXfd+LXX1bGaO+I88kDuf1GsZkRR7fF+neNaEPYXVa9lr1msBXode+XXtlV1lCl/FX5+PwVjCgX+QW5atl7mPFn8sjUFiv0/YU15TqI+pj6uPTZAHaGpfmIFoiNaci2ErUip2bF+MZdJv6G6+W0hkdVGwUcRnGU7JeXyZs3Bdd153X3dgd2R3Z3dpd2p3bXdud293cHdxd3J3c3d0d3V3dnd3d3h3end7d3x3gXeCd4N3hneHd4h3iXeKd4t3j3eQd5N3lHeVd5Z3l3eYd5l3mnebd5x3nXeed6F3o3ekd6Z3qHerd613rnevd7F3sne0d7Z3t3e4d7l3une8d753wHfBd8J3w3fEd8V3xnfHd8h3yXfKd8t3zHfOd8930HfRd9J303fUd9V31nfYd9l32nfdd95333fgd+F35HfFdXZeu3Pgg61k6GK1lOJsWlPDUg9kwpSUey9PG142ghaBioEkbspsc5pVY1xT+lRliOBXDU4DXmVrP3zokBZg5mQcc8GIUGdNYiKNbHcpjseRaV/cgyGFEJnCU5WGi2vtYOhgf3DNgjGC006nbM+FzWTZfP1p+WZJg5VTVnunT4xRS21CXG2O0mPJUyyDNoPlZ7R4PWTfW5Rc7l3ni8Zi9Gd6jABkumNJh4uZF4wgf/KUp04QlqSYDGYWc+Z36Hfqd+938Hfxd/J39Hf1d/d3+Xf6d/t3/HcDeAR4BXgGeAd4CHgKeAt4DngPeBB4E3gVeBl4G3geeCB4IXgieCR4KHgqeCt4LngveDF4MngzeDV4Nng9eD94QXhCeEN4RHhGeEh4SXhKeEt4TXhPeFF4U3hUeFh4WXhaeFt4XHheeF94YHhheGJ4Y3hkeGV4ZnhneGh4aXhveHB4cXhyeHN4dHh1eHZ4eHh5eHp4e3h9eH54f3iAeIF4gniDeDpXHVw4Xn+Vf1CggIJTXmVFdTFVIVCFjYRinpQdZzJWbm/iXTVUknBmj29ipGSjY3tfiG/0kOOBsI8YXGhm8V+JbEiWgY1siJFk8HnOV1lqEGJIVFhOC3rpYIRv2ot/Yh6Qi5rkeQNU9HUBYxlTYGzfjxtfcJo7gH+fiE86XGSNxX+lZb1wRVGyUWuGB12gW71ibJF0dQyOIHoBYXl7x074foV3EU7tgR1S+lFxaqhTh44Elc+WwW5kllpphHiFeIZ4iHiKeIt4j3iQeJJ4lHiVeJZ4mXideJ54oHiieKR4pnioeKl4qnireKx4rXiueK94tXi2eLd4uHi6eLt4vHi9eL94wHjCeMN4xHjGeMd4yHjMeM14znjPeNF40njTeNZ413jYeNp423jceN143njfeOB44XjieON45HjleOZ453jpeOp463jteO5473jwePF483j1ePZ4+Hj5ePt4/Hj9eP54/3gAeQJ5A3kEeQZ5B3kIeQl5CnkLeQx5QHioUNd3EGTmiQRZ42PdXX96PWkgTzmCmFUyTq51l3piXope75UbUjlUinB2YySVglclZj9ph5EHVfNtr34iiDNi8H61dSiDwXjMlp6PSGH3dM2LZGs6UlCNIWtqgHGE8VYGU85OG07RUZd8i5EHfMNPf47he5x6Z2QUXaxQBoEBdrl87G3gf1FnWFv4W8t4rmQTZKpjK2MZlS1kvo9Ueyl2U2InWUZUeWujUDRiJl6Ga+NON42LiIVfLpANeQ55D3kQeRF5EnkUeRV5FnkXeRh5GXkaeRt5HHkdeR95IHkheSJ5I3kleSZ5J3koeSl5KnkreSx5LXkueS95MHkxeTJ5M3k1eTZ5N3k4eTl5PXk/eUJ5Q3lEeUV5R3lKeUt5THlNeU55T3lQeVF5UnlUeVV5WHlZeWF5Y3lkeWZ5aXlqeWt5bHlueXB5cXlyeXN5dHl1eXZ5eXl7eXx5fXl+eX95gnmDeYZ5h3mIeYl5i3mMeY15jnmQeZF5knkgYD2AxWI5TlVT+JC4Y8aA5mUubEZP7mDhbd6LOV/LhlNfIWNaUWGDY2gAUmNjSI4SUJtcd3n8WzBSO3q8YFOQ13a3X5dfhHZsjm9we3ZJe6p381GTkCRYTk/0buqPTGUbe8RypG3ff+FatWKVXjBXgoQsex1eH18SkBR/oJiCY8dumHi5cHhRW5erVzV1Q084dZde5mBgWcBtv2uJePxT1ZbLUQFSiWMKVJOUA4zMjTlyn3h2h+2PDYzgU5N5lHmVeZZ5l3mYeZl5m3mceZ15nnmfeaB5oXmieaN5pHmleaZ5qHmpeap5q3msea15rnmvebB5sXmyebR5tXm2ebd5uHm8eb95wnnEecV5x3nIecp5zHnOec950HnTedR51nnXedl52nnbedx53XneeeB54XnieeV56Hnqeex57nnxefJ583n0efV59nn3efl5+nn8ef55/3kBegR6BXoHegh6CXoKegx6D3oQehF6EnoTehV6FnoYehl6G3ocegFO73buU4mUdpgOny2VmluiiyJOHE6sUWOEwmGoUgtol09rYLtRHm1cUZZil2VhlkaMF5DYdf2QY3fSa4py7HL7izVYeXdMjVxnQJWagKZeIW6SWe967Xc7lbVrrWUOfwZYUVEflvlbqVgoVHKOZmV/mORWnZT+dkGQh2PGVBpZOlmbV7KONWf6jTWCQVLwYBVY/oboXEWexE+dmLmLJVp2YIRTfGJPkAKRf5lpYAyAP1EzgBRcdZkxbYxOHXofeiF6InokeiV6Jnoneih6KXoqeit6LHotei56L3owejF6Mno0ejV6Nno4ejp6PnpAekF6QnpDekR6RXpHekh6SXpKekt6THpNek56T3pQelJ6U3pUelV6VnpYell6Wnpbelx6XXpeel96YHphemJ6Y3pkemV6Znpnemh6aXpqemt6bHptem56b3pxenJ6c3p1ent6fHp9en56gnqFeod6iXqKeot6jHqOeo96kHqTepR6mXqaept6nnqheqJ6MI3RU1p/T3sQT09OAJbVbNBz6YUGXmp1+38Kav53kpRBfuFR5nDNU9SPA4Mpja9ybZnbbEpXs4K5ZaqAP2IylqhZ/06/i7p+PmXyg16XYVXemKWAKlP9iyBUuoCfXrhsOY2sglqRKVQbbAZSt35fVxpxfmyJfEtZ/U7/XyRhqnwwTgFcq2cCh/BcC5XOmK91/XAikK9RHX+9i0lZ5FFbTyZUK1l3ZaSAdVt2YsJikI9FXh9sJnsPT9hPDWejeqR6p3qpeqp6q3queq96sHqxerJ6tHq1erZ6t3q4erl6unq7erx6vXq+esB6wXrCesN6xHrFesZ6x3rIesl6ynrMes16znrPetB60XrSetN61HrVetd62Hraett63HrdeuF64nrkeud66Hrpeup663rseu568HrxevJ683r0evV69nr3evh6+3r8ev56AHsBewJ7BXsHewl7DHsNew57EHsSexN7FnsXexh7Gnscex17H3sheyJ7I3sneyl7LXtubaptj3mxiBdfK3WaYoWP70/ckadlL4FRgZxeUIF0jW9SholLjQ1ZhVDYThyWNnJ5gR+NzFuji0SWh1kaf5BUdlYOVuWLOWWCaZmU1naJbnJeGHVGZ9Fn/3qdgHaNH2HGeWJlY42IURpSopQ4f5uAsn6XXC9uYGfZe4t22JqPgZR/1XweZFCVP3pKVOVUTGsBZAhiPZ7zgJl1clJpl1uEPGjkhgGWlJbslCpOBFTZfjlo340VgPRmml65fy97MHsyezR7NXs2ezd7OXs7ez17P3tAe0F7QntDe0R7RntIe0p7TXtOe1N7VXtXe1l7XHtee197YXtje2R7ZXtme2d7aHtpe2p7a3tse217b3twe3N7dHt2e3h7ent8e317f3uBe4J7g3uEe4Z7h3uIe4l7inuLe4x7jnuPe5F7knuTe5Z7mHuZe5p7m3uee597oHuje6R7pXuue697sHuye7N7tXu2e7d7uXu6e7t7vHu9e757v3vAe8J7w3vEe8JXP4CXaOVdO2WfUm1gmp+bT6yObFGrWxNf6V1ebPFiIY1xUamU/lKfbN+C13KiV4RnLY0fWZyPx4OVVI17ME+9bGRb0VkTn+RTyoaomjeMoYBFZX6Y+lbHli5S3HRQUuFbAmMCiVZO0GIqYPpoc1GYW6BRwomhe4aZUH/vYExwL41JUX9eG5BwdMSJLVdFeFJfn5/6lWiPPJvhi3h2QmjcZ+qNNY09UoqP2m7NaAWV7ZD9Vpxn+YjHj8hUxXvIe8l7ynvLe817znvPe9B70nvUe9V71nvXe9h723vce95733vge+J743vke+d76Hvpe+t77Hvte+978Hvye/N79Hv1e/Z7+Hv5e/p7+3v9e/97AHwBfAJ8A3wEfAV8BnwIfAl8CnwNfA58EHwRfBJ8E3wUfBV8F3wYfBl8GnwbfBx8HXwefCB8IXwifCN8JHwlfCh8KXwrfCx8LXwufC98MHwxfDJ8M3w0fDV8Nnw3fDl8Onw7fDx8PXw+fEJ8uJppW3dtJmylTrNbh5pjkahhr5DplytUtW3SW/1RilVVf/B/vGRNY/FlvmGNYApxV2xJbC9ZbWcqgtVYjlZqjOtr3ZB9WReA91NpbXVUnVV3g8+DOGi+eYxUVU8IVNJ2iYwClrNsuG1rjRCJZJ46jT9W0Z7VdYhf4HJoYPxUqE4qamGIUmBwj8RU2HB5hj+eKm2PWxhfon6JVa9PNHM8VJpTGVAOVHxUTk79X1p09lhrhOGAdIfQcsp8Vm5DfER8RXxGfEd8SHxJfEp8S3xMfE58T3xQfFF8UnxTfFR8VXxWfFd8WHxZfFp8W3xcfF18XnxffGB8YXxifGN8ZHxlfGZ8Z3xofGl8anxrfGx8bXxufG98cHxxfHJ8dXx2fHd8eHx5fHp8fnx/fIB8gXyCfIN8hHyFfIZ8h3yIfIp8i3yMfI18jnyPfJB8k3yUfJZ8mXyafJt8oHyhfKN8pnynfKh8qXyrfKx8rXyvfLB8tHy1fLZ8t3y4fLp8u3wnX06GLFWkYpJOqmw3YrGC11ROUz5z0W47dRJSFlPdi9Bpil8AYO5tT1cia69zU2jYjxN/YmOjYCRV6nVijBVxo22mW3teUoNMYcSe+nhXhyd8h3bwUfZgTHFDZkxeTWAOjHBwJWOJj71fYmDUht5WwWuUYGdhSVPgYGZmP439eRpP6XBHbLOL8ovYfmSDD2ZaWkKbUW33bUGMO20ZT2twt4MWYtFgDZcnjXh5+1E+V/pXOmd4dT1673mVe798wHzCfMN8xHzGfMl8y3zOfM980HzRfNJ803zUfNh82nzbfN183nzhfOJ843zkfOV85nznfOl86nzrfOx87XzufPB88XzyfPN89Hz1fPZ893z5fPp8/Hz9fP58/3wAfQF9An0DfQR9BX0GfQd9CH0JfQt9DH0NfQ59D30QfRF9En0TfRR9FX0WfRd9GH0ZfRp9G30cfR19Hn0ffSF9I30kfSV9Jn0ofSl9Kn0sfS19Ln0wfTF9Mn0zfTR9NX02fYyAZZn5j8BvpYshnuxZ6X4JfwlUgWfYaJGPTXzGlspTJWC+dXJsc1PJWqd+JGPgUQqB8V3fhIBigFFjWw5PbXlCUrhgTm3EW8JboYuwi+JlzF9FlpNZ536qfglWt2c5WXNPtlugUlqDipg+jTJ1vpRHUDx69062Z36awVp8a9F2WlcWXDp79JVOcXxRqYBwgnhZBH8ng8Bo7GexeHd442JhY4B77U9qUs9RUIPbaXSS9Y0xjcGJLpWte/ZON304fTl9On07fTx9PX0+fT99QH1BfUJ9Q31EfUV9Rn1HfUh9SX1KfUt9TH1NfU59T31QfVF9Un1TfVR9VX1WfVd9WH1ZfVp9W31cfV19Xn1ffWB9YX1ifWN9ZH1lfWZ9Z31ofWl9an1rfWx9bX1vfXB9cX1yfXN9dH11fXZ9eH15fXp9e318fX19fn1/fYB9gX2CfYN9hH2FfYZ9h32IfYl9in2LfYx9jX2OfY99kH2RfZJ9k32UfZV9ln2XfZh9ZVAwglFSb5kQboVup236XvVQ3FkGXEZtX2yGdYuEaGhWWbKLIFNxkU2WSYUSaQF5JnH2gKROypBHbYSaB1q8VgVk8JTrd6VPGoHhctKJepk0f95+f1JZZXWRf4+Dj+tTlnrtY6Vjhnb4eVeINpYqYqtSgoJUaHBnd2Nrd+16AW3TfuOJ0FkSYsmFpYJMdR9Qy06ldeuLSlz+XUt7pGXRkcpOJW1fiSd9JpXFTiiM249zl0tmgXnRj+xweG2ZfZp9m32cfZ19nn2ffaB9oX2ifaN9pH2lfad9qH2pfap9q32sfa19r32wfbF9sn2zfbR9tX22fbd9uH25fbp9u328fb19vn2/fcB9wX3CfcN9xH3FfcZ9x33Ifcl9yn3Lfcx9zX3Ofc990H3RfdJ9033UfdV91n3Xfdh92X3afdt93H3dfd59333gfeF94n3jfeR95X3mfed96H3pfep9633sfe197n3vffB98X3yffN99H31ffZ99334ffl9+n09XLJSRoNiUQ6DW3d2ZricrE7KYL58s3zPfpVOZotvZoiYWZeDWGxlXJWEX8l1Vpffet56wFGvcJh66mN2eqB+lnPtl0VOeHBdTlKRqVNRZedl/IEFgo5UMVyadaCX2GLZcr11RVx5msqDQFyAVOl3Pk6ubFqA0mJuY+hdd1HdjR6OL5XxT+VT52CscGdSUGNDnh9aJlA3d3dT4n6FZCtliWKYYxRQNXLJibNRwIvdfkdXzIOnlJtRG1T7XPt9/H39ff59/30AfgF+An4DfgR+BX4Gfgd+CH4Jfgp+C34Mfg1+Dn4PfhB+EX4SfhN+FH4VfhZ+F34Yfhl+Gn4bfhx+HX4efh9+IH4hfiJ+I34kfiV+Jn4nfih+KX4qfit+LH4tfi5+L34wfjF+Mn4zfjR+NX42fjd+OH45fjp+PH49fj5+P35AfkJ+Q35EfkV+Rn5Ifkl+Sn5Lfkx+TX5Ofk9+UH5RflJ+U35UflV+Vn5Xflh+WX5aflt+XH5dfspP43pabeGQj5qAVZZUYVOvVABf6WN3ae9RaGEKUipY2FJOVw14C3e3Xndh4HxbYpdiok6VcAOA92LkcGCXd1fbgu9n9WjVeJeY0XnzWLNU71M0bktRO1KiW/6Lr4BDVaZXc2BRVy1UenpQYFRbp2OgYuNTY2LHW69n7VSfeuaCd5GTXuSIOFmuVw5j6I3vgFdXd3upT+tfvVs+ayFTUHvCckZo/3c2d/dltVGPTtR2v1ylenWETllBm4BQXn5ffmB+YX5ifmN+ZH5lfmZ+Z35ofml+an5rfmx+bX5ufm9+cH5xfnJ+c350fnV+dn53fnh+eX56fnt+fH59fn5+f36AfoF+g36EfoV+hn6Hfoh+iX6Kfot+jH6Nfo5+j36QfpF+kn6TfpR+lX6Wfpd+mH6Zfpp+nH6dfp5+rn60frt+vH7WfuR+7H75fgp/EH8efzd/OX87fzx/PX8+fz9/QH9Bf0N/Rn9Hf0h/SX9Kf0t/TH9Nf05/T39Sf1N/iJknYYNuZFcGZkZj8FbsYmli014UloNXyWKHVSGHSoGjj2ZVsYNlZ1aN3YRqWg9o5mLuexGWcFGcbzCM/WPIidJhBn/CcOVuBXSUafxyyl7OkBdnam1eY7NSYnIBgGxP5VlqkdlwnW3SUlBO95ZtlX6FyngvfSFRklfCZIuAe3zqbPFoXmm3UZhTqGiBcs6e8Xv4crt5E28GdE5nzJGknDx5iYNUgw9UF2g9TolTsVI+eIZTKVKIUItP0E9Wf1l/W39cf11/Xn9gf2N/ZH9lf2Z/Z39rf2x/bX9vf3B/c391f3Z/d394f3p/e398f31/f3+Af4J/g3+Ef4V/hn+Hf4h/iX+Lf41/j3+Qf5F/kn+Tf5V/ln+Xf5h/mX+bf5x/oH+if6N/pX+mf6h/qX+qf6t/rH+tf65/sX+zf7R/tX+2f7d/un+7f75/wH/Cf8N/xH/Gf8d/yH/Jf8t/zX/Pf9B/0X/Sf9N/1n/Xf9l/2n/bf9x/3X/ef+J/43/idct6knylbLaWm1KDdOlU6U9UgLKD3o9wlcleHGCfbRheW2U4gf6US2C8cMN+rnzJUYFosXxvgiROho/PkX5mrk4FjKlkSoDaUJd1znHlW72PZm+GToJkY5XWXpllF1LCiMhwo1IOczN0l2f3eBaXNE67kN6cy23bUUGNHVTOYrJz8YP2loSfw5Q2T5p/zFF1cHWWrVyGmOZT5E6cbgl0tGlreI+ZWXUYUiR2QW3zZ21RmZ9LgJlUPHu/euR/53/of+p/63/sf+1/73/yf/R/9X/2f/d/+H/5f/p//X/+f/9/AoAHgAiACYAKgA6AD4ARgBOAGoAbgB2AHoAfgCGAI4AkgCuALIAtgC6AL4AwgDKANIA5gDqAPIA+gECAQYBEgEWAR4BIgEmAToBPgFCAUYBTgFWAVoBXgFmAW4BcgF2AXoBfgGCAYYBigGOAZIBlgGaAZ4BogGuAbIBtgG6Ab4BwgHKAc4B0gHWAdoB3gHiAeYB6gHuAfIB9gIaWhFfiYkeWfGkEWgJk03sPb0uWpoJiU4WYkF6JcLNjZFNPhoGck56MeDKX741CjX+eXm+EeVVfRpYuYnSaFVTdlKNPxWVlXGFcFX9Rhi9si1+Hc+Ru/37mXBtjalvmbnVTcU6gY2V1oWJujyZP0U6mbLZ+uosdhLqHV387kCOVqXuhmviIPYQbbYaa3H6IWbuem3MBeIKGbJqCmhtWF1TLV3BOpp5WU8iPCYGSd5KZ7obhbhOF/GZiYStvfoCBgIKAhYCIgIqAjYCOgI+AkICRgJKAlICVgJeAmYCegKOApoCngKiArICwgLOAtYC2gLiAuYC7gMWAx4DIgMmAyoDLgM+A0IDRgNKA04DUgNWA2IDfgOCA4oDjgOaA7oD1gPeA+YD7gP6A/4AAgQGBA4EEgQWBB4EIgQuBDIEVgReBGYEbgRyBHYEfgSCBIYEigSOBJIElgSaBJ4EogSmBKoErgS2BLoEwgTOBNIE1gTeBOYE6gTuBPIE9gT+BKYySgiuD8nYTbNlfvYMrcwWDGpXba9t3xpRvUwKDklE9XoyMOI1ITqtzmmeFaHaRCZdkcaFsCXeSWkGVz2uOfydm0Fu5WZpa6JX3lexODISZhKxq33YwlRtzpmhfWy93mpFhl9x8948cjCVfc3zYecWJzGwch8ZbQl7JaCB39X6VUU1RyVIpWgV/YpfXgs9jhHfQhdJ5Om6ZXplZEYVtcBFsv2K/dk9lr2D9lQ5mn4cjnu2UDVR9VCyMeGRAgUGBQoFDgUSBRYFHgUmBTYFOgU+BUoFWgVeBWIFbgVyBXYFegV+BYYFigWOBZIFmgWiBaoFrgWyBb4FygXOBdYF2gXeBeIGBgYOBhIGFgYaBh4GJgYuBjIGNgY6BkIGSgZOBlIGVgZaBl4GZgZqBnoGfgaCBoYGigaSBpYGngamBq4Gsga2BroGvgbCBsYGygbSBtYG2gbeBuIG5gbyBvYG+gb+BxIHFgceByIHJgcuBzYHOgc+B0IHRgdKB04F5ZBGGIWqcgeh4aWRUm7liK2erg6hY2J6rbCBv3ltMlguMX3LQZ8diYXKpTsZZzWuTWK5mVV7fUlVhKGfudmZ3Z3JGev9i6lRQVKCUo5AcWrN+FmxDTnZZEIBIWVdTN3W+lspWIGMRgXxg+ZXWbWJUgZmFUela/YCuWROXKlDlbDxc32JgTz9Te4EGkLpuK4XIYnRevni1ZHtj9V8YWn+RH54/XE9jQoB9W25VSpVNlYVtqGDgZ95y3VGBW9SB1YHWgdeB2IHZgdqB24Hcgd2B3oHfgeCB4YHigeSB5YHmgeiB6YHrge6B74HwgfGB8oH1gfaB94H4gfmB+oH9gf+BA4IHggiCCYIKgguCDoIPghGCE4IVghaCF4IYghmCGoIdgiCCJIIlgiaCJ4Ipgi6CMoI6gjyCPYI/gkCCQYJCgkOCRYJGgkiCSoJMgk2CToJQglGCUoJTglSCVYJWgleCWYJbglyCXYJegmCCYYJigmOCZIJlgmaCZ4Jpgudi3mxbcm1irpS9fhOBU22cUQRfdFmqUhJgc1mWZlCGn3UqY+Zh73z6i+ZUJ2slnrRr1YVVVHZQpGxqVbSNLHIVXhVgNnTNYpJjTHKYX0NuPm0AZVhv2HbQePx2VHUkUttTU06eXsFlKoDWgJtihlQoUq5wjYjRjeFseFTagPlX9IhUjWqWTZFpT5tst1XGdjB4qGL5cI5vbV/shNpofHj3e6iBC2dPnmdjsHhvVxJ4OZd5YqtiiFI1dNdraoJrgmyCbYJxgnWCdoJ3gniCe4J8goCCgYKDgoWChoKHgomCjIKQgpOClIKVgpaCmoKbgp6CoIKigqOCp4KygrWCtoK6gruCvIK/gsCCwoLDgsWCxoLJgtCC1oLZgtqC3YLigueC6ILpguqC7ILtgu6C8ILygvOC9YL2gviC+oL8gv2C/oL/ggCDCoMLgw2DEIMSgxODFoMYgxmDHYMegx+DIIMhgyKDI4MkgyWDJoMpgyqDLoMwgzKDN4M7gz2DZFU+gbJ1rnY5U951+1BBXGyLx3tPUEdyl5rYmAJv4nRoeYdkpXf8YpGYK43BVFiAUk5qV/mCDYRzXu1R9nTEi09cYVf8bIeYRlo0eESb64+VfFZSUWL6lMZOhoNhhOmDsoTUVzRnA1duZmZtMYzdZhFwH2c6axZoGmK7WQNOxFEGb9Jnj2x2UctoR1lna2Z1Dl0QgVCf12VIeUF5kZp3jYJcXk4BTy9UUVkMeGhWFGzEjwNffWzjbKuLkGM+gz+DQYNCg0SDRYNIg0qDS4NMg02DToNTg1WDVoNXg1iDWYNdg2KDcINxg3KDc4N0g3WDdoN5g3qDfoN/g4CDgYOCg4ODhIOHg4iDioOLg4yDjYOPg5CDkYOUg5WDloOXg5mDmoOdg5+DoYOig6ODpIOlg6aDp4Osg62DroOvg7WDu4O+g7+DwoPDg8SDxoPIg8mDy4PNg86D0IPRg9KD04PVg9eD2YPag9uD3oPig+OD5IPmg+eD6IPrg+yD7YNwYD1tdXJmYo6UxZRDU8GPfnvfTiaMfk7UnrGUs5RNUlxvY5BFbTSMEVhMXSBrSWuqZ1tUVIGMf5lYN4U6X6JiR2o5lXJlhGBlaKd3VE6oT+ddmJesZNh/7VzPT416B1IEgxROL2CDeqaUtU+yTuZ5NHTkUrmC0mS9ed1bgWxSl3uPImw+UH9TBW7OZHRmMGzFYHeY94uGXjx0d3rLeRhOsZADdEJs2lZLkcVsi406U8aG8mavjkhccZogbu6D74Pzg/SD9YP2g/eD+oP7g/yD/oP/gwCEAoQFhAeECIQJhAqEEIQShBOEFIQVhBaEF4QZhBqEG4QehB+EIIQhhCKEI4QphCqEK4QshC2ELoQvhDCEMoQzhDSENYQ2hDeEOYQ6hDuEPoQ/hECEQYRChEOERIRFhEeESIRJhEqES4RMhE2EToRPhFCEUoRThFSEVYRWhFiEXYRehF+EYIRihGSEZYRmhGeEaIRqhG6Eb4RwhHKEdIR3hHmEe4R8hNZTNlqLn6ONu1MIV6eYQ2ebkclsaFHKdfNirHI4Up1SOn+UcDh2dFNKnrdpbnjAltmIpH82ccNxiVHTZ+R05FgYZbdWqYt2mXBi1X75YO1w7FjBTrpOzV/nl/tOpIsDUopZq35UYs1O5WUOYjiDyYRjg42HlHG2brlb0n6XUclj1GeJgDmDFYgSUXpbglmxj3NOXWxlUSWJb48ulkqFXnQQlfCVpm3lgjFfkmQSbSiEboHDnF5YW40JTsFTfYR+hH+EgISBhIOEhISFhIaEioSNhI+EkISRhJKEk4SUhJWEloSYhJqEm4SdhJ6En4SghKKEo4SkhKWEpoSnhKiEqYSqhKuErISthK6EsISxhLOEtYS2hLeEu4S8hL6EwITChMOExYTGhMeEyITLhMyEzoTPhNKE1ITVhNeE2ITZhNqE24TchN6E4YTihOSE54TohOmE6oTrhO2E7oTvhPGE8oTzhPSE9YT2hPeE+IT5hPqE+4T9hP6EAIUBhQKFHk9jZVFo01UnThRkmpprYsJaX3Rygqlt7mjnUI6DAnhAZzlSmWyxfrtQZVVecVt7UmbKc+uCSWdxXCBSfXFriOqVVZbFZGGNs4GEVVVsR2Iuf5JYJE9GVU+NTGYKThpc84iiaE5jDXrncI2C+lL2lxFc6FS1kM1+YllKjceGDIINgmaNRGQEXFFhiW0+eb6LN3gzdXtUOE+rjvFtIFrFfl55iGyhW3ZaGnW+gE5hF27wWB91JXVyckdT834DhQSFBYUGhQeFCIUJhQqFC4UNhQ6FD4UQhRKFFIUVhRaFGIUZhRuFHIUdhR6FIIUihSOFJIUlhSaFJ4UohSmFKoUthS6FL4UwhTGFMoUzhTSFNYU2hT6FP4VAhUGFQoVEhUWFRoVHhUuFTIVNhU6FT4VQhVGFUoVThVSFVYVXhViFWoVbhVyFXYVfhWCFYYVihWOFZYVmhWeFaYVqhWuFbIVthW6Fb4VwhXGFc4V1hXaFd4V4hXyFfYV/hYCFgYUBd9t2aVLcgCNXCF4xWe5yvWV/bteLOFxxhkFT83f+YvZlwE7fmICGnlvGi/JT4nd/T05cdprLWQ9fOnnrWBZO/2eLTu1ik4odkL9SL2bcVWxWApDVTo1PypFwmQ9sAl5DYKRbxonVizZlS2KWmYhb/1uIYy5V11Mmdn1RLIWiZ7NoimuSYpOP1FMSgtFtj3VmTk6NcFufca+FkWbZZnJ/AIfNniCfXlwvZ/CPEWhfZw1i1nqFWLZecGUxb4KFg4WGhYiFiYWKhYuFjIWNhY6FkIWRhZKFk4WUhZWFloWXhZiFmYWahZ2FnoWfhaCFoYWihaOFpYWmhaeFqYWrhayFrYWxhbKFs4W0hbWFtoW4hbqFu4W8hb2FvoW/hcCFwoXDhcSFxYXGhceFyIXKhcuFzIXNhc6F0YXShdSF1oXXhdiF2YXahduF3YXehd+F4IXhheKF44XlheaF54XoheqF64Xshe2F7oXvhfCF8YXyhfOF9IX1hfaF94X4hVVgN1INgFRkcIgpdQVeE2j0YhyXzFM9cgGMNGxhdw56LlSsd3qYHIL0i1V4FGfBcK9llWQ2Vh1gwXn4Ux1Oe2uGgPpb41XbVjpPPE9ymfNdfmc4gAJggpgBkItbvIv1ixxkWILeZP1Vz4JlkddPIH0fkJ9881BRWK9uv1vJi4OAeJGchJd7fYaLlo+W5X7Tmo54gVxXekKQp5ZfeVlbX2MLe9GErWgGVSl/EHQifQGVQGJMWNZOg1t5WVRY+YX6hfyF/YX+hQCGAYYChgOGBIYGhgeGCIYJhgqGC4YMhg2GDoYPhhCGEoYThhSGFYYXhhiGGYYahhuGHIYdhh6GH4YghiGGIoYjhiSGJYYmhiiGKoYrhiyGLYYuhi+GMIYxhjKGM4Y0hjWGNoY3hjmGOoY7hj2GPoY/hkCGQYZChkOGRIZFhkaGR4ZIhkmGSoZLhkyGUoZThlWGVoZXhliGWYZbhlyGXYZfhmCGYYZjhmSGZYZmhmeGaIZphmqGbXMeY0uOD47OgNSCrGLwU/BsXpEqWQFgcGxNV0pkKo0rduluW1eAavB1bW8tjAiMZlfva5KIs3iiY/lTrXBkbFhYKmQCWOBom4EQVdZ8GFC6jsxtn43rcI9jm23UbuZ+BIRDaAOQ2G12lqiLV1l5cuSFfoG8dYqKr2hUUiKOEZXQY5iYRI58VVNP/2aPVtVglW1DUklcKVn7bWtYMHUcdWxgFIJGgRFjYWfijzp38400jcGUFl6FUyxUw3Bthm+GcIZyhnOGdIZ1hnaGd4Z4hoOGhIaFhoaGh4aIhomGjoaPhpCGkYaShpSGloaXhpiGmYaahpuGnoafhqCGoYaihqWGpoarhq2GroayhrOGt4a4hrmGu4a8hr2Gvoa/hsGGwobDhsWGyIbMhs2G0obThtWG1obXhtqG3IbdhuCG4YbihuOG5YbmhueG6IbqhuuG7IbvhvWG9ob3hvqG+4b8hv2G/4YBhwSHBYcGhwuHDIcOhw+HEIcRhxSHFodAbPdeXFCtTq1eOmNHghqQUGhukbN3DFTclGRf5Xp2aEVjUnvfftt1d1CVYjRZD5D4UcN5gXr+VpJfFJCCbWBcH1cQVFRRTW7iVqhjk5h/gRWHKokAkB5Ub1zAgdZiWGIxgTWeQJZumnyaLWmlWdNiPlUWY8dU2YY8bQNa5nSciGprFllMjC9ffm6pc32YOE73cIxbl3g9Y1pmlnbLYJtbSVoHTlWBamyLc6FOiWdRf4Bf+mUbZ9hfhFkBWhmHG4cdhx+HIIckhyaHJ4cohyqHK4cshy2HL4cwhzKHM4c1hzaHOIc5hzqHPIc9h0CHQYdCh0OHRIdFh0aHSodLh02HT4dQh1GHUodUh1WHVodYh1qHW4dch12HXodfh2GHYodmh2eHaIdph2qHa4dsh22Hb4dxh3KHc4d1h3eHeId5h3qHf4eAh4GHhIeGh4eHiYeKh4yHjoePh5CHkYeSh5SHlYeWh5iHmYeah5uHnIedh56HoIehh6KHo4ekh81drl9xU+aX3Y9FaPRWL1XfYDpOTW/0fseCDoTUWR9PKk8+XKx+KmcahXNUT3XDgIJVT5tNTy1uE4wJXHBha1MfdiluioaHZfuVuX47VDN6Cn3uleFVwX/udB1jF4ehbZ16EWKhZWdT4WODbOtdXFSolExOYWzsi0tc4GWcgqdoPlQ0VMtrZmuUTkJjSFMegg1Prk9eVwpi/pZkZmly/1KhUp9g74sUZplxkGd/iVJ4/XdwZjtWOFQhlXpypYemh6eHqYeqh66HsIexh7KHtIe2h7eHuIe5h7uHvIe+h7+HwYfCh8OHxIfFh8eHyIfJh8yHzYfOh8+H0IfUh9WH1ofXh9iH2Yfah9yH3Yfeh9+H4Yfih+OH5Ifmh+eH6Ifph+uH7Ifth++H8Ifxh/KH84f0h/WH9of3h/iH+of7h/yH/Yf/hwCIAYgCiASIBYgGiAeICIgJiAuIDIgNiA6ID4gQiBGIEogUiBeIGIgZiBqIHIgdiB6IH4ggiCOIAHpvYAxeiWCdgRVZ3GCEce9wqm5QbIByhGqtiC1eYE6zWpxV45QXbft8mZYPYsZ+jnd+hiNTHpeWj4dm4VygT+1yC06mUw9ZE1SAYyiVSFHZTpycpH64VCSNVIg3gvKVjm0mX8xaPmZplrBzLnO/U3qBhZmhf6pbd5ZQlr9++HaiU3aVmZmxe0SJWG5hTtR/ZXnmi/NgzVSrTnmY911has9QEVRhjCeEXXgEl0pS7lSjVgCViG21W8ZtU2YkiCWIJogniCiIKYgqiCuILIgtiC6IL4gwiDGIM4g0iDWINog3iDiIOog7iD2IPog/iEGIQohDiEaIR4hIiEmISohLiE6IT4hQiFGIUohTiFWIVohYiFqIW4hciF2IXohfiGCIZohniGqIbYhviHGIc4h0iHWIdoh4iHmIeoh7iHyIgIiDiIaIh4iJiIqIjIiOiI+IkIiRiJOIlIiViJeImIiZiJqIm4idiJ6In4igiKGIo4iliKaIp4ioiKmIqogPXF1bIWiWgHhVEXtIZVRpm05Ha06Hi5dPUx9jOmSqkJxlwYAQjJlRsGh4U/mHyGHEbPtsIoxRXKqFr4IMlSNrm4+wZftfw1/hT0WIH2ZlgSlz+mB0URFSi1diX6KQTIiSkXheT2cnYNNZRFH2UfiACFN5bMSWinERT+5Pnn89Z8VVCJXAeZaI436fWAxiAJdahhhWe5iQX7iLxIRXkdlT7WWPXlx1ZGBufX9a6n7tfmmPp1WjW6xgy2WEc6yIroiviLCIsoiziLSItYi2iLiIuYi6iLuIvYi+iL+IwIjDiMSIx4jIiMqIy4jMiM2Iz4jQiNGI04jWiNeI2ojbiNyI3YjeiOCI4YjmiOeI6YjqiOuI7IjtiO6I74jyiPWI9oj3iPqI+4j9iP+IAIkBiQOJBIkFiQaJB4kIiQmJC4kMiQ2JDokPiRGJFIkViRaJF4kYiRyJHYkeiR+JIIkiiSOJJIkmiSeJKIkpiSyJLYkuiS+JMYkyiTOJNYk3iQmQY3Ypd9p+dJebhWZbdHrqlkCIy1KPcapf7GXii/tbb5rhXYlrW2yti6+LCpDFj4tTvGImni2eQFQrTr2CWXKchhZdWYivbcWW0VSaTraLCXG9VAmW33D5bdB2JU4UeBKHqVz2XgCKnJgOlo5wv2xEWaljPHdNiBRvc4IwWNVxjFMaeMGWAVVmXzBxtFsajIyag2suWS+e53loZ2xib0+hdYp/C20zlids8E7SdXtRN2g+b4CQcIGWWXZ0OIk5iTqJO4k8iT2JPok/iUCJQolDiUWJRolHiUiJSYlKiUuJTIlNiU6JT4lQiVGJUolTiVSJVYlWiVeJWIlZiVqJW4lciV2JYIlhiWKJY4lkiWWJZ4loiWmJaolriWyJbYluiW+JcIlxiXKJc4l0iXWJdol3iXiJeYl6iXyJfYl+iYCJgomEiYWJh4mIiYmJiomLiYyJjYmOiY+JkImRiZKJk4mUiZWJlomXiZiJmYmaiZuJnImdiZ6Jn4mgiaGJR2QnXGWQkXojjNpZrFQAgm+DgYkAgDBpTlY2gDdyzpG2UV9OdZiWYxpO9lPzZkuBHFmybQBO+Vg7U9Zj8ZSdTwpPY4iQmDdZV5D7eepO8ICRdYJsnFvoWV1fBWmBhhpQ8l1ZTuN35U56gpFiE2aRkHlcv055X8aBOJCEgKt1pk7UiA9hxWvGX0lOynaibuOLrosKjNGLAl/8f8x/zn41g2uD4Fa3a/OXNJb7WR9U9pTrbcVbbpk5XBVfkJaiiaOJpImliaaJp4moiamJqomriayJrYmuia+JsImxibKJs4m0ibWJtom3ibiJuYm6ibuJvIm9ib6Jv4nAicOJzYnTidSJ1YnXidiJ2Ynbid2J34ngieGJ4onkieeJ6InpieqJ7Intie6J8InxifKJ9In1ifaJ94n4ifmJ+on7ifyJ/Yn+if+JAYoCigOKBIoFigaKCIoJigqKC4oMig2KDooPihCKEYoSihOKFIoVihaKF4oYihmKGoobihyKHYpwU/GCMWp0WnCelF4of7mDJIQlhGeDR4fOj2KNyHZxX5aYbHggZt9U5WJjT8OByHW4Xs2WCo75ho9U82yMbThsf2DHUih1fV4YT6Bg518kXDF1rpDAlLlyuWw4bkmRCWfLU/NTUU/JkfGLyFN8XsKP5G2OTsJ2hmlehhphBoJZT95PPpB8nAlhHW4UboWWiE4xWuiWDk5/XLl5h1vti71/iXPfV4uCwZABVEeQu1XqXKFfCGEya/FysoCJih6KH4ogiiGKIoojiiSKJYomiieKKIopiiqKK4osii2KLoovijCKMYoyijOKNIo1ijaKN4o4ijmKOoo7ijyKPYo/ikCKQYpCikOKRIpFikaKR4pJikqKS4pMik2KTopPilCKUYpSilOKVIpVilaKV4pYilmKWopbilyKXYpeil+KYIphimKKY4pkimWKZopnimiKaYpqimuKbIptim6Kb4pwinGKcopzinSKdYp2ineKeIp6inuKfIp9in6Kf4qAinRt01vViISYa4xtmjOeCm6kUUNRo1eBiJ9T9GOVj+1WWFQGVz9zkG4Yf9yP0YI/YShgYpbwZqZ+io3DjaWUs1ykfAhnpmAFlhiAkU7nkABTaJZBUdCPdIVdkVVm9ZdVWx1TOHhCZz1oyVR+cLBbfY+NUShXsVQSZYJmXo1DjQ+BbIRtkN98/1H7haNn6WWhb6SGgY5qViCQgnZ2cOVxI43pYhlS/Ww8jQ5gnliOYf5mYI1OYrNVI24tZ2ePgYqCioOKhIqFioaKh4qIiouKjIqNio6Kj4qQipGKkoqUipWKloqXipiKmYqaipuKnIqdip6Kn4qgiqGKooqjiqSKpYqmiqeKqIqpiqqKq4qsiq2KroqvirCKsYqyirOKtIq1iraKt4q4irmKuoq7iryKvYq+ir+KwIrBisKKw4rEisWKxorHisiKyYrKisuKzIrNis6Kz4rQitGK0orTitSK1YrWiteK2IrZitqK24rcit2K3orfiuCK4YriiuOK4ZT4lSh3BWioaYtUTU64cMiLWGSLZYVbhHo6UOhbu3fha3mKmHy+bM92qWWXjy1dVVw4hghoYFMYYtl6W279fh9q4HpwXzNvIF+MY6htVmcIThBeJo3XTsCANHaclttiLWZ+YrxsdY1ncWl/RlGHgOxTbpCYYvJU8IaZjwWAF5UXhdmPWW3Nc59lH3cEdSd4+4EejYiUpk+VZ7l1yosHly9jR5U1lriEI2NBd4Ff8HKJThRgdGXvYmNrP2XkiuWK5orniuiK6YrqiuuK7Irtiu6K74rwivGK8orzivSK9Yr2iveK+Ir5ivqK+4r8iv2K/or/igCLAYsCiwOLBIsFiwaLCIsJiwqLC4sMiw2LDosPixCLEYsSixOLFIsVixaLF4sYixmLGosbixyLHYseix+LIIshiyKLI4skiyWLJ4soiymLKosriyyLLYsuiy+LMIsxizKLM4s0izWLNos3iziLOYs6izuLPIs9iz6LP4tAi0GLQotDi0SLRYsnXsd10ZDBi52CnWcvZTFUGIfld6KAAoFBbEtOx35MgPR2DWmWa2diPFCET0BXB2Nia76N6lPoZbh+118aY7dj84H0gW5/HF7ZXDZSembpeRp6KI2ZcNR13m67bJJ6LU7FduBfn5R3iMh+zXm/gM2R8k4XTx+CaFTeXTJtzIulfHSPmIAaXpJUsXaZWzxmpJrgcypo24YxZypz+IvbixCQ+XrbcG5xxGKpdzFWO05XhPFnqVLAhi6N+JRRe0aLR4tIi0mLSotLi0yLTYtOi0+LUItRi1KLU4tUi1WLVotXi1iLWYtai1uLXItdi16LX4tgi2GLYotji2SLZYtni2iLaYtqi2uLbYtui2+LcItxi3KLc4t0i3WLdot3i3iLeYt6i3uLfIt9i36Lf4uAi4GLgouDi4SLhYuGi4eLiIuJi4qLi4uMi42LjouPi5CLkYuSi5OLlIuVi5aLl4uYi5mLmoubi5yLnYuei5+LrIuxi7uLx4vQi+qLCYwejE9P6GxdeXuak2Iqcv1iE04WeGyPsGRajcZ7aWiEXsWIhlmeZO5YtnIOaSWV/Y9YjWBXAH8GjMZRSWPZYlNTTGgidAGDTJFEVUB3fHBKbXlRqFREjf9Zy27EbVxbK33UTn18025QW+qBDW5XWwOb1Wgqjpdb/H47YLV+uZBwjU9ZzWPfebONUlPPZVZ5xYs7lsR+u5SCfjRWiZEAZ2p/Clx1kChm5l1QT95nWlBcT1BXp14Q6BHoEugT6BToOIw5jDqMO4w8jD2MPow/jECMQoxDjESMRYxIjEqMS4xNjE6MT4xQjFGMUoxTjFSMVoxXjFiMWYxbjFyMXYxejF+MYIxjjGSMZYxmjGeMaIxpjGyMbYxujG+McIxxjHKMdIx1jHaMd4x7jHyMfYx+jH+MgIyBjIOMhIyGjIeMiIyLjI2MjoyPjJCMkYySjJOMlYyWjJeMmYyajJuMnIydjJ6Mn4ygjKGMooyjjKSMpYymjKeMqIypjKqMq4ysjK2MjU4MTkBREE7/XkVTFU6YTh5OMptsW2lWKE66eT9OFVNHTi1ZO3JuUxBs31bkgJeZ02t+dxefNk6fThCfXE5pTpNOiIJbW2xVD1bETo1TnVOjU6VTrlNll12NGlP1UyZTLlM+U1yNZlNjUwJSCFIOUi1SM1I/UkBSTFJeUmFSXFKvhH1SglKBUpBSk1KCUVR/u07DTslOwk7oTuFO607eThtP804iT2RP9U4lTydPCU8rT15PZ084ZVpPXU+ujK+MsIyxjLKMs4y0jLWMtoy3jLiMuYy6jLuMvIy9jL6Mv4zAjMGMwozDjMSMxYzGjMeMyIzJjMqMy4zMjM2MzozPjNCM0YzSjNOM1IzVjNaM14zYjNmM2ozbjNyM3YzejN+M4IzhjOKM44zkjOWM5oznjOiM6YzqjOuM7IztjO6M74zwjPGM8ozzjPSM9Yz2jPeM+Iz5jPqM+4z8jP2M/oz/jACNAY0CjQONBI0FjQaNB40IjQmNCo0LjQyNDY1fT1dPMk89T3ZPdE+RT4lPg0+PT35Pe0+qT3xPrE+UT+ZP6E/qT8VP2k/jT9xP0U/fT/hPKVBMUPNPLFAPUC5QLVD+TxxQDFAlUChQflBDUFVQSFBOUGxQe1ClUKdQqVC6UNZQBlHtUOxQ5lDuUAdRC1HdTj1sWE9lT85PoJ9GbHR8blH9XcmemJmBURRZ+VINUweKEFPrURlZVVGgTlZRs05uiKSItU4UgdKIgHk0WwOIuH+rUbFRvVG8UQ6ND40QjRGNEo0TjRSNFY0WjReNGI0ZjRqNG40cjSCNUY1SjVeNX41ljWiNaY1qjWyNbo1vjXGNco14jXmNeo17jXyNfY1+jX+NgI2CjYONho2HjYiNiY2MjY2Njo2PjZCNko2TjZWNlo2XjZiNmY2ajZuNnI2djZ6NoI2hjaKNpI2ljaaNp42ojamNqo2rjayNrY2uja+NsI2yjbaNt425jbuNvY3AjcGNwo3FjceNyI3JjcqNzY3QjdKN043UjcdRllGiUaVRoIumi6eLqou0i7WLt4vCi8OLy4vPi86L0ovTi9SL1ovYi9mL3Ivfi+CL5Ivoi+mL7ovwi/OL9ov5i/yL/4sAjAKMBIwHjAyMD4wRjBKMFIwVjBaMGYwbjBiMHYwfjCCMIYwljCeMKowrjC6ML4wyjDOMNYw2jGlTelMdliKWIZYxliqWPZY8lkKWSZZUll+WZ5ZslnKWdJaIlo2Wl5awlpeQm5CdkJmQrJChkLSQs5C2kLqQ1Y3YjdmN3I3gjeGN4o3ljeaN543pje2N7o3wjfGN8o30jfaN/I3+jf+NAI4BjgKOA44EjgaOB44IjguODY4OjhCOEY4SjhOOFY4WjheOGI4ZjhqOG44cjiCOIY4kjiWOJo4njiiOK44tjjCOMo4zjjSONo43jjiOO448jj6OP45DjkWORo5Mjk2OTo5PjlCOU45UjlWOVo5XjliOWo5bjlyOXY5ejl+OYI5hjmKOY45kjmWOZ45ojmqOa45ujnGOuJCwkM+QxZC+kNCQxJDHkNOQ5pDikNyQ15DbkOuQ75D+kASRIpEekSORMZEvkTmRQ5FGkQ1SQlmiUqxSrVK+Uv9U0FLWUvBS31Pucc139F71UfxRL5u2UwFfWnXvXUxXqVehV35YvFjFWNFYKVcsVypXM1c5Vy5XL1dcVztXQldpV4VXa1eGV3xXe1doV21XdldzV61XpFeMV7JXz1enV7RXk1egV9VX2FfaV9lX0le4V/RX71f4V+RX3VdzjnWOd454jnmOeo57jn2Ofo6AjoKOg46EjoaOiI6JjoqOi46Mjo2Ojo6RjpKOk46VjpaOl46YjpmOmo6bjp2On46gjqGOoo6jjqSOpY6mjqeOqI6pjqqOrY6ujrCOsY6zjrSOtY62jreOuI65jruOvI69jr6Ov47AjsGOwo7DjsSOxY7GjseOyI7JjsqOy47Mjs2Oz47QjtGO0o7TjtSO1Y7WjteO2I7ZjtqO247cjt2O3o7fjuCO4Y7ijuOO5I4LWA1Y/VftVwBYHlgZWERYIFhlWGxYgViJWJpYgFiomRmf/2F5gn2Cf4KPgoqCqIKEgo6CkYKXgpmCq4K4gr6CsILIgsqC44KYgreCroLLgsyCwYKpgrSCoYKqgp+CxILOgqSC4YIJg/eC5IIPgweD3IL0gtKC2IIMg/uC04IRgxqDBoMUgxWD4ILVghyDUYNbg1yDCIOSgzyDNIMxg5uDXoMvg0+DR4NDg1+DQIMXg2CDLYM6gzODZoNlg+WO5o7njuiO6Y7qjuuO7I7tju6O747wjvGO8o7zjvSO9Y72jveO+I75jvqO+478jv2O/o7/jgCPAY8CjwOPBI8FjwaPB48IjwmPCo8LjwyPDY8Ojw+PEI8RjxKPE48UjxWPFo8XjxiPGY8ajxuPHI8djx6PH48gjyGPIo8jjySPJY8mjyePKI8pjyqPK48sjy2PLo8vjzCPMY8yjzOPNI81jzaPN484jzmPOo87jzyPPY8+jz+PQI9Bj0KPQ49Ej2iDG4Npg2yDaoNtg26DsIN4g7ODtIOgg6qDk4Ocg4WDfIO2g6mDfYO4g3uDmIOeg6iDuoO8g8GDAYTlg9iDB1gYhAuE3YP9g9aDHIQ4hBGEBoTUg9+DD4QDhPiD+YPqg8WDwIMmhPCD4YNchFGEWoRZhHOEh4SIhHqEiYR4hDyERoRphHaEjISOhDGEbYTBhM2E0ITmhL2E04TKhL+EuoTghKGEuYS0hJeE5YTjhAyFDXU4hfCEOYUfhTqFRY9Gj0ePSI9Jj0qPS49Mj02PTo9Pj1CPUY9Sj1OPVI9Vj1aPV49Yj1mPWo9bj1yPXY9ej1+PYI9hj2KPY49kj2WPao+Aj4yPko+dj6CPoY+ij6SPpY+mj6ePqo+sj62Pro+vj7KPs4+0j7WPt4+4j7qPu4+8j7+PwI/Dj8aPyY/Kj8uPzI/Nj8+P0o/Wj9eP2o/gj+GP44/nj+yP74/xj/KP9I/1j/aP+o/7j/yP/o//jweQCJAMkA6QE5AVkBiQVoU7hf+E/IRZhUiFaIVkhV6FeoWid0OFcoV7haSFqIWHhY+FeYWuhZyFhYW5hbeFsIXThcGF3IX/hSeGBYYphhaGPIb+XghfPFlBWTeAVVlaWVhZD1MiXCVcLFw0XExiamKfYrtiymLaYtdi7mIiY/ZiOWNLY0NjrWP2Y3FjemOOY7RjbWOsY4pjaWOuY7xj8mP4Y+Bj/2PEY95jzmNSZMZjvmNFZEFkC2QbZCBkDGQmZCFkXmSEZG1klmQZkByQI5AkkCWQJ5AokCmQKpArkCyQMJAxkDKQM5A0kDeQOZA6kD2QP5BAkEOQRZBGkEiQSZBKkEuQTJBOkFSQVZBWkFmQWpBckF2QXpBfkGCQYZBkkGaQZ5BpkGqQa5BskG+QcJBxkHKQc5B2kHeQeJB5kHqQe5B8kH6QgZCEkIWQhpCHkImQipCMkI2QjpCPkJCQkpCUkJaQmJCakJyQnpCfkKCQpJClkKeQqJCpkKuQrZCykLeQvJC9kL+QwJB6ZLdkuGSZZLpkwGTQZNdk5GTiZAllJWUuZQtf0l8ZdRFfX1PxU/1T6VPoU/tTElQWVAZUS1RSVFNUVFRWVENUIVRXVFlUI1QyVIJUlFR3VHFUZFSaVJtUhFR2VGZUnVTQVK1UwlS0VNJUp1SmVNNU1FRyVKNU1VS7VL9UzFTZVNpU3FSpVKpUpFTdVM9U3lQbVedUIFX9VBRV81QiVSNVD1URVSdVKlVnVY9VtVVJVW1VQVVVVT9VUFU8VcKQw5DGkMiQyZDLkMyQzZDSkNSQ1ZDWkNiQ2ZDakN6Q35DgkOOQ5JDlkOmQ6pDskO6Q8JDxkPKQ85D1kPaQ95D5kPqQ+5D8kP+QAJEBkQORBZEGkQeRCJEJkQqRC5EMkQ2RDpEPkRCREZESkRORFJEVkRaRF5EYkRqRG5EckR2RH5EgkSGRJJElkSaRJ5EokSmRKpErkSyRLZEukTCRMpEzkTSRNZE2kTeROJE6kTuRPJE9kT6RP5FAkUGRQpFEkTdVVlV1VXZVd1UzVTBVXFWLVdJVg1WxVblViFWBVZ9VflXWVZFVe1XfVb1VvlWUVZlV6lX3VclVH1bRVetV7FXUVeZV3VXEVe9V5VXyVfNVzFXNVehV9VXkVZSPHlYIVgxWAVYkViNW/lUAVidWLVZYVjlWV1YsVk1WYlZZVlxWTFZUVoZWZFZxVmtWe1Z8VoVWk1avVtRW11bdVuFW9VbrVvlW/1YEVwpXCVccVw9eGV4UXhFeMV47XjxeRZFHkUiRUZFTkVSRVZFWkViRWZFbkVyRX5FgkWaRZ5FokWuRbZFzkXqRe5F8kYCRgZGCkYORhJGGkYiRipGOkY+Rk5GUkZWRlpGXkZiRmZGckZ2RnpGfkaCRoZGkkaWRppGnkaiRqZGrkayRsJGxkbKRs5G2kbeRuJG5kbuRvJG9kb6Rv5HAkcGRwpHDkcSRxZHGkciRy5HQkdKR05HUkdWR1pHXkdiR2ZHakduR3ZHekd+R4JHhkeKR45HkkeWRN15EXlReW15eXmFejFx6XI1ckFyWXIhcmFyZXJFcmlycXLVcoly9XKxcq1yxXKNcwVy3XMRc0lzkXMtc5VwCXQNdJ10mXS5dJF0eXQZdG11YXT5dNF09XWxdW11vXV1da11LXUpdaV10XYJdmV2dXXOMt13FXXNfd1+CX4dfiV+MX5VfmV+cX6hfrV+1X7xfYohhX61ysHK0crdyuHLDcsFyznLNctJy6HLvculy8nL0cvdyAXPzcgNz+nLmkeeR6JHpkeqR65Hske2R7pHvkfCR8ZHykfOR9JH1kfaR95H4kfmR+pH7kfyR/ZH+kf+RAJIBkgKSA5IEkgWSBpIHkgiSCZIKkguSDJINkg6SD5IQkhGSEpITkhSSFZIWkheSGJIZkhqSG5Ickh2SHpIfkiCSIZIikiOSJJIlkiaSJ5IokimSKpIrkiySLZIuki+SMJIxkjKSM5I0kjWSNpI3kjiSOZI6kjuSPJI9kj6SP5JAkkGSQpJDkkSSRZL7chdzE3MhcwpzHnMdcxVzInM5cyVzLHM4czFzUHNNc1dzYHNsc29zfnMbgiVZ55gkWQJZY5lnmWiZaZlqmWuZbJl0mXeZfZmAmYSZh5mKmY2ZkJmRmZOZlJmVmYBekV6LXpZepV6gXrletV6+XrNeU43SXtFe217oXupeuoHEX8lf1l/PXwNg7l8EYOFf5F/+XwVgBmDqX+1f+F8ZYDVgJmAbYA9gDWApYCtgCmA/YCFgeGB5YHtgemBCYEaSR5JIkkmSSpJLkkySTZJOkk+SUJJRklKSU5JUklWSVpJXkliSWZJakluSXJJdkl6SX5JgkmGSYpJjkmSSZZJmkmeSaJJpkmqSa5Jskm2SbpJvknCScZJyknOSdZJ2kneSeJJ5knqSe5J8kn2SfpJ/koCSgZKCkoOShJKFkoaSh5KIkomSipKLkoySjZKPkpCSkZKSkpOSlJKVkpaSl5KYkpmSmpKbkpySnZKekp+SoJKhkqKSo5KkkqWSppKnkmpgfWCWYJpgrWCdYINgkmCMYJtg7GC7YLFg3WDYYMZg2mC0YCBhJmEVYSNh9GAAYQ5hK2FKYXVhrGGUYadht2HUYfVh3V+zlumV65XxlfOV9ZX2lfyV/pUDlgSWBpYIlgqWC5YMlg2WD5YSlhWWFpYXlhmWGpYsTj9yFWI1bFRsXGxKbKNshWyQbJRsjGxobGlsdGx2bIZsqWzQbNRsrWz3bPhs8WzXbLJs4GzWbPps62zubLFs02zvbP5sqJKpkqqSq5Kskq2Sr5KwkrGSspKzkrSStZK2kreSuJK5krqSu5K8kr2SvpK/ksCSwZLCksOSxJLFksaSx5LJksqSy5LMks2SzpLPktCS0ZLSktOS1JLVktaS15LYktmS2pLbktyS3ZLekt+S4JLhkuKS45LkkuWS5pLnkuiS6ZLqkuuS7JLtku6S75LwkvGS8pLzkvSS9ZL2kveS+JL5kvqS+5L8kv2S/pL/kgCTAZMCkwOTBJMFkwaTB5MIkwmTOW0nbQxtQ21IbQdtBG0ZbQ5tK21NbS5tNW0abU9tUm1UbTNtkW1vbZ5toG1ebZNtlG1cbWBtfG1jbRpux23Fbd5tDm6/beBtEW7mbd1t2W0WbqttDG6ubStubm5Obmtusm5fboZuU25UbjJuJW5Ebt9usW6YbuBuLW/ibqVup269brtut27XbrRuz26PbsJun25ib0ZvR28kbxVv+W4vbzZvS290bypvCW8pb4lvjW+Mb3hvcm98b3pv0W8KkwuTDJMNkw6TD5MQkxGTEpMTkxSTFZMWkxeTGJMZkxqTG5Mckx2THpMfkyCTIZMikyOTJJMlkyaTJ5MokymTKpMrkyyTLZMuky+TMJMxkzKTM5M0kzWTNpM3kziTOZM6kzuTPJM9kz+TQJNBk0KTQ5NEk0WTRpNHk0iTSZNKk0uTTJNNk06TT5NQk1GTUpNTk1STVZNWk1eTWJNZk1qTW5Nck12TXpNfk2CTYZNik2OTZJNlk2aTZ5Nok2mTa5PJb6dvuW+2b8Jv4W/ub95v4G/vbxpwI3AbcDlwNXBPcF5wgFuEW5Vbk1ulW7hbL3WemjRk5FvuWzCJ8FtHjgeLto/Tj9WP5Y/uj+SP6Y/mj/OP6I8FkASQC5AmkBGQDZAWkCGQNZA2kC2QL5BEkFGQUpBQkGiQWJBikFuQuWZ0kH2QgpCIkIOQi5BQX1dfVl9YXztcq1RQXFlccVtjXGZcvH8qXylfLV90gjxfO5tuXIFZg1mNWalZqlmjWWyTbZNuk2+TcJNxk3KTc5N0k3WTdpN3k3iTeZN6k3uTfJN9k36Tf5OAk4GTgpODk4SThZOGk4eTiJOJk4qTi5OMk42TjpOQk5GTkpOTk5STlZOWk5eTmJOZk5qTm5Ock52TnpOfk6CToZOik6OTpJOlk6aTp5Ook6mTqpOrk6yTrZOuk6+TsJOxk7KTs5O0k7WTtpO3k7iTuZO6k7uTvJO9k76Tv5PAk8GTwpPDk8STxZPGk8eTyJPJk8uTzJPNk5dZylmrWZ5ZpFnSWbJZr1nXWb5ZBVoGWt1ZCFrjWdhZ+VkMWglaMlo0WhFaI1oTWkBaZ1pKWlVaPFpiWnVa7ICqWptad1p6Wr5a61qyWtJa1Fq4WuBa41rxWtZa5lrYWtxaCVsXWxZbMls3W0BbFVwcXFpbZVtzW1FbU1tiW3Wad5p4mnqaf5p9moCagZqFmoiaipqQmpKak5qWmpiam5qcmp2an5qgmqKao5qlmqean36hfqN+pX6ofql+zpPPk9CT0ZPSk9OT1JPVk9eT2JPZk9qT25Pck92T3pPfk+CT4ZPik+OT5JPlk+aT55Pok+mT6pPrk+yT7ZPuk++T8JPxk/KT85P0k/WT9pP3k/iT+ZP6k/uT/JP9k/6T/5MAlAGUApQDlASUBZQGlAeUCJQJlAqUC5QMlA2UDpQPlBCUEZQSlBOUFJQVlBaUF5QYlBmUGpQblByUHZQelB+UIJQhlCKUI5QklCWUJpQnlCiUKZQqlCuULJQtlC6UrX6wfr5+wH7BfsJ+yX7Lfsx+0H7Uftd+237gfuF+6H7rfu5+737xfvJ+DX/2fvp++37+fgF/An8Dfwd/CH8Lfwx/D38RfxJ/F38Zfxx/G38ffyF/In8jfyR/JX8mfyd/Kn8rfyx/LX8vfzB/MX8yfzN/NX96Xn91210+dZWQjnORc65zonOfc89zwnPRc7dzs3PAc8lzyHPlc9lzfJgKdOlz53Pec7pz8nMPdCp0W3QmdCV0KHQwdC50LHQvlDCUMZQylDOUNJQ1lDaUN5Q4lDmUOpQ7lDyUPZQ/lECUQZRClEOURJRFlEaUR5RIlEmUSpRLlEyUTZROlE+UUJRRlFKUU5RUlFWUVpRXlFiUWZRalFuUXJRdlF6UX5RglGGUYpRjlGSUZZRmlGeUaJRplGqUbJRtlG6Ub5RwlHGUcpRzlHSUdZR2lHeUeJR5lHqUe5R8lH2UfpR/lICUgZSClIOUhJSRlJaUmJTHlM+U05TUlNqU5pT7lByVIJUbdBp0QXRcdFd0VXRZdHd0bXR+dJx0jnSAdIF0h3SLdJ50qHSpdJB0p3TSdLp06pfrl+yXTGdTZ15nSGdpZ6Vnh2dqZ3NnmGenZ3VnqGeeZ61ni2d3Z3xn8GcJaNhnCmjpZ7BnDGjZZ7Vn2mezZ91nAGjDZ7hn4mcOaMFn/WcyaDNoYGhhaE5oYmhEaGRog2gdaFVoZmhBaGdoQGg+aEpoSWgpaLVoj2h0aHdok2hraMJobmn8aB9pIGn5aCeVM5U9lUOVSJVLlVWVWpVglW6VdJV1lXeVeJV5lXqVe5V8lX2VfpWAlYGVgpWDlYSVhZWGlYeViJWJlYqVi5WMlY2VjpWPlZCVkZWSlZOVlJWVlZaVl5WYlZmVmpWblZyVnZWelZ+VoJWhlaKVo5WklaWVppWnlaiVqZWqlauVrJWtla6Vr5WwlbGVspWzlbSVtZW2lbeVuJW5lbqVu5W8lb2VvpW/lcCVwZXClcOVxJXFlcaVx5XIlcmVypXLlSRp8GgLaQFpV2njaBBpcWk5aWBpQmldaYRpa2mAaZhpeGk0acxph2mIac5piWlmaWNpeWmbaadpu2mraa1p1GmxacFpymnfaZVp4GmNaf9pL2rtaRdqGGplavJpRGo+aqBqUGpbajVqjmp5aj1qKGpYanxqkWqQaqlql2qrajdzUnOBa4Jrh2uEa5Jrk2uNa5prm2uha6pra49tj3GPco9zj3WPdo94j3ePeY96j3yPfo+Bj4KPhI+Hj4uPzJXNlc6Vz5XQldGV0pXTldSV1ZXWldeV2JXZldqV25Xcld2V3pXfleCV4ZXileOV5JXlleaV55Xslf+VB5YTlhiWG5YeliCWI5YkliWWJpYnliiWKZYrliyWLZYvljCWN5Y4ljmWOpY+lkGWQ5ZKlk6WT5ZRllKWU5ZWlleWWJZZllqWXJZdll6WYJZjlmWWZpZrlm2WbpZvlnCWcZZzlniWeZZ6lnuWfJZ9ln6Wf5aAloGWgpaDloSWh5aJloqWjY+Oj4+PmI+aj86OC2IXYhtiH2IiYiFiJWIkYixi54HvdPR0/3QPdRF1E3U0Ze5l72XwZQpmGWZyZwNmFWYAZoVw92YdZjRmMWY2ZjVmBoBfZlRmQWZPZlZmYWZXZndmhGaMZqdmnWa+Zttm3GbmZulmMo0zjTaNO409jUCNRY1GjUiNSY1HjU2NVY1ZjceJyonLicyJzonPidCJ0Ylucp9yXXJmcm9yfnJ/coRyi3KNco9yknIIYzJjsGOMlo6WkZaSlpOWlZaWlpqWm5adlp6Wn5aglqGWopajlqSWpZamlqiWqZaqlquWrJatlq6Wr5axlrKWtJa1lreWuJa6lruWv5bClsOWyJbKlsuW0JbRltOW1JbWlteW2JbZltqW25bclt2W3pbfluGW4pbjluSW5ZbmlueW65bslu2W7pbwlvGW8pb0lvWW+Jb6lvuW/Jb9lv+WApcDlwWXCpcLlwyXEJcRlxKXFJcVlxeXGJcZlxqXG5cdlx+XIJc/ZNhkBIDqa/Nr/Wv1a/lrBWwHbAZsDWwVbBhsGWwabCFsKWwkbCpsMmw1ZVVla2VNclJyVnIwcmKGFlKfgJyAk4C8gApnvYCxgKuArYC0gLeA54DogOmA6oDbgMKAxIDZgM2A14AQZ92A64DxgPSA7YANgQ6B8oD8gBVnEoFajDaBHoEsgRiBMoFIgUyBU4F0gVmBWoFxgWCBaYF8gX2BbYFngU1YtVqIgYKBkYHVbqOBqoHMgSZnyoG7gSGXIpcjlySXJZcmlyeXKJcplyuXLJculy+XMZczlzSXNZc2lzeXOpc7lzyXPZc/l0CXQZdCl0OXRJdFl0aXR5dIl0mXSpdLl0yXTZdOl0+XUJdRl1SXVZdXl1iXWpdcl12XX5djl2SXZpdnl2iXapdrl2yXbZdul2+XcJdxl3KXdZd3l3iXeZd6l3uXfZd+l3+XgJeBl4KXg5eEl4aXh5eIl4mXipeMl46Xj5eQl5OXlZeWl5eXmZeal5uXnJedl8GBpoEkazdrOWtDa0ZrWWvRmNKY05jVmNmY2piza0BfwmvziZBlUZ+TZbxlxmXEZcNlzGXOZdJl1mWAcJxwlnCdcLtwwHC3cKtwsXDocMpwEHETcRZxL3ExcXNxXHFocUVxcnFKcXhxenGYcbNxtXGocaBx4HHUcedx+XEdcihybHAYcWZxuXE+Yj1iQ2JIYkliO3lAeUZ5SXlbeVx5U3laeWJ5V3lgeW95Z3l6eYV5inmaead5s3nRX9Bfnpefl6GXopekl6WXppenl6iXqZeql6yXrpewl7GXs5e1l7aXt5e4l7mXupe7l7yXvZe+l7+XwJfBl8KXw5fEl8WXxpfHl8iXyZfKl8uXzJfNl86Xz5fQl9GX0pfTl9SX1ZfWl9eX2JfZl9qX25fcl92X3pffl+CX4Zfil+OX5Jfll+iX7pfvl/CX8Zfyl/SX95f4l/mX+pf7l/yX/Zf+l/+XAJgBmAKYA5gEmAWYBpgHmAiYCZgKmAuYDJgNmA6YPGBdYFpgZ2BBYFlgY2CrYAZhDWFdYalhnWHLYdFhBmKAgH+Ak2z2bPxt9nf4dwB4CXgXeBh4EXirZS14HHgdeDl4Ong7eB94PHgleCx4I3gpeE54bXhWeFd4JnhQeEd4THhqeJt4k3iaeId4nHiheKN4sni5eKV41HjZeMl47HjyeAV59HgTeSR5Hnk0eZuf+Z77nvye8XYEdw13+XYHdwh3Gncidxl3LXcmdzV3OHdQd1F3R3dDd1p3aHcPmBCYEZgSmBOYFJgVmBaYF5gYmBmYGpgbmByYHZgemB+YIJghmCKYI5gkmCWYJpgnmCiYKZgqmCuYLJgtmC6YL5gwmDGYMpgzmDSYNZg2mDeYOJg5mDqYO5g8mD2YPpg/mECYQZhCmEOYRJhFmEaYR5hImEmYSphLmEyYTZhOmE+YUJhRmFKYU5hUmFWYVphXmFiYWZhamFuYXJhdmF6YX5hgmGGYYphjmGSYZZhmmGeYaJhpmGqYa5hsmG2Ybphid2V3f3eNd313gHeMd5F3n3egd7B3tXe9dzp1QHVOdUt1SHVbdXJ1eXWDdVh/YX9ff0iKaH90f3F/eX+Bf35/zXbldjKIhZSGlIeUi5SKlIyUjZSPlJCUlJSXlJWUmpSblJyUo5SklKuUqpStlKyUr5SwlLKUtJS2lLeUuJS5lLqUvJS9lL+UxJTIlMmUypTLlMyUzZTOlNCU0ZTSlNWU1pTXlNmU2JTblN6U35TglOKU5JTllOeU6JTqlG+YcJhxmHKYc5h0mIuYjpiSmJWYmZijmKiYqZiqmKuYrJitmK6Yr5iwmLGYspizmLSYtZi2mLeYuJi5mLqYu5i8mL2Yvpi/mMCYwZjCmMOYxJjFmMaYx5jImMmYypjLmMyYzZjPmNCY1JjWmNeY25jcmN2Y4JjhmOKY45jkmOWY5pjpmOqY65jsmO2Y7pjvmPCY8ZjymPOY9Jj1mPaY95j4mPmY+pj7mPyY/Zj+mP+YAJkBmQKZA5kEmQWZBpkHmemU65TulO+U85T0lPWU95T5lPyU/ZT/lAOVApUGlQeVCZUKlQ2VDpUPlRKVE5UUlRWVFpUYlRuVHZUelR+VIpUqlSuVKZUslTGVMpU0lTaVN5U4lTyVPpU/lUKVNZVElUWVRpVJlUyVTpVPlVKVU5VUlVaVV5VYlVmVW5VelV+VXZVhlWKVZJVllWaVZ5VolWmVapVrlWyVb5VxlXKVc5U6led37HfJltV57Xnjeet5BnpHXQN6AnoeehR6CJkJmQqZC5kMmQ6ZD5kRmRKZE5kUmRWZFpkXmRiZGZkamRuZHJkdmR6ZH5kgmSGZIpkjmSSZJZkmmSeZKJkpmSqZK5ksmS2ZL5kwmTGZMpkzmTSZNZk2mTeZOJk5mTqZO5k8mT2ZPpk/mUCZQZlCmUOZRJlFmUaZR5lImUmZSplLmUyZTZlOmU+ZUJlRmVKZU5lWmVeZWJlZmVqZW5lcmV2ZXplfmWCZYZlimWSZZplzmXiZeZl7mX6ZgpmDmYmZOXo3elF6z56lmXB6iHaOdpN2mXakdt504HQsdSCeIp4onimeKp4rniyeMp4xnjaeOJ43njmeOp4+nkGeQp5EnkaeR55InkmeS55Mnk6eUZ5VnleeWp5bnlyeXp5jnmaeZ55onmmeap5rnmyecZ5tnnOeknWUdZZ1oHWddax1o3WzdbR1uHXEdbF1sHXDdcJ11nXNdeN16HXmdeR163XndQN28XX8df91EHYAdgV2DHYXdgp2JXYYdhV2GXaMmY6ZmpmbmZyZnZmemZ+ZoJmhmaKZo5mkmaaZp5mpmaqZq5msma2ZrpmvmbCZsZmymbOZtJm1mbaZt5m4mbmZupm7mbyZvZm+mb+ZwJnBmcKZw5nEmcWZxpnHmciZyZnKmcuZzJnNmc6Zz5nQmdGZ0pnTmdSZ1ZnWmdeZ2JnZmdqZ25ncmd2Z3pnfmeCZ4ZnimeOZ5JnlmeaZ55nomemZ6pnrmeyZ7Znume+Z8JnxmfKZ85n0mfWZ9pn3mfiZ+Zkbdjx2InYgdkB2LXYwdj92NXZDdj52M3ZNdl52VHZcdlZ2a3Zvdsp/5np4enl6gHqGeoh6lXqmeqB6rHqoeq16s3pkiGmIcoh9iH+IgoiiiMaIt4i8iMmI4ojOiOOI5YjxiBqJ/IjoiP6I8IghiRmJE4kbiQqJNIkriTaJQYlmiXuJi3XlgLJ2tHbcdxKAFIAWgByAIIAigCWAJoAngCmAKIAxgAuANYBDgEaATYBSgGmAcYCDiXiYgJiDmPqZ+5n8mf2Z/pn/mQCaAZoCmgOaBJoFmgaaB5oImgmaCpoLmgyaDZoOmg+aEJoRmhKaE5oUmhWaFpoXmhiaGZoamhuaHJodmh6aH5ogmiGaIpojmiSaJZommieaKJopmiqaK5osmi2aLpovmjCaMZoymjOaNJo1mjaaN5o4mjmaOpo7mjyaPZo+mj+aQJpBmkKaQ5pEmkWaRppHmkiaSZpKmkuaTJpNmk6aT5pQmlGaUppTmlSaVZpWmleaWJpZmomYjJiNmI+YlJiamJuYnpifmKGYopilmKaYTYZUhmyGboZ/hnqGfIZ7hqiGjYaLhqyGnYanhqOGqoaThqmGtobEhrWGzoawhrqGsYavhsmGz4a0humG8Ybyhu2G84bQhhOH3ob0ht+G2IbRhgOHB4f4hgiHCocNhwmHI4c7hx6HJYcuhxqHPodIhzSHMYcphzeHP4eChyKHfYd+h3uHYIdwh0yHboeLh1OHY4d8h2SHWYdlh5OHr4eoh9KHWppbmlyaXZpeml+aYJphmmKaY5pkmmWaZppnmmiaaZpqmmuacpqDmomajZqOmpSalZqZmqaaqZqqmquarJqtmq6ar5qymrOatJq1mrmau5q9mr6av5rDmsSaxprHmsiayZrKms2azprPmtCa0prUmtWa1prXmtma2prbmtya3ZremuCa4prjmuSa5Zrnmuia6Zrqmuya7prwmvGa8przmvSa9Zr2mvea+Jr6mvya/Zr+mv+aAJsBmwKbBJsFmwabxoeIh4WHrYeXh4OHq4flh6yHtYezh8uH04e9h9GHwIfKh9uH6ofgh+6HFogTiP6HCogbiCGIOYg8iDZ/Qn9Ef0V/EIL6ev16CHsDewR7FXsKeyt7D3tHezh7KnsZey57MXsgeyV7JHszez57HntYe1p7RXt1e0x7XXtge257e3tie3J7cXuQe6Z7p3u4e6x7nXuoe4V7qnuce6J7q3u0e9F7wXvMe9172nvle+Z76nsMfP57/HsPfBZ8C3wHmwmbCpsLmwybDZsOmxCbEZsSmxSbFZsWmxebGJsZmxqbG5scmx2bHpsgmyGbIpskmyWbJpsnmyibKZsqmyubLJstmy6bMJsxmzObNJs1mzabN5s4mzmbOps9mz6bP5tAm0abSptLm0ybTptQm1KbU5tVm1abV5tYm1mbWptbm1ybXZtem1+bYJthm2KbY5tkm2WbZptnm2ibaZtqm2ubbJttm26bb5twm3Gbcptzm3SbdZt2m3ebeJt5m3qbe5sffCp8Jnw4fEF8QHz+gQGCAoIEguyBRIghgiKCI4Itgi+CKIIrgjiCO4IzgjSCPoJEgkmCS4JPglqCX4Jogn6IhYiIiNiI34heiZ1/n3+nf69/sH+yf3x8SWWRfJ18nHyefKJ8sny8fL18wXzHfMx8zXzIfMV813zofG6CqGa/f85/1X/lf+F/5n/pf+5/83/4fHd9pn2ufUd+m364nrSec42EjZSNkY2xjWeNbY1HjEmMSpFQkU6RT5FkkXybfZt+m3+bgJuBm4Kbg5uEm4WbhpuHm4ibiZuKm4ubjJuNm46bj5uQm5GbkpuTm5SblZuWm5ebmJuZm5qbm5ucm52bnpufm6CboZuim6ObpJulm6abp5uom6mbqpurm6ybrZuum6+bsJuxm7Kbs5u0m7Wbtpu3m7ibuZu6m7ubvJu9m76bv5vAm8GbwpvDm8SbxZvGm8ebyJvJm8qby5vMm82bzpvPm9Cb0ZvSm9Ob1JvVm9ab15vYm9mb2pvbm2KRYZFwkWmRb5F9kX6RcpF0kXmRjJGFkZCRjZGRkaKRo5Gqka2RrpGvkbWRtJG6kVWMfp64jeuNBY5ZjmmOtY2/jbyNuo3EjdaN143ajd6Nzo3PjduNxo3sjfeN+I3jjfmN+43kjQmO/Y0Ujh2OH44sji6OI44vjjqOQI45jjWOPY4xjkmOQY5CjlGOUo5KjnCOdo58jm+OdI6Fjo+OlI6QjpyOno54jIKMioyFjJiMlIybZdaJ3onaidyJ3Jvdm96b35vgm+Gb4pvjm+Sb5Zvmm+eb6Jvpm+qb65vsm+2b7pvvm/Cb8Zvym/Ob9Jv1m/ab95v4m/mb+pv7m/yb/Zv+m/+bAJwBnAKcA5wEnAWcBpwHnAicCZwKnAucDJwNnA6cD5wQnBGcEpwTnBScFZwWnBecGJwZnBqcG5wcnB2cHpwfnCCcIZwinCOcJJwlnCacJ5wonCmcKpwrnCycLZwunC+cMJwxnDKcM5w0nDWcNpw3nDicOZw6nDuc5Ynrie+JPoomi1OX6Zbzlu+WBpcBlwiXD5cOlyqXLZcwlz6XgJ+Dn4Wfhp+Hn4ifiZ+Kn4yf/p4Lnw2fuZa8lr2WzpbSlr934JaOkq6SyJI+k2qTypOPkz6Ua5R/nIKchZyGnIeciJwjeoucjpyQnJGckpyUnJWcmpybnJ6cn5ygnKGcopyjnKWcppynnKicqZyrnK2crpywnLGcspyznLSctZy2nLecupy7nLycvZzEnMWcxpzHnMqcy5w8nD2cPpw/nECcQZxCnEOcRJxFnEacR5xInEmcSpxLnEycTZxOnE+cUJxRnFKcU5xUnFWcVpxXnFicWZxanFucXJxdnF6cX5xgnGGcYpxjnGScZZxmnGecaJxpnGqca5xsnG2cbpxvnHCccZxynHOcdJx1nHacd5x4nHmcepx7nH2cfpyAnIOchJyJnIqcjJyPnJOclpyXnJicmZydnKqcrJyvnLmcvpy/nMCcwZzCnMicyZzRnNKc2pzbnOCc4ZzMnM2czpzPnNCc05zUnNWc15zYnNmc3JzdnN+c4px8l4WXkZeSl5SXr5erl6OXspe0l7GasJq3mlietpq6mryawZrAmsWawprLmsya0ZpFm0ObR5tJm0ibTZtRm+iYDZkumVWZVJnfmuGa5prvmuua+5rtmvmaCJsPmxObH5sjm72evp47foKeh56Inouekp7Wk52en57bntye3Z7gnt+e4p7pnuee5Z7qnu+eIp8sny+fOZ83nz2fPp9En+Oc5JzlnOac55zonOmc6pzrnOyc7ZzunO+c8JzxnPKc85z0nPWc9pz3nPic+Zz6nPuc/Jz9nP6c/5wAnQGdAp0DnQSdBZ0GnQedCJ0JnQqdC50MnQ2dDp0PnRCdEZ0SnROdFJ0VnRadF50YnRmdGp0bnRydHZ0enR+dIJ0hnSKdI50knSWdJp0nnSidKZ0qnSudLJ0tnS6dL50wnTGdMp0znTSdNZ02nTedOJ05nTqdO508nT2dPp0/nUCdQZ1CnTTiNeI24jfiOOI54jriO+I84j3iPuI/4kDiQeJC4kPiROJF4kbiR+JI4kniSuJL4kziTeJO4k/iUOJR4lLiU+JU4lXiVuJX4ljiWeJa4lviXOJd4l7iX+Jg4mHiYuJj4mTiZeJm4mfiaOJp4mria+Js4m3ibuJv4nDiceJy4nPidOJ14nbid+J44nnieuJ74nzifeJ+4n/igOKB4oLig+KE4oXihuKH4ojiieKK4ovijOKN4o7ij+KQ4pHiQ51EnUWdRp1HnUidSZ1KnUudTJ1NnU6dT51QnVGdUp1TnVSdVZ1WnVedWJ1ZnVqdW51cnV2dXp1fnWCdYZ1inWOdZJ1lnWadZ51onWmdap1rnWydbZ1unW+dcJ1xnXKdc510nXWddp13nXideZ16nXudfJ19nX6df52AnYGdgp2DnYSdhZ2GnYediJ2JnYqdi52MnY2djp2PnZCdkZ2SnZOdlJ2VnZadl52YnZmdmp2bnZydnZ2enZ+doJ2hnaKdkuKT4pTileKW4pfimOKZ4prim+Kc4p3inuKf4qDioeKi4qPipOKl4qbip+Ko4qniquKr4qzireKu4q/isOKx4rLis+K04rXituK34rjiueK64rvivOK94r7iv+LA4sHiwuLD4sTixeLG4sfiyOLJ4sriy+LM4s3izuLP4tDi0eLS4tPi1OLV4tbi1+LY4tni2uLb4tzi3eLe4t/i4OLh4uLi4+Lk4uXi5uLn4uji6eLq4uvi7OLt4u7i7+KjnaSdpZ2mnaedqJ2pnaqdq52sna2drp2vnbCdsZ2ynbOdtJ21nbadt524nbmdup27nbydvZ2+nb+dwJ3BncKdw53EncWdxp3HncidyZ3KncudzJ3Nnc6dz53QndGd0p3TndSd1Z3Wnded2J3Zndqd253cnd2d3p3fneCd4Z3ineOd5J3lnead553onemd6p3rneyd7Z3une+d8J3xnfKd8530nfWd9p33nfid+Z36nfud/J39nf6d/50AngGeAp7w4vHi8uLz4vTi9eL24vfi+OL54vri++L84v3i/uL/4gDjAeMC4wPjBOMF4wbjB+MI4wnjCuML4wzjDeMO4w/jEOMR4xLjE+MU4xXjFuMX4xjjGeMa4xvjHOMd4x7jH+Mg4yHjIuMj4yTjJeMm4yfjKOMp4yrjK+Ms4y3jLuMv4zDjMeMy4zPjNOM14zbjN+M44znjOuM74zzjPeM+4z/jQONB40LjQ+NE40XjRuNH40jjSeNK40vjTONN4wOeBJ4FngaeB54IngmeCp4LngyeDZ4Ong+eEJ4RnhKeE54UnhWeFp4XnhieGZ4anhueHJ4dnh6eJJ4nni6eMJ40njuePJ5Ank2eUJ5SnlOeVJ5WnlmeXZ5fnmCeYZ5inmWebp5vnnKedJ51nnaed554nnmeep57nnyefZ6AnoGeg56EnoWehp6JnoqejJ6Nno6ej56QnpGelJ6Vnpael56Ynpmemp6bnpyenp6gnqGeop6jnqSepZ6nnqieqZ6qnk7jT+NQ41HjUuNT41TjVeNW41fjWONZ41rjW+Nc413jXuNf42DjYeNi42PjZONl42bjZ+No42njauNr42zjbeNu42/jcONx43Ljc+N043XjduN343jjeeN643vjfON9437jf+OA44HjguOD44TjheOG44fjiOOJ44rji+OM443jjuOP45DjkeOS45PjlOOV45bjl+OY45njmuOb45zjneOe45/joOOh46Ljo+Ok46XjpuOn46jjqeOq46vjq56snq2erp6vnrCesZ6ynrOetZ62nreeuZ66nryev57AnsGewp7DnsWexp7Hnsieyp7Lnsye0J7SntOe1Z7Wntee2Z7ant6e4Z7jnuSe5p7onuue7J7tnu6e8J7xnvKe8570nvWe9p73nvie+p79nv+eAJ8BnwKfA58EnwWfBp8HnwifCZ8KnwyfD58RnxKfFJ8VnxafGJ8anxufHJ8dnx6fH58hnyOfJJ8lnyafJ58onymfKp8r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khudaVi8ZVpsJXX5US5ZZVmAX9xfvGL6ZSpqJ2u0a4tzwX9WiSydDp3EnqFclmx7gwRRS1y2YcaBdmhhcllO+k94U2lgKW5PevOXC04WU+5OVU89T6FPc0+gUu9TCVYPWcFatlvhW9F5h2acZ7ZnTGuzbGtwwnONeb55PHqHe7GC24IEg3eD74PTg2aHsoopVqiM5o9OkB6XiobET+hcEWJZcjt15YG9gv6GwIzFlhOZ1ZnLThpP44neVkpYylj7XutfKmCUYGJg0GESYtBiOWVBm2ZmsGh3bXBwTHWGdnV9pYL5h4uVjpadjPFRvlIWWbNUs1sWXWhhgmmvbY14y4RXiHKKp5O4mmxtqJnZhqNX/2fOhg6Sg1KHVgRU017hYrlkPGg4aLtrcnO6eGt6monSiWuNA4/tkKOVlJZpl2Zbs1x9aU2YTpibYyB7K2p/arZoDZxfb3JSnVVwYOxiO20HbtFuW4QQiUSPFE45nPZTG2k6aoSXKmhcUcN6soTckYyTW1YonSJoBYMxhKV8CFLFguZ0fk6DT6BR0lsKUthS51L7XZpVKljmWYxbmFvbW3JeeV6jYB9hY2G+YdtjYmXRZ1No+mg+a1NrV2wib5dvRW+wdBh143YLd/96oXshfOl9Nn/wf52AZoKeg7OJzIqrjISQUZSTlZGVopVlltOXKJkYgjhOK1S4XMxdqXNMdjx3qVzrfwuNwZYRmFSYWJgBTw5PcVOcVWhW+ldHWQlbxFuQXAxefl7MX+5jOmfXZeJlH2fLaMRoX2owXsVrF2x9bH91SHljWwB6AH29X4+JGIq0jHeNzI4dj+KYDpo8m4BOfVAAUZNZnFsvYoBi7GQ6a6BykXVHeal/+4e8inCLrGPKg6CXCVQDVKtVVGhYanCKJ3h1Z82edFOiWxqBUIYGkBhORU7HThFPylM4VK5bE18lYFFlPWdCbHJs42x4cAN0dnquegh7Gn3+fGZ952VbcrtTRVzoXdJi4GIZYyBuWoYxit2N+JIBb6Z5WpuoTqtOrE6bT6BP0VBHUfZ6cVH2UVRTIVN/U+tTrFWDWOFcN19KXy9gUGBtYB9jWWVLasFswnLtcu93+IAFgQiCToX3kOGT/5dXmVqa8E7dUS1cgWZtaUBc8mZ1aYlzUGiBfMVQ5FJHV/5dJpOkZSNrPWs0dIF5vXlLe8p9uYLMg3+IX4k5i9GP0ZEfVICSXU42UOVTOlPXcpZz6Xfmgq+OxpnImdKZd1EaYV6GsFV6enZQ01tHkIWWMk7baueRUVxIXJhjn3qTbHSXYY+qeopxiJaCfBdocH5RaGyT8lIbVKuFE4qkf82O4ZBmU4iIQXnCT75QEVJEUVNVLVfqc4tXUVliX4RfdWB2YWdhqWGyYzpkbGVvZkJoE25mdT16+3xMfZl9S35rfw6DSoPNhgiKY4pmi/2OGpiPnbiCzo/om4dSH2KDZMBvmZZBaJFQIGt6bFRvdHpQfUCII4oIZ/ZOOVAmUGVQfFE4UmNSp1UPVwVYzFr6XrJh+GHzYnJjHGkpan1yrHIucxR4b3h5fQx3qYCLiRmL4ozSjmOQdZN6llWYE5p4nkNRn1OzU3teJl8bbpBuhHP+c0N9N4IAivqKUJZOTgtQ5FN8VPpW0VlkW/Fdq14nXzhiRWWvZ1Zu0HLKfLSIoYDhgPCDToaHiuiNN5LHlmeYE5+UTpJODU9IU0lUPlQvWoxfoV+fYKdojmpadIF4noqkineLkJFeTsmbpE58T69PGVAWUElRbFGfUrlS/lKaU+NTEVQOVIlVUVeiV31ZVFtdW49b5V3nXfddeF6DXppet14YX1JgTGGXYthip2M7ZQJmQ2b0Zm1nIWiXaMtpX2wqbWltL26dbjJ1h3ZseD964HwFfRh9Xn2xfRWAA4CvgLGAVIGPgSqCUoNMiGGIG4uijPyMypB1kXGSP3j8kqSVTZYFmJmZ2Jo7nVtSq1L3UwhU1Vj3YuBvaoxfj7meS1E7UkpU/VZAeneRYJ3SnkRzCW9wgRF1/V/aYKia23K8j2RrA5jKTvBWZFe+WFpaaGDHYQ9mBmY5aLFo923VdTp9boJCm5tOUE/JUwZVb13mXe5d+2eZbHN0AnhQipaT34hQV6deK2O1UKxQjVEAZ8lUXli7WbBbaV9NYqFjPWhzawhufXDHkYByFXgmeG15jmUwfdyDwYgJj5uWZFIoV1Bnan+hjLRRQlcqljpYimm0gLJUDl38V5V4+p1cT0pSi1Q+ZChmFGf1Z4R6VnsifS+TXGitmzl7GVOKUTdS31v2Yq5k5mQtZ7prqYXRlpB21ptMYwaTq5u/dlJmCU6YUMJTcVzoYJJkY2VfaOZxynMjdZd7gn6VhoOL24x4kRCZrGWrZotr1U7UTjpPf086UvhT8lPjVdtW61jLWclZ/1lQW01cAl4rXtdfHWAHYy9lXFuvZb1l6GWdZ2Jre2sPbEVzSXnBefh8GX0rfaKAAoHzgZaJXoppimaKjIruiseM3IzMlvyYb2uLTjxPjU9QUVdb+ltIYQFjQmYha8tuu2w+cr101HXBeDp5DIAzgOqBlISej1Bsf54PX1iLK536eviOjVvrlgNO8VP3VzFZyVqkW4lgf24Gb7516oyfWwCF4HtyUPRnnYJhXEqFHn4OgplRBFxoY2aNnGVucT55F30FgB2Lyo5ukMeGqpAfUPpSOlxTZ3xwNXJMkciRK5PlgsJbMV/5YDtO1lOIW0tiMWeKa+ly4HMuemuBo41SkZaZElHXU2pU/1uIYzlqrH0Al9pWzlNoVJdbMVzeXe5PAWH+YjJtwHnLeUJ9TX7Sf+2BH4KQhEaIcomQi3SOL48xkEuRbJHGlpyRwE5PT0VRQVOTXw5i1GdBbAtuY3Mmfs2Rg5LUUxlZv1vRbV15Ln6bfH5Yn3H6UVOI8I/KT/tcJWasd+N6HIL/mcZRql/sZW9piWvzbZZuZG/+dhR94V11kIeRBpjmUR1SQGKRZtlmGm62XtJ9cn/4Zq+F94X4iqlS2VNzWY9ekF9VYOSSZJa3UB9R3VIgU0dT7FPoVEZVMVUXVmhZvlk8WrVbBlwPXBFcGlyEXope4F5wX39ihGLbYoxjd2MHZgxmLWZ2Zn5nomgfajVqvGyIbQluWG48cSZxZ3HHdQF3XXgBeWV58HngehF7p3w5fZaA1oOLhEmFXYjziB+KPIpUinOKYYzejKSRZpJ+kxiUnJaYlwpOCE4eTldOl1FwUs5XNFjMWCJbOF7FYP5kYWdWZ0RttnJzdWN6uIRyi7iRIJMxVvRX/pjtYg1plmvtcVR+d4ByguaJ35hVh7GPO1w4T+FPtU8HVSBa3VvpW8NfTmEvY7BlS2buaJtpeG3xbTN1uXUfd1555nkzfeOBr4KqhaqJOoqrjpuPMpDdkQeXuk7BTgNSdVjsWAtcGnU9XE6BCorFj2OWbZcle8+KCJhikfNWqFMXkDlUglclXqhjNGyKcGF3i3zgf3CIQpBUkRCTGJOPll50xJoHXWldcGWiZ6iN25ZuY0lnGWnFgxeYwJb+iIRvemT4WxZOLHBddS9mxFE2UuJS01mBXydgEGI/ZXRlH2Z0ZvJoFmhjawVucnIfddt2vnxWgPBY/Yh/iaCKk4rLih2QkpFSl1mXiWUOegaBu5YtXtxgGmKlZRRmkGfzd016TXw+fgqBrIxkjeGNX46peAdS2WKlY0JkmGItioN6wHusiuqWdn0MgkmH2U5IUUNTYFOjWwJcFlzdXSZiR2KwZBNoNGjJbEVtF23TZ1xvTnF9cctlf3qte9p9Sn6of3qBG4I5gqaFborOjPWNeJB3kK2SkZKDla6bTVKEVThvNnFoUYV5VX6zgc58TFZRWKhcqmP+Zv1mWmnZco91jnUOeVZ533mXfCB9RH0HhjSKO5ZhkCCf51B1UsxT4lMJUKpV7lhPWT1yi1tkXB1T42DzYFxjg2M/Y7tjzWTpZflm413Naf1pFW/lcYlO6XX4dpN633zPfZx9YYBJg1iDbIS8hPuFxYhwjQGQbZCXkxyXEprPUJdYjmHTgTWFCI0gkMNPdFBHUnNTb2BJY19nLG6zjR+Q109eXMqMz2WafVJTloh2UcNjWFtrWwpcDWRRZ1yQ1k4aWSpZcGxRij5VFVilWfBgU2LBZzWCVWlAlsSZKJpTTwZY/lsQgLFcL16FXyBgS2E0Yv9m8Gzebs6Af4HUgouIuIwAkC6Qipbbntub407wUydZLHuNkUyY+Z3dbidwU1NEVYVbWGKeYtNiomzvbyJ0F4o4lMFv/oo4g+dR+IbqU+lTRk9UkLCPalkxgf1d6nq/j9poN4z4ckicPWqwijlOWFMGVmZXxWKiY+ZlTmvhbVturXDtd+96qnu7fT2AxoDLhpWKW5PjVsdYPl+tZZZmgGq1azd1x4okUOV3MFcbX2VgemZgbPR1Gnpuf/SBGIdFkLOZyXtcdfl6UXvEhBCQ6XmSejaD4VpAdy1O8k6ZW+BfvWI8ZvFn6GxrhneIO4pOkfOS0JkXaiZwKnPngleEr4wBTkZRy1GLVfVbFl4zXoFeFF81X2tftF/yYRFjomYdZ25vUnI6dTp3dIA5gXiBdoe/ityKhY3zjZqSd5UCmOWcxVJXY/R2FWeIbM1zw4yuk3OWJW2cWA5pzGn9j5qT23UakFpYAmi0Y/tpQ08sb9hnu48mhbR9VJM/aXBvalf3WCxbLH0qcgpU45G0na1OTk9cUHVQQ1KejEhUJFiaWx1elV6tXvdeH1+MYLViOmPQY69oQGyHeI55C3rgfUeCAormikSOE5C4kC2R2JEOn+VsWGTiZHVl9G6Edht7aZDRk7pu8lS5X6RkTY/tj0SSeFFrWClZVVyXXvttj34cdbyM4o5bmLlwHU+/a7FvMHX7lk5REFQ1WFdYrFlgXJJfl2VcZyFue3bfg+2MFJD9kE2TJXg6eKpSpl4fV3RZEmASUFpRrFHNUQBSEFVUWFhYV1mVW/Zci128YJViLWRxZ0NovGjfaNd22G1vbpttb3DIcVNf2HV3eUl7VHtSe9Z8cX0wUmOEaYXkhQ6KBItGjA+OA5APkBmUdpYtmDCa2JXNUNVSDFQCWA5cp2GeZB5ts3flevSABIRTkIWS4FwHnT9Tl1+zX5xteXJjd7955HvSa+xyrYoDaGFq+FGBejRpSlz2nOuCxVtJkR5weFZvXMdgZmWMbFqMQZATmFFUx2YNkkhZo5CFUU1O6lGZhQ6LWHB6Y0uTYmm0mQR+d3VXU2Bp347jll1sjE48XBBf6Y8CU9GMiYB5hv9e5WVzTmVRglk/XO6X+06KWc1fjYrhb7B5YnnnW3GEK3OxcXRe9V97Y5pkw3GYfENO/F5LTtxXolapYMNvDX39gDOBv4Gyj5eJpIb0XYpirWSHiXdn4mw+bTZ0NHhGWnV/rYKsmfNPw17dYpJjV2VvZ8N2THLMgLqAKY9NkQ1Q+VeSWoVoc2lkcf1yt4zyWOCMapYZkH+H5HnndymEL09lUlpTzWLPZ8psfXaUe5V8NoKEheuP3WYgbwZyG36rg8GZpp79UbF7cni4e4eASHvoamFejIBRdWB1a1FikoxuenaXkeqaEE9wf5xiT3ullemcelZZWOSGvJY0TyRSSlPNU9tTBl4sZJFlf2c+bE5sSHKvcu1zVHVBfiyC6YWpjMR7xpFpcRKY75g9Y2lmanXkdtB4Q4XuhipTUVMmVINZh158X7JgSWJ5YqtikGXUa8xssnWudpF42HnLfXd/pYCriLmKu4x/kF6X25gLajh8mVA+XK5fh2fYazV0CXeOfzufymcXejlTi3XtmmZfnYHxg5iAPF/FX2J1Rns8kGdo61mbWhB9fnYsi/VPal8ZajdsAm/idGh5aIhVinmM317PY8V10nnXgiiT8pKchO2GLZzBVGxfjGVcbRVwp4zTjDuYT2X2dA1O2E7gVytZZlrMW6hRA16cXhZgdmJ3ZadlbmZubTZyJntQgZqBmYJci6CM5ox0jRyWRJauT6tkZmsegmGEaoXokAFcU2momHqEV4UPT29SqV9FXg1nj3l5gQeJhon1bRdfVWK4bM9OaXKSmwZSO1R0VrNYpGFuYhpxblmJfN58G33wlodlXoAZTnVPdVFAWGNec14KX8RnJk49hYmVW5ZzfAGY+1DBWFZ2p3glUqV3EYWGe09QCVlHcsd76H26j9SPTZC/T8lSKVoBX62X3U8XguqSA1dVY2lrK3XciBSPQnrfUpNYVWEKYq5mzWs/fOmDI1D4TwVTRlQxWElZnVvwXO9cKV2WXrFiZ2M+ZbllC2fVbOFs+XAyeCt+3oCzggyE7IQChxKJKopKjKaQ0pL9mPOcbJ1PTqFOjVBWUkpXqFk9Xthf2V8/YrRmG2fQZ9JoklEhfaqAqIEAi4yMv4x+kjKWIFQsmBdT1VBcU6hYsmQ0Z2dyZndGeuaRw1KhbIZrAFhMXlRZLGf7f+FRxnZpZOh4VJu7nstXuVknZppnzmvpVNlpVV6cgZVnqpv+Z1KcXWimTuNPyFO5Yitnq2zEj61PbX6/ngdOYmGAbitvE4VzVCpnRZvzXZV7rFzGWxyHSm7RhBR6CIGZWY18EWwgd9lSIlkhcV9y23cnl2GdC2l/WhhapVENVH1UDmbfdvePmJL0nOpZXXLFbk1RyWi/fex9Ype6nnhkIWoCg4RZX1vbaxtz8nayfReAmYQyUShn2Z7udmJn/1IFmSRcO2J+fLCMT1W2YAt9gJUBU19OtlEcWTpyNoDOkSVf4neEU3lfBH2shTOKjY5Wl/NnroVTlAlhCGG5bFJ27Yo4jy9VUU8qUcdSy1OlW31eoGCCYdZjCWfaZ2dujG02czdzMXVQedWImIpKkJGQ9ZDElo2HFVmITllPDk6Jij+PEJitUHxellm5W7he2mP6Y8Fk3GZKadhpC222bpRxKHWveop/AIBJhMmEgYkhiwqOZZB9lgqZfmGRYjJrg2x0bcx//H/AbYV/uof4iGVnsYM8mPeWG21hfT2EapFxTnVTUF0Ea+tvzYUthqeJKVIPVGVcTmeoaAZ0g3Tidc+I4YjMkeKWeJaLX4dzy3pOhKBjZXWJUkFtnG4JdFl1a3iSfIaW3HqNn7ZPbmHFZVyGhk6uTtpQIU7MUe5bmWWBaLxtH3NCdq13HHrnfG+C0op8kM+RdZYYmJtS0X0rUJhTl2fLbdBxM3TogSqPo5ZXnJ+eYHRBWJltL31emORONk+LT7dRsVK6XRxgsnM8edOCNJK3lvaWCpeXnmKfpmZ0axdSo1LIcMKIyV5LYJBhI29JcT589H1vgO6EI5Ask0JUb5vTaolwwozvjTKXtFJBWspeBF8XZ3xplGlqbQ9vYnL8cu17AYB+gEuHzpBtUZOehHmLgDKT1ootUIxUcYpqa8SMB4HRYKBn8p2ZTphOEJxrisGFaIUAaX5ul3hVgQBB1PwGC/w0DF8QThVOKk4xTjZOPE4/TkJOVk5YToJOhU5rjIpOEoINX45Onk6fTqBOok6wTrNOtk7OTs1OxE7GTsJO107eTu1O3073TglPWk8wT1tPXU9XT0dPdk+IT49PmE97T2lPcE+RT29Phk+WTxhR1E/fT85P2E/bT9FP2k/QT+RP5U8aUChQFFAqUCVQBVAcT/ZPIVApUCxQ/k/vTxFQBlBDUEdQA2dVUFBQSFBaUFZQbFB4UIBQmlCFULRQslDJUMpQs1DCUNZQ3lDlUO1Q41DuUPlQ9VAJUQFRAlEWURVRFFEaUSFROlE3UTxRO1E/UUBRUlFMUVRRYlH4emlRalFuUYBRglHYVoxRiVGPUZFRk1GVUZZRpFGmUaJRqVGqUatRs1GxUbJRsFG1Ub1RxVHJUdtR4FFVhulR7VHwUfVR/lEEUgtSFFIOUidSKlIuUjNSOVJPUkRSS1JMUl5SVFJqUnRSaVJzUn9SfVKNUpRSklJxUohSkVKoj6ePrFKtUrxStVLBUs1S11LeUuNS5lLtmOBS81L1UvhS+VIGUwhTOHUNUxBTD1MVUxpTI1MvUzFTM1M4U0BTRlNFUxdOSVNNU9ZRXlNpU25TGFl7U3dTglOWU6BTplOlU65TsFO2U8NTEnzZlt9T/Gbuce5T6FPtU/pTAVQ9VEBULFQtVDxULlQ2VClUHVROVI9UdVSOVF9UcVR3VHBUklR7VIBUdlSEVJBUhlTHVKJUuFSlVKxUxFTIVKhUq1TCVKRUvlS8VNhU5VTmVA9VFFX9VO5U7VT6VOJUOVVAVWNVTFUuVVxVRVVWVVdVOFUzVV1VmVWAVa9UilWfVXtVflWYVZ5VrlV8VYNVqVWHVahV2lXFVd9VxFXcVeRV1FUUVvdVFlb+Vf1VG1b5VU5WUFbfcTRWNlYyVjhWa1ZkVi9WbFZqVoZWgFaKVqBWlFaPVqVWrla2VrRWwla8VsFWw1bAVshWzlbRVtNW11buVvlWAFf/VgRXCVcIVwtXDVcTVxhXFlfHVRxXJlc3VzhXTlc7V0BXT1dpV8BXiFdhV39XiVeTV6BXs1ekV6pXsFfDV8ZX1FfSV9NXCljWV+NXC1gZWB1YclghWGJYS1hwWMBrUlg9WHlYhVi5WJ9Yq1i6WN5Yu1i4WK5YxVjTWNFY11jZWNhY5VjcWORY31jvWPpY+Vj7WPxY/VgCWQpZEFkbWaZoJVksWS1ZMlk4WT5Z0npVWVBZTllaWVhZYllgWWdZbFlpWXhZgVmdWV5Pq0+jWbJZxlnoWdxZjVnZWdpZJVofWhFaHFoJWhpaQFpsWklaNVo2WmJaalqaWrxavlrLWsJavVrjWtda5lrpWtZa+lr7WgxbC1sWWzJb0FoqWzZbPltDW0VbQFtRW1VbWltbW2VbaVtwW3NbdVt4W4hleluAW4Nbplu4W8Nbx1vJW9Rb0FvkW+Zb4lveW+Vb61vwW/Zb81sFXAdcCFwNXBNcIFwiXChcOFw5XEFcRlxOXFNcUFxPXHFbbFxuXGJOdlx5XIxckVyUXJtZq1y7XLZcvFy3XMVcvlzHXNlc6Vz9XPpc7VyMXepcC10VXRddXF0fXRtdEV0UXSJdGl0ZXRhdTF1SXU5dS11sXXNddl2HXYRdgl2iXZ1drF2uXb1dkF23XbxdyV3NXdNd0l3WXdtd613yXfVdC14aXhleEV4bXjZeN15EXkNeQF5OXldeVF5fXmJeZF5HXnVedl56Xryef16gXsFewl7IXtBez17WXuNe3V7aXtte4l7hXuhe6V7sXvFe817wXvRe+F7+XgNfCV9dX1xfC18RXxZfKV8tXzhfQV9IX0xfTl8vX1FfVl9XX1lfYV9tX3Nfd1+DX4Jff1+KX4hfkV+HX55fmV+YX6BfqF+tX7xf1l/7X+Rf+F/xX91fs2D/XyFgYGAZYBBgKWAOYDFgG2AVYCtgJmAPYDpgWmBBYGpgd2BfYEpgRmBNYGNgQ2BkYEJgbGBrYFlggWCNYOdgg2CaYIRgm2CWYJdgkmCnYItg4WC4YOBg02C0YPBfvWDGYLVg2GBNYRVhBmH2YPdgAGH0YPpgA2EhYftg8WANYQ5hR2E+YShhJ2FKYT9hPGEsYTRhPWFCYURhc2F3YVhhWWFaYWthdGFvYWVhcWFfYV1hU2F1YZlhlmGHYaxhlGGaYYphkWGrYa5hzGHKYclh92HIYcNhxmG6YctheX/NYeZh42H2Yfph9GH/Yf1h/GH+YQBiCGIJYg1iDGIUYhtiHmIhYipiLmIwYjJiM2JBYk5iXmJjYltiYGJoYnxigmKJYn5ikmKTYpZi1GKDYpRi12LRYrtiz2L/YsZi1GTIYtxizGLKYsJix2KbYsliDGPuYvFiJ2MCYwhj72L1YlBjPmNNYxxkT2OWY45jgGOrY3Zjo2OPY4ljn2O1Y2tjaWO+Y+ljwGPGY+NjyWPSY/ZjxGMWZDRkBmQTZCZkNmQdZRdkKGQPZGdkb2R2ZE5kKmWVZJNkpWSpZIhkvGTaZNJkxWTHZLtk2GTCZPFk52QJguBk4WSsYuNk72QsZfZk9GTyZPpkAGX9ZBhlHGUFZSRlI2UrZTRlNWU3ZTZlOGVLdUhlVmVVZU1lWGVeZV1lcmV4ZYJlg2WKi5tln2WrZbdlw2XGZcFlxGXMZdJl22XZZeBl4WXxZXJnCmYDZvtlc2c1ZjZmNGYcZk9mRGZJZkFmXmZdZmRmZ2ZoZl9mYmZwZoNmiGaOZolmhGaYZp1mwWa5Zslmvma8ZsRmuGbWZtpm4GY/ZuZm6WbwZvVm92YPZxZnHmcmZydnOJcuZz9nNmdBZzhnN2dGZ15nYGdZZ2NnZGeJZ3BnqWd8Z2pnjGeLZ6ZnoWeFZ7dn72e0Z+xns2fpZ7hn5GfeZ91n4mfuZ7lnzmfGZ+dnnGoeaEZoKWhAaE1oMmhOaLNoK2hZaGNod2h/aJ9oj2itaJRonWibaINormq5aHRotWigaLpoD2mNaH5oAWnKaAhp2GgiaSZp4WgMac1o1GjnaNVoNmkSaQRp12jjaCVp+WjgaO9oKGkqaRppI2khacZoeWl3aVxpeGlraVRpfmluaTlpdGk9aVlpMGlhaV5pXWmBaWppsmmuadBpv2nBadNpvmnOaehbymndabtpw2mnaS5qkWmgaZxplWm0ad5p6GkCahtq/2kKa/lp8mnnaQVqsWkeau1pFGrraQpqEmrBaiNqE2pEagxqcmo2anhqR2piallqZmpIajhqImqQao1qoGqEaqJqo2qXaheGu2rDasJquGqzaqxq3mrRat9qqmraaupq+2oFaxaG+moSaxZrMZsfazhrN2vcdjlr7phHa0NrSWtQa1lrVGtba19rYWt4a3lrf2uAa4Rrg2uNa5hrlWuea6Rrqmura69rsmuxa7Nrt2u8a8Zry2vTa99r7Gvra/Nr72u+nghsE2wUbBtsJGwjbF5sVWxibGpsgmyNbJpsgWybbH5saGxzbJJskGzEbPFs02y9bNdsxWzdbK5ssWy+bLps22zvbNls6mwfbU2INm0rbT1tOG0ZbTVtM20SbQxtY22TbWRtWm15bVltjm2VbeRvhW35bRVuCm61bcdt5m24bcZt7G3ebcxt6G3SbcVt+m3ZbeRt1W3qbe5tLW5ubi5uGW5ybl9uPm4jbmtuK252bk1uH25DbjpuTm4kbv9uHW44boJuqm6Ybslut27Tbr1ur27EbrJu1G7Vbo9upW7Cbp9uQW8Rb0xw7G74bv5uP2/ybjFv724yb8xuPm8Tb/duhm96b3hvgW+Ab29vW2/zb21vgm98b1hvjm+Rb8JvZm+zb6NvoW+kb7lvxm+qb99v1W/sb9Rv2G/xb+5v228JcAtw+m8RcAFwD3D+bxtwGnB0bx1wGHAfcDBwPnAycFFwY3CZcJJwr3DxcKxwuHCzcK5w33DLcN1w2XAJcf1wHHEZcWVxVXGIcWZxYnFMcVZxbHGPcftxhHGVcahxrHHXcblxvnHScclx1HHOceBx7HHncfVx/HH5cf9xDXIQchtyKHItcixyMHIycjtyPHI/ckByRnJLclhydHJ+coJygXKHcpJylnKicqdyuXKycsNyxnLEcs5y0nLicuBy4XL5cvdyD1AXcwpzHHMWcx1zNHMvcylzJXM+c05zT3PYnldzanNoc3BzeHN1c3tzenPIc7NzznO7c8Bz5XPuc95zonQFdG90JXT4czJ0OnRVdD90X3RZdEF0XHRpdHB0Y3RqdHZ0fnSLdJ50p3TKdM901HTxc+B043TndOl07nTydPB08XT4dPd0BHUDdQV1DHUOdQ11FXUTdR51JnUsdTx1RHVNdUp1SXVbdUZ1WnVpdWR1Z3VrdW11eHV2dYZ1h3V0dYp1iXWCdZR1mnWddaV1o3XCdbN1w3W1db11uHW8dbF1zXXKddJ12XXjdd51/nX/dfx1AXbwdfp18nXzdQt2DXYJdh92J3YgdiF2InYkdjR2MHY7dkd2SHZGdlx2WHZhdmJ2aHZpdmp2Z3ZsdnB2cnZ2dnh2fHaAdoN2iHaLdo52lnaTdpl2mnawdrR2uHa5drp2wnbNdtZ20nbeduF25Xbndup2L4b7dgh3B3cEdyl3JHcedyV3Jncbdzd3OHdHd1p3aHdrd1t3ZXd/d353eXeOd4t3kXegd553sHe2d7l3v3e8d713u3fHd81313fad9x343fud/x3DHgSeCZ5IHgqeUV4jnh0eIZ4fHiaeIx4o3i1eKp4r3jReMZ4y3jUeL54vHjFeMp47HjneNp4/Xj0eAd5EnkReRl5LHkreUB5YHlXeV95WnlVeVN5enl/eYp5nXmneUufqnmuebN5uXm6ecl51Xnneex54XnjeQh6DXoYehl6IHofeoB5MXo7ej56N3pDeld6SXphemJ6aXqdn3B6eXp9eoh6l3qVeph6lnqpesh6sHq2esV6xHq/eoOQx3rKes16z3rVetN62Xraet164XrieuZ67XrwegJ7D3sKewZ7M3sYexl7Hns1eyh7NntQe3p7BHtNewt7THtFe3V7ZXt0e2d7cHtxe2x7bnude5h7n3uNe5x7mnuLe5J7j3tde5l7y3vBe8x7z3u0e8Z73XvpexF8FHzme+V7YHwAfAd8E3zze/d7F3wNfPZ7I3wnfCp8H3w3fCt8PXxMfEN8VHxPfEB8UHxYfF98ZHxWfGV8bHx1fIN8kHykfK18onyrfKF8qHyzfLJ8sXyufLl8vXzAfMV8wnzYfNJ83HzifDub73zyfPR89nz6fAZ9An0cfRV9Cn1FfUt9Ln0yfT99NX1GfXN9Vn1OfXJ9aH1ufU99Y32TfYl9W32PfX19m326fa59o321fcd9vX2rfT1+on2vfdx9uH2ffbB92H3dfeR93n37ffJ94X0Ffgp+I34hfhJ+MX4ffgl+C34ifkZ+Zn47fjV+OX5Dfjd+Mn46fmd+XX5Wfl5+WX5afnl+an5pfnx+e36DftV9fX6uj39+iH6Jfox+kn6QfpN+lH6Wfo5+m36cfjh/On9Ff0x/TX9Of1B/UX9Vf1R/WH9ff2B/aH9pf2d/eH+Cf4Z/g3+If4d/jH+Uf55/nX+af6N/r3+yf7l/rn+2f7h/cYvFf8Z/yn/Vf9R/4X/mf+l/83/5f9yYBoAEgAuAEoAYgBmAHIAhgCiAP4A7gEqARoBSgFiAWoBfgGKAaIBzgHKAcIB2gHmAfYB/gISAhoCFgJuAk4CagK2AkFGsgNuA5YDZgN2AxIDagNaACYHvgPGAG4EpgSOBL4FLgYuWRoE+gVOBUYH8gHGBboFlgWaBdIGDgYiBioGAgYKBoIGVgaSBo4FfgZOBqYGwgbWBvoG4gb2BwIHCgbqByYHNgdGB2YHYgciB2oHfgeCB54H6gfuB/oEBggKCBYIHggqCDYIQghaCKYIrgjiCM4JAglmCWIJdglqCX4JkgmKCaIJqgmuCLoJxgneCeIJ+go2CkoKrgp+Cu4KsguGC44LfgtKC9ILzgvqCk4MDg/uC+YLeggaD3IIJg9mCNYM0gxaDMoMxg0CDOYNQg0WDL4MrgxeDGIOFg5qDqoOfg6KDloMjg46Dh4OKg3yDtYNzg3WDoIOJg6iD9IMThOuDzoP9gwOE2IMLhMGD94MHhOCD8oMNhCKEIIS9gziEBoX7g22EKoQ8hFqFhIR3hGuErYRuhIKEaYRGhCyEb4R5hDWEyoRihLmEv4SfhNmEzYS7hNqE0ITBhMaE1oShhCGF/4T0hBeFGIUshR+FFYUUhfyEQIVjhViFSIVBhQKGS4VVhYCFpIWIhZGFioWohW2FlIWbheqFh4WchXeFfoWQhcmFuoXPhbmF0IXVhd2F5YXchfmFCoYThguG/oX6hQaGIoYahjCGP4ZNhlVOVIZfhmeGcYaThqOGqYaqhouGjIa2hq+GxIbGhrCGyYYjiKuG1IbehumG7IbfhtuG74YShwaHCIcAhwOH+4YRhwmHDYf5hgqHNIc/hzeHO4clhymHGodgh1+HeIdMh06HdIdXh2iHbodZh1OHY4dqhwWIooefh4KHr4fLh72HwIfQh9aWq4fEh7OHx4fGh7uH74fyh+CHD4gNiP6H9of3hw6I0ocRiBaIFYgiiCGIMYg2iDmIJ4g7iESIQohSiFmIXohiiGuIgYh+iJ6IdYh9iLWIcoiCiJeIkoiuiJmIooiNiKSIsIi/iLGIw4jEiNSI2IjZiN2I+YgCifyI9IjoiPKIBIkMiQqJE4lDiR6JJYkqiSuJQYlEiTuJNok4iUyJHYlgiV6JZolkiW2JaolviXSJd4l+iYOJiImKiZOJmImhiamJpomsia+Jsom6ib2Jv4nAidqJ3IndieeJ9In4iQOKFooQigyKG4odiiWKNopBiluKUopGikiKfIptimyKYoqFioKKhIqoiqGKkYqliqaKmoqjisSKzYrCitqK64rziueK5IrxihSL4IriiveK3orbigyLB4sai+GKFosQixeLIIszi6uXJosriz6LKItBi0yLT4tOi0mLVotbi1qLa4tfi2yLb4t0i32LgIuMi46LkouTi5aLmYuaizqMQYw/jEiMTIxOjFCMVYxijGyMeIx6jIKMiYyFjIqMjYyOjJSMfIyYjB1irYyqjL2MsoyzjK6MtozIjMGM5IzjjNqM/Yz6jPuMBI0FjQqNB40PjQ2NEI1OnxONzYwUjRaNZ41tjXGNc42BjZmNwo2+jbqNz43ajdaNzI3bjcuN6o3rjd+N4438jQiOCY7/jR2OHo4Qjh+OQo41jjCONI5KjkeOSY5MjlCOSI5ZjmSOYI4qjmOOVY52jnKOfI6BjoeOhY6EjouOio6TjpGOlI6ZjqqOoY6sjrCOxo6xjr6OxY7IjsuO247jjvyO+47rjv6OCo8FjxWPEo8ZjxOPHI8fjxuPDI8mjzOPO485j0WPQo8+j0yPSY9Gj06PV49cj2KPY49kj5yPn4+jj62Pr4+3j9qP5Y/ij+qP74+HkPSPBZD5j/qPEZAVkCGQDZAekBaQC5AnkDaQNZA5kPiPT5BQkFGQUpAOkEmQPpBWkFiQXpBokG+QdpColnKQgpB9kIGQgJCKkImQj5CokK+QsZC1kOKQ5JBIYtuQApESkRmRMpEwkUqRVpFYkWORZZFpkXORcpGLkYmRgpGikauRr5GqkbWRtJG6kcCRwZHJkcuR0JHWkd+R4ZHbkfyR9ZH2kR6S/5EUkiySFZIRkl6SV5JFkkmSZJJIkpWSP5JLklCSnJKWkpOSm5Jaks+SuZK3kumSD5P6kkSTLpMZkyKTGpMjkzqTNZM7k1yTYJN8k26TVpOwk6yTrZOUk7mT1pPXk+iT5ZPYk8OT3ZPQk8iT5JMalBSUE5QDlAeUEJQ2lCuUNZQhlDqUQZRSlESUW5RglGKUXpRqlCmScJR1lHeUfZRalHyUfpSBlH+UgpWHlYqVlJWWlZiVmZWglaiVp5WtlbyVu5W5lb6VypX2b8OVzZXMldWV1JXWldyV4ZXlleKVIZYoli6WL5ZClkyWT5ZLlneWXJZell2WX5ZmlnKWbJaNlpiWlZaXlqqWp5axlrKWsJa0lraWuJa5ls6Wy5bJls2WTYnclg2X1Zb5lgSXBpcIlxOXDpcRlw+XFpcZlySXKpcwlzmXPZc+l0SXRpdIl0KXSZdcl2CXZJdm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XPRde17/XhRfFV/DXwhiNmJLYk5iL2WHZZdlpGW5ZeVl8GYIZyhnIGtia3lry2vUa9trD2w0bGtwKnI2cjtyR3JZcltyrHKLcxlOFk4VThROGE47Tk1OT05OTuVO2E7UTtVO1k7XTuNO5E7ZTt5ORVFEUYlRilGsUflR+lH4UQpSoFKfUgVTBlMXUx1T305KU0lTYVNgU29TblO7U+9T5FPzU+xT7lPpU+hT/FP4U/VT61PmU+pT8lPxU/BT5VPtU/tT21baVhZZLlkxWXRZdllVW4NbPFzoXedd5l0CXgNec158XgFfGF8XX8VfCmJTYlRiUmJRYqVl5mUuZyxnKmcrZy1nY2vNaxFsEGw4bEFsQGw+bK9yhHOJc9x05nQYdR91KHUpdTB1MXUydTN1i3V9dq52v3budtt34nfzdzp5vnl0est6Hk4fTlJOU05pTplOpE6mTqVO/04JTxlPCk8VTw1PEE8RTw9P8k72TvtO8E7zTv1OAU8LT0lRR1FGUUhRaFFxUY1RsFEXUhFSElIOUhZSo1IIUyFTIFNwU3FTCVQPVAxUClQQVAFUC1QEVBFUDVQIVANUDlQGVBJU4FbeVt1WM1cwVyhXLVcsVy9XKVcZWRpZN1k4WYRZeFmDWX1ZeVmCWYFZV1tYW4dbiFuFW4lb+lsWXHlc3l0GXnZedF4PXxtf2V/WXw5iDGINYhBiY2JbYlhiNmXpZehl7GXtZfJm82YJZz1nNGcxZzVnIWtka3trFmxdbFdsWWxfbGBsUGxVbGFsW2xNbE5scHBfcl1yfnb5enN8+Hw2f4p/vX8BgAOADIASgDOAf4CJgIuAjIDjgeqB84H8gQyCG4Ifgm6CcoJ+gmuGQIhMiGOIf4khljJOqE5NT09PR09XT15PNE9bT1VPME9QT1FPPU86TzhPQ09UTzxPRk9jT1xPYE8vT05PNk9ZT11PSE9aT0xRS1FNUXVRtlG3USVSJFIpUipSKFKrUqlSqlKsUiNTc1N1Ux1ULVQeVD5UJlROVCdURlRDVDNUSFRCVBtUKVRKVDlUO1Q4VC5UNVQ2VCBUPFRAVDFUK1QfVCxU6lbwVuRW61ZKV1FXQFdNV0dXTlc+V1BXT1c7V+9YPlmdWZJZqFmeWaNZmVmWWY1ZpFmTWYpZpVldW1xbWltbW4xbi1uPWyxcQFxBXD9cPlyQXJFclFyMXOtdDF6PXodeil73XgRfH19kX2Jfd195X9hfzF/XX81f8V/rX/hf6l8SYhFihGKXYpZigGJ2YolibWKKYnxifmJ5YnNikmJvYphibmKVYpNikWKGYjllO2U4ZfFl9GZfZ05nT2dQZ1FnXGdWZ15nSWdGZ2BnU2dXZ2Vrz2tCbF5smWyBbIhsiWyFbJtsamx6bJBscGyMbGhslmySbH1sg2xybH5sdGyGbHZsjWyUbJhsgmx2cHxwfXB4cGJyYXJgcsRywnKWcyx1K3U3dTh1gnbvduN3wXnAeb95dnr7fFV/loCTgJ2AmICbgJqAsoBvgpKCi4KNgouJ0okAijeMRoxVjJ2MZI1wjbONq47KjpuPsI/Cj8aPxY/Ej+FdkZCikKqQppCjkEmRxpHMkTKWLpYxliqWLJYmTlZOc06LTptOnk6rTqxOb0+dT41Pc09/T2xPm0+LT4ZPg09wT3VPiE9pT3tPlk9+T49PkU96T1RRUlFVUWlRd1F2UXhRvVH9UTtSOFI3UjpSMFIuUjZSQVK+UrtSUlNUU1NTUVNmU3dTeFN5U9ZT1FPXU3NUdVSWVHhUlVSAVHtUd1SEVJJUhlR8VJBUcVR2VIxUmlRiVGhUi1R9VI5U+laDV3dXaldpV2FXZldkV3xXHFlJWUdZSFlEWVRZvlm7WdRZuVmuWdFZxlnQWc1Zy1nTWcpZr1mzWdJZxVlfW2RbY1uXW5pbmFucW5lbm1saXEhcRVxGXLdcoVy4XKlcq1yxXLNcGF4aXhZeFV4bXhFeeF6aXpdenF6VXpZe9l4mXydfKV+AX4Fff198X91f4F/9X/Vf/18PYBRgL2A1YBZgKmAVYCFgJ2ApYCtgG2AWYhViP2I+YkBif2LJYsxixGK/YsJiuWLSYttiq2LTYtRiy2LIYqhivWK8YtBi2WLHYs1itWLaYrFi2GLWYtdixmKsYs5iPmWnZbxl+mUUZhNmDGYGZgJmDmYAZg9mFWYKZgdmDWcLZ21ni2eVZ3FnnGdzZ3dnh2edZ5dnb2dwZ39niWd+Z5BndWeaZ5NnfGdqZ3JnI2tma2drf2sTbBts42zobPNssWzMbOVss2y9bL5svGzibKts1WzTbLhsxGy5bMFsrmzXbMVs8Wy/bLts4WzbbMpsrGzvbNxs1mzgbJVwjnCScIpwmXAsci1yOHJIcmdyaXLAcs5y2XLXctByqXOoc59zq3Olcz11nXWZdZp1hHbCdvJ29Hbld/13PnlAeUF5yXnIeXp6eXr6ev58VH+Mf4t/BYC6gKWAooCxgKGAq4CpgLSAqoCvgOWB/oENgrOCnYKZgq2CvYKfgrmCsYKsgqWCr4K4gqOCsIK+greCToZxhh1SaIjLjs6P1I/Rj7WQuJCxkLaQx5HRkXeVgJUclkCWP5Y7lkSWQpa5luiWUpdel59OrU6uTuFPtU+vT79P4E/RT89P3U/DT7ZP2E/fT8pP10+uT9BPxE/CT9pPzk/eT7dPV1GSUZFRoFFOUkNSSlJNUkxSS1JHUsdSyVLDUsFSDVNXU3tTmlPbU6xUwFSoVM5UyVS4VKZUs1THVMJUvVSqVMFUxFTIVK9Uq1SxVLtUqVSnVL9U/1aCV4tXoFejV6JXzleuV5NXVVlRWU9ZTllQWdxZ2Fn/WeNZ6FkDWuVZ6lnaWeZZAVr7WWlbo1umW6RbolulWwFcTlxPXE1cS1zZXNJc910dXiVeH159XqBepl76XghfLV9lX4hfhV+KX4tfh1+MX4lfEmAdYCBgJWAOYChgTWBwYGhgYmBGYENgbGBrYGpgZGBBYtxiFmMJY/xi7WIBY+5i/WIHY/Fi92LvYuxi/mL0YhFjAmM/ZUVlq2W9ZeJlJWYtZiBmJ2YvZh9mKGYxZiRm92b/Z9Nn8WfUZ9Bn7Ge2Z69n9WfpZ+9nxGfRZ7Rn2mflZ7hnz2feZ/NnsGfZZ+Jn3WfSZ2prg2uGa7Vr0mvXax9syWwLbTJtKm1BbSVtDG0xbR5tF207bT1tPm02bRtt9Ww5bSdtOG0pbS5tNW0ObSttq3C6cLNwrHCvcK1wuHCucKRwMHJycm9ydHLpcuBy4XK3c8pzu3Oyc81zwHOzcxp1LXVPdUx1TnVLdat1pHWldaJ1o3V4doZ2h3aIdsh2xnbDdsV2AXf5dvh2CXcLd/52/HYHd9x3AngUeAx4DXhGeUl5SHlHebl5unnRedJ5y3l/eoF6/3r9en18An0FfQB9CX0HfQR9Bn04f45/v38EgBCADYARgDaA1oDlgNqAw4DEgMyA4YDbgM6A3oDkgN2A9IEigueCA4MFg+OC24LmggSD5YICgwmD0oLXgvGCAYPcgtSC0YLegtOC34LvggaDUIZ5hnuGeoZNiGuIgYnUiQiKAooDip6MoIx0jXONtI3NjsyO8I/mj+KP6o/lj+2P64/kj+iPypDOkMGQw5BLkUqRzZGClVCWS5ZMlk2WYpdpl8uX7ZfzlwGYqJjbmN+YlpmZmVhOs04MUA1QI1DvTyZQJVD4TylQFlAGUDxQH1AaUBJQEVD6TwBQFFAoUPFPIVALUBlQGFDzT+5PLVAqUP5PK1AJUHxRpFGlUaJRzVHMUcZRy1FWUlxSVFJbUl1SKlN/U59TnVPfU+hUEFUBVTdV/FTlVPJUBlX6VBRV6VTtVOFUCVXuVOpU5lQnVQdV/VQPVQNXBFfCV9RXy1fDVwlYD1lXWVhZWlkRWhhaHFofWhtaE1rsWSBaI1opWiVaDFoJWmtbWFywW7Nbtlu0W65btVu5W7hbBFxRXFVcUFztXP1c+1zqXOhc8Fz2XAFd9FzuXS1eK16rXq1ep14xX5JfkV+QX1lgY2BlYFBgVWBtYGlgb2CEYJ9gmmCNYJRgjGCFYJZgR2LzYghj/2JOYz5jL2NVY0JjRmNPY0ljOmNQYz1jKmMrYyhjTWNMY0hlSWWZZcFlxWVCZklmT2ZDZlJmTGZFZkFm+GYUZxVnF2chaDhoSGhGaFNoOWhCaFRoKWizaBdoTGhRaD1o9GdQaEBoPGhDaCpoRWgTaBhoQWiKa4lrt2sjbCdsKGwmbCRs8GxqbZVtiG2HbWZteG13bVltk21sbYltbm1abXRtaW2MbYpteW2FbWVtlG3KcNhw5HDZcMhwz3A5cnly/HL5cv1y+HL3coZz7XMJdO5z4HPqc95zVHVddVx1WnVZdb51xXXHdbJ1s3W9dbx1uXXCdbh1i3awdsp2zXbOdil3H3cgdyh36XcweCd4OHgdeDR4N3gleC14IHgfeDJ4VXlQeWB5X3lWeV55XXlXeVp55Hnjeed533nmeel52HmEeoh62XoGexF7iXwhfRd9C30KfSB9In0UfRB9FX0afRx9DX0ZfRt9On9ff5R/xX/BfwaAGIAVgBmAF4A9gD+A8YACgfCABYHtgPSABoH4gPOACIH9gAqB/IDvgO2B7IEAghCCKoIrgiiCLIK7giuDUoNUg0qDOINQg0mDNYM0g0+DMoM5gzaDF4NAgzGDKINDg1SGioaqhpOGpIaphoyGo4achnCId4iBiIKIfYh5iBiKEIoOigyKFYoKiheKE4oWig+KEYpIjHqMeYyhjKKMd42sjtKO1I7PjrGPAZAGkPePAJD6j/SPA5D9jwWQ+I+VkOGQ3ZDikFKRTZFMkdiR3ZHXkdyR2ZGDlWKWY5ZhlluWXZZklliWXpa7luKYrJmomtiaJZsymzybfk56UH1QXFBHUENQTFBaUElQZVB2UE5QVVB1UHRQd1BPUA9Qb1BtUFxRlVHwUWpSb1LSUtlS2FLVUhBTD1MZUz9TQFM+U8NT/GZGVWpVZlVEVV5VYVVDVUpVMVVWVU9VVVUvVWRVOFUuVVxVLFVjVTNVQVVXVQhXC1cJV99XBVgKWAZY4FfkV/pXAlg1WPdX+VcgWWJZNlpBWklaZlpqWkBaPFpiWlpaRlpKWnBbx1vFW8Rbwlu/W8ZbCVwIXAdcYFxcXF1cB10GXQ5dG10WXSJdEV0pXRRdGV0kXSddF13iXTheNl4zXjdet164XrZetV6+XjVfN19XX2xfaV9rX5dfmV+eX5hfoV+gX5xff2CjYIlgoGCoYMtgtGDmYL1gxWC7YLVg3GC8YNhg1WDGYN9guGDaYMdgGmIbYkhioGOnY3JjlmOiY6Vjd2NnY5hjqmNxY6ljiWODY5tja2OoY4RjiGOZY6FjrGOSY49jgGN7Y2ljaGN6Y11lVmVRZVllV2VfVU9lWGVVZVRlnGWbZaxlz2XLZcxlzmVdZlpmZGZoZmZmXmb5ZtdSG2eBaK9oomiTaLVof2h2aLFop2iXaLBog2jEaK1ohmiFaJRonWioaJ9ooWiCaDJrumvra+xrK2yObbxt823ZbbJt4W3MbeRt+236bQVux23Lba9t0W2ubd5t+W24bfdt9W3FbdJtGm61bdpt623Ybept8W3ubehtxm3Ebapt7G2/beZt+XAJcQpx/XDvcD1yfXKBchxzG3MWcxNzGXOHcwV0CnQDdAZ0/nMNdOB09nT3dBx1InVldWZ1YnVwdY911HXVdbV1ynXNdY521HbSdtt2N3c+dzx3Nnc4dzp3a3hDeE54ZXloeW15+3mSepV6IHsoext7LHsmexl7Hnsue5J8l3yVfEZ9Q31xfS59OX08fUB9MH0zfUR9L31CfTJ9MX09f55/mn/Mf85/0n8cgEqARoAvgRaBI4ErgSmBMIEkgQKCNYI3gjaCOYKOg56DmIN4g6KDloO9g6uDkoOKg5ODiYOgg3eDe4N8g4aDp4NVhmpfx4bAhraGxIa1hsaGy4axhq+GyYZTiJ6IiIiriJKIloiNiIuIk4mPiSqKHYojiiWKMYotih+KG4oiikmMWoypjKyMq4yojKqMp4xnjWaNvo26jduO344ZkA2QGpAXkCOQH5AdkBCQFZAekCCQD5AikBaQG5AUkOiQ7ZD9kFeRzpH1keaR45Hnke2R6ZGJlWqWdZZzlniWcJZ0lnaWd5ZslsCW6pbpluB633oCmAOYWpvlnHWef56lnrueolCNUIVQmVCRUIBQllCYUJpQAGfxUXJSdFJ1UmlS3lLdUttSWlOlU3tVgFWnVXxVilWdVZhVglWcVapVlFWHVYtVg1WzVa5Vn1U+VbJVmlW7VaxVsVV+VYlVq1WZVQ1XL1gqWDRYJFgwWDFYIVgdWCBY+Vj6WGBZd1qaWn9aklqbWqdac1txW9JbzFvTW9BbClwLXDFcTF1QXTRdR139XUVePV5AXkNefl7KXsFewl7EXjxfbV+pX6pfqF/RYOFgsmC2YOBgHGEjYfpgFWHwYPtg9GBoYfFgDmH2YAlhAGESYR9iSWKjY4xjz2PAY+ljyWPGY81j0mPjY9Bj4WPWY+1j7mN2Y/Rj6mPbY1Jk2mP5Y15lZmViZWNlkWWQZa9lbmZwZnRmdmZvZpFmemZ+Zndm/mb/Zh9nHWf6aNVo4GjYaNdoBWnfaPVo7mjnaPlo0mjyaONoy2jNaA1pEmkOaclo2mhuaftoPms6az1rmGuWa7xr72subC9sLGwvbjhuVG4hbjJuZ25KbiBuJW4jbhtuW25YbiRuVm5ubi1uJm5vbjRuTW46bixuQ24dbj5uy26JbhluTm5jbkRucm5pbl9uGXEacSZxMHEhcTZxbnEccUxyhHKAcjZzJXM0cylzOnQqdDN0InQldDV0NnQ0dC90G3QmdCh0JXUmdWt1anXiddt143XZddh13nXgdXt2fHaWdpN2tHbcdk937XddeGx4b3gNegh6C3oFegB6mHqXepZ65Xrjekl7VntGe1B7UntUe017S3tPe1F7n3ylfF59UH1ofVV9K31ufXJ9YX1mfWJ9cH1zfYRV1H/VfwuAUoCFgFWBVIFLgVGBToE5gUaBPoFMgVOBdIESghyC6YMDhPiDDYTgg8WDC4TBg++D8YP0g1eECoTwgwyEzIP9g/KDyoM4hA6EBITcgweE1IPfg1uG34bZhu2G1IbbhuSG0IbehleIwYjCiLGIg4mWiTuKYIpVil6KPIpBilSKW4pQikaKNIo6ijaKVophjIKMr4y8jLOMvYzBjLuMwIy0jLeMtoy/jLiMio2FjYGNzo3djcuN2o3RjcyN243GjfuO+I78jpyPLpA1kDGQOJAykDaQApH1kAmR/pBjkWWRz5EUkhWSI5IJkh6SDZIQkgeSEZKUlY+Vi5WRlZOVkpWOlYqWjpaLln2WhZaGlo2WcpaElsGWxZbElsaWx5bvlvKWzJcFmAaYCJjnmOqY75jpmPKY7Ziuma2Zw57NntGegk6tULVQslCzUMVQvlCsULdQu1CvUMdQf1J3Un1S31LmUuRS4lLjUi9T31XoVdNV5lXOVdxVx1XRVeNV5FXvVdpV4VXFVcZV5VXJVRJXE1deWFFYWFhXWFpYVFhrWExYbVhKWGJYUlhLWGdZwVrJWsxavlq9Wrxas1rCWrJaaV1vXUxeeV7JXsheEl9ZX6xfrl8aYQ9hSGEfYfNgG2H5YAFhCGFOYUxhRGFNYT5hNGEnYQ1hBmE3YSFiImITZD5kHmQqZC1kPWQsZA9kHGQUZA1kNmQWZBdkBmRsZZ9lsGWXZolmh2aIZpZmhGaYZo1mA2eUaW1pWml3aWBpVGl1aTBpgmlKaWhpa2leaVNpeWmGaV1pY2lbaUdrcmvAa79r02v9a6Jur27TbrZuwm6Qbp1ux27FbqVumG68brpuq27RbpZunG7EbtRuqm6nbrRuTnFZcWlxZHFJcWdxXHFscWZxTHFlcV5xRnFocVZxOnJScjdzRXM/cz5zb3RadFV0X3RedEF0P3RZdFt0XHR2dXh1AHbwdQF28nXxdfp1/3X0dfN13nbfdlt3a3dmd153Y3d5d2p3bHdcd2V3aHdid+53jniweJd4mHiMeIl4fHiReJN4f3h6eX95gXkshL15HHoaeiB6FHofeh56n3qgend7wHtge257Z3uxfLN8tXyTfXl9kX2BfY99W31uf2l/an9yf6l/qH+kf1aAWICGgISAcYFwgXiBZYFugXOBa4F5gXqBZoEFgkeCgoR3hD2EMYR1hGaEa4RJhGyEW4Q8hDWEYYRjhGmEbYRGhF6GXIZfhvmGE4cIhweHAIf+hvuGAocDhwaHCodZiN+I1IjZiNyI2IjdiOGIyojViNKInInjiWuKcopzimaKaYpwioeKfIpjiqCKcYqFim2KYopuimyKeYp7ij6KaIpijIqMiYzKjMeMyIzEjLKMw4zCjMWM4Y3fjeiN743zjfqN6o3kjeaNso4DjwmP/o4Kj5+Pso9LkEqQU5BCkFSQPJBVkFCQR5BPkE6QTZBRkD6QQZASkReRbJFqkWmRyZE3kleSOJI9kkCSPpJbkkuSZJJRkjSSSZJNkkWSOZI/klqSmJWYlpSWlZbNlsuWyZbKlveW+5b5lvaWVpd0l3aXEJgRmBOYCpgSmAyY/Jj0mP2Y/pizmbGZtJnhmumcgp4OnxOfIJ/nUO5Q5VDWUO1Q2lDVUM9Q0VDxUM5Q6VBiUfNRg1KCUjFTrVP+VQBWG1YXVv1VFFYGVglWDVYOVvdVFlYfVghWEFb2VRhXFld1WH5Yg1iTWIpYeViFWH1Y/VglWSJZJFlqWWlZ4VrmWula11rWWtha41p1W95b51vhW+Vb5lvoW+Jb5FvfWw1cYlyEXYddW15jXlVeV15UXtNe1l4KX0ZfcF+5X0dhP2FLYXdhYmFjYV9hWmFYYXVhKmKHZFhkVGSkZHhkX2R6ZFFkZ2Q0ZG1ke2RyZaFl12XWZaJmqGadZpxpqGmVacFprmnTactpm2m3abtpq2m0adBpzWmtacxppmnDaaNpSWtMazNsM28Ub/5uE2/0bilvPm8gbyxvD28CbyJv/27vbgZvMW84bzJvI28VbytvL2+Ibypv7G4Bb/JuzG73bpRxmXF9cYpxhHGScT5yknKWckRzUHNkdGN0anRwdG10BHWRdSd2DXYLdgl2E3bhduN2hHd9d393YXfBeJ94p3izeKl4o3iOeY95jXkuejF6qnqpeu1673qhe5V7i3t1e5d7nXuUe497uHuHe4R7uXy9fL58u32wfZx9vX2+faB9yn20fbJ9sX26faJ9v321fbh9rX3Sfcd9rH1wf+B/4X/ff16AWoCHgFCBgIGPgYiBioF/gYKB54H6gQeCFIIegkuCyYS/hMaExISZhJ6EsoSchMuEuITAhNOEkIS8hNGEyoQ/hxyHO4cihyWHNIcYh1WHN4cph/OIAon0iPmI+Ij9iOiIGonviKaKjIqeiqOKjYqhipOKpIqqiqWKqIqYipGKmoqnimqMjYyMjNOM0YzSjGuNmY2VjfyNFI8SjxWPE4+jj2CQWJBckGOQWZBekGKQXZBbkBmRGJEekXWReJF3kXSReJKAkoWSmJKWknuSk5KckqiSfJKRkqGVqJWplaOVpZWklZmWnJablsyW0pYAl3yXhZf2lxeYGJivmLGYA5kFmQyZCZnBma+asJrmmkGbQpv0nPac85y8njufSp8EUQBR+1D1UPlQAlEIUQlRBVHcUYdSiFKJUo1SilLwUrJTLlY7VjlWMlY/VjRWKVZTVk5WV1Z0VjZWL1YwVoBYn1ieWLNYnFiuWKlYplhtWQlb+1oLW/VaDFsIW+5b7FvpW+tbZFxlXJ1dlF1iXl9eYV7iXtpe317dXuNe4F5IX3Fft1+1X3ZhZ2FuYV1hVWGCYXxhcGFrYX5hp2GQYathjmGsYZphpGGUYa5hLmJpZG9keWSeZLJkiGSQZLBkpWSTZJVkqWSSZK5krWSrZJpkrGSZZKJks2R1ZXdleGWuZqtmtGaxZiNqH2roaQFqHmoZav1pIWoTagpq82kCagVq7WkRalBrTmuka8Vrxms/b3xvhG9Rb2ZvVG+Gb21vW294b25vjm96b3BvZG+Xb1hv1W5vb2BvX2+fcaxxsXGocVZym3JOc1dzaXSLdIN0fnSAdH91IHYpdh92JHYmdiF2Inaadrp25HaOd4d3jHeRd4t3y3jFeLp4yni+eNV4vHjQeD96PHpAej16N3o7eq96rnqte7F7xHu0e8Z7x3vBe6B7zHvKfOB99H3vfft92H3sfd196H3jfdp93n3pfZ592X3yffl9dX93f69/6X8mgJuBnIGdgaCBmoGYgReFPYUahe6ELIUthROFEYUjhSGFFIXshCWF/4QGhYKHdId2h2CHZod4h2iHWYdXh0yHU4dbiF2IEIkHiRKJE4kViQqJvIrSiseKxIqVisuK+IqyismKwoq/irCK1orNiraKuYrbikyMToxsjOCM3ozmjOSM7IztjOKM44zcjOqM4YxtjZ+No40rjhCOHY4ijg+OKY4fjiGOHo66jh2PG48fjymPJo8qjxyPHo8lj2mQbpBokG2Qd5AwkS2RJ5ExkYeRiZGLkYORxZK7kreS6pKskuSSwZKzkryS0pLHkvCSspKtlbGVBJcGlweXCZdgl42Xi5ePlyGYK5gcmLOYCpkTmRKZGJndmdCZ35nbmdGZ1ZnSmdmZt5rumu+aJ5tFm0Sbd5tvmwadCZ0Dnamevp7OnqhYUp8SURhRFFEQURVRgFGqUd1RkVKTUvNSWVZrVnlWaVZkVnhWalZoVmVWcVZvVmxWYlZ2VsFYvljHWMVYblkdWzRbeFvwWw5cSl+yYZFhqWGKYc1htmG+YcphyGEwYsVkwWTLZLtkvGTaZMRkx2TCZM1kv2TSZNRkvmR0ZcZmyWa5ZsRmx2a4Zj1qOGo6allqa2pYajlqRGpiamFqS2pHajVqX2pIallrd2sFbMJvsW+hb8NvpG/Bb6dvs2/Ab7lvtm+mb6BvtG++cclx0HHScchx1XG5cc5x2XHcccNxxHFoc5x0o3SYdJ90nnTidAx1DXU0djh2OnbnduV2oHeed593pXfoeNp47HjneKZ5TXpOekZ6THpLerp62XsRfMl75Hvbe+F76Xvme9V81nwKfhF+CH4bfiN+Hn4dfgl+EH55f7J/8H/xf+5/KICzgamBqIH7gQiCWIJZgkqFWYVIhWiFaYVDhUmFbYVqhV6Fg4efh56HooeNh2GIKokyiSWJK4khiaqJponmivqK64rxigCL3Irniu6K/ooBiwKL94rtivOK9or8imuMbYyTjPSMRI4xjjSOQo45jjWOO48vjziPM4+oj6aPdZB0kHiQcpB8kHqQNJGSkSCTNpP4kjOTL5Mik/ySK5MEkxqTEJMmkyGTFZMukxmTu5WnlqiWqpbVlg6XEZcWlw2XE5cPl1uXXJdml5iXMJg4mDuYN5gtmDmYJJgQmSiZHpkbmSGZGpntmeKZ8Zm4mrya+5rtmiibkZsVnSOdJp0onRKdG53YntSejZ+cnypRH1EhUTJR9VKOVoBWkFaFVodWj1bVWNNY0VjOWDBbKlskW3pbN1xoXLxdul29Xbhda15MX71fyWHCYcdh5mHLYTJiNGLOZMpk2GTgZPBk5mTsZPFk4mTtZIJlg2XZZtZmgGqUaoRqomqcattqo2p+apdqkGqgalxrrmvaawhs2G/xb99v4G/bb+Rv62/vb4Bv7G/hb+lv1W/ub/Bv53Hfce5x5nHlce1x7HH0ceBxNXJGcnBzcnOpdLB0pnSodEZ2QnZMdup2s3eqd7B3rHend61373f3ePp49HjveAF5p3mqeVd6v3oHfA18/nv3ewx84HvgfNx83nzifN982XzdfC5+Pn5Gfjd+Mn5Dfit+PX4xfkV+QX40fjl+SH41fj9+L35Ef/N//H9xgHKAcIBvgHOAxoHDgbqBwoHAgb+BvYHJgb6B6IEJgnGCqoWEhX6FnIWRhZSFr4WbhYeFqIWKhWeGwIfRh7OH0ofGh6uHu4e6h8iHy4c7iTaJRIk4iT2JrIkOixeLGYsbiwqLIIsdiwSLEItBjD+Mc4z6jP2M/Iz4jPuMqI1JjkuOSI5KjkSPPo9Cj0WPP49/kH2QhJCBkIKQgJA5kaORnpGckU2TgpMok3WTSpNlk0uTGJN+k2yTW5Nwk1qTVJPKlcuVzJXIlcaVsZa4ltaWHJcel6CX05dGmLaYNZkBmv+Zrpurm6qbrZs7nT+di57Pnt6e3J7dntuePp9Ln+JTlVauVtlY2Fg4W11f42EzYvRk8mT+ZAZl+mT7ZPdkt2XcZiZns2qsasNqu2q4asJqrmqval9reGuvawlwC3D+bwZw+m8RcA9w+3H8cf5x+HF3c3Vzp3S/dBV1VnZYdlJ2vXe/d7t3vHcOea55YXpiemB6xHrFeit8J3wqfB58I3whfOd8VH5Vfl5+Wn5hflJ+WX5If/l/+393gHaAzYHPgQqCz4Wphc2F0IXJhbCFuoW5haaF74fsh/KH4IeGibKJ9IkoizmLLIsri1CMBY1ZjmOOZo5kjl+OVY7AjkmPTY+HkIOQiJCrkayR0JGUk4qTlpOik7OTrpOsk7CTmJOak5eT1JXWldCV1ZXiltyW2Zbblt6WJJejl6aXrZf5l02YT5hMmE6YU5i6mD6ZP5k9mS6ZpZkOmsGaA5sGm0+bTptNm8qbyZv9m8ibwJtRnV2dYJ3gnhWfLJ8zUaVW3ljfWOJY9VuQn+xe8mH3YfZh9WEAZQ9l4GbdZuVq3WraatNqG3AfcChwGnAdcBVwGHAGcg1yWHKicnhzenO9dMp043SHdYZ1X3Zhdsd3GXmxeWt6aXo+fD98OHw9fDd8QHxrfm1+eX5pfmp+hX9zfrZ/uX+4f9iB6YXdheqF1YXkheWF94X7hwWIDYj5h/6HYIlfiVaJXolBi1yLWItJi1qLTotPi0aLWYsIjQqNfI5yjoeOdo5sjnqOdI5Uj06PrY+KkIuQsZGukeGT0ZPfk8OTyJPck92T1pPik82T2JPkk9eT6JPclbSW45YqlyeXYZfcl/uXXphYmFuYvJhFmUmZFpoZmg2b6Jvnm9ab25uJnWGdcp1qnWydkp6XnpOetJ74UqhWt1a2VrRWvFbkWEBbQ1t9W/ZbyV34YfphGGUUZRll5mYnZ+xqPnAwcDJwEHJ7c890YnZldiZ5KnkseSt5x3r2ekx8Q3xNfO988Hyuj31+fH6Cfkx/AIDagWaC+4X5hRGG+oUGhguGB4YKhhSIFYhkibqJ+Ilwi2yLZotvi1+La4sPjQ2NiY6BjoWOgo60kcuRGJQDlP2T4ZUwl8SYUplRmaiZK5owmjeaNZoTnA2ceZ61nuieL59fn2OfYZ83UThRwVbAVsJWFFlsXM1d/GH+YR1lHGWVZelm+2oEa/pqsmtMcBtyp3LWdNR0aXbTd1B8j36Mfrx/F4YthhqGI4giiCGIH4hqiWyJvYl0i3eLfYsTjYqOjY6Ljl+Pr4+6kS6UM5Q1lDqUOJQylCuU4pU4lzmXMpf/l2eYZZhXmUWaQ5pAmj6az5pUm1GbLZwlnK+dtJ3CnbidnZ7vnhmfXJ9mn2efPFE7UchWylbJVn9b1F3SXU5f/2EkZQprYWtRcFhwgHPkdIp1bnZsdrN5YHxffH6AfYDfgXKJb4n8iYCLFo0XjZGOk45hj0iRRJRRlFKUPZc+l8OXwZdrmFWZVZpNmtKaGptJnDGcPpw7nNOd1500n2yfap+Un8xW1l0AYiNlK2UqZexmEGvadMp6ZHxjfGV8k36WfpR+4oE4hj+GMYiKi5CQj5BjlGCUZJRol2+YXJlamluaV5rTmtSa0ZpUnFecVpzlnZ+e9J7RVulYLGVecHF2cnbXd1B/iH82iDmIYoiTi5KLlot3ghuNwJFqlEKXSJdEl8aXcJhfmiKbWJtfnPmd+p18nn2eB593n3Kf814Wa2NwbHxufDuIwImhjsGRcpRwlHGYXpnWmiObzJ5kcNp3mot3lMmXYpplmpx+nIuqjsWRfZR+lHyUd5x4nPeeVIx/lBqeKHJqmjGbG54ennJ8YCRhJGIkYyRkJGUkZiRnJGgkaSR0JHUkdiR3JHgkeSR6JHskfCR9JHAhcSFyIXMhdCF1IXYhdyF4IXkhNk4/ToVOoE6CUZZRq1H5UjhTaVO2UwpZgFvbXXpef170XlBfYV80ZeBlknV2drWPtpaoAMYC/TD+MJ0wnjAAAAAABTAGMAcw/DA7/z3/PSdBMEIwQzBEMEUwRjBHMEgwSTBKMEswTDBNME4wTzBQMFEwUjBTMFQwVTBWMFcwWDBZMFowWzBcMF0wXjBfMGAwYTBiMGMwZDBlMGYwZzBoMGkwajBrMGwwbTBuMG8wcDBxMHIwczB0MHUwdjB3MHgweTB6MHswfDB9MH4wfzCAMIEwgjCDMIQwhTCGMIcwiDCJMIowizCMMI0wjjCPMJAwkTCSMJMwoTCiMKMwpDClMKYwpzCoMKkwqjCrMKwwrTCuMK8wsDCxMLIwszC0MLUwtjC3MLgwuTC6MLswvDC9ML4wvzDAMMEwwjDDMMQwxTDGMMcwyDDJMMowyzDMMM0wzjDPMNAw0TDSMNMw1DDVMNYw1zDYMNkw2jDbMNww3TDeMN8w4DDhMOIw4zDkMOUw5jDnMOgw6TDqMOsw7DDtMO4w7zDwMPEw8jDzMPQw9TD2MBAEEQQSBBMEFAQVBAEEFgQXBBgEGQQaBBsEHAQdBB4EHwQgBCEEIgQjBCQEJQQmBCcEKAQpBCoEKwQsBC0ELgQvBDAEMQQyBDMENAQ1BFEENgQ3BDgEOQQ6BDsEPAQ9BD4EPwRABEEEQgRDBEQERQRGBEcESARJBEoESwRMBE0ETgRPBOchuCG5Ic8xzABaTooAAlKRRLCfiFGxnwd2AEGslAgLzXvi/+T/B/8C/zEyFiEhIZswnDCALoQuhi6HLoguii6MLo0ulS6cLp0upS6nLqourC6uLrYuvC6+LsYuyi7MLs0uzy7WLtcu3i7jLgAAAAAAAIMCUAJbAlQCdQJTAfgASwGKAmoCQk5cTvVRGlOCUwdODE5HTo1O11YM+m5cc18PTodRDk4uTpNOwk7JTshOmFH8UmxTuVMgVwNZLFkQXP9d4WWza8xrFGw/cjFOPE7oTtxO6U7hTt1O2k4MUhxTTFMiVyNXF1kvWYFbhFsSXDtcdFxzXARegF6CXslfCWJQYhVsNmxDbD9sO2yucrByinO4eYqAHpYOTxhPLE/1ThRP8U4AT/dOCE8dTwJPBU8iTxNPBE/0ThJPsVETUglSEFKmUiJTH1NNU4pTB1ThVt9WLlcqVzRXPFmAWXxZhVl7WX5Zd1l/WVZbFVwlXHxcelx7XH5c3111XoReAl8aX3Rf1V/UX89fXGJeYmRiYWJmYmJiWWJgYlpiZWLvZe5lPmc5ZzhnO2c6Zz9nPGczZxhsRmxSbFxsT2xKbFRsS2xMbHFwXnK0crVyjnMqdX92dXpRf3iCfIKAgn2Cf4JNhn6JmZCXkJiQm5CUkCKWJJYgliOWVk87T2JPSU9TT2RPPk9nT1JPX09BT1hPLU8zTz9PYU+PUblRHFIeUiFSrVKuUglTY1NyU45Tj1MwVDdUKlRUVEVUGVQcVCVUGFQ9VE9UQVQoVCRUR1TuVudW5VZBV0VXTFdJV0tXUlcGWUBZplmYWaBZl1mOWaJZkFmPWadZoVmOW5JbKFwqXI1cj1yIXItciVySXIpchlyTXJVc4F0KXg5ei16JXoxeiF6NXgVfHV94X3Zf0l/RX9Bf7V/oX+5f81/hX+Rf41/6X+9f91/7XwBg9F86YoNijGKOYo9ilGKHYnFie2J6YnBigWKIYndifWJyYnRiN2XwZfRl82XyZfVlRWdHZ1lnVWdMZ0hnXWdNZ1pnS2fQaxlsGmx4bGdsa2yEbItsj2xxbG9saWyabG1sh2yVbJxsZmxzbGVse2yObHRwenBjcr9yvXLDcsZywXK6csVylXOXc5NzlHOSczp1OXWUdZV1gXY9eTSAlYCZgJCAkoCcgJCCj4KFgo6CkYKTgoqCg4KEgniMyY+/j5+QoZClkJ6Qp5CgkDCWKJYvli2WM06YT3xPhU99T4BPh092T3RPiU+ET3dPTE+XT2pPmk95T4FPeE+QT5xPlE+eT5JPgk+VT2tPbk+eUbxRvlE1UjJSM1JGUjFSvFIKUwtTPFOSU5RTh1R/VIFUkVSCVIhUa1R6VH5UZVRsVHRUZlSNVG9UYVRgVJhUY1RnVGRU91b5Vm9XcldtV2tXcVdwV3ZXgFd1V3tXc1d0V2JXaFd9VwxZRVm1WbpZz1nOWbJZzFnBWbZZvFnDWdZZsVm9WcBZyFm0WcdZYltlW5NblVtEXEdcrlykXKBctVyvXKhcrFyfXKNcrVyiXKpcp1ydXKVctlywXKZcF14UXhleKF8iXyNfJF9UX4Jffl99X95f5V8tYCZgGWAyYAtgNGAKYBdgM2AaYB5gLGAiYA1gEGAuYBNgEWAMYAlgHGAUYj1irWK0YtFivmKqYrZiymKuYrNir2K7YqlisGK4Yj1lqGW7ZQlm/GUEZhJmCGb7ZQNmC2YNZgVm/WURZhBm9mYKZ4VnbGeOZ5Jndmd7Z5hnhmeEZ3RnjWeMZ3pnn2eRZ5lng2d9Z4FneGd5Z5RnJWuAa35r3msdbJNs7GzrbO5s2Wy2bNRsrWznbLds0GzCbLpsw2zGbO1s8mzSbN1stGyKbJ1sgGzebMBsMG3NbMdssGz5bM9s6WzRbJRwmHCFcJNwhnCEcJFwlnCCcJpwg3BqctZyy3LYcsly3HLSctRy2nLMctFypHOhc61zpnOic6BzrHOdc9106HQ/dUB1PnWMdZh1r3bzdvF28Hb1dvh3/Hf5d/t3+nf3d0J5P3nFeXh6e3r7enV8/Xw1gI+AroCjgLiAtYCtgCCCoILAgquCmoKYgpuCtYKngq6CvIKegrqCtIKogqGCqYLCgqSCw4K2gqKCcIZvhm2GboZWjNKPy4/Tj82P1o/Vj9ePspC0kK+Qs5CwkDmWPZY8ljqWQ5bNT8VP00+yT8lPy0/BT9RP3E/ZT7tPs0/bT8dP1k+6T8BPuU/sT0RSSVLAUsJSPVN8U5dTllOZU5hTulShVK1UpVTPVMNUDYO3VK5U1lS2VMVUxlSgVHBUvFSiVL5UclTeVLBUtVeeV59XpFeMV5dXnVebV5RXmFePV5lXpVeaV5VX9FgNWVNZ4VneWe5ZAFrxWd1Z+ln9WfxZ9lnkWfJZ91nbWelZ81n1WeBZ/ln0We1ZqFtMXNBc2FzMXNdcy1zbXN5c2lzJXMdcylzWXNNc1FzPXMhcxlzOXN9c+Fz5XSFeIl4jXiBeJF6wXqReol6bXqNepV4HXy5fVl+GXzdgOWBUYHJgXmBFYFNgR2BJYFtgTGBAYEJgX2AkYERgWGBmYG5gQmJDYs9iDWMLY/ViDmMDY+ti+WIPYwxj+GL2YgBjE2MUY/piFWP7YvBiQWVDZaplv2U2ZiFmMmY1ZhxmJmYiZjNmK2Y6Zh1mNGY5Zi5mD2cQZ8Fn8mfIZ7pn3Ge7Z/hn2GfAZ7dnxWfrZ+Rn32e1Z81ns2f3Z/Zn7mfjZ8JnuWfOZ+dn8GeyZ/xnxmftZ8xnrmfmZ9tn+mfJZ8pnw2fqZ8tnKGuCa4RrtmvWa9hr4GsgbCFsKG00bS1tH208bT9tEm0KbdpsM20EbRltOm0abRFtAG0dbUJtAW0YbTdtA20PbUBtB20gbSxtCG0ibQltEG23cJ9wvnCxcLBwoXC0cLVwqXBBcklySnJscnByc3Jucspy5HLocuty33LqcuZy43KFc8xzwnPIc8VzuXO2c7VztHPrc79zx3O+c8NzxnO4c8tz7HTudC51R3VIdad1qnV5dsR2CHcDdwR3BXcKd/d2+3b6dud36HcGeBF4EngFeBB4D3gOeAl4A3gTeEp5THlLeUV5RHnVec15z3nWec55gHp+etF6AHsBe3p8eHx5fH98gHyBfAN9CH0BfVh/kX+Nf75/B4AOgA+AFIA3gNiAx4DggNGAyIDCgNCAxYDjgNmA3IDKgNWAyYDPgNeA5oDNgP+BIYKUgtmC/oL5ggeD6IIAg9WCOoPrgtaC9ILsguGC8oL1ggyD+4L2gvCC6oLkguCC+oLzgu2Cd4Z0hnyGc4ZBiE6IZ4hqiGmI04kEigeKco3jj+GP7o/gj/GQvZC/kNWQxZC+kMeQy5DIkNSR05FUlk+WUZZTlkqWTpYeUAVQB1ATUCJQMFAbUPVP9E8zUDdQLFD2T/dPF1AcUCBQJ1A1UC9QMVAOUFpRlFGTUcpRxFHFUchRzlFhUlpSUlJeUl9SVVJiUs1SDlOeUyZV4lQXVRJV51TzVORUGlX/VARVCFXrVBFVBVXxVApV+1T3VPhU4FQOVQNVC1UBVwJXzFcyWNVX0le6V8ZXvVe8V7hXtle/V8dX0Fe5V8FXDllKWRlaFlotWi5aFVoPWhdaCloeWjNabFunW61brFsDXFZcVFzsXP9c7lzxXPdcAF35XCleKF6oXq5eql6sXjNfMF9nX11gWmBnYEFgomCIYIBgkmCBYJ1gg2CVYJtgl2CHYJxgjmAZYkZi8mIQY1ZjLGNEY0VjNmNDY+RjOWNLY0pjPGMpY0FjNGNYY1RjWWMtY0djM2NaY1FjOGNXY0BjSGNKZUZlxmXDZcRlwmVKZl9mR2ZRZhJnE2cfaBpoSWgyaDNoO2hLaE9oFmgxaBxoNWgraC1oL2hOaERoNGgdaBJoFGgmaChoLmhNaDpoJWggaCxrL2stazFrNGtta4KAiGvma+Rr6Gvja+Jr52slbHptY21kbXZtDW1hbZJtWG1ibW1tb22RbY1t721/bYZtXm1nbWBtl21wbXxtX22CbZhtL21obYttfm2AbYRtFm2DbXttfW11bZBt3HDTcNFw3XDLcDl/4nDXcNJw3nDgcNRwzXDFcMZwx3DacM5w4XBCcnhyd3J2cgBz+nL0cv5y9nLzcvtyAXPTc9lz5XPWc7xz53Pjc+lz3HPSc9tz1HPdc9pz13PYc+hz3nTfdPR09XQhdVt1X3WwdcF1u3XEdcB1v3W2dbp1inbJdh13G3cQdxN3EncjdxF3FXcZdxp3IncndyN4LHgieDV4L3goeC54K3gheCl4M3gqeDF4VHlbeU95XHlTeVJ5UXnreex54Hnuee156nnced553XmGeol6hXqLeox6inqHeth6EHsEexN7BXsPewh7CnsOewl7EnuEfJF8inyMfIh8jXyFfB59HX0RfQ59GH0WfRN9H30SfQ99DH1cf2F/Xn9gf11/W3+Wf5J/w3/Cf8B/FoA+gDmA+oDygPmA9YABgfuAAIEBgi+CJYIzgy2DRIMZg1GDJYNWgz+DQYMmgxyDIoNCg06DG4MqgwiDPINNgxaDJIMggzeDL4Mpg0eDRYNMg1ODHoMsg0uDJ4NIg1OGUoaihqiGloaNhpGGnoaHhpeGhoaLhpqGhYalhpmGoYanhpWGmIaOhp2GkIaUhkOIRIhtiHWIdohyiICIcYh/iG+Ig4h+iHSIfIgSikeMV4x7jKSMo4x2jXiNtY23jbaN0Y7Tjv6P9Y8CkP+P+48EkPyP9o/WkOCQ2ZDakOOQ35DlkNiQ25DXkNyQ5JBQkU6RT5HVkeKR2pFcll+WvJbjmN+aL5t/TnBQalBhUF5QYFBTUEtQXVByUEhQTVBBUFtQSlBiUBVQRVBfUGlQa1BjUGRQRlBAUG5Qc1BXUFFQ0FFrUm1SbFJuUtZS01ItU5xTdVV2VTxVTVVQVTRVKlVRVWJVNlU1VTBVUlVFVQxVMlVlVU5VOVVIVS1VO1VAVUtVClcHV/tXFFjiV/ZX3Ff0VwBY7Vf9VwhY+FcLWPNXz1cHWO5X41fyV+VX7FfhVw5Y/FcQWOdXAVgMWPFX6VfwVw1YBFhcWWBaWFpVWmdaXlo4WjVabVpQWl9aZVpsWlNaZFpXWkNaXVpSWkRaW1pIWo5aPlpNWjlaTFpwWmlaR1pRWlZaQlpcWnJbblvBW8BbWVweXQtdHV0aXSBdDF0oXQ1dJl0lXQ9dMF0SXSNdH10uXT5eNF6xXrReuV6yXrNeNl84X5tfll+fX4pgkGCGYL5gsGC6YNNg1GDPYORg2WDdYMhgsWDbYLdgymC/YMNgzWDAYDJjZWOKY4JjfWO9Y55jrWOdY5djq2OOY29jh2OQY25jr2N1Y5xjbWOuY3xjpGM7Y59jeGOFY4FjkWONY3BjU2XNZWVmYWZbZllmXGZiZhhneWiHaJBonGhtaG5ormiraFZpb2ijaKxoqWh1aHRosmiPaHdokmh8aGtocmiqaIBocWh+aJtolmiLaKBoiWikaHhoe2iRaIxoimh9aDZrM2s3azhrkWuPa41rjmuMaypswG2rbbRts210bqxt6W3ibbdt9m3UbQBuyG3gbd9t1m2+beVt3G3dbdtt9G3Kbb1t7W3wbbpt1W3Cbc9tyW3QbfJt0239bddtzW3jbbtt+nANcfdwF3H0cAxx8HAEcfNwEHH8cP9wBnETcQBx+HD2cAtxAnEOcX5ye3J8cn9yHXMXcwdzEXMYcwpzCHP/cg9zHnOIc/Zz+HP1cwR0AXT9cwd0AHT6c/xz/3MMdAt09HMIdGR1Y3XOddJ1z3XLdcx10XXQdY92iXbTdjl3L3ctdzF3Mnc0dzN3PXcldzt3NXdIeFJ4SXhNeEp4THgmeEV4UHhkeWd5aXlqeWN5a3lhebt5+nn4efZ593mPepR6kHo1e0d7NHslezB7InskezN7GHsqex17MXsrey17L3syezh7Gnsje5R8mHyWfKN8NX09fTh9Nn06fUV9LH0pfUF9R30+fT99Sn07fSh9Y3+Vf5x/nX+bf8p/y3/Nf9B/0X/Hf89/yX8fgB6AG4BHgEOASIAYgSWBGYEbgS2BH4EsgR6BIYEVgSeBHYEigRGCOIIzgjqCNIIygnSCkIOjg6iDjYN6g3ODpIN0g4+DgYOVg5mDdYOUg6mDfYODg4yDnYObg6qDi4N+g6WDr4OIg5eDsIN/g6aDh4Oug3aDmoNZhlaGv4a3hsKGwYbFhrqGsIbIhrmGs4a4hsyGtIa7hryGw4a9hr6GUoiJiJWIqIiiiKqImoiRiKGIn4iYiKeImYibiJeIpIisiIyIk4iOiIKJ1onZidWJMIoniiyKHoo5jDuMXIxdjH2MpYx9jXuNeY28jcKNuY2/jcGN2I7ejt2O3I7XjuCO4Y4kkAuQEZAckAyQIZDvkOqQ8JD0kPKQ85DUkOuQ7JDpkFaRWJFakVORVZHskfSR8ZHzkfiR5JH5keqR65H3keiR7pF6lYaViJV8lm2Wa5Zxlm+Wv5ZqlwSY5ZiXmZtQlVCUUJ5Qi1CjUINQjFCOUJ1QaFCcUJJQglCHUF9R1FESUxFTpFOnU5FVqFWlVa1Vd1VFVqJVk1WIVY9VtVWBVaNVklWkVX1VjFWmVX9VlVWhVY5VDFcpWDdYGVgeWCdYI1goWPVXSFglWBxYG1gzWD9YNlguWDlYOFgtWCxYO1hhWa9alFqfWnpaolqeWnhaplp8WqVarFqVWq5aN1qEWopal1qDWotaqVp7Wn1ajFqcWo9ak1qdWupbzVvLW9Rb0VvKW85bDFwwXDddQ11rXUFdS10/XTVdUV1OXVVdM106XVJdPV0xXVldQl05XUldOF08XTJdNl1AXUVdRF5BXlhfpl+lX6tfyWC5YMxg4mDOYMRgFGHyYAphFmEFYfVgE2H4YPxg/mDBYANhGGEdYRBh/2AEYQthSmKUY7FjsGPOY+Vj6GPvY8NjnWTzY8pj4GP2Y9Vj8mP1Y2Fk32O+Y91j3GPEY9hj02PCY8djzGPLY8hj8GPXY9ljMmVnZWplZGVcZWhlZWWMZZ1lnmWuZdBl0mV8Zmxme2aAZnFmeWZqZnJmAWcMadNoBGncaCpp7GjqaPFoD2nWaPdo62jkaPZoE2kQafNo4WgHacxoCGlwabRoEWnvaMZoFGn4aNBo/Wj8aOhoC2kKaRdpzmjIaN1o3mjmaPRo0WgGadRo6WgVaSVpx2g5aztrP2s8a5Rrl2uZa5VrvWvwa/Jr82swbPxtRm5Hbh9uSW6IbjxuPW5FbmJuK24/bkFuXW5zbhxuM25LbkBuUW47bgNuLm5ebmhuXG5hbjFuKG5gbnFua245biJuMG5TbmVuJ254bmRud25VbnluUm5mbjVuNm5abiBxHnEvcftwLnExcSNxJXEicTJxH3EocTpxG3FLclpyiHKJcoZyhXKLchJzC3MwcyJzMXMzcydzMnMtcyZzI3M1cwxzLnQsdDB0K3QWdBp0IXQtdDF0JHQjdB10KXQgdDJ0+3QvdW91bHXnddp14XXmdd1133Xkddd1lXaSdtp2RndHd0R3TXdFd0p3TndLd0x33nfsd2B4ZHhleFx4bXhxeGp4bnhweGl4aHheeGJ4dHlzeXJ5cHkCegp6A3oMegR6mXrmeuR6Sns7e0R7SHtMe057QHtYe0V7onyefKh8oXxYfW99Y31TfVZ9Z31qfU99bX1cfWt9Un1UfWl9UX1ffU59Pn8/f2V/Zn+if6B/oX/Xf1GAT4BQgP6A1IBDgUqBUoFPgUeBPYFNgTqB5oHugfeB+IH5gQSCPII9gj+CdYI7g8+D+YMjhMCD6IMShOeD5IP8g/aDEITGg8iD64Pjg7+DAYTdg+WD2IP/g+GDy4POg9aD9YPJgwmED4TegxGEBoTCg/OD1YP6g8eD0YPqgxOEw4Psg+6DxIP7g9eD4oMbhNuD/oPYhuKG5obThuOG2obqht2G64bchuyG6YbXhuiG0YZIiFaIVYi6iNeIuYi4iMCIvoi2iLyIt4i9iLKIAYnJiJWJmImXid2J2onbiU6KTYo5ilmKQIpXiliKRIpFilKKSIpRikqKTIpPil+MgYyAjLqMvoywjLmMtYyEjYCNiY3YjdONzY3HjdaN3I3PjdWN2Y3IjdeNxY3vjveO+o75juaO7o7ljvWO547ojvaO647xjuyO9I7pji2QNJAvkAaRLJEEkf+Q/JAIkfmQ+5ABkQCRB5EFkQORYZFkkV+RYpFgkQGSCpIlkgOSGpImkg+SDJIAkhKS/5H9kQaSBJInkgKSHJIkkhmSF5IFkhaSe5WNlYyVkJWHln6WiJaJloOWgJbClsiWw5bxlvCWbJdwl26XB5ipmOuY5pz5noNOhE62Tr1Qv1DGUK5QxFDKULRQyFDCULBQwVC6ULFQy1DJULZQuFDXUXpSeFJ7UnxSw1XbVcxV0FXLVcpV3VXAVdRVxFXpVb9V0lWNVc9V1VXiVdZVyFXyVc1V2VXCVRRXU1hoWGRYT1hNWElYb1hVWE5YXVhZWGVYW1g9WGNYcVj8WMdaxFrLWrpauFqxWrVasFq/Wshau1rGWrdawFrKWrRatlrNWrlakFrWW9hb2VsfXDNccV1jXUpdZV1yXWxdXl1oXWddYl3wXU9eTl5KXk1eS17FXsxexl7LXsdeQF+vX61f92BJYUphK2FFYTZhMmEuYUZhL2FPYSlhQGEgYmiRI2IlYiRixWPxY+tjEGQSZAlkIGQkZDNkQ2QfZBVkGGQ5ZDdkImQjZAxkJmQwZChkQWQ1ZC9kCmQaZEBkJWQnZAtk52MbZC5kIWQOZG9lkmXTZYZmjGaVZpBmi2aKZplmlGZ4ZiBnZmlfaThpTmliaXFpP2lFaWppOWlCaVdpWWl6aUhpSWk1aWxpM2k9aWVp8Gh4aTRpaWlAaW9pRGl2aVhpQWl0aUxpO2lLaTdpXGlPaVFpMmlSaS9pe2k8aUZrRWtDa0JrSGtBa5trDfr7a/xr+Wv3a/hrm27Wbshuj27Abp9uk26UbqBusW65bsZu0m69bsFunm7JbrdusG7NbqZuz26ybr5uw27cbthumW6Sbo5ujW6kbqFuv26zbtBuym6Xbq5uo25HcVRxUnFjcWBxQXFdcWJxcnF4cWpxYXFCcVhxQ3FLcXBxX3FQcVNxRHFNcVpxT3KNcoxykXKQco5yPHNCcztzOnNAc0pzSXNEdEp0S3RSdFF0V3RAdE90UHROdEJ0RnRNdFR04XT/dP50/XQddXl1d3WDae91D3YDdvd1/nX8dfl1+HUQdvt19nXtdfV1/XWZdrV23XZVd193YHdSd1Z3Wndpd2d3VHdZd2134HeHeJp4lHiPeIR4lXiFeIZ4oXiDeHl4mXiAeJZ4e3h8eYJ5fXl5eRF6GHoZehJ6F3oVeiJ6E3obehB6o3qiep5663pme2R7bXt0e2l7cntle3N7cXtwe2F7eHt2e2N7sny0fK98iH2GfYB9jX1/fYV9en2OfXt9g318fYx9lH2EfX19kn1tf2t/Z39of2x/pn+lf6d/23/cfyGAZIFggXeBXIFpgVuBYoFygSFnXoF2gWeBb4FEgWGBHYJJgkSCQIJCgkWC8YQ/hFaEdoR5hI+EjYRlhFGEQISGhGeEMIRNhH2EWoRZhHSEc4RdhAeFXoQ3hDqENIR6hEOEeIQyhEWEKYTZg0uEL4RChC2EX4RwhDmEToRMhFKEb4TFhI6EO4RHhDaEM4RohH6ERIQrhGCEVIRuhFCEC4cEh/eGDIf6htaG9YZNh/iGDocJhwGH9oYNhwWH1ojLiM2IzojeiNuI2ojMiNCIhYmbid+J5YnkieGJ4IniidyJ5ol2ioaKf4phij+Kd4qCioSKdYqDioGKdIp6ijyMS4xKjGWMZIxmjIaMhIyFjMyMaI1pjZGNjI2OjY+NjY2TjZSNkI2SjfCN4I3sjfGN7o3QjemN443ijeeN8o3rjfSNBo//jgGPAI8FjwePCI8CjwuPUpA/kESQSZA9kBCRDZEPkRGRFpEUkQuRDpFukW+RSJJSkjCSOpJmkjOSZZJekoOSLpJKkkaSbZJskk+SYJJnkm+SNpJhknCSMZJUkmOSUJJykk6SU5JMklaSMpKflZyVnpWblZKWk5aRlpeWzpb6lv2W+Jb1lnOXd5d4l3KXD5gNmA6YrJj2mPmYr5mymbCZtZmtmquaW5vqnO2c55yAnv2e5lDUUNdQ6FDzUNtQ6lDdUORQ01DsUPBQ71DjUOBQ2FGAUoFS6VLrUjBTrFMnVhVWDFYSVvxVD1YcVgFWE1YCVvpVHVYEVv9V+VWJWHxYkFiYWIZYgVh/WHRYi1h6WIdYkViOWHZYgliIWHtYlFiPWP5Ya1ncWu5a5VrVWupa2lrtWuta81riWuBa21rsWt5a3VrZWuha31p3W+Bb41tjXIJdgF19XYZdel2BXXddil2JXYhdfl18XY1deV1/XVheWV5TXthe0V7XXs5e3F7VXtle0l7UXkRfQ19vX7ZfLGEoYUFhXmFxYXNhUmFTYXJhbGGAYXRhVGF6YVthZWE7YWphYWFWYSliJ2IrYitkTWRbZF1kdGR2ZHJkc2R9ZHVkZmSmZE5kgmReZFxkS2RTZGBkUGR/ZD9kbGRrZFlkZWR3ZHNloGWhZqBmn2YFZwRnImexabZpyWmgac5plmmwaaxpvGmRaZlpjmmnaY1pqWm+aa9pv2nEab1ppGnUablpymmaac9ps2mTaappoWmeadlpl2mQacJptWmlacZpSmtNa0trnmufa6Brw2vEa/5rzm71bvFuA28lb/huN2/7bi5vCW9ObxlvGm8nbxhvO28Sb+1uCm82b3Nv+W7ubi1vQG8wbzxvNW/rbgdvDm9DbwVv/W72bjlvHG/8bjpvH28Nbx5vCG8hb4dxkHGJcYBxhXGCcY9xe3GGcYFxl3FEclNyl3KVcpNyQ3NNc1FzTHNidHN0cXR1dHJ0Z3RudAB1AnUDdX11kHUWdgh2DHYVdhF2CnYUdrh2gXd8d4V3gndud4B3b3d+d4N3sniqeLR4rXioeH54q3ieeKV4oHiseKJ4pHiYeYp5i3mWeZV5lHmTeZd5iHmSeZB5K3pKejB6L3ooeiZ6qHqreqx67nqIe5x7inuRe5B7lnuNe4x7m3uOe4V7mHuEUpl7pHuCe7t8v3y8fLp8p323fcJ9o32qfcF9wH3FfZ19zn3EfcZ9y33Mfa99uX2Wfbx9n32mfa59qX2hfcl9c3/if+N/5X/efySAXYBcgImBhoGDgYeBjYGMgYuBFYKXhKSEoYSfhLqEzoTChKyEroSrhLmEtITBhM2EqoSahLGE0ISdhKeEu4SihJSEx4TMhJuEqYSvhKiE1oSYhLaEz4SghNeE1ITShNuEsISRhGGGM4cjhyiHa4dAhy6HHochhxmHG4dDhyyHQYc+h0aHIIcyhyqHLYc8hxKHOocxhzWHQocmhyeHOIckhxqHMIcRh/eI54jxiPKI+oj+iO6I/Ij2iPuI8IjsiOuInYmhiZ+JnonpieuJ6ImripmKi4qSio+Kloo9jGiMaYzVjM+M14yWjQmOAo7/jQ2O/Y0KjgOOB44GjgWO/o0AjgSOEI8Rjw6PDY8jkRyRIJEikR+RHZEakSSRIZEbkXqRcpF5kXORpZKkknaSm5J6kqCSlJKqko2SppKakquSeZKXkn+So5Luko6SgpKVkqKSfZKIkqGSipKGkoySmZKnkn6Sh5Kpkp2Si5Itkp6WoZb/lliXfZd6l36Xg5eAl4KXe5eEl4GXf5fOl82XFpitmK6YApkAmQeZnZmcmcOZuZm7mbqZwpm9mceZsZrjmueaPps/m2CbYZtfm/Gc8pz1nKee/1ADUTBR+FAGUQdR9lD+UAtRDFH9UApRi1KMUvFS71JIVkJWTFY1VkFWSlZJVkZWWFZaVkBWM1Y9VixWPlY4VipWOlYaV6tYnVixWKBYo1ivWKxYpVihWP9Y/1r0Wv1a91r2WgNb+FoCW/laAVsHWwVbD1tnXJldl12fXZJdol2TXZVdoF2cXaFdml2eXWleXV5gXlxe833bXt5e4V5JX7Jfi2GDYXlhsWGwYaJhiWGbYZNhr2GtYZ9hkmGqYaFhjWFmYbNhLWJuZHBklmSgZIVkl2ScZI9ki2SKZIxko2SfZGhksWSYZHZlemV5ZXtlsmWzZbVmsGapZrJmt2aqZq9mAGoGahdq5Wn4aRVq8WnkaSBq/2nsaeJpG2odav5pJ2ryae5pFGr3aedpQGoIauZp+2kNavxp62kJagRqGGolag9q9mkmagdq9GkWalFrpWuja6JrpmsBbABs/2sCbEFvJm9+b4dvxm+Sb41viW+Mb2JvT2+Fb1pvlm92b2xvgm9Vb3JvUm9Qb1dvlG+Tb11vAG9hb2tvfW9nb5BvU2+Lb2lvf2+Vb2Nvd29qb3tvsnGvcZtxsHGgcZpxqXG1cZ1xpXGecaRxoXGqcZxxp3GzcZhymnJYc1JzXnNfc2BzXXNbc2FzWnNZc2Jzh3SJdIp0hnSBdH10hXSIdHx0eXQIdQd1fnUldh52GXYddhx2I3Yadih2G3acdp12nnabdo13j3eJd4h3zXi7eM94zHjReM541HjIeMN4xHjJeJp5oXmgeZx5onmbeXZrOXqyerR6s3q3e8t7vnuse857r3u5e8p7tXvFfMh8zHzLfPd9233qfed9133hfQN++n3mffZ98X3wfe593312f6x/sH+tf+1/63/qf+x/5n/of2SAZ4CjgZ+BnoGVgaKBmYGXgRaCT4JTglKCUIJOglGCJIU7hQ+FAIUphQ6FCYUNhR+FCoUnhRyF+4QrhfqECIUMhfSEKoXyhBWF94TrhPOE/IQSheqE6YQWhf6EKIUdhS6FAoX9hB6F9oQxhSaF54TohPCE74T5hBiFIIUwhQuFGYUvhWKGVodjh2SHd4fhh3OHWIdUh1uHUodhh1qHUYdeh22HaodQh06HX4ddh2+HbId6h26HXIdlh0+He4d1h2KHZ4dph1qIBYkMiRSJC4kXiRiJGYkGiRaJEYkOiQmJoomkiaOJ7YnwieyJz4rGiriK04rRitSK1Yq7iteKvorAisWK2IrDirqKvYrZij6MTYyPjOWM34zZjOiM2ozdjOeMoI2cjaGNm40gjiOOJY4kji6OFY4bjhaOEY4ZjiaOJ44UjhKOGI4TjhyOF44ajiyPJI8YjxqPII8jjxaPF49zkHCQb5BnkGuQL5ErkSmRKpEykSaRLpGFkYaRipGBkYKRhJGAkdCSw5LEksCS2ZK2ks+S8ZLfktiS6ZLXkt2SzJLvksKS6JLKksiSzpLmks2S1ZLJkuCS3pLnktGS05K1kuGSxpK0knyVrJWrla6VsJWklqKW05YFlwiXApdal4qXjpeIl9CXz5cemB2YJpgpmCiYIJgbmCeYspgImfqYEZkUmRaZF5kVmdyZzZnPmdOZ1JnOmcmZ1pnYmcuZ15nMmbOa7JrrmvOa8prxmkabQ5tnm3SbcZtmm3abdZtwm2ibZJtsm/yc+pz9nP+c95wHnQCd+Zz7nAidBZ0EnYOe054PnxCfHFETURdRGlERUd5RNFPhU3BWYFZuVnNWZlZjVm1WclZeVndWHFcbV8hYvVjJWL9YuljCWLxYxlgXWxlbG1shWxRbE1sQWxZbKFsaWyBbHlvvW6xdsV2pXaddtV2wXa5dql2oXbJdrV2vXbRdZ15oXmZeb17pXude5l7oXuVeS1+8X51hqGGWYcVhtGHGYcFhzGG6Yb9huGGMYddk1mTQZM9kyWS9ZIlkw2TbZPNk2WQzZX9lfGWiZchmvmbAZspmy2bPZr1mu2a6ZsxmI2c0amZqSWpnajJqaGo+al1qbWp2altqUWooalpqO2o/akFqampkalBqT2pUam9qaWpgajxqXmpWalVqTWpOakZqVWtUa1Zrp2uqa6tryGvHawRsA2wGbK1vy2+jb8dvvG/Ob8hvXm/Eb71vnm/Kb6hvBHClb65vum+sb6pvz2+/b7hvom/Jb6tvzW+vb7JvsG/FccJxv3G4cdZxwHHBcctx1HHKccdxz3G9cdhxvHHGcdpx23Gdcp5yaXNmc2dzbHNlc2tzanN/dJp0oHSUdJJ0lXShdAt1gHUvdi12MXY9djN2PHY1djJ2MHa7duZ2mnedd6F3nHebd6J3o3eVd5l3l3fdeOl45XjqeN5443jbeOF44njteN944HikeUR6SHpHerZ6uHq1erF6t3ree+N753vde9V75Xvae+h7+XvUe+p74nvce+t72Hvfe9J81HzXfNB80XwSfiF+F34Mfh9+IH4Tfg5+HH4Vfhp+In4Lfg9+Fn4NfhR+JX4kfkN/e398f3p/sX/vfyqAKYBsgLGBpoGugbmBtYGrgbCBrIG0gbKBt4GngfKBVYJWgleCVoVFhWuFTYVThWGFWIVAhUaFZIVBhWKFRIVRhUeFY4U+hVuFcYVOhW6FdYVVhWeFYIWMhWaFXYVUhWWFbIVjhmWGZIabh4+Hl4eTh5KHiIeBh5aHmId5h4eHo4eFh5CHkYedh4SHlIech5qHiYceiSaJMIktiS6JJ4kxiSKJKYkjiS+JLIkfifGJ4IriivKK9Ir1it2KFIvkit+K8IrIit6K4Yroiv+K74r7ipGMkoyQjPWM7ozxjPCM84xsjW6NpY2njTOOPo44jkCORY42jjyOPY5BjjCOP469jjaPLo81jzKPOY83jzSPdpB5kHuQhpD6kDORNZE2kZORkJGRkY2Rj5Enkx6TCJMfkwaTD5N6kziTPJMbkyOTEpMBk0aTLZMOkw2Ty5Idk/qSJZMTk/mS95I0kwKTJJP/kimTOZM1kyqTFJMMkwuT/pIJkwCT+5IWk7yVzZW+lbmVupW2lb+VtZW9lamW1JYLlxKXEJeZl5eXlJfwl/iXNZgvmDKYJJkfmSeZKZmeme6Z7JnlmeSZ8JnjmeqZ6Znnmbmav5q0mrua9pr6mvma95ozm4CbhZuHm3ybfpt7m4Kbk5uSm5CbepuVm32biJslnRedIJ0enRSdKZ0dnRidIp0QnRmdH52Inoaeh56unq2e1Z7WnvqeEp89nyZRJVEiUSRRIFEpUfRSk1aMVo1WhlaEVoNWflaCVn9WgVbWWNRYz1jSWC1bJVsyWyNbLFsnWyZbL1suW3tb8VvyW7ddbF5qXr5fu1/DYbVhvGHnYeBh5WHkYehh3mHvZOlk42TrZORk6GSBZYBltmXaZdJmjWqWaoFqpWqJap9qm2qhap5qh2qTao5qlWqDaqhqpGqRan9qpmqaaoVqjGqSaltrrWsJbMxvqW/0b9Rv42/cb+1v52/mb95v8m/db+Jv6G/hcfFx6HHyceRx8HHicXNzbnNvc5d0snSrdJB0qnStdLF0pXSvdBB1EXUSdQ91hHVDdkh2SXZHdqR26Xa1d6t3sne3d7Z3tHexd6h38HfzeP14Ann7ePx48ngFefl4/ngEeat5qHlcelt6VnpYelR6Wnq+esB6wXoFfA988nsAfP97+3sOfPR7C3zzewJ8CXwDfAF8+Hv9ewZ88HvxexB8CnzofC1+PH5CfjN+SJg4fip+SX5Afkd+KX5MfjB+O342fkR+On5Ff39/fn99f/R/8n8sgLuBxIHMgcqBxYHHgbyB6YFbglqCXIKDhYCFj4WnhZWFoIWLhaOFe4WkhZqFnoV3hXyFiYWhhXqFeIVXhY6FloWGhY2FmYWdhYGFooWChYiFhYV5hXaFmIWQhZ+FaIa+h6qHrYfFh7CHrIe5h7WHvIeuh8mHw4fCh8yHt4evh8SHyoe0h7aHv4e4h72H3oeyhzWJM4k8iT6JQYlSiTeJQomtia+JronyifOJHosYixaLEYsFiwuLIosPixKLFYsHiw2LCIsGixyLE4sai0+McIxyjHGMb4yVjJSM+YxvjU6OTY5TjlCOTI5HjkOPQI+FkH6QOJGakaKRm5GZkZ+RoZGdkaCRoZODk6+TZJNWk0eTfJNYk1yTdpNJk1CTUZNgk22Tj5NMk2qTeZNXk1WTUpNPk3GTd5N7k2GTXpNjk2eTgJNOk1mTx5XAlcmVw5XFlbeVrpawlqyWIJcflxiXHZcZl5qXoZecl56XnZfVl9SX8ZdBmESYSphJmEWYQ5glmSuZLJkqmTOZMpkvmS2ZMZkwmZiZo5mhmQKa+pn0mfeZ+Zn4mfaZ+5n9mf6Z/JkDmr6a/pr9mgGb/JpIm5qbqJuem5ubppuhm6WbpJuGm6KboJuvmzOdQZ1nnTadLp0vnTGdOJ0wnUWdQp1DnT6dN51AnT2d9X8tnYqeiZ6NnrCeyJ7anvue/54knyOfIp9Un6CfMVEtUS5RmFacVpdWmladVplWcFk8W2lcalzAXW1ebl7YYd9h7WHuYfFh6mHwYeth1mHpYf9kBGX9ZPhkAWUDZfxklGXbZdpm22bYZsVquWq9auFqxmq6arZqt2rHarRqrWpea8lrC2wHcAxwDXABcAVwFHAOcP9vAHD7byZw/G/3bwpwAXL/cflxA3L9cXZzuHTAdLV0wXS+dLZ0u3TCdBR1E3VcdmR2WXZQdlN2V3ZadqZ2vXbsdsJ3unf/eAx5E3kUeQl5EHkSeRF5rXmseV96HHwpfBl8IHwffC18HXwmfCh8InwlfDB8XH5QflZ+Y35YfmJ+X35RfmB+V35TfrV/s3/3f/h/dYDRgdKB0IFfgl6CtIXGhcCFw4XChbOFtYW9hceFxIW/hcuFzoXIhcWFsYW2hdKFJIa4hbeFvoVphueH5ofih9uH64fqh+WH34fzh+SH1Ifch9OH7YfYh+OHpIfXh9mHAYj0h+iH3YdTiUuJT4lMiUaJUIlRiUmJKosniyOLM4swizWLR4svizyLPosxiyWLN4smizaLLoskizuLPYs6i0KMdYyZjJiMl4z+jASNAo0AjVyOYo5gjleOVo5ejmWOZ45bjlqOYY5djmmOVI5Gj0ePSI9LjyiROpE7kT6RqJGlkaeRr5GqkbWTjJOSk7eTm5Odk4mTp5OOk6qTnpOmk5WTiJOZk5+TjZOxk5GTspOkk6iTtJOjk6WT0pXTldGVs5bXltqWwl3fltiW3ZYjlyKXJZesl66XqJerl6SXqpeil6WX15fZl9aX2Jf6l1CYUZhSmLiYQZk8mTqZD5oLmgmaDZoEmhGaCpoFmgeaBprAmtyaCJsEmwWbKZs1m0qbTJtLm8ebxpvDm7+bwZu1m7ib05u2m8SbuZu9m1ydU51PnUqdW51LnVmdVp1MnVedUp1UnV+dWJ1anY6ejJ7fngGfAJ8WnyWfK58qnymfKJ9Mn1WfNFE1UZZS91K0U6tWrVamVqdWqlasVtpY3VjbWBJZPVs+Wz9bw11wXr9f+2EHZRBlDWUJZQxlDmWEZd5l3WXeZudq4GrMatFq2WrLat9q3GrQautqz2rNat5qYGuwawxsGXAncCBwFnArcCFwInAjcClwF3AkcBxwKnAMcgpyB3ICcgVypXKmcqRyo3Khcst0xXS3dMN0FnVgdsl3ynfEd/F3HXkbeSF5HHkXeR55sHlnemh6M3w8fDl8LHw7fOx86nx2fnV+eH5wfnd+b356fnJ+dH5ofkt/Sn+Df4Z/t3/9f/5/eIDXgdWBZIJhgmOC64Xxhe2F2YXhheiF2oXXheyF8oX4hdiF34XjhdyF0YXwheaF74XeheKFAIj6hwOI9of3hwmIDIgLiAaI/IcIiP+HCogCiGKJWolbiVeJYYlciViJXYlZiYiJt4m2ifaJUItIi0qLQItTi1aLVItLi1WLUYtCi1KLV4tDjHeMdoyajAaNB40JjayNqo2tjauNbY54jnOOao5vjnuOwo5Sj1GPT49Qj1OPtI9AkT+RsJGtkd6Tx5PPk8KT2pPQk/mT7JPMk9mTqZPmk8qT1JPuk+OT1ZPEk86TwJPSk+eTfZXalduV4ZYplyuXLJcolyaXs5e3l7aX3Zfel9+XXJhZmF2YV5i/mL2Yu5i+mEiZR5lDmaaZp5kamhWaJZodmiSaG5oimiCaJ5ojmh6aHJoUmsKaC5sKmw6bDJs3m+qb65vgm96b5Jvmm+Kb8JvUm9eb7Jvcm9mb5ZvVm+Gb2pt3nYGdip2EnYidcZ2AnXidhp2LnYydfZ1rnXSddZ1wnWmdhZ1znXudgp1vnXmdf52HnWidlJ6RnsCe/J4tn0CfQZ9Nn1afV59YnzdTsla1VrNW41hFW8Zdx13uXu9ewF/BX/lhF2UWZRVlE2XfZehm42bkZvNq8Grqauhq+Wrxau5q72o8cDVwL3A3cDRwMXBCcDhwP3A6cDlwQHA7cDNwQXATchRyqHJ9c3xzunSrdqp2vnbtdsx3znfPd8138ncleSN5J3koeSR5KXmyeW56bHptevd6SXxIfEp8R3xFfO58e35+foF+gH66f/9/eYDbgdmBC4JogmmCIob/hQGG/oUbhgCG9oUEhgmGBYYMhv2FGYgQiBGIF4gTiBaIY4lmibmJ94lgi2qLXYtoi2OLZYtni22Lro2GjoiOhI5Zj1aPV49Vj1iPWo+NkEORQZG3kbWRspGzkQuUE5T7kyCUD5QUlP6TFZQQlCiUGZQNlPWTAJT3kweUDpQWlBKU+pMJlPiTCpT/k/yTDJT2kxGUBpTeleCV35Uuly+XuZe7l/2X/pdgmGKYY5hfmMGYwphQmU6ZWZlMmUuZU5kymjSaMZosmiqaNpopmi6aOJotmseayprGmhCbEpsRmwucCJz3mwWcEpz4m0CcB5wOnAacF5wUnAmcn52ZnaSdnZ2SnZidkJ2bnaCdlJ2cnaqdl52hnZqdop2onZ6do52/namdlp2mnaedmZ6bnpqe5Z7knuee5p4wny6fW59gn16fXZ9Zn5GfOlE5UZhSl1LDVr1WvlZIW0dby13PXfFe/WEbZQJr/GoDa/hqAGtDcERwSnBIcElwRXBGcB1yGnIZcn5zF3VqdtB3LXkxeS95VHxTfPJ8in6Hfoh+i36Gfo1+TX+7fzCA3YEYhiqGJoYfhiOGHIYZhieGLoYhhiCGKYYehiWGKYgdiBuIIIgkiByIK4hKiG2JaYluiWuJ+ol5i3iLRYt6i3uLEI0Uja+Njo6Mjl6PW49dj0aRRJFFkbmRP5Q7lDaUKZQ9lDyUMJQ5lCqUN5QslECUMZTlleSV45U1lzqXv5fhl2SYyZjGmMCYWJlWmTmaPZpGmkSaQppBmjqaP5rNmhWbF5sYmxabOptSmyucHZwcnCycI5wonCmcJJwhnLedtp28ncGdx53Knc+dvp3FncOdu521nc6duZ26naydyJ2xna2dzJ2znc2dsp16npye657unu2eG58YnxqfMZ9On2WfZJ+Sn7lOxlbFVstWcVlLW0xb1V3RXfJeIWUgZSZlImULawhrCWsNbFVwVnBXcFJwHnIfcqlyf3PYdNV02XTXdG12rXY1ebR5cHpxeld8XHxZfFt8Wnz0fPF8kX5Pf4d/3oFrgjSGNYYzhiyGMoY2hiyIKIgmiCqIJYhxib+Jvon7iX6LhIuCi4aLhYt/ixWNlY6UjpqOko6QjpaOl45gj2KPR5FMlFCUSpRLlE+UR5RFlEiUSZRGlD+X45dqmGmYy5hUmVuZTppTmlSaTJpPmkiaSppJmlKaUJrQmhmbK5s7m1abVZtGnEicP5xEnDmcM5xBnDycN5w0nDKcPZw2nNud0p3endqdy53Qndyd0Z3fnemd2Z3Yndad9Z3Vnd2dtp7wnjWfM58yn0Kfa5+Vn6KfPVGZUuhY51hyWU1b2F0viE9fAWIDYgRiKWUlZZZl62YRaxJrD2vKa1twWnAicoJzgXODc3B21HdnfGZ8lX5sgjqGQIY5hjyGMYY7hj6GMIgyiC6IM4h2iXSJc4n+iYyLjouLi4iLRYwZjZiOZI9jj7yRYpRVlF2UV5RelMSXxZcA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rCCsJKwsrC2sL6wwrDGsOKw5rDysQKxLrE2sVKxYrFyscKxxrHSsd6x4rHqsgKyBrIOshKyFrIasiayKrIusjKyQrJSsnKydrJ+soKyhrKisqayqrKysr6ywrLisuay7rLysvazBrMSsyKzMrNWs16zgrOGs5KznrOis6qzsrO+s8KzxrPOs9az2rPys/awArQStBq0MrQ2tD60RrRitHK0grSmtLK0trTStNa04rTytRK1FrUetSa1QrVStWK1hrWOtbK1trXCtc610rXWtdq17rXytfa1/rYGtgq2IrYmtjK2QrZytna2krbetwK3BrcStyK3QrdGt063creCt5K34rfmt/K3/rQCuAa4IrgmuC64NrhSuMK4xrjSuN644rjquQK5BrkOuRa5GrkquTK5Nrk6uUK5UrlauXK5drl+uYK5hrmWuaK5prmyucK54rnmue658rn2uhK6FroyuvK69rr6uwK7Ersyuza7PrtCu0a7Yrtmu3K7oruuu7a70rviu/K4HrwivDa8QryyvLa8wrzKvNK88rz2vP69Br0KvQ69Ir0mvUK9cr12vZK9lr3mvgK+Er4ivkK+Rr5WvnK+4r7mvvK/Ar8evyK/Jr8uvza/Or9Sv3K/or+mv8K/xr/Sv+K8AsAGwBLAMsBCwFLAcsB2wKLBEsEWwSLBKsEywTrBTsFSwVbBXsFmwXbB8sH2wgLCEsIywjbCPsJGwmLCZsJqwnLCfsKCwobCisKiwqbCrsKywrbCusK+wsbCzsLSwtbC4sLywxLDFsMewyLDJsNCw0bDUsNiw4LDlsAixCbELsQyxELESsROxGLEZsRuxHLEdsSOxJLElsSixLLE0sTWxN7E4sTmxQLFBsUSxSLFQsVGxVLFVsVixXLFgsXixebF8sYCxgrGIsYmxi7GNsZKxk7GUsZixnLGoscyx0LHUsdyx3bHfseix6bHssfCx+bH7sf2xBLIFsgiyC7IMshSyFbIXshmyILI0sjyyWLJcsmCyaLJpsnSydbJ8soSyhbKJspCykbKUspiymbKasqCyobKjsqWyprKqsqyysLK0ssiyybLMstCy0rLYstmy27LdsuKy5LLlsuay6LLrsuyy7bLusu+y87L0svWy97L4svmy+rL7sv+yALMBswSzCLMQsxGzE7MUsxWzHLNUs1WzVrNYs1uzXLNes1+zZLNls2ezabNrs26zcLNxs3SzeLOAs4Gzg7OEs4WzjLOQs5SzoLOhs6izrLPEs8WzyLPLs8yzzrPQs9Sz1bPXs9mz27Pds+Cz5LPos/yzELQYtBy0ILQotCm0K7Q0tFC0UbRUtFi0YLRhtGO0ZbRstIC0iLSdtKS0qLSstLW0t7S5tMC0xLTItNC01bTctN204LTjtOS05rTstO2077TxtPi0FLUVtRi1G7UctSS1JbUntSi1KbUqtTC1MbU0tTi1QLVBtUO1RLVFtUu1TLVNtVC1VLVctV21X7VgtWG1oLWhtaS1qLWqtau1sLWxtbO1tLW1tbu1vLW9tcC1xLXMtc21z7XQtdG12LXstRC2EbYUthi2JbYstjS2SLZktmi2nLadtqC2pLartqy2sbbUtvC29Lb4tgC3AbcFtyi3Kbcsty+3MLc4tzm3O7dEt0i3TLdUt1W3YLdkt2i3cLdxt3O3dbd8t323gLeEt4y3jbePt5C3kbeSt5a3l7eYt5m3nLegt6i3qbert6y3rbe0t7W3uLfHt8m37Lftt/C39Lf8t/23/7cAuAG4B7gIuAm4DLgQuBi4GbgbuB24JLgluCi4LLg0uDW4N7g4uDm4QLhEuFG4U7hcuF24YLhkuGy4bbhvuHG4eLh8uI24qLiwuLS4uLjAuMG4w7jFuMy40LjUuN2437jhuOi46bjsuPC4+Lj5uPu4/bgEuRi5ILk8uT25QLlEuUy5T7lRuVi5WblcuWC5aLlpuWu5bbl0uXW5eLl8uYS5hbmHuYm5irmNuY65rLmtubC5tLm8ub25v7nBuci5ybnMuc65z7nQudG50rnYudm527ndud654bnjueS55bnouey59Ln1ufe5+Ln5ufq5ALoBugi6Fbo4ujm6PLpAukK6SLpJuku6TbpOulO6VLpVuli6XLpkumW6Z7poumm6cLpxunS6eLqDuoS6hbqHuoy6qLqpuqu6rLqwurK6uLq5uru6vbrEusi62LrZuvy6ALsEuw27D7sRuxi7HLsguym7K7s0uzW7Nrs4uzu7PLs9uz67RLtFu0e7SbtNu0+7ULtUu1i7Ybtju2y7iLuMu5C7pLuou6y7tLu3u8C7xLvIu9C707v4u/m7/Lv/uwC8ArwIvAm8C7wMvA28D7wRvBS8FbwWvBe8GLwbvBy8HbwevB+8JLwlvCe8KbwtvDC8Mbw0vDi8QLxBvEO8RLxFvEm8TLxNvFC8XbyEvIW8iLyLvIy8jryUvJW8l7yZvJq8oLyhvKS8p7yovLC8sbyzvLS8tby8vL28wLzEvM28z7zQvNG81bzYvNy89Lz1vPa8+Lz8vAS9Bb0HvQm9EL0UvSS9LL1AvUi9Sb1MvVC9WL1ZvWS9aL2AvYG9hL2HvYi9ib2KvZC9kb2TvZW9mb2avZy9pL2wvbi91L3Vvdi93L3pvfC99L34vQC+A74Fvgy+Db4QvhS+HL4dvh++RL5Fvki+TL5OvlS+Vb5Xvlm+Wr5bvmC+Yb5kvmi+ar5wvnG+c750vnW+e758vn2+gL6Evoy+jb6PvpC+kb6Yvpm+qL7QvtG+1L7Xvti+4L7jvuS+5b7svgG/CL8Jvxi/Gb8bvxy/Hb9Av0G/RL9Iv1C/Ub9Vv5S/sL/Fv8y/zb/Qv9S/3L/fv+G/PMBRwFjAXMBgwGjAacCQwJHAlMCYwKDAocCjwKXArMCtwK/AsMCzwLTAtcC2wLzAvcC/wMDAwcDFwMjAycDMwNDA2MDZwNvA3MDdwOTA5cDowOzA9MD1wPfA+cAAwQTBCMEQwRXBHMEdwR7BH8EgwSPBJMEmwSfBLMEtwS/BMMExwTbBOME5wTzBQMFIwUnBS8FMwU3BVMFVwVjBXMFkwWXBZ8FowWnBcMF0wXjBhcGMwY3BjsGQwZTBlsGcwZ3Bn8GhwaXBqMGpwazBsMG9wcTByMHMwdTB18HYweDB5MHowfDB8cHzwfzB/cEAwgTCDMINwg/CEcIYwhnCHMIfwiDCKMIpwivCLcIvwjHCMsI0wkjCUMJRwlTCWMJgwmXCbMJtwnDCdMJ8wn3Cf8KBwojCicKQwpjCm8KdwqTCpcKowqzCrcK0wrXCt8K5wtzC3cLgwuPC5MLrwuzC7cLvwvHC9sL4wvnC+8L8wgDDCMMJwwzDDcMTwxTDFcMYwxzDJMMlwyjDKcNFw2jDacNsw3DDcsN4w3nDfMN9w4TDiMOMw8DD2MPZw9zD38Pgw+LD6MPpw+3D9MP1w/jDCMQQxCTELMQwxDTEPMQ9xEjEZMRlxGjEbMR0xHXEecSAxJTEnMS4xLzE6cTwxPHE9MT4xPrE/8QAxQHFDMUQxRTFHMUoxSnFLMUwxTjFOcU7xT3FRMVFxUjFScVKxUzFTcVOxVPFVMVVxVfFWMVZxV3FXsVgxWHFZMVoxXDFccVzxXTFdcV8xX3FgMWExYfFjMWNxY/FkcWVxZfFmMWcxaDFqcW0xbXFuMW5xbvFvMW9xb7FxMXFxcbFx8XIxcnFysXMxc7F0MXRxdTF2MXgxeHF48XlxezF7cXuxfDF9MX2xffF/MX9xf7F/8UAxgHGBcYGxgfGCMYMxhDGGMYZxhvGHMYkxiXGKMYsxi3GLsYwxjPGNMY1xjfGOcY7xkDGQcZExkjGUMZRxlPGVMZVxlzGXcZgxmzGb8ZxxnjGecZ8xoDGiMaJxovGjcaUxpXGmMacxqTGpcanxqnGsMaxxrTGuMa5xrrGwMbBxsPGxcbMxs3G0MbUxtzG3cbgxuHG6MbpxuzG8Mb4xvnG/cYExwXHCMcMxxTHFccXxxnHIMchxyTHKMcwxzHHM8c1xzfHPMc9x0DHRMdKx0zHTcdPx1HHUsdTx1THVcdWx1fHWMdcx2DHaMdrx3THdcd4x3zHfcd+x4PHhMeFx4fHiMeJx4rHjseQx5HHlMeWx5fHmMeax6DHocejx6THpcemx6zHrcewx7THvMe9x7/HwMfBx8jHycfMx87H0MfYx93H5Mfox+zHAMgByATICMgKyBDIEcgTyBXIFsgcyB3IIMgkyCzILcgvyDHIOMg8yEDISMhJyEzITchUyHDIcch0yHjIesiAyIHIg8iFyIbIh8iLyIzIjciUyJ3In8ihyKjIvMi9yMTIyMjMyNTI1cjXyNnI4MjhyOTI9cj8yP3IAMkEyQXJBskMyQ3JD8kRyRjJLMk0yVDJUclUyVjJYMlhyWPJbMlwyXTJfMmIyYnJjMmQyZjJmcmbyZ3JwMnBycTJx8nIycrJ0MnRydPJ1cnWydnJ2sncyd3J4MniyeTJ58nsye3J78nwyfHJ+Mn5yfzJAMoIygnKC8oMyg3KFMoYyinKTMpNylDKVMpcyl3KX8pgymHKaMp9yoTKmMq8yr3KwMrEyszKzcrPytHK08rYytnK4MrsyvTKCMsQyxTLGMsgyyHLQctIy0nLTMtQy1jLWctdy2TLeMt5y5zLuMvUy+TL58vpywzMDcwQzBTMHMwdzCHMIswnzCjMKcwszC7MMMw4zDnMO8w8zD3MPsxEzEXMSMxMzFTMVcxXzFjMWcxgzGTMZsxozHDMdcyYzJnMnMygzKjMqcyrzKzMrcy0zLXMuMy8zMTMxczHzMnM0MzUzOTM7MzwzAHNCM0JzQzNEM0YzRnNG80dzSTNKM0szTnNXM1gzWTNbM1tzW/Ncc14zYjNlM2VzZjNnM2kzaXNp82pzbDNxM3MzdDN6M3szfDN+M35zfvN/c0EzgjODM4UzhnOIM4hziTOKM4wzjHOM841zljOWc5czl/OYM5hzmjOac5rzm3OdM51znjOfM6EzoXOh86JzpDOkc6UzpjOoM6hzqPOpM6lzqzOrc7BzuTO5c7ozuvO7M70zvXO9874zvnOAM8BzwTPCM8QzxHPE88VzxzPIM8kzyzPLc8vzzDPMc84z1TPVc9Yz1zPZM9lz2fPac9wz3HPdM94z4DPhc+Mz6HPqM+wz8TP4M/hz+TP6M/wz/HP88/1z/zPANAE0BHQGNAt0DTQNdA40DzQRNBF0EfQSdBQ0FTQWNBg0GzQbdBw0HTQfNB90IHQpNCl0KjQrNC00LXQt9C50MDQwdDE0MjQydDQ0NHQ09DU0NXQ3NDd0ODQ5NDs0O3Q79Dw0PHQ+NAN0TDRMdE00TjROtFA0UHRQ9FE0UXRTNFN0VDRVNFc0V3RX9Fh0WjRbNF80YTRiNGg0aHRpNGo0bDRsdGz0bXRutG80cDR2NH00fjRB9IJ0hDSLNIt0jDSNNI80j3SP9JB0kjSXNJk0oDSgdKE0ojSkNKR0pXSnNKg0qTSrNKx0rjSudK80r/SwNLC0sjSydLL0tTS2NLc0uTS5dLw0vHS9NL40gDTAdMD0wXTDNMN0w7TENMU0xbTHNMd0x/TINMh0yXTKNMp0yzTMNM40znTO9M80z3TRNNF03zTfdOA04TTjNON04/TkNOR05jTmdOc06DTqNOp06vTrdO007jTvNPE08XTyNPJ09DT2NPh0+PT7NPt0/DT9NP80/3T/9MB1AjUHdRA1ETUXNRg1GTUbdRv1HjUedR81H/UgNSC1IjUidSL1I3UlNSp1MzU0NTU1NzU39To1OzU8NT41PvU/dQE1QjVDNUU1RXVF9U81T3VQNVE1UzVTdVP1VHVWNVZ1VzVYNVl1WjVadVr1W3VdNV11XjVfNWE1YXVh9WI1YnVkNWl1cjVydXM1dDV0tXY1dnV29Xd1eTV5dXo1ezV9NX11ffV+dUA1gHWBNYI1hDWEdYT1hTWFdYc1iDWJNYt1jjWOdY81kDWRdZI1knWS9ZN1lHWVNZV1ljWXNZn1mnWcNZx1nTWg9aF1ozWjdaQ1pTWndaf1qHWqNas1rDWuda71sTWxdbI1szW0dbU1tfW2dbg1uTW6Nbw1vXW/Nb91gDXBNcR1xjXGdcc1yDXKNcp1yvXLdc01zXXONc810TXR9dJ11DXUddU11bXV9dY11nXYNdh12PXZddp12zXcNd013zXfdeB14jXideM15DXmNeZ15vXndcAQczJCQvDwQE9T3NPR1D5UKBS71N1VOVUCVbBWrZbh2a2Z7dn72dMa8JzwnU8etuCBINXiIiINorIjM+N+47mj9WZO1J0UwRUamBkYbxrz3MagbqJ0omjlYNPClK+WHhZ5llyXnlex2HAY0Zn7Gd/aJdvTnYLd/V4CHr/eiF8nYBugnGC64qTlWtOnVX3ZjRuo3jteluEEIlOh6iX2FJOVypYTF0fYb5hIWJiZdFnRGobbhh1s3XjdrB3On2vkFGUUpSVnyNTrFwydduAQJKYlVtSCFjcWaFcF123XjpfSl93YV9senWGdeB8c32xfYx/VIEhgpGFQYkbi/ySTZZHnMtO904LUPFRT1g3YT5haGE5ZeppEW+ldYZ21naHe6WCy4QA+aeTi5WAVaJbUVcB+bN8uX+1kShQu1NFXOhd0mJuY9pk52QgbqxwW3ndjR6OAvl9kEWS+JJ+TvZOZVD+XfpeBmFXaXGBVIZHjnWTK5peTpFQcGdAaAlRjVKSUqJqvHcQktSeq1IvYPKPSFCpYe1jymQ8aIRqwG+IgaGJlJYFWH1yrHIEdXl9bX6pgIuJdItjkFGdiWJ6bFRvUH06fyOKfFFKYZ17GYtXkoyTrE7TTx5QvlAGUcFSzVJ/U3BXg1iaXpFfdmGsYc5kbGVvZrtm9GaXaIdthXDxcJ90pXTKdNl1bHjseN969npFfZN9FYA/gBuBloNmixWPFZDhkwOYOJhamuibwk9TVTpYUVljW0ZcuGASYkJosGjoaKpuTHV4ds54PXr7fGt+fH4IiqGKP4yOlsSd5FPpU0pUcVT6VtFZZFs7XKte92I3ZUVlcmWgZq9nwWm9bPx1kHZ+dz96lH8DgKGAj4Hmgv2C8IPBhTGItIiligP5nI8uk8eWZ5jYmhOf7VSbZfJmj2hAejeMYJ3wVmRXEV0GZrFozWj+bih0nojkm2hsBPmomptPbFFxUZ9SVFvlXVBgbWDxYqdjO2XZc3p6o4aijI+XMk7hWwhinGfcdNF504OHirKK6I1OkEuTRpjTXuhp/4XtkAX5oFGYW+xbY2H6aD5rTHAvdNh0oXtQf8WDwImrjNyVKJkuUl1g7GICkIpPSVEhU9lY417gZjhtmnDCctZzUHvxgFuUZlObY2t/Vk6AUEpY3lgqYCdh0GLQaUGbj1sYfbGAX4+kTtFQrFSsVQxboF3nXSplTmUhaEtq4XKOdu93Xn35f6CBToXfhgOPTo/KkAOZVZqrmxhORU5dTsdO8U93Uf5SQFPjU+VTjlQUVnVXolfHW4dd0F78YdhiUWW4Z+lny2lQa8Zr7GtCbJ1ueHDXcpZzA3S/d+l3dnp/fQmA/IEFggqC34JiiDOL/IzAjhGQsZBkkraS0plFmumc152cnwtXQFzKg6CXq5e0nhtUmHqkf9mIzY7hkABYSFyYY596rlsTX3l6rnqOgqyOJlA4UvhSd1MIV/NicmMKa8NtN3elU1dzaIV2jtWVOmfDanBvbYrMjkuZBvl3ZnhrtIw8mwf561MtV05ZxmP7aepzRXi6esV6/nx1hI+Jc401kKiV+1JHV0d1YHvMgx6SCPlYaktRS1KHUh9i2Gh1aZmWxVCkUuRSw2GkZTlo/2l+dEt7uYLrg7KJOYvRj0mZCfnKTpdZ0mQRZo5qNHSBeb15qYJ+iH+IX4kK+SaTC0/KUyVgcWJybBp9Zn2YTmJR3HevgAFPDk92UYBR3FVoVjtX+lf8VxRZR1mTWcRbkFwOXfFdfl7MX4Bi12XjZR5nH2deZ8toxGhfajprI2x9bIJsx22YcyZ0KnSCdKN0eHV/dYF473hBeUd5SHl6eZV7AH26fYh/BoAtgIyAGIpPi0iMd40hkyST4phRmQ6aD5plmpKeyn12TwlU7mJUaNGRq1U6UQv5DPkcWuZhDfnPYv9iDvkP+RD5EfkS+RP5o5AU+RX5FvkX+Rj5/ooZ+Rr5G/kc+ZZmHflWcR75H/njliD5T2N6Y1dTIfmPZ2Bpc24i+Td1I/kk+SX5DX0m+Sf5cojKVhhaKPkp+Sr5K/ks+UNOLflnUUhZ8GcQgC75c1l0Xppkynn1X2xgyGJ7Y+db11uqUi/5dFkpXxJgMPkx+TL5WXQz+TT5Nfk2+Tf5OPnRmTn5Ovk7+Tz5Pfk++T/5QPlB+UL5Q/nDb0T5Rfm/gbKP8WBG+Uf5ZoFI+Un5P1xK+Uv5TPlN+U75T/lQ+VH56VolintnEH1S+VP5VPlV+Vb5V/n9gFj5Wfk8XOVsP1O6bhpZNoM5TrZORk+uVRhXx1hWX7dl5mWAarVrTW7td+96HnzefcuGkogykVuTu2S+b3pzuHVUkFZVTVe6YdRkx2bhbVtubW+5b/B1Q4C9gUGFg4nHilqLH5OTbFN1VHsPjl2QEFUCWFhYYl4HYp5k4Gh2ddZ8s4fonuNOiFduVydZDVyxXDZehV80YuFks3P6gYuIuIyKltuehVu3X7NgElAAUjBSFlc1WFdYDlxgXPZci12mXpJfvGARY4ljF2RDaPlowmrYbSFu1G7kb/5x3HZ5d7F5O3oEhKmJ7YzzjUiOA5AUkFOQ/ZBNk3aW3JfSawZwWHKicmhzY3e/eeR7m36Ai6lYx2BmZf1lvmaMbB5xyXFajBOYbU6Bet1OrFHNUdVSDFSnYXFnUGjfaB5tfG+8dbN35Xr0gGOEhZJcUZdlXGeTZ9h1x3pzg1r5RowXkC2Yb1zAgZqCQZBvkA2Sl1+dXVlqyHF7dkl75IUEiyeRMJqHVfZhW/lpdoV/P4a6h/iIj5Bc+Rtt2XDec2F9PYRd+WqR8Zle+YJOdVMEaxJrPnAbci2GHp5MUqOPUF3lZCxlFmvrb0N8nH7NhWSJvYnJYtiBH4jKXhdnam38cgV0b3SCh96Qhk8NXaBfCoS3UaBjZXWuTgZQaVHJUYFoEWqufLF853xvgtKKG4/PkbZPN1H1UkJU7F5uYT5ixWXaav5vKnnchSOIrZVimmqal57OnptSxmZ3ax1wK3lij0KXkGEAYiNlI29JcYl09H1vgO6EJo8jkEqTvVEXUqNSDG3IcMKIyV6CZa5rwm8+fHVz5E42T/lWX/m6XLpdHGCycy17mn/Of0aAHpA0kvaWSJcYmGGfi0+nb655tJG3lt5SYPmIZMRk02pebxhwEHLndgGABoZchu+NBY8yl2+b+p11nox4f3mgfcmDBJN/npOe1orfWARfJ2cncM90YHx+gCFRKHBicsp4wozajPSM95aGTtpQ7lvWXpllznFCdq13SoD8hHyQJ5uNn9hYQVpiXBNq2m0Pbzt2L303fh6FOInkk0uWiVLSZfNntGlBbZxuD3AJdGB0WXUkdmt4LItemG1RLmJ4lpZPK1AZXeptuH0qj4tfRGEXaGH5hpbSUouA3FHMUV5pHHq+ffGDdZbaTylSmFMPVA5VZVynYE5nqGhsbYFy+HIGdIN0YvnidWx8eX+4f4mDz4jhiMyR0JHilsmbHVR+b9BxmHT6haqOo5ZXnJ+el2fLbTN06IEWlyx4y3oge5J8aWRqdPJ1vHjoeKyZVJu7nt5bVV4gb5yBq4OIkAdOTVMpWtJdTl9iYT1jaWb8Zv9uK29jcJ53LIQThTuIE49FmTucHFW5Yitnq2wJg2qJepehToRZ2F/ZXxtnsn1Uf5KCK4O9gx6PmZDLV7lZklrQWydmmmeFaM9rZHF1f7eM44yBkEWbCIGKjEyWQJqlnl9bE2wbc/J233YMhKpRk4lNUZVRyVLJaJRsBHcgd7997H1il7WexW4RhaVRDVR9VA5mnWYnaZ9uv3aRdxeDwoSfh2mRmJL0nIKIrk+SUd9Sxlk9XlVheGR5ZK5m0Gchas1r22tfcmFyQXQ4d9t3F4C8ggWDAIsoi4yMKGeQbGdy7nZmd0Z6qZ1/a5JsIlkmZ5mEb1OTWJlZ317PYzRmc2c6bitz13rXgiiT2VLrXa5hy2EKYsdiq2TgZVlpZmvLayFx93NddUZ+HoICg2qFo4q/jCeXYZ2oWNieEVAOUjtUT1WHZXZsCn0LfV6AioaAle+W/1KVbGlyc1SaWj5cS11MX65fKme2aGNpPG5Ebgl3c3yOf4eFDov3j2GX9J63XLZgDWGrYU9l+2X8ZRFs72yfc8lz4X2UlcZbHIcQi11SWlPNYg9ksmQ0ZzhqymzAc550lHuVfBt+ioE2goSF64/5lsGZNE9KU81T21PMYixkAGWRZcNp7mxYb+1zVHUiduR2/HbQePt4LHlGfSyC4IfUjxKY75jDUtRipWQkblFvfHbLjbGRYpLumkObI1CNUEpXqFkoXEded18/Yj5luWXBZQlmi2ecacJuxXghfaqAgIErgrOCoYSMhiqKF4umkDKWkJ8NUPNPY/n5V5hf3GKSY29nQ24ZccN2zIDagPSI9YgZieCMKY9NkWqWL09wTxtez2ciaH12fnZEm2FeCmppcdRxanVk+UF+Q4XphdyYEE9Pe3B/pZXhUQZetWg+bE5s22yvcsR7A4PVbDp0+1CIUsFY2GSXaqd0VnaneBeG4pU5l2X5XlMBX4qLqI+vj4qQJVKld0mcCJ8ZTgJQdVFbXHdeHmY6ZsRnxWizcAF1xXXJed16J48gmQia3U8hWDFY9ltuZmVrEW16bn1v5HMrdemD3IgTiVyLFI8PT9VQEFNcU5NbqV8NZ495eYEvgxSFB4mGiTmPO4+lmRKcLGd2TvhPSVkBXO9c8FxnY9Jo/XCicSt0K37shAKHIpDSkvOcDU7YTu9PhVBWUm9SJlSQVOBXK1lmWlpbdVvMW5xeZvl2Yndlp2VubaVuNnImez98Nn9QgVGBmoFAgpmCqYMDiqCM5oz7jHSNuo3okNyRHJZEltmZ55wXUwZSKVR0VrNYVFluWf9fpGFuYhBmfmwaccZ2iXzefBt9rILBjPCWZ/lbTxdff1/CYildC2faaHx4Q35snRVOmVAVUypTUVODWWJah16yYIphSWJ5YpBlh2enadRr1mvXa9hruGxo+TV0+nUSeJF41XnYeYN8y33hf6WAPoHCgfKDGofoiLmKbIu7jBmRXpfbmDufrFYqW2xfjGWzaq9rXG3xbxVwXXKtc6eM04w7mJFhN2xYgAGaTU6LTptO1U46TzxPf0/fT/9Q8lP4UwZV41XbVutYYlkRWutb+lsEXPNdK16ZXx1gaGOcZa9l9mf7Z61oe2uZbNdsI24JcEVzAng+eUB5YHnBeel7F31yfYaADYKOg9GEx4bfiFCKXoodi9yMZo2tj6qQ/JjfmZ2eSlJp+RRnavmYUCpScVxjZVVsynMjdZ11l3uchHiRMJd3TpJkumtecamFCU5r+Uln7mgXbp+CGIVriPdjgW8Skq+YCk63UM9QH1FGVapVF1ZAWxlc4Fw4XopeoF7CXvNgUWhhalhuPXJAcsBy+HZlebF71H/ziPSJc4phjN6MHJdeWL10/YzHVWz5YXoifXKCcnIfdSV1bfkZe4VY+1i8XY9etl6QX1VgkmJ/Y01lkWbZZvhmFmjyaIByXnRue2591n1yf+WAEoKvhX+Jk4odkOSSzZ4gnxVZbVktXtxgFGZzZpBnUGzFbV9v83epeMaEy5Erk9lOylBIUYRVC1ujW0difmXLZTJufXEBdER0h3S/dGx2qnnafVV+qH96gbOBOYIahuyHdYrjjXiQkZIllE2ZrptoU1FcVGnEbCltK24MgpuFO4ktiqqK6pZnn2FSuWaya5Z+/ocNjYOVXZYdZYlt7nFu+c5X01msWydg+mAQYh9mX2Ypc/lz23YBd2x7VoBygGWBoIqSkRZO4lJyaxdtBXo5ezB9b/mwjOxTL1ZRWLVbD1wRXOJdQGKDYxRkLWazaLxsiG2vbh9wpHDScSZ1j3WOdRl2EXvgeyt8IH05fSyFbYUHhjSKDZBhkLWQt5L2lzea109sXF9nkW2ffIx+FosWjR+Qa1v9XQ1kwIRckOGYh3OLW5pgfmfebR+KpooBkAyYN1Jw+VFwjniWk3CI15HuT9dT/VXaVoJX/VjCWohbq1zAXCVeAWENYktiiGMcZDZleGU5aoprNGwZbTFv53HpcnhzB3SydCZ2YXfAeVd66nq5fI99rH1hfp5/KYExg5CE2oTqhZaIsIqQiziPQpCDkGyRlpK5kouWp5aoltaWAJcImJaZ05oam9RTflgZWXBbv1vRbVpvn3EhdLl0hYD9g+Fdh1+qX0Jg7GUSaG9pU2qJazVt823jc/52rHdNexR9I4EcgkCD9IRjhWKKxIqHkR6TBpi0mQxiU4jwj2WSB10nXWldX3SdgWiH1W/+YtJ/NolyiR5OWE7nUN1SR1N/YgdmaX4FiF6WjU8ZUzZWy1mkWjhcTlxNXAJeEV9DYL1lL2ZCZr5n9Gccc+J3OnnFf5SEzYSWiWaKaYrhilWMeoz0V9RbD19vYO1iDWmWa1xuhHHSe1WHWIv+jt+Y/pg4T4FP4U97VCBauFs8YbBlaGb8cTN1XnkzfU6B44GYg6qFzoUDhwqKq46bj3H5xY8xWaRb5luJYOlbC1zDX4FscvnxbQtwGnWvgvaKwE5BU3P52ZYPbJ5OxE9SUV5VJVroXBFiWXK9gqqD/oZZiB2KP5bFlhOZCZ1dnQpYs1y9XURe4WAVYeFjAmolbgKRVJNOmBCcd5+JW7hcCWNPZkhoPHfBlo2XVJifm6FlAYvLjryVNVWpXNZdtV6XZkx29IPHldNYvGLOciid8E4uWQ9gO2aDa+d5Jp2TU8BUw1cWXRth1mavbY14foKYlkSXhFN8YpZjsm0KfkuBTZj7akx/r50anl9OO1C2URxZ+WD2YzBpOnI2gHT5zpExX3X5dvkEfeWCb4S7hOWFjY53+W9PePl5+eRYQ1tZYNpjGGVtZZhmevlKaSNqC20BcGxx0nUNdrN5cHp7+Yp/fPlEiX35k4vAkX2WfvkKmQRXoV+8ZQFvAHameZ6KrZlam2yfBFG2YZFijWrGgUNQMFhmXwlxAIr6inxbFob6TzxRtFZEWalj+W2qXW1phlGITllPf/mA+YH5glmC+YP5X2tdbIT5tXQWeYX5B4JFgjmDP49dj4b5GJmH+Yj5ifmmTor531d5XxNmi/mM+at1eX5vi435BpBbmqVWJ1j4WR9atFuO+fZej/mQ+VBjO2OR+T1ph2y/bI5tk231bRRvkvnfcDZxWXGT+cNx1XGU+U94b3iV+XV7432W+S9+l/lNiN+OmPmZ+Zr5W5Kb+facnPmd+Z75hWCFbZ/5sXGg+aH5sZWtU6L5o/mk+dNnpfmOcDBxMHR2gtKCpvm7leWafZ7EZqf5wXFJhKj5qflLWKr5q/m4XXFfrPkgZo5meWmuaThs82w2bkFv2m8bcC9wUHHfcXBzrflbdK751HTIdk56k36v+bD58YJgis6PsflIk7L5GZez+bT5Qk4qULX5CFLhU/NmbWzKbwpzf3dieq6C3YUChrb51Ihjin2La4y3+bOSuPkTlxCYlE4NT8lPslBIUz5UM1TaVWJYulhnWRta5FufYLn5ymFWZf9lZGanaFpss2/PcKxxUnN9ewiHpIoynAefS1yDbERziXM6kqtuZXQfdml6FX4KhkBRxVjBZO50FXVwdsF/lZDNllSZJm7mdKl6qnrlgdmGeIcbiklajFubW6FoAGljbalzE3QsdJd46X3rfxiBVYGeg0yMLpYRmPBmgF/6ZYlnamyLcy1QA1pqa+53FllsXc1dJXNPdbr5u/nlUPlRL1gtWZZZ2lnlW7z5vfmiXddiFmSTZP5kvvncZr/5SGrA+f9xZHTB+Yh6r3pHfl5+AIBwgcL574eBiSCLWZDD+YCQUpl+YTJrdG0ffiWJsY/RT61Ql1HHUsdXiVi5W7heQmGVaYxtZ262bpRxYnQodSx1c4A4g8mECo6Uk96TxPmOTlFPdlAqUchTy1PzU4db01skXBphgmH0ZVtyl3NAdMJ2UHmRebl5Bn29f4uC1YVehsKPR5D1kOqRhZbolumW1lJnX+1lMWYvaFxxNnrBkAqYkU7F+VJqnmuQb4lxGIC4glOFS5CVlvKW+5cahTGbkE6KccSWQ1GfU+FUE1cSV6NXm1rEWsNbKGA/YfRjhWw5bXJukG4wcj9zV3TRgoGIRY9gkMb5YpZYmBudCGeKjV6STU9JUN5QcVMNV9RZAVoJXHBhkGYtbjJyS3TvfcOADoRmhD+FX4dbiBiJAotVkMuXT5tzTpFPElFqUcf5L1WpVXpbpVt8Xn1evl6gYN9gCGEJYcRjOGUJZ8j51GfaZ8n5YWliablsJ23K+Thuy/nhbzZzN3PM+Vx0MXXN+VJ2zvnP+a19/oE4hNWImIrbiu2KMI5CjkqQPpB6kEmRyZFuk9D50fkJWNL502uJgLKA0/nU+UFRa1k5XNX51vlkb6dz5IAHjdf5F5KPldj52fna+dv5f4AOYhxwaH2Nh9z5oFdpYEdht2u+ioCSsZZZTh9U620thXCW85fumNZj42yRkN1RyWG6gfmdnU8aUABRnFsPYf9h7GQFacVrkXXjd6l/ZIKPhfuHY4i8inCLq5GMTuVOCk/d+d75N1noWd/58l0bX1tfIWDg+eH54vnj+T5y5XPk+XB1zXXl+ft55vkMgDOAhIDhglGD5/no+b2Ms4yHkOn56vn0mAyZ6/ns+TdwynbKf8x//H8ai7pOwU4DUnBT7fm9VOBW+1nFWxVfzV9ubu757/lqfTWD8PmTho2K8fltl3eX8vnz+QBOWk9+T/lY5WWibjiQsJO5mftO7FiKWdlZQWD0+fX5FHr2+U+Dw4xlUURT9/n4+fn5zU5pUlVbv4LUTjpSqFTJWf9ZUFtXW1xbY2BIYctumXBucYZz93S1dcF4K30FgOqBKIMXhcmF7orHjMyWXE/6UrxWq2UoZnxwuHA1cr19jYJMkcCWcp1xW+domGt6b952kVyrZltvtHsqfDaI3JYITtdOIFM0WLtY71hsWQdcM16EXjVfjGOyZlZnH2qjagxrP29Gcvr5UHOLdOB6p3x4gd+B54GKg2yEI4WUhc+F3YgTjayRd5Wclo1RyVQoV7BbTWJQZz1ok2g9btNufXAhfsGIoYwJj0ufTp8tco97zYoak0dPTk8yUYBU0FmVXrVidWduaRdqrmwabtlyKnO9dbh7NX3ngvmDV4T3hVuKr4yHjhmQuJDOll+f41IKVOFawltYZHVl9G7Ecvv5hHZNeht7TXw+ft9/e4Mri8qMZI3hjV+O6o/5j2mQ0ZNDT3pPs1BoUXhRTVJqUmFYfFhgWQhcVVzbXptgMGITaL9rCGyxb05xIHQwdTh1UXVydkx7i3ute8Z7j35uij6PSY8/kpOSIpMrlPuWWphrmB6ZB1IqYphiWW1kdsp6wHt2fWBTvlyXXjhvuXCYfBGXjpvenqVjemR2hwFOlU6tTlxQdVBIVMNZmltAXq1e916BX8VgOmM/ZXRlzGV2Znhm/mdoaYlqY2tAbMBt6G0fbl5uHnChcI5z/XM6dVt3h3iOeQt6fXq+fI59R4ICiuqKnowtkUqR2JFmksySIJMGl1aXXJcCmA6fNlKRUnxVJFgdXh9fjGDQY69o329teSx7zYG6hf2I+IpEjo2RZJablj2XTJhKn85PRlHLUalSMlYUX2tfqmPNZOllQWb6ZvlmHWedaNdo/WkVb25vZ3HlcSpyqnQ6d1Z5WnnfeSB6lXqXfN98RH1wfoeA+4WkhlSKv4qZjYGOIJBtkOORO5bVluWcz2UHfLONw5NYWwpcUlPZYh1zJ1CXW55fsGBrYdVo2W0udC56Qn2cfTF+a4EqjjWOfpMYlFBPUFfmXadeK2NqfztOT0+PT1pQ3VnEgGpUaFT+VU9ZmVveXdpeXWYxZ/FnKmjobDJtSm6Nb7dw4HOHdUx8An0sfaJ9H4LbhjuKhYpwjYqOM48xkE6RUpFElNCZ+XqlfMpPAVHGUchX71v7XFlmPWpabZZu7G8McW9143oiiCGQdZDLlv+ZAYMtTvJORojNkX1T22praUFseoSeWI5h/mbvYt1wEXXHdVJ+uIRJiwiNS07qU6tUMFdAV9dfAWMHY29kL2XoZXpmnWezZ2JrYGyabCxv5XcleEl5V3kZfaKAAoHzgZ2Ct4IYh4yK/PkEjb6NcpD0dhl6N3pUfneAB1XUVXVYL2MiZElmS2ZtaJtphGslbbFuzXNodKF0W3W5deF2HneLd+Z5CX4dfvuBL4WXiDqK0YzrjrCPMpCtk2OWc5YHl4RP8VPqWclaGV5OaMZ0vnXpeZJ6o4HthuqMzI3tj59lFWf9+fdXV2/dfS+P9pPGlrVf8mGEbxROmE8fUMlT31VvXe5dIWtka8t4mnv++UmOyo5ukEljPmRAd4R6L5N/lGqfsGSvb+ZxqHTadMR6EnyCfrJ8mH6aiwqNfZQQmUyZOVLfW+ZkLWcufe1Qw1N5WFhhWWH6Yaxl2XqSi5aLCVAhUHVSMVU8WuBecF80YV5lDGY2ZqJmzWnEbjJvFnMhdpN6OYFZgtaDvIS1UPBXwFvoW2lfoWMmeLV93IMhhceR9ZGKUfVnVnusjMRRu1m9YFWGHFD/+VRSOlx9YRpi02LyZKVlzG4gdgqBYI5flruW305DU5hVKVndXcVkyWz6bZRzf3obgqaF5IwQjneQ55HhlSGWxpf4UfJUhlW5X6RkiG+0fR+PTY81lMlQFly+bPttG3W7dz18ZHx5isKKHli+WRZed2NScop1a3fciryMEo/zXnRm+G19gMGDy4pRl9abAPpDUv9mlW3vbuB95ooukF6Q1JodUn9S6FSUYYRi22KiaBJpWmk1apJwJnFdeAF5DnnSeQ16loB4gtWCSYNJhYKMhY1ikYuRrpHDT9FW7XHXdwCH+In4W9ZfUWeokOJTWlj1W6RggWFgZD1+cIAlhYOSrmSsUBRdAGecWL1iqGMOaXhpHmprbrp2y3m7gimEz4qojf2PEpFLkZyREJMYk5qT25Y2mg2cEU5cdV15+npRe8l7Ln7EhFmOdI74jhCQJWY/aUN0+lEuZ9yeRVHgX5Zs8oddiHeItGC1gQOEBY3WUzlUNFY2WjFcinDgf1qABoHtgaONiZFfmvKddFDETqBT+2AsbmRciE8kUORV2VxfXmVglGi7bMRtvnHUdfR1YXYaekl6x337fW5/9IGphhyPyZazmVKfR1LFUu2YqokDTtJnBm+1T+JblWeIbHhtG3QneN2RfJPEh+R5MXrrX9ZOpFQ+Va5YpVnwYFNi1mI2Z1VpNYJAlrGZ3ZksUFNTRFV8VwH6WGIC+uJka2bdZ8Fv728idDh0F4o4lFFUBlZmV0hfmmFOa1hwrXC7fZWKalkrgaJjCHc9gKqMVFgtZLtplVsRXm9uA/pphUxR8FMqWSBgS2GGa3Bs8Gwee86A1ILGjbCQsZgE+sdkpG+RZARlTlEQVB9XDopfYXZoBfrbdVJ7cX0akAZYzGl/gSqJAJA5mHhQV1msWZViD5Aqm11heXLWlWFXRlr0XYpirWT6ZHdn4mw+bSxyNnQ0eHd/rYLbjReYJFJCV39nSHLjdKmMpo8RkiqWa1HtU0xjaU8EVZZgV2WbbH9tTHL9chd6h4mdjG1fjm/5cKiBDmG/T09QQWJHcsd76H3pf02QrZcZmraMaldzXrBnDYRViiBUFltjXuJeCl+DZbqAPYWJlVuWSE8FUw1TD1OGVPpUA1cDXhZgm2KxYlVjBvrhbGZtsXUyeN6AL4HegmGEsoSNiBKJC5Dqkv2YkZtFXrRm3WYRcAZyB/r1T31Sal9TYVNnGWoCb+J0aHloiHmMx5jEmEOawVQfelNp94pKjKiYrpl8X6tisnWudquIf5BCljlTPF/FX8xszHNidYt1Rnv+gp2ZT048kAtOVU+mUw9ZyF4wZrNsVXR3g2aHwIxQkB6XFZzRWHhbUIYUi7Sd0ltoYI1g8WVXbCJvo28acFV/8H+RlZKVUJbTl3JSRI/9UStUuFRjVYpVu2q1bdh9ZoKckneWeZ4IVMhU0nbkhqSV1JVclqJOCU/uWeZa911SYJdibWdBaIZsL244f5uAKoII+gn6BZilTlVQs1STV1pZaVuzW8hhd2l3bSNw+YfjiXKK54qCkO2ZuJq+UjhoFlB4Xk9nR4NMiKtOEVSuVuZzFZH/lwmZV5mZmVNWn1hbhjGKsmH2antz0o5Ha6qWV5pVWQBya41pl9RP9FwmX/hhW2brbKtwhHO5c/5zKXdNd0N9Yn0jfjeCUogK+uKMSZJvmFFbdHpAiAGYzFrgT1RTPln9XD5jeW35cgWBB4Gig8+SMJioTkRREVKLV2JfwmzObgVwUHCvcJJx6XNpdEqDoodhiAiQopCjk6iZblFXX+BgZ2GzZlmFSo6vkYuXTk6STnxU1Vj6WH1ZtVwnXzZiSGIKZmdm62tpbc9tVm74bpRv4G/pb11w0HIldFp04HSTdlx5ynwefuGApoJrhL+EToZfhnSHd4tqjKyTAJhlmNFgFmJ3kVpaD2b3bT5uP3RCm/1f2mAPe8RUGF9ebNNsKm3YcAV9eYYMijudFlOMVAVbOmprcHV1jXm+ebGC74NxikGLqIx0lwv69GQrZbp4u3hrejhOmlVQWaZbe16jYNtjYWtlZlNoGW5lcbB0CH2EkGmaJZw7bdFuPnNBjMqV8FFMXqhfTWD2YDBhTGFDZkRmpWnBbF9uyW5ib0xxnHSHdsF7J3xSg1eHUZCNlsOeL1PeVvteil9iYJRg92FmZgNnnGruba5vcHBqc2p+voE0g9SGqIrEjINScnOWW2tqBJTuVIZWXVtIZYVlyWafaI1txm07crSAdZFNmq9PGVCaUw5UPFSJVcVVP16MXz1nZnHdcwWQ21LzUmRYzlgEcY9x+3GwhROKiGaohadVhGZKcTGESVOZVcFrWV+9X+5jiWZHcfGKHY++nhFPOmTLcGZ1Z4ZkYE6L+J1HUfZRCFM2bfiA0Z4VZiNrmHDVdQNUeVwHfRaKIGs9a0ZrOFRwYD1t1X8IgtZQ3lGcVWtWzVbsWQlbDF6ZYZhhMWJeZuZmmXG5cbpxp3KneQB6sn9wigAAAAAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFgEXARgBGQEaARsBHAEdAR4BHwEgASEBIgEjASQBJQEmAScBKAEpASoBKwEuAS8BMAExATQBNQE2ATcBOAE5AToBOwE8AT0BPgFBAUIBQwFEAUUBRgFHAUgBSgFLAUwBTQFQAVEBUgFTAVQBVQFWAVcBWAFZAVoBWwFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkBagFrAWwBbQFuAW8BcAFxAXIBcwF0AXUBdgF3AXgBeQF6AXsBfAF9AX4BkgGgAaEBrwGwARgCGQIaAhsCxgLHAtgC2QLbAtwC3QIAAwEDAwMJAyMDegOEA4UDhgOIA4kDigOMA44DjwOQA5EDkgOTA5QDlQOWA5cDmAOZA5oDmwOcA50DngOfA6ADoQOjA6QDpQOmA6cDqAOpA6oDqwOsA60DrgOvA7ADsQOyA7MDtAO1A7YDtwO4A7kDugO7A7wDvQO+A78DwAPBA8IDwwPEA8UDxgPHA8gDyQPKA8sDzAPNA84DAQQCBAMEBAQFBAYEBwQIBAkECgQLBAwEDgQPBBAEEQQSBBMEFAQVBBYEFwQYBBkEGgQbBBwEHQQeBB8EIAQhBCIEIwQkBCUEJgQnBCgEKQQqBCsELAQtBC4ELwQwBDEEMgQzBDQENQQ2BDcEOAQ5BDoEOwQ8BD0EPgQ/BEAEQQRCBEMERARFBEYERwRIBEkESgRLBEwETQROBE8EUQRSBFMEVARVBFYEVwRYBFkEWgRbBFwEXgRfBJAEkQSwBbEFsgWzBbQFtQW2BbcFuAW5BbsFvAW9Bb4FvwXABcEFwgXDBdAF0QXSBdMF1AXVBdYF1wXYBdkF2gXbBdwF3QXeBd8F4AXhBeIF4wXkBeUF5gXnBegF6QXqBfAF8QXyBfMF9AUMBhsGHwYhBiIGIwYkBiUGJgYnBigGKQYqBisGLAYtBi4GLwYwBjEGMgYzBjQGNQY2BjcGOAY5BjoGQAZBBkIGQwZEBkUGRgZHBkgGSQZKBksGTAZNBk4GTwZQBlEGUgZ5Bn4GhgaIBpEGmAapBq8Guga+BsEG0gYBDgIOAw4EDgUOBg4HDggOCQ4KDgsO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", module.meta.url).href;
          }
          var wasmBinaryFile;
          function getBinarySync(file) {
            if (file == wasmBinaryFile && wasmBinary2) {
              return new Uint8Array(wasmBinary2);
            }
            if (readBinary) {
              return readBinary(file);
            }
            throw "both async and sync fetching of the wasm failed";
          }
          function getBinaryPromise(binaryFile) {
            if (!wasmBinary2) {
              return readAsync(binaryFile).then((response) => new Uint8Array(response), () => getBinarySync(binaryFile));
            }
            return Promise.resolve().then(() => getBinarySync(binaryFile));
          }
          function instantiateArrayBuffer(binaryFile, imports, receiver) {
            return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
              err2(`failed to asynchronously prepare wasm: ${reason}`);
              abort(reason);
            });
          }
          function instantiateAsync(binary, binaryFile, imports, callback) {
            if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && typeof fetch == "function") {
              return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {
                var result = WebAssembly.instantiateStreaming(response, imports);
                return result.then(callback, function(reason) {
                  err2(`wasm streaming compile failed: ${reason}`);
                  err2("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(binaryFile, imports, callback);
                });
              });
            }
            return instantiateArrayBuffer(binaryFile, imports, callback);
          }
          function getWasmImports() {
            return { a: wasmImports };
          }
          function createWasm() {
            var info2 = getWasmImports();
            function receiveInstance(instance, module) {
              wasmExports = instance.exports;
              wasmMemory = wasmExports["v"];
              updateMemoryViews();
              addOnInit(wasmExports["w"]);
              removeRunDependency();
              return wasmExports;
            }
            addRunDependency();
            function receiveInstantiationResult(result) {
              receiveInstance(result["instance"]);
            }
            if (Module2["instantiateWasm"]) {
              try {
                return Module2["instantiateWasm"](info2, receiveInstance);
              } catch (e) {
                err2(`Module.instantiateWasm callback failed with error: ${e}`);
                readyPromiseReject(e);
              }
            }
            if (!wasmBinaryFile) wasmBinaryFile = findWasmBinary();
            instantiateAsync(wasmBinary2, wasmBinaryFile, info2, receiveInstantiationResult).catch(readyPromiseReject);
            return {};
          }
          var tempDouble;
          var tempI64;
          function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = `Program terminated with exit(${status})`;
            this.status = status;
          }
          var callRuntimeCallbacks = (callbacks) => {
            while (callbacks.length > 0) {
              callbacks.shift()(Module2);
            }
          };
          Module2["noExitRuntime"] || true;
          var PATH = { isAbs: (path) => path.charAt(0) === "/", splitPath: (filename) => {
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          }, normalizeArray: (parts, allowAboveRoot) => {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up; up--) {
                parts.unshift("..");
              }
            }
            return parts;
          }, normalize: (path) => {
            var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
            path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          }, dirname: (path) => {
            var result = PATH.splitPath(path), root = result[0], dir = result[1];
            if (!root && !dir) {
              return ".";
            }
            if (dir) {
              dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
          }, basename: (path) => {
            if (path === "/") return "/";
            path = PATH.normalize(path);
            path = path.replace(/\/$/, "");
            var lastSlash = path.lastIndexOf("/");
            if (lastSlash === -1) return path;
            return path.substr(lastSlash + 1);
          }, join: (...paths) => PATH.normalize(paths.join("/")), join2: (l, r) => PATH.normalize(l + "/" + r) };
          var initRandomFill = () => {
            if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
              return (view) => crypto.getRandomValues(view);
            } else abort("initRandomDevice");
          };
          var randomFill = (view) => (randomFill = initRandomFill())(view);
          var PATH_FS = { resolve: (...args) => {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? args[i] : FS.cwd();
              if (typeof path != "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                return "";
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = PATH.isAbs(path);
            }
            resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          }, relative: (from, to) => {
            from = PATH_FS.resolve(from).substr(1);
            to = PATH_FS.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "") break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "") break;
              }
              if (start > end) return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          } };
          var UTF8Decoder = new TextDecoder();
          var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
            return UTF8Decoder.decode(heapOrArray.buffer ? heapOrArray.subarray(idx, endPtr) : new Uint8Array(heapOrArray.slice(idx, endPtr)));
          };
          var FS_stdin_getChar_buffer = [];
          var lengthBytesUTF8 = (str) => {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var c = str.charCodeAt(i);
              if (c <= 127) {
                len++;
              } else if (c <= 2047) {
                len += 2;
              } else if (c >= 55296 && c <= 57343) {
                len += 4;
                ++i;
              } else {
                len += 3;
              }
            }
            return len;
          };
          var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
            if (!(maxBytesToWrite > 0)) return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i);
                u = 65536 + ((u & 1023) << 10) | u1 & 1023;
              }
              if (u <= 127) {
                if (outIdx >= endIdx) break;
                heap[outIdx++] = u;
              } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx) break;
                heap[outIdx++] = 192 | u >> 6;
                heap[outIdx++] = 128 | u & 63;
              } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx) break;
                heap[outIdx++] = 224 | u >> 12;
                heap[outIdx++] = 128 | u >> 6 & 63;
                heap[outIdx++] = 128 | u & 63;
              } else {
                if (outIdx + 3 >= endIdx) break;
                heap[outIdx++] = 240 | u >> 18;
                heap[outIdx++] = 128 | u >> 12 & 63;
                heap[outIdx++] = 128 | u >> 6 & 63;
                heap[outIdx++] = 128 | u & 63;
              }
            }
            heap[outIdx] = 0;
            return outIdx - startIdx;
          };
          function intArrayFromString(stringy, dontAddNull, length) {
            var len = lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            u8array.length = numBytesWritten;
            return u8array;
          }
          var FS_stdin_getChar = () => {
            if (!FS_stdin_getChar_buffer.length) {
              var result = null;
              if (!result) {
                return null;
              }
              FS_stdin_getChar_buffer = intArrayFromString(result);
            }
            return FS_stdin_getChar_buffer.shift();
          };
          var TTY = { ttys: [], init() {
          }, shutdown() {
          }, register(dev, ops) {
            TTY.ttys[dev] = { input: [], output: [], ops };
            FS.registerDevice(dev, TTY.stream_ops);
          }, stream_ops: { open(stream) {
            var tty = TTY.ttys[stream.node.rdev];
            if (!tty) {
              throw new FS.ErrnoError(43);
            }
            stream.tty = tty;
            stream.seekable = false;
          }, close(stream) {
            stream.tty.ops.fsync(stream.tty);
          }, fsync(stream) {
            stream.tty.ops.fsync(stream.tty);
          }, read(stream, buffer, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.get_char) {
              throw new FS.ErrnoError(60);
            }
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = stream.tty.ops.get_char(stream.tty);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0) break;
              bytesRead++;
              buffer[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write(stream, buffer, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.put_char) {
              throw new FS.ErrnoError(60);
            }
            try {
              for (var i = 0; i < length; i++) {
                stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
              }
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          } }, default_tty_ops: { get_char(tty) {
            return FS_stdin_getChar();
          }, put_char(tty, val) {
            if (val === null || val === 10) {
              out(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            } else {
              if (val != 0) tty.output.push(val);
            }
          }, fsync(tty) {
            if (tty.output && tty.output.length > 0) {
              out(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            }
          }, ioctl_tcgets(tty) {
            return { c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
          }, ioctl_tcsets(tty, optional_actions, data) {
            return 0;
          }, ioctl_tiocgwinsz(tty) {
            return [24, 80];
          } }, default_tty1_ops: { put_char(tty, val) {
            if (val === null || val === 10) {
              err2(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            } else {
              if (val != 0) tty.output.push(val);
            }
          }, fsync(tty) {
            if (tty.output && tty.output.length > 0) {
              err2(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            }
          } } };
          var mmapAlloc = (size2) => {
            abort();
          };
          var MEMFS = { ops_table: null, mount(mount) {
            return MEMFS.createNode(null, "/", 16384 | 511, 0);
          }, createNode(parent, name2, mode2, dev) {
            if (FS.isBlkdev(mode2) || FS.isFIFO(mode2)) {
              throw new FS.ErrnoError(63);
            }
            MEMFS.ops_table ||= { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
            var node = FS.createNode(parent, name2, mode2, dev);
            if (FS.isDir(node.mode)) {
              node.node_ops = MEMFS.ops_table.dir.node;
              node.stream_ops = MEMFS.ops_table.dir.stream;
              node.contents = {};
            } else if (FS.isFile(node.mode)) {
              node.node_ops = MEMFS.ops_table.file.node;
              node.stream_ops = MEMFS.ops_table.file.stream;
              node.usedBytes = 0;
              node.contents = null;
            } else if (FS.isLink(node.mode)) {
              node.node_ops = MEMFS.ops_table.link.node;
              node.stream_ops = MEMFS.ops_table.link.stream;
            } else if (FS.isChrdev(node.mode)) {
              node.node_ops = MEMFS.ops_table.chrdev.node;
              node.stream_ops = MEMFS.ops_table.chrdev.stream;
            }
            node.timestamp = Date.now();
            if (parent) {
              parent.contents[name2] = node;
              parent.timestamp = node.timestamp;
            }
            return node;
          }, getFileDataAsTypedArray(node) {
            if (!node.contents) return new Uint8Array(0);
            if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
            return new Uint8Array(node.contents);
          }, expandFileStorage(node, newCapacity) {
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity) return;
            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
            if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
          }, resizeFileStorage(node, newSize) {
            if (node.usedBytes == newSize) return;
            if (newSize == 0) {
              node.contents = null;
              node.usedBytes = 0;
            } else {
              var oldContents = node.contents;
              node.contents = new Uint8Array(newSize);
              if (oldContents) {
                node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
              }
              node.usedBytes = newSize;
            }
          }, node_ops: { getattr(node) {
            var attr = {};
            attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
            attr.ino = node.id;
            attr.mode = node.mode;
            attr.nlink = 1;
            attr.uid = 0;
            attr.gid = 0;
            attr.rdev = node.rdev;
            if (FS.isDir(node.mode)) {
              attr.size = 4096;
            } else if (FS.isFile(node.mode)) {
              attr.size = node.usedBytes;
            } else if (FS.isLink(node.mode)) {
              attr.size = node.link.length;
            } else {
              attr.size = 0;
            }
            attr.atime = new Date(node.timestamp);
            attr.mtime = new Date(node.timestamp);
            attr.ctime = new Date(node.timestamp);
            attr.blksize = 4096;
            attr.blocks = Math.ceil(attr.size / attr.blksize);
            return attr;
          }, setattr(node, attr) {
            if (attr.mode !== void 0) {
              node.mode = attr.mode;
            }
            if (attr.timestamp !== void 0) {
              node.timestamp = attr.timestamp;
            }
            if (attr.size !== void 0) {
              MEMFS.resizeFileStorage(node, attr.size);
            }
          }, lookup(parent, name2) {
            throw FS.genericErrors[44];
          }, mknod(parent, name2, mode2, dev) {
            return MEMFS.createNode(parent, name2, mode2, dev);
          }, rename(old_node, new_dir, new_name) {
            if (FS.isDir(old_node.mode)) {
              var new_node;
              try {
                new_node = FS.lookupNode(new_dir, new_name);
              } catch (e) {
              }
              if (new_node) {
                for (var i in new_node.contents) {
                  throw new FS.ErrnoError(55);
                }
              }
            }
            delete old_node.parent.contents[old_node.name];
            old_node.parent.timestamp = Date.now();
            old_node.name = new_name;
            new_dir.contents[new_name] = old_node;
            new_dir.timestamp = old_node.parent.timestamp;
          }, unlink(parent, name2) {
            delete parent.contents[name2];
            parent.timestamp = Date.now();
          }, rmdir(parent, name2) {
            var node = FS.lookupNode(parent, name2);
            for (var i in node.contents) {
              throw new FS.ErrnoError(55);
            }
            delete parent.contents[name2];
            parent.timestamp = Date.now();
          }, readdir(node) {
            var entries = [".", ".."];
            for (var key of Object.keys(node.contents)) {
              entries.push(key);
            }
            return entries;
          }, symlink(parent, newname, oldpath) {
            var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
            node.link = oldpath;
            return node;
          }, readlink(node) {
            if (!FS.isLink(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            return node.link;
          } }, stream_ops: { read(stream, buffer, offset, length, position) {
            var contents = stream.node.contents;
            if (position >= stream.node.usedBytes) return 0;
            var size2 = Math.min(stream.node.usedBytes - position, length);
            if (size2 > 8 && contents.subarray) {
              buffer.set(contents.subarray(position, position + size2), offset);
            } else {
              for (var i = 0; i < size2; i++) buffer[offset + i] = contents[position + i];
            }
            return size2;
          }, write(stream, buffer, offset, length, position, canOwn) {
            if (!length) return 0;
            var node = stream.node;
            node.timestamp = Date.now();
            if (buffer.subarray && (!node.contents || node.contents.subarray)) {
              if (canOwn) {
                node.contents = buffer.subarray(offset, offset + length);
                node.usedBytes = length;
                return length;
              } else if (node.usedBytes === 0 && position === 0) {
                node.contents = buffer.slice(offset, offset + length);
                node.usedBytes = length;
                return length;
              } else if (position + length <= node.usedBytes) {
                node.contents.set(buffer.subarray(offset, offset + length), position);
                return length;
              }
            }
            MEMFS.expandFileStorage(node, position + length);
            if (node.contents.subarray && buffer.subarray) {
              node.contents.set(buffer.subarray(offset, offset + length), position);
            } else {
              for (var i = 0; i < length; i++) {
                node.contents[position + i] = buffer[offset + i];
              }
            }
            node.usedBytes = Math.max(node.usedBytes, position + length);
            return length;
          }, llseek(stream, offset, whence) {
            var position = offset;
            if (whence === 1) {
              position += stream.position;
            } else if (whence === 2) {
              if (FS.isFile(stream.node.mode)) {
                position += stream.node.usedBytes;
              }
            }
            if (position < 0) {
              throw new FS.ErrnoError(28);
            }
            return position;
          }, allocate(stream, offset, length) {
            MEMFS.expandFileStorage(stream.node, offset + length);
            stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
          }, mmap(stream, length, position, prot, flags) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            var ptr;
            var allocated;
            var contents = stream.node.contents;
            if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
              allocated = false;
              ptr = contents.byteOffset;
            } else {
              allocated = true;
              ptr = mmapAlloc();
              if (!ptr) {
                throw new FS.ErrnoError(48);
              }
              if (contents) {
                if (position > 0 || position + length < contents.length) {
                  if (contents.subarray) {
                    contents = contents.subarray(position, position + length);
                  } else {
                    contents = Array.prototype.slice.call(contents, position, position + length);
                  }
                }
                HEAP8.set(contents, ptr);
              }
            }
            return { ptr, allocated };
          }, msync(stream, buffer, offset, length, mmapFlags) {
            MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
            return 0;
          } } };
          var asyncLoad = (url, onload, onerror, noRunDep) => {
            var dep = getUniqueRunDependency(`al ${url}`);
            readAsync(url).then((arrayBuffer) => {
              onload(new Uint8Array(arrayBuffer));
              if (dep) removeRunDependency();
            }, (err3) => {
              if (onerror) {
                onerror();
              } else {
                throw `Loading data file "${url}" failed.`;
              }
            });
            if (dep) addRunDependency();
          };
          var FS_createDataFile = (parent, name2, fileData, canRead, canWrite, canOwn) => {
            FS.createDataFile(parent, name2, fileData, canRead, canWrite, canOwn);
          };
          var preloadPlugins = Module2["preloadPlugins"] || [];
          var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
            if (typeof Browser != "undefined") Browser.init();
            var handled = false;
            preloadPlugins.forEach((plugin) => {
              if (handled) return;
              if (plugin["canHandle"](fullname)) {
                plugin["handle"](byteArray, fullname, finish, onerror);
                handled = true;
              }
            });
            return handled;
          };
          var FS_createPreloadedFile = (parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
            var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
            function processData(byteArray) {
              function finish(byteArray2) {
                preFinish?.();
                if (!dontCreateFile) {
                  FS_createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
                }
                onload?.();
                removeRunDependency();
              }
              if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
                onerror?.();
                removeRunDependency();
              })) {
                return;
              }
              finish(byteArray);
            }
            addRunDependency();
            if (typeof url == "string") {
              asyncLoad(url, processData, onerror);
            } else {
              processData(url);
            }
          };
          var FS_modeStringToFlags = (str) => {
            var flagModes = { r: 0, "r+": 2, w: 512 | 64 | 1, "w+": 512 | 64 | 2, a: 1024 | 64 | 1, "a+": 1024 | 64 | 2 };
            var flags = flagModes[str];
            if (typeof flags == "undefined") {
              throw new Error(`Unknown file open mode: ${str}`);
            }
            return flags;
          };
          var FS_getMode = (canRead, canWrite) => {
            var mode2 = 0;
            if (canRead) mode2 |= 292 | 73;
            if (canWrite) mode2 |= 146;
            return mode2;
          };
          var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, ErrnoError: class {
            constructor(errno) {
              this.name = "ErrnoError";
              this.errno = errno;
            }
          }, genericErrors: {}, filesystems: null, syncFSRequests: 0, FSStream: class {
            constructor() {
              this.shared = {};
            }
            get object() {
              return this.node;
            }
            set object(val) {
              this.node = val;
            }
            get isRead() {
              return (this.flags & 2097155) !== 1;
            }
            get isWrite() {
              return (this.flags & 2097155) !== 0;
            }
            get isAppend() {
              return this.flags & 1024;
            }
            get flags() {
              return this.shared.flags;
            }
            set flags(val) {
              this.shared.flags = val;
            }
            get position() {
              return this.shared.position;
            }
            set position(val) {
              this.shared.position = val;
            }
          }, FSNode: class {
            constructor(parent, name2, mode2, rdev) {
              if (!parent) {
                parent = this;
              }
              this.parent = parent;
              this.mount = parent.mount;
              this.mounted = null;
              this.id = FS.nextInode++;
              this.name = name2;
              this.mode = mode2;
              this.node_ops = {};
              this.stream_ops = {};
              this.rdev = rdev;
              this.readMode = 292 | 73;
              this.writeMode = 146;
            }
            get read() {
              return (this.mode & this.readMode) === this.readMode;
            }
            set read(val) {
              val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
            }
            get write() {
              return (this.mode & this.writeMode) === this.writeMode;
            }
            set write(val) {
              val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
            }
            get isFolder() {
              return FS.isDir(this.mode);
            }
            get isDevice() {
              return FS.isChrdev(this.mode);
            }
          }, lookupPath(path, opts = {}) {
            path = PATH_FS.resolve(path);
            if (!path) return { path: "", node: null };
            var defaults = { follow_mount: true, recurse_count: 0 };
            opts = Object.assign(defaults, opts);
            if (opts.recurse_count > 8) {
              throw new FS.ErrnoError(32);
            }
            var parts = path.split("/").filter((p) => !!p);
            var current = FS.root;
            var current_path = "/";
            for (var i = 0; i < parts.length; i++) {
              var islast = i === parts.length - 1;
              if (islast && opts.parent) {
                break;
              }
              current = FS.lookupNode(current, parts[i]);
              current_path = PATH.join2(current_path, parts[i]);
              if (FS.isMountpoint(current)) {
                if (!islast || islast && opts.follow_mount) {
                  current = current.mounted.root;
                }
              }
              if (!islast || opts.follow) {
                var count2 = 0;
                while (FS.isLink(current.mode)) {
                  var link = FS.readlink(current_path);
                  current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                  var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
                  current = lookup.node;
                  if (count2++ > 40) {
                    throw new FS.ErrnoError(32);
                  }
                }
              }
            }
            return { path: current_path, node: current };
          }, getPath(node) {
            var path;
            while (true) {
              if (FS.isRoot(node)) {
                var mount = node.mount.mountpoint;
                if (!path) return mount;
                return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
              }
              path = path ? `${node.name}/${path}` : node.name;
              node = node.parent;
            }
          }, hashName(parentid, name2) {
            var hash = 0;
            for (var i = 0; i < name2.length; i++) {
              hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
            }
            return (parentid + hash >>> 0) % FS.nameTable.length;
          }, hashAddNode(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            node.name_next = FS.nameTable[hash];
            FS.nameTable[hash] = node;
          }, hashRemoveNode(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            if (FS.nameTable[hash] === node) {
              FS.nameTable[hash] = node.name_next;
            } else {
              var current = FS.nameTable[hash];
              while (current) {
                if (current.name_next === node) {
                  current.name_next = node.name_next;
                  break;
                }
                current = current.name_next;
              }
            }
          }, lookupNode(parent, name2) {
            var errCode = FS.mayLookup(parent);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            var hash = FS.hashName(parent.id, name2);
            for (var node = FS.nameTable[hash]; node; node = node.name_next) {
              var nodeName = node.name;
              if (node.parent.id === parent.id && nodeName === name2) {
                return node;
              }
            }
            return FS.lookup(parent, name2);
          }, createNode(parent, name2, mode2, rdev) {
            var node = new FS.FSNode(parent, name2, mode2, rdev);
            FS.hashAddNode(node);
            return node;
          }, destroyNode(node) {
            FS.hashRemoveNode(node);
          }, isRoot(node) {
            return node === node.parent;
          }, isMountpoint(node) {
            return !!node.mounted;
          }, isFile(mode2) {
            return (mode2 & 61440) === 32768;
          }, isDir(mode2) {
            return (mode2 & 61440) === 16384;
          }, isLink(mode2) {
            return (mode2 & 61440) === 40960;
          }, isChrdev(mode2) {
            return (mode2 & 61440) === 8192;
          }, isBlkdev(mode2) {
            return (mode2 & 61440) === 24576;
          }, isFIFO(mode2) {
            return (mode2 & 61440) === 4096;
          }, isSocket(mode2) {
            return (mode2 & 49152) === 49152;
          }, flagsToPermissionString(flag) {
            var perms = ["r", "w", "rw"][flag & 3];
            if (flag & 512) {
              perms += "w";
            }
            return perms;
          }, nodePermissions(node, perms) {
            if (FS.ignorePermissions) {
              return 0;
            }
            if (perms.includes("r") && !(node.mode & 292)) {
              return 2;
            } else if (perms.includes("w") && !(node.mode & 146)) {
              return 2;
            } else if (perms.includes("x") && !(node.mode & 73)) {
              return 2;
            }
            return 0;
          }, mayLookup(dir) {
            if (!FS.isDir(dir.mode)) return 54;
            var errCode = FS.nodePermissions(dir, "x");
            if (errCode) return errCode;
            if (!dir.node_ops.lookup) return 2;
            return 0;
          }, mayCreate(dir, name2) {
            try {
              var node = FS.lookupNode(dir, name2);
              return 20;
            } catch (e) {
            }
            return FS.nodePermissions(dir, "wx");
          }, mayDelete(dir, name2, isdir) {
            var node;
            try {
              node = FS.lookupNode(dir, name2);
            } catch (e) {
              return e.errno;
            }
            var errCode = FS.nodePermissions(dir, "wx");
            if (errCode) {
              return errCode;
            }
            if (isdir) {
              if (!FS.isDir(node.mode)) {
                return 54;
              }
              if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return 10;
              }
            } else {
              if (FS.isDir(node.mode)) {
                return 31;
              }
            }
            return 0;
          }, mayOpen(node, flags) {
            if (!node) {
              return 44;
            }
            if (FS.isLink(node.mode)) {
              return 32;
            } else if (FS.isDir(node.mode)) {
              if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
                return 31;
              }
            }
            return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
          }, MAX_OPEN_FDS: 4096, nextfd() {
            for (var fd2 = 0; fd2 <= FS.MAX_OPEN_FDS; fd2++) {
              if (!FS.streams[fd2]) {
                return fd2;
              }
            }
            throw new FS.ErrnoError(33);
          }, getStreamChecked(fd2) {
            var stream = FS.getStream(fd2);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            return stream;
          }, getStream: (fd2) => FS.streams[fd2], createStream(stream, fd2 = -1) {
            stream = Object.assign(new FS.FSStream(), stream);
            if (fd2 == -1) {
              fd2 = FS.nextfd();
            }
            stream.fd = fd2;
            FS.streams[fd2] = stream;
            return stream;
          }, closeStream(fd2) {
            FS.streams[fd2] = null;
          }, dupStream(origStream, fd2 = -1) {
            var stream = FS.createStream(origStream, fd2);
            stream.stream_ops?.dup?.(stream);
            return stream;
          }, chrdev_stream_ops: { open(stream) {
            var device = FS.getDevice(stream.node.rdev);
            stream.stream_ops = device.stream_ops;
            stream.stream_ops.open?.(stream);
          }, llseek() {
            throw new FS.ErrnoError(70);
          } }, major: (dev) => dev >> 8, minor: (dev) => dev & 255, makedev: (ma, mi) => ma << 8 | mi, registerDevice(dev, ops) {
            FS.devices[dev] = { stream_ops: ops };
          }, getDevice: (dev) => FS.devices[dev], getMounts(mount) {
            var mounts = [];
            var check = [mount];
            while (check.length) {
              var m = check.pop();
              mounts.push(m);
              check.push(...m.mounts);
            }
            return mounts;
          }, syncfs(populate, callback) {
            if (typeof populate == "function") {
              callback = populate;
              populate = false;
            }
            FS.syncFSRequests++;
            if (FS.syncFSRequests > 1) {
              err2(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
            }
            var mounts = FS.getMounts(FS.root.mount);
            var completed = 0;
            function doCallback(errCode) {
              FS.syncFSRequests--;
              return callback(errCode);
            }
            function done(errCode) {
              if (errCode) {
                if (!done.errored) {
                  done.errored = true;
                  return doCallback(errCode);
                }
                return;
              }
              if (++completed >= mounts.length) {
                doCallback(null);
              }
            }
            mounts.forEach((mount) => {
              if (!mount.type.syncfs) {
                return done(null);
              }
              mount.type.syncfs(mount, populate, done);
            });
          }, mount(type, opts, mountpoint) {
            var root = mountpoint === "/";
            var pseudo = !mountpoint;
            var node;
            if (root && FS.root) {
              throw new FS.ErrnoError(10);
            } else if (!root && !pseudo) {
              var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
              mountpoint = lookup.path;
              node = lookup.node;
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
            }
            var mount = { type, opts, mountpoint, mounts: [] };
            var mountRoot = type.mount(mount);
            mountRoot.mount = mount;
            mount.root = mountRoot;
            if (root) {
              FS.root = mountRoot;
            } else if (node) {
              node.mounted = mount;
              if (node.mount) {
                node.mount.mounts.push(mount);
              }
            }
            return mountRoot;
          }, unmount(mountpoint) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            if (!FS.isMountpoint(lookup.node)) {
              throw new FS.ErrnoError(28);
            }
            var node = lookup.node;
            var mount = node.mounted;
            var mounts = FS.getMounts(mount);
            Object.keys(FS.nameTable).forEach((hash) => {
              var current = FS.nameTable[hash];
              while (current) {
                var next = current.name_next;
                if (mounts.includes(current.mount)) {
                  FS.destroyNode(current);
                }
                current = next;
              }
            });
            node.mounted = null;
            var idx = node.mount.mounts.indexOf(mount);
            node.mount.mounts.splice(idx, 1);
          }, lookup(parent, name2) {
            return parent.node_ops.lookup(parent, name2);
          }, mknod(path, mode2, dev) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            if (!name2 || name2 === "." || name2 === "..") {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.mayCreate(parent, name2);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.mknod) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.mknod(parent, name2, mode2, dev);
          }, create(path, mode2) {
            mode2 = mode2 !== void 0 ? mode2 : 438;
            mode2 &= 4095;
            mode2 |= 32768;
            return FS.mknod(path, mode2, 0);
          }, mkdir(path, mode2) {
            mode2 = mode2 !== void 0 ? mode2 : 511;
            mode2 &= 511 | 512;
            mode2 |= 16384;
            return FS.mknod(path, mode2, 0);
          }, mkdirTree(path, mode2) {
            var dirs = path.split("/");
            var d = "";
            for (var i = 0; i < dirs.length; ++i) {
              if (!dirs[i]) continue;
              d += "/" + dirs[i];
              try {
                FS.mkdir(d, mode2);
              } catch (e) {
                if (e.errno != 20) throw e;
              }
            }
          }, mkdev(path, mode2, dev) {
            if (typeof dev == "undefined") {
              dev = mode2;
              mode2 = 438;
            }
            mode2 |= 8192;
            return FS.mknod(path, mode2, dev);
          }, symlink(oldpath, newpath) {
            if (!PATH_FS.resolve(oldpath)) {
              throw new FS.ErrnoError(44);
            }
            var lookup = FS.lookupPath(newpath, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var newname = PATH.basename(newpath);
            var errCode = FS.mayCreate(parent, newname);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.symlink) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.symlink(parent, newname, oldpath);
          }, rename(old_path, new_path) {
            var old_dirname = PATH.dirname(old_path);
            var new_dirname = PATH.dirname(new_path);
            var old_name = PATH.basename(old_path);
            var new_name = PATH.basename(new_path);
            var lookup, old_dir, new_dir;
            lookup = FS.lookupPath(old_path, { parent: true });
            old_dir = lookup.node;
            lookup = FS.lookupPath(new_path, { parent: true });
            new_dir = lookup.node;
            if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
            if (old_dir.mount !== new_dir.mount) {
              throw new FS.ErrnoError(75);
            }
            var old_node = FS.lookupNode(old_dir, old_name);
            var relative = PATH_FS.relative(old_path, new_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(28);
            }
            relative = PATH_FS.relative(new_path, old_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(55);
            }
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (old_node === new_node) {
              return;
            }
            var isdir = FS.isDir(old_node.mode);
            var errCode = FS.mayDelete(old_dir, old_name, isdir);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!old_dir.node_ops.rename) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
              throw new FS.ErrnoError(10);
            }
            if (new_dir !== old_dir) {
              errCode = FS.nodePermissions(old_dir, "w");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            FS.hashRemoveNode(old_node);
            try {
              old_dir.node_ops.rename(old_node, new_dir, new_name);
              old_node.parent = new_dir;
            } catch (e) {
              throw e;
            } finally {
              FS.hashAddNode(old_node);
            }
          }, rmdir(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, true);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.rmdir) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            parent.node_ops.rmdir(parent, name2);
            FS.destroyNode(node);
          }, readdir(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            if (!node.node_ops.readdir) {
              throw new FS.ErrnoError(54);
            }
            return node.node_ops.readdir(node);
          }, unlink(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var name2 = PATH.basename(path);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, false);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.unlink) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            parent.node_ops.unlink(parent, name2);
            FS.destroyNode(node);
          }, readlink(path) {
            var lookup = FS.lookupPath(path);
            var link = lookup.node;
            if (!link) {
              throw new FS.ErrnoError(44);
            }
            if (!link.node_ops.readlink) {
              throw new FS.ErrnoError(28);
            }
            return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
          }, stat(path, dontFollow) {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            var node = lookup.node;
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (!node.node_ops.getattr) {
              throw new FS.ErrnoError(63);
            }
            return node.node_ops.getattr(node);
          }, lstat(path) {
            return FS.stat(path, true);
          }, chmod(path, mode2, dontFollow) {
            var node;
            if (typeof path == "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, { mode: mode2 & 4095 | node.mode & -4096, timestamp: Date.now() });
          }, lchmod(path, mode2) {
            FS.chmod(path, mode2, true);
          }, fchmod(fd2, mode2) {
            var stream = FS.getStreamChecked(fd2);
            FS.chmod(stream.node, mode2);
          }, chown(path, uid, gid, dontFollow) {
            var node;
            if (typeof path == "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, { timestamp: Date.now() });
          }, lchown(path, uid, gid) {
            FS.chown(path, uid, gid, true);
          }, fchown(fd2, uid, gid) {
            var stream = FS.getStreamChecked(fd2);
            FS.chown(stream.node, uid, gid);
          }, truncate(path, len) {
            if (len < 0) {
              throw new FS.ErrnoError(28);
            }
            var node;
            if (typeof path == "string") {
              var lookup = FS.lookupPath(path, { follow: true });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isDir(node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!FS.isFile(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.nodePermissions(node, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
          }, ftruncate(fd2, len) {
            var stream = FS.getStreamChecked(fd2);
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(28);
            }
            FS.truncate(stream.node, len);
          }, utime(path, atime, mtime) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
          }, open(path, flags, mode2) {
            if (path === "") {
              throw new FS.ErrnoError(44);
            }
            flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
            if (flags & 64) {
              mode2 = typeof mode2 == "undefined" ? 438 : mode2;
              mode2 = mode2 & 4095 | 32768;
            } else {
              mode2 = 0;
            }
            var node;
            if (typeof path == "object") {
              node = path;
            } else {
              path = PATH.normalize(path);
              try {
                var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
                node = lookup.node;
              } catch (e) {
              }
            }
            var created = false;
            if (flags & 64) {
              if (node) {
                if (flags & 128) {
                  throw new FS.ErrnoError(20);
                }
              } else {
                node = FS.mknod(path, mode2, 0);
                created = true;
              }
            }
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (FS.isChrdev(node.mode)) {
              flags &= -513;
            }
            if (flags & 65536 && !FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
            if (!created) {
              var errCode = FS.mayOpen(node, flags);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            if (flags & 512 && !created) {
              FS.truncate(node, 0);
            }
            flags &= -131713;
            var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false });
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
            if (Module2["logReadFiles"] && !(flags & 1)) {
              if (!FS.readFiles) FS.readFiles = {};
              if (!(path in FS.readFiles)) {
                FS.readFiles[path] = 1;
              }
            }
            return stream;
          }, close(stream) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (stream.getdents) stream.getdents = null;
            try {
              if (stream.stream_ops.close) {
                stream.stream_ops.close(stream);
              }
            } catch (e) {
              throw e;
            } finally {
              FS.closeStream(stream.fd);
            }
            stream.fd = null;
          }, isClosed(stream) {
            return stream.fd === null;
          }, llseek(stream, offset, whence) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (!stream.seekable || !stream.stream_ops.llseek) {
              throw new FS.ErrnoError(70);
            }
            if (whence != 0 && whence != 1 && whence != 2) {
              throw new FS.ErrnoError(28);
            }
            stream.position = stream.stream_ops.llseek(stream, offset, whence);
            stream.ungotten = [];
            return stream.position;
          }, read(stream, buffer, offset, length, position) {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.read) {
              throw new FS.ErrnoError(28);
            }
            var seeking = typeof position != "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
            if (!seeking) stream.position += bytesRead;
            return bytesRead;
          }, write(stream, buffer, offset, length, position, canOwn) {
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.write) {
              throw new FS.ErrnoError(28);
            }
            if (stream.seekable && stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position != "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
            if (!seeking) stream.position += bytesWritten;
            return bytesWritten;
          }, allocate(stream, offset, length) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (offset < 0 || length <= 0) {
              throw new FS.ErrnoError(28);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (!stream.stream_ops.allocate) {
              throw new FS.ErrnoError(138);
            }
            stream.stream_ops.allocate(stream, offset, length);
          }, mmap(stream, length, position, prot, flags) {
            if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
              throw new FS.ErrnoError(2);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(2);
            }
            if (!stream.stream_ops.mmap) {
              throw new FS.ErrnoError(43);
            }
            if (!length) {
              throw new FS.ErrnoError(28);
            }
            return stream.stream_ops.mmap(stream, length, position, prot, flags);
          }, msync(stream, buffer, offset, length, mmapFlags) {
            if (!stream.stream_ops.msync) {
              return 0;
            }
            return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
          }, ioctl(stream, cmd, arg) {
            if (!stream.stream_ops.ioctl) {
              throw new FS.ErrnoError(59);
            }
            return stream.stream_ops.ioctl(stream, cmd, arg);
          }, readFile(path, opts = {}) {
            opts.flags = opts.flags || 0;
            opts.encoding = opts.encoding || "binary";
            if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
              throw new Error(`Invalid encoding type "${opts.encoding}"`);
            }
            var ret;
            var stream = FS.open(path, opts.flags);
            var stat = FS.stat(path);
            var length = stat.size;
            var buf = new Uint8Array(length);
            FS.read(stream, buf, 0, length, 0);
            if (opts.encoding === "utf8") {
              ret = UTF8ArrayToString(buf, 0);
            } else if (opts.encoding === "binary") {
              ret = buf;
            }
            FS.close(stream);
            return ret;
          }, writeFile(path, data, opts = {}) {
            opts.flags = opts.flags || 577;
            var stream = FS.open(path, opts.flags, opts.mode);
            if (typeof data == "string") {
              var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
              var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
              FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
            } else if (ArrayBuffer.isView(data)) {
              FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
            } else {
              throw new Error("Unsupported data type");
            }
            FS.close(stream);
          }, cwd: () => FS.currentPath, chdir(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            if (lookup.node === null) {
              throw new FS.ErrnoError(44);
            }
            if (!FS.isDir(lookup.node.mode)) {
              throw new FS.ErrnoError(54);
            }
            var errCode = FS.nodePermissions(lookup.node, "x");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            FS.currentPath = lookup.path;
          }, createDefaultDirectories() {
            FS.mkdir("/tmp");
            FS.mkdir("/home");
            FS.mkdir("/home/web_user");
          }, createDefaultDevices() {
            FS.mkdir("/dev");
            FS.registerDevice(FS.makedev(1, 3), { read: () => 0, write: (stream, buffer, offset, length, pos) => length });
            FS.mkdev("/dev/null", FS.makedev(1, 3));
            TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
            TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
            FS.mkdev("/dev/tty", FS.makedev(5, 0));
            FS.mkdev("/dev/tty1", FS.makedev(6, 0));
            var randomBuffer = new Uint8Array(1024), randomLeft = 0;
            var randomByte = () => {
              if (randomLeft === 0) {
                randomLeft = randomFill(randomBuffer).byteLength;
              }
              return randomBuffer[--randomLeft];
            };
            FS.createDevice("/dev", "random", randomByte);
            FS.createDevice("/dev", "urandom", randomByte);
            FS.mkdir("/dev/shm");
            FS.mkdir("/dev/shm/tmp");
          }, createSpecialDirectories() {
            FS.mkdir("/proc");
            var proc_self = FS.mkdir("/proc/self");
            FS.mkdir("/proc/self/fd");
            FS.mount({ mount() {
              var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
              node.node_ops = { lookup(parent, name2) {
                var fd2 = +name2;
                var stream = FS.getStreamChecked(fd2);
                var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => stream.path } };
                ret.parent = ret;
                return ret;
              } };
              return node;
            } }, {}, "/proc/self/fd");
          }, createStandardStreams(input, output, error) {
            if (input) {
              FS.createDevice("/dev", "stdin", input);
            } else {
              FS.symlink("/dev/tty", "/dev/stdin");
            }
            if (output) {
              FS.createDevice("/dev", "stdout", null, output);
            } else {
              FS.symlink("/dev/tty", "/dev/stdout");
            }
            if (error) {
              FS.createDevice("/dev", "stderr", null, error);
            } else {
              FS.symlink("/dev/tty1", "/dev/stderr");
            }
            FS.open("/dev/stdin", 0);
            FS.open("/dev/stdout", 1);
            FS.open("/dev/stderr", 1);
          }, staticInit() {
            [44].forEach((code) => {
              FS.genericErrors[code] = new FS.ErrnoError(code);
              FS.genericErrors[code].stack = "<generic error, no stack>";
            });
            FS.nameTable = new Array(4096);
            FS.mount(MEMFS, {}, "/");
            FS.createDefaultDirectories();
            FS.createDefaultDevices();
            FS.createSpecialDirectories();
            FS.filesystems = { MEMFS };
          }, init(input, output, error) {
            FS.initialized = true;
            input ??= Module2["stdin"];
            output ??= Module2["stdout"];
            error ??= Module2["stderr"];
            FS.createStandardStreams(input, output, error);
          }, quit() {
            FS.initialized = false;
            for (var i = 0; i < FS.streams.length; i++) {
              var stream = FS.streams[i];
              if (!stream) {
                continue;
              }
              FS.close(stream);
            }
          }, findObject(path, dontResolveLastLink) {
            var ret = FS.analyzePath(path, dontResolveLastLink);
            if (!ret.exists) {
              return null;
            }
            return ret.object;
          }, analyzePath(path, dontResolveLastLink) {
            try {
              var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              path = lookup.path;
            } catch (e) {
            }
            var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
            try {
              var lookup = FS.lookupPath(path, { parent: true });
              ret.parentExists = true;
              ret.parentPath = lookup.path;
              ret.parentObject = lookup.node;
              ret.name = PATH.basename(path);
              lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              ret.exists = true;
              ret.path = lookup.path;
              ret.object = lookup.node;
              ret.name = lookup.node.name;
              ret.isRoot = lookup.path === "/";
            } catch (e) {
              ret.error = e.errno;
            }
            return ret;
          }, createPath(parent, path, canRead, canWrite) {
            parent = typeof parent == "string" ? parent : FS.getPath(parent);
            var parts = path.split("/").reverse();
            while (parts.length) {
              var part = parts.pop();
              if (!part) continue;
              var current = PATH.join2(parent, part);
              try {
                FS.mkdir(current);
              } catch (e) {
              }
              parent = current;
            }
            return current;
          }, createFile(parent, name2, properties, canRead, canWrite) {
            var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
            var mode2 = FS_getMode(canRead, canWrite);
            return FS.create(path, mode2);
          }, createDataFile(parent, name2, data, canRead, canWrite, canOwn) {
            var path = name2;
            if (parent) {
              parent = typeof parent == "string" ? parent : FS.getPath(parent);
              path = name2 ? PATH.join2(parent, name2) : parent;
            }
            var mode2 = FS_getMode(canRead, canWrite);
            var node = FS.create(path, mode2);
            if (data) {
              if (typeof data == "string") {
                var arr = new Array(data.length);
                for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
                data = arr;
              }
              FS.chmod(node, mode2 | 146);
              var stream = FS.open(node, 577);
              FS.write(stream, data, 0, data.length, 0, canOwn);
              FS.close(stream);
              FS.chmod(node, mode2);
            }
          }, createDevice(parent, name2, input, output) {
            var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
            var mode2 = FS_getMode(!!input, !!output);
            if (!FS.createDevice.major) FS.createDevice.major = 64;
            var dev = FS.makedev(FS.createDevice.major++, 0);
            FS.registerDevice(dev, { open(stream) {
              stream.seekable = false;
            }, close(stream) {
              if (output?.buffer?.length) {
                output(10);
              }
            }, read(stream, buffer, offset, length, pos) {
              var bytesRead = 0;
              for (var i = 0; i < length; i++) {
                var result;
                try {
                  result = input();
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (result === void 0 && bytesRead === 0) {
                  throw new FS.ErrnoError(6);
                }
                if (result === null || result === void 0) break;
                bytesRead++;
                buffer[offset + i] = result;
              }
              if (bytesRead) {
                stream.node.timestamp = Date.now();
              }
              return bytesRead;
            }, write(stream, buffer, offset, length, pos) {
              for (var i = 0; i < length; i++) {
                try {
                  output(buffer[offset + i]);
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
              }
              if (length) {
                stream.node.timestamp = Date.now();
              }
              return i;
            } });
            return FS.mkdev(path, mode2, dev);
          }, forceLoadFile(obj) {
            if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
            if (typeof XMLHttpRequest != "undefined") {
              throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
            } else {
              try {
                obj.contents = readBinary(obj.url);
                obj.usedBytes = obj.contents.length;
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
          }, createLazyFile(parent, name2, url, canRead, canWrite) {
            class LazyUint8Array {
              constructor() {
                this.lengthKnown = false;
                this.chunks = [];
              }
              get(idx) {
                if (idx > this.length - 1 || idx < 0) {
                  return void 0;
                }
                var chunkOffset = idx % this.chunkSize;
                var chunkNum = idx / this.chunkSize | 0;
                return this.getter(chunkNum)[chunkOffset];
              }
              setDataGetter(getter) {
                this.getter = getter;
              }
              cacheLength() {
                var xhr = new XMLHttpRequest();
                xhr.open("HEAD", url, false);
                xhr.send(null);
                if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
                var datalength = Number(xhr.getResponseHeader("Content-length"));
                var header;
                var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
                var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
                var chunkSize = 1024 * 1024;
                if (!hasByteServing) chunkSize = datalength;
                var doXHR = (from, to) => {
                  if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                  if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
                  var xhr2 = new XMLHttpRequest();
                  xhr2.open("GET", url, false);
                  if (datalength !== chunkSize) xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
                  xhr2.responseType = "arraybuffer";
                  if (xhr2.overrideMimeType) {
                    xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                  }
                  xhr2.send(null);
                  if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
                  if (xhr2.response !== void 0) {
                    return new Uint8Array(xhr2.response || []);
                  }
                  return intArrayFromString(xhr2.responseText || "");
                };
                var lazyArray2 = this;
                lazyArray2.setDataGetter((chunkNum) => {
                  var start = chunkNum * chunkSize;
                  var end = (chunkNum + 1) * chunkSize - 1;
                  end = Math.min(end, datalength - 1);
                  if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
                    lazyArray2.chunks[chunkNum] = doXHR(start, end);
                  }
                  if (typeof lazyArray2.chunks[chunkNum] == "undefined") throw new Error("doXHR failed!");
                  return lazyArray2.chunks[chunkNum];
                });
                if (usesGzip || !datalength) {
                  chunkSize = datalength = 1;
                  datalength = this.getter(0).length;
                  chunkSize = datalength;
                  out("LazyFiles on gzip forces download of the whole file when length is accessed");
                }
                this._length = datalength;
                this._chunkSize = chunkSize;
                this.lengthKnown = true;
              }
              get length() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
              get chunkSize() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
            if (typeof XMLHttpRequest != "undefined") {
              var lazyArray = new LazyUint8Array();
              var properties = { isDevice: false, contents: lazyArray };
            } else {
              var properties = { isDevice: false, url };
            }
            var node = FS.createFile(parent, name2, properties, canRead, canWrite);
            if (properties.contents) {
              node.contents = properties.contents;
            } else if (properties.url) {
              node.contents = null;
              node.url = properties.url;
            }
            Object.defineProperties(node, { usedBytes: { get: function() {
              return this.contents.length;
            } } });
            var stream_ops = {};
            var keys = Object.keys(node.stream_ops);
            keys.forEach((key) => {
              var fn = node.stream_ops[key];
              stream_ops[key] = (...args) => {
                FS.forceLoadFile(node);
                return fn(...args);
              };
            });
            function writeChunks(stream, buffer, offset, length, position) {
              var contents = stream.node.contents;
              if (position >= contents.length) return 0;
              var size2 = Math.min(contents.length - position, length);
              if (contents.slice) {
                for (var i = 0; i < size2; i++) {
                  buffer[offset + i] = contents[position + i];
                }
              } else {
                for (var i = 0; i < size2; i++) {
                  buffer[offset + i] = contents.get(position + i);
                }
              }
              return size2;
            }
            stream_ops.read = (stream, buffer, offset, length, position) => {
              FS.forceLoadFile(node);
              return writeChunks(stream, buffer, offset, length, position);
            };
            stream_ops.mmap = (stream, length, position, prot, flags) => {
              FS.forceLoadFile(node);
              var ptr = mmapAlloc();
              if (!ptr) {
                throw new FS.ErrnoError(48);
              }
              writeChunks(stream, HEAP8, ptr, length, position);
              return { ptr, allocated: true };
            };
            node.stream_ops = stream_ops;
            return node;
          } };
          var UTF8ToString = (ptr, maxBytesToRead) => {
            if (!ptr) return "";
            var maxPtr = ptr + maxBytesToRead;
            for (var end = ptr; !(end >= maxPtr) && HEAPU8[end]; ) ++end;
            return UTF8Decoder.decode(HEAPU8.subarray(ptr, end));
          };
          var SYSCALLS = { DEFAULT_POLLMASK: 5, calculateAt(dirfd, path, allowEmpty) {
            if (PATH.isAbs(path)) {
              return path;
            }
            var dir;
            if (dirfd === -100) {
              dir = FS.cwd();
            } else {
              var dirstream = SYSCALLS.getStreamFromFD(dirfd);
              dir = dirstream.path;
            }
            if (path.length == 0) {
              if (!allowEmpty) {
                throw new FS.ErrnoError(44);
              }
              return dir;
            }
            return PATH.join2(dir, path);
          }, doStat(func, path, buf) {
            var stat = func(path);
            HEAP32[buf >> 2] = stat.dev;
            HEAP32[buf + 4 >> 2] = stat.mode;
            HEAPU32[buf + 8 >> 2] = stat.nlink;
            HEAP32[buf + 12 >> 2] = stat.uid;
            HEAP32[buf + 16 >> 2] = stat.gid;
            HEAP32[buf + 20 >> 2] = stat.rdev;
            tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
            HEAP32[buf + 32 >> 2] = 4096;
            HEAP32[buf + 36 >> 2] = stat.blocks;
            var atime = stat.atime.getTime();
            var mtime = stat.mtime.getTime();
            var ctime = stat.ctime.getTime();
            tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
            HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
            tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
            HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
            tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
            HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
            tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
            return 0;
          }, doMsync(addr, stream, len, flags, offset) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (flags & 2) {
              return 0;
            }
            var buffer = HEAPU8.slice(addr, addr + len);
            FS.msync(stream, buffer, offset, len, flags);
          }, getStreamFromFD(fd2) {
            var stream = FS.getStreamChecked(fd2);
            return stream;
          }, varargs: void 0, getStr(ptr) {
            var ret = UTF8ToString(ptr);
            return ret;
          } };
          function ___syscall_chmod(path, mode2) {
            try {
              path = SYSCALLS.getStr(path);
              FS.chmod(path, mode2);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return -e.errno;
            }
          }
          function ___syscall_fchownat(dirfd, path, owner, group, flags) {
            try {
              path = SYSCALLS.getStr(path);
              var nofollow = flags & 256;
              flags = flags & ~256;
              path = SYSCALLS.calculateAt(dirfd, path);
              (nofollow ? FS.lchown : FS.chown)(path, owner, group);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return -e.errno;
            }
          }
          function syscallGetVarargI() {
            var ret = HEAP32[+SYSCALLS.varargs >> 2];
            SYSCALLS.varargs += 4;
            return ret;
          }
          var syscallGetVarargP = syscallGetVarargI;
          function ___syscall_fcntl64(fd2, cmd, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd2);
              switch (cmd) {
                case 0: {
                  var arg = syscallGetVarargI();
                  if (arg < 0) {
                    return -28;
                  }
                  while (FS.streams[arg]) {
                    arg++;
                  }
                  var newStream;
                  newStream = FS.dupStream(stream, arg);
                  return newStream.fd;
                }
                case 1:
                case 2:
                  return 0;
                case 3:
                  return stream.flags;
                case 4: {
                  var arg = syscallGetVarargI();
                  stream.flags |= arg;
                  return 0;
                }
                case 12: {
                  var arg = syscallGetVarargP();
                  var offset = 0;
                  HEAP16[arg + offset >> 1] = 2;
                  return 0;
                }
                case 13:
                case 14:
                  return 0;
              }
              return -28;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return -e.errno;
            }
          }
          function ___syscall_fstat64(fd2, buf) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd2);
              return SYSCALLS.doStat(FS.stat, stream.path, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return -e.errno;
            }
          }
          function ___syscall_ioctl(fd2, op, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd2);
              switch (op) {
                case 21509: {
                  if (!stream.tty) return -59;
                  return 0;
                }
                case 21505: {
                  if (!stream.tty) return -59;
                  if (stream.tty.ops.ioctl_tcgets) {
                    var termios = stream.tty.ops.ioctl_tcgets(stream);
                    var argp = syscallGetVarargP();
                    HEAP32[argp >> 2] = termios.c_iflag || 0;
                    HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
                    HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
                    HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
                    for (var i = 0; i < 32; i++) {
                      HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
                    }
                    return 0;
                  }
                  return 0;
                }
                case 21510:
                case 21511:
                case 21512: {
                  if (!stream.tty) return -59;
                  return 0;
                }
                case 21506:
                case 21507:
                case 21508: {
                  if (!stream.tty) return -59;
                  if (stream.tty.ops.ioctl_tcsets) {
                    var argp = syscallGetVarargP();
                    var c_iflag = HEAP32[argp >> 2];
                    var c_oflag = HEAP32[argp + 4 >> 2];
                    var c_cflag = HEAP32[argp + 8 >> 2];
                    var c_lflag = HEAP32[argp + 12 >> 2];
                    var c_cc = [];
                    for (var i = 0; i < 32; i++) {
                      c_cc.push(HEAP8[argp + i + 17]);
                    }
                    return stream.tty.ops.ioctl_tcsets(stream.tty, op, { c_iflag, c_oflag, c_cflag, c_lflag, c_cc });
                  }
                  return 0;
                }
                case 21519: {
                  if (!stream.tty) return -59;
                  var argp = syscallGetVarargP();
                  HEAP32[argp >> 2] = 0;
                  return 0;
                }
                case 21520: {
                  if (!stream.tty) return -59;
                  return -28;
                }
                case 21531: {
                  var argp = syscallGetVarargP();
                  return FS.ioctl(stream, op, argp);
                }
                case 21523: {
                  if (!stream.tty) return -59;
                  if (stream.tty.ops.ioctl_tiocgwinsz) {
                    var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
                    var argp = syscallGetVarargP();
                    HEAP16[argp >> 1] = winsize[0];
                    HEAP16[argp + 2 >> 1] = winsize[1];
                  }
                  return 0;
                }
                case 21524: {
                  if (!stream.tty) return -59;
                  return 0;
                }
                case 21515: {
                  if (!stream.tty) return -59;
                  return 0;
                }
                default:
                  return -28;
              }
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return -e.errno;
            }
          }
          function ___syscall_lstat64(path, buf) {
            try {
              path = SYSCALLS.getStr(path);
              return SYSCALLS.doStat(FS.lstat, path, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return -e.errno;
            }
          }
          function ___syscall_newfstatat(dirfd, path, buf, flags) {
            try {
              path = SYSCALLS.getStr(path);
              var nofollow = flags & 256;
              var allowEmpty = flags & 4096;
              flags = flags & ~6400;
              path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
              return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return -e.errno;
            }
          }
          function ___syscall_openat(dirfd, path, flags, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              var mode2 = varargs ? syscallGetVarargI() : 0;
              return FS.open(path, flags, mode2).fd;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return -e.errno;
            }
          }
          function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
            try {
              oldpath = SYSCALLS.getStr(oldpath);
              newpath = SYSCALLS.getStr(newpath);
              oldpath = SYSCALLS.calculateAt(olddirfd, oldpath);
              newpath = SYSCALLS.calculateAt(newdirfd, newpath);
              FS.rename(oldpath, newpath);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return -e.errno;
            }
          }
          function ___syscall_stat64(path, buf) {
            try {
              path = SYSCALLS.getStr(path);
              return SYSCALLS.doStat(FS.stat, path, buf);
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return -e.errno;
            }
          }
          function ___syscall_unlinkat(dirfd, path, flags) {
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path);
              if (flags === 0) {
                FS.unlink(path);
              } else if (flags === 512) {
                FS.rmdir(path);
              } else {
                abort("Invalid flags passed to unlinkat");
              }
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return -e.errno;
            }
          }
          var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
          function ___syscall_utimensat(dirfd, path, times, flags) {
            try {
              path = SYSCALLS.getStr(path);
              path = SYSCALLS.calculateAt(dirfd, path, true);
              var now = Date.now(), atime, mtime;
              if (!times) {
                atime = now;
                mtime = now;
              } else {
                var seconds = readI53FromI64(times);
                var nanoseconds = HEAP32[times + 8 >> 2];
                if (nanoseconds == 1073741823) {
                  atime = now;
                } else if (nanoseconds == 1073741822) {
                  atime = -1;
                } else {
                  atime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
                }
                times += 16;
                seconds = readI53FromI64(times);
                nanoseconds = HEAP32[times + 8 >> 2];
                if (nanoseconds == 1073741823) {
                  mtime = now;
                } else if (nanoseconds == 1073741822) {
                  mtime = -1;
                } else {
                  mtime = seconds * 1e3 + nanoseconds / (1e3 * 1e3);
                }
              }
              if (mtime != -1 || atime != -1) {
                FS.utime(path, atime, mtime);
              }
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return -e.errno;
            }
          }
          var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);
          var abortOnCannotGrowMemory = (requestedSize) => {
            abort("OOM");
          };
          var _emscripten_resize_heap = (requestedSize) => {
            HEAPU8.length;
            abortOnCannotGrowMemory();
          };
          var ENV = {};
          var getExecutableName = () => thisProgram || "./this.program";
          var getEnvStrings = () => {
            if (!getEnvStrings.strings) {
              var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
              var env = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: lang, _: getExecutableName() };
              for (var x in ENV) {
                if (ENV[x] === void 0) delete env[x];
                else env[x] = ENV[x];
              }
              var strings = [];
              for (var x in env) {
                strings.push(`${x}=${env[x]}`);
              }
              getEnvStrings.strings = strings;
            }
            return getEnvStrings.strings;
          };
          var stringToAscii = (str, buffer) => {
            for (var i = 0; i < str.length; ++i) {
              HEAP8[buffer++] = str.charCodeAt(i);
            }
            HEAP8[buffer] = 0;
          };
          var _environ_get = (__environ, environ_buf) => {
            var bufSize = 0;
            getEnvStrings().forEach((string, i) => {
              var ptr = environ_buf + bufSize;
              HEAPU32[__environ + i * 4 >> 2] = ptr;
              stringToAscii(string, ptr);
              bufSize += string.length + 1;
            });
            return 0;
          };
          var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
            var strings = getEnvStrings();
            HEAPU32[penviron_count >> 2] = strings.length;
            var bufSize = 0;
            strings.forEach((string) => bufSize += string.length + 1);
            HEAPU32[penviron_buf_size >> 2] = bufSize;
            return 0;
          };
          var _proc_exit = (code) => {
            EXITSTATUS = code;
            quit_(code, new ExitStatus(code));
          };
          var exitJS = (status, implicit) => {
            EXITSTATUS = status;
            _proc_exit(status);
          };
          var _exit = exitJS;
          function _fd_close(fd2) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd2);
              FS.close(stream);
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return e.errno;
            }
          }
          var doReadv = (stream, iov, iovcnt, offset) => {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = HEAPU32[iov >> 2];
              var len = HEAPU32[iov + 4 >> 2];
              iov += 8;
              var curr = FS.read(stream, HEAP8, ptr, len, offset);
              if (curr < 0) return -1;
              ret += curr;
              if (curr < len) break;
            }
            return ret;
          };
          function _fd_read(fd2, iov, iovcnt, pnum) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd2);
              var num = doReadv(stream, iov, iovcnt);
              HEAPU32[pnum >> 2] = num;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return e.errno;
            }
          }
          var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
          function _fd_seek(fd2, offset_low, offset_high, whence, newOffset) {
            var offset = convertI32PairToI53Checked(offset_low, offset_high);
            try {
              if (isNaN(offset)) return 61;
              var stream = SYSCALLS.getStreamFromFD(fd2);
              FS.llseek(stream, offset, whence);
              tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
              if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return e.errno;
            }
          }
          var doWritev = (stream, iov, iovcnt, offset) => {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = HEAPU32[iov >> 2];
              var len = HEAPU32[iov + 4 >> 2];
              iov += 8;
              var curr = FS.write(stream, HEAP8, ptr, len, offset);
              if (curr < 0) return -1;
              ret += curr;
              if (curr < len) {
                break;
              }
            }
            return ret;
          };
          function _fd_write(fd2, iov, iovcnt, pnum) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd2);
              var num = doWritev(stream, iov, iovcnt);
              HEAPU32[pnum >> 2] = num;
              return 0;
            } catch (e) {
              if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
              return e.errno;
            }
          }
          var handleException = (e) => {
            if (e instanceof ExitStatus || e == "unwind") {
              return EXITSTATUS;
            }
            quit_(1, e);
          };
          var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
          var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
          var stringToUTF8OnStack = (str) => {
            var size2 = lengthBytesUTF8(str) + 1;
            var ret = stackAlloc(size2);
            stringToUTF8(str, ret, size2);
            return ret;
          };
          FS.createPreloadedFile = FS_createPreloadedFile;
          FS.staticInit();
          var wasmImports = { t: ___syscall_chmod, i: ___syscall_fchownat, c: ___syscall_fcntl64, s: ___syscall_fstat64, e: ___syscall_ioctl, p: ___syscall_lstat64, q: ___syscall_newfstatat, f: ___syscall_openat, o: ___syscall_renameat, r: ___syscall_stat64, n: ___syscall_unlinkat, m: ___syscall_utimensat, g: __emscripten_memcpy_js, j: _emscripten_resize_heap, k: _environ_get, l: _environ_sizes_get, u: _exit, a: _fd_close, d: _fd_read, h: _fd_seek, b: _fd_write };
          var wasmExports = createWasm();
          var _main = Module2["_main"] = (a0, a1) => (_main = Module2["_main"] = wasmExports["x"])(a0, a1);
          var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["z"])(a0);
          Module2["callMain"] = callMain;
          Module2["FS"] = FS;
          var calledRun;
          dependenciesFulfilled = function runCaller() {
            if (!calledRun) run();
            if (!calledRun) dependenciesFulfilled = runCaller;
          };
          function callMain(args = []) {
            var entryFunction = _main;
            args.unshift(thisProgram);
            var argc = args.length;
            var argv = stackAlloc((argc + 1) * 4);
            var argv_ptr = argv;
            args.forEach((arg) => {
              HEAPU32[argv_ptr >> 2] = stringToUTF8OnStack(arg);
              argv_ptr += 4;
            });
            HEAPU32[argv_ptr >> 2] = 0;
            try {
              var ret = entryFunction(argc, argv);
              exitJS(ret, true);
              return ret;
            } catch (e) {
              return handleException(e);
            }
          }
          function run(args = arguments_) {
            if (runDependencies > 0) {
              return;
            }
            preRun();
            if (runDependencies > 0) {
              return;
            }
            function doRun() {
              if (calledRun) return;
              calledRun = true;
              Module2["calledRun"] = true;
              if (ABORT) return;
              initRuntime();
              preMain();
              readyPromiseResolve(Module2);
              Module2["onRuntimeInitialized"]?.();
              if (shouldRunNow) callMain(args);
              postRun();
            }
            if (Module2["setStatus"]) {
              Module2["setStatus"]("Running...");
              setTimeout(() => {
                setTimeout(() => Module2["setStatus"](""), 1);
                doRun();
              }, 1);
            } else {
              doRun();
            }
          }
          if (Module2["preInit"]) {
            if (typeof Module2["preInit"] == "function") Module2["preInit"] = [Module2["preInit"]];
            while (Module2["preInit"].length > 0) {
              Module2["preInit"].pop()();
            }
          }
          var shouldRunNow = false;
          if (Module2["noInitialRun"]) shouldRunNow = false;
          run();
          moduleRtn = readyPromise;
          return moduleRtn;
        });
      })();
      let wasmBinary;
      async function preloadWASM(source = new URL("data:application/wasm;base64,AGFzbQEAAAAB4AEhYAN/f38Bf2ACf38Bf2ADf39/AGABfwF/YAR/f39/AX9gAX8AYAJ/fwBgA39+fwF/YAV/f39/fwF/YAV/fn5+fgBgA39+fwF+YAF/AX5gBH9/f38AYAZ/f39/f38Bf2AEf35+fwBgBX9/f39/AGAAAGAGf3x/f39/AX9gAn98AGAEfn5+fgF/YAJ+fwF/YAR/f399AX9gAAF/YAR/f39+AX5gAX8BfGABfgF/YAJ+fgF8YAZ/f39/f38AYAN+fn4Bf2AHf39/f39/fwF/YAJ/fwF8YAR/fn5+AGACfH8BfAJ/FQFhAWEAAwFhAWIABAFhAWMAAAFhAWQABAFhAWUAAAFhAWYABAFhAWcAAgFhAWgACAFhAWkACAFhAWoAAwFhAWsAAQFhAWwAAQFhAW0ABAFhAW4AAAFhAW8ABAFhAXAAAQFhAXEABAFhAXIAAQFhAXMAAQFhAXQAAQFhAXUABQPjAeEBBAUGAgEAAwMEAAABAQkFAAEFBQMBBQIJDwMOCQYDBQgBBgAAAQESAAMFAAIABQwBBQEBBxMAAQAOBgMDFAAFBgEBBwEMFQUEARYFBQAGAQAAAwUAFwMBBAgABg8GBwMDAAADAAsBAwEBAQEDCQENBRADAQMBAAIFBgABGAIAAwYFDRAEAAEAAAEFBAEGAAMMAAUIARkBCAMGCwMaGwkcBgINAQIMAx0eCwkOHwMGAwsLBQcgAwUADQEDAAMDAQUDAgQCAgQEAgIBBAIEAgIEAwAGEQoDAwAACgQHAAABAAIBBAUBcAEmJgUGAQGGAoYCBggBfwFBoKUWCwcYBQF2AgABdwCXAQF4APUBAXkBAAF6AOQBCUwBAEEBCyXgAd8B4wHiAeEB3QGfAdwB2wEdV3naAdkB2AHXAdYBnwHVAfQB3gHzAfIB7gHxAfAB7wHtAewB6wHqAUrnAeYB5QHpAegBCuTbCuEBQgEBfyABIAJsIQQgBAJ/IAMoAkxBAEgEQCAAIAQgAxCSAQwBCyAAIAQgAxCSAQsiAEYEQCACQQAgARsPCyAAIAFuC+4LAQd/AkAgAEUNACAAQQhrIgMgAEEEaygCACIBQXhxIgBqIQUCQCABQQFxDQAgAUECcUUNASADIAMoAgAiAWsiA0HAoRIoAgBJDQEgACABaiEAAkACQAJAQcShEigCACADRwRAIAMoAgwhAiABQf8BTQRAIAIgAygCCCIERw0CQbChEkGwoRIoAgBBfiABQQN2d3E2AgAMBQsgAygCGCEGIAIgA0cEQCADKAIIIgEgAjYCDCACIAE2AggMBAsgAygCFCIBBH8gA0EUagUgAygCECIBRQ0DIANBEGoLIQQDQCAEIQcgASICQRRqIQQgAigCFCIBDQAgAkEQaiEEIAIoAhAiAQ0ACyAHQQA2AgAMAwsgBSgCBCIBQQNxQQNHDQNBuKESIAA2AgAgBSABQX5xNgIEIAMgAEEBcjYCBCAFIAA2AgAPCyAEIAI2AgwgAiAENgIIDAILQQAhAgsgBkUNAAJAIAMoAhwiAUECdEHgoxJqIgQoAgAgA0YEQCAEIAI2AgAgAg0BQbShEkG0oRIoAgBBfiABd3E2AgAMAgsgBkEQQRQgBigCECADRhtqIAI2AgAgAkUNAQsgAiAGNgIYIAMoAhAiAQRAIAIgATYCECABIAI2AhgLIAMoAhQiAUUNACACIAE2AhQgASACNgIYCyADIAVPDQAgBSgCBCIBQQFxRQ0AAkACQAJAAkAgAUECcUUEQEHIoRIoAgAgBUYEQEHIoRIgAzYCAEG8oRJBvKESKAIAIABqIgA2AgAgAyAAQQFyNgIEIANBxKESKAIARw0GQbihEkEANgIAQcShEkEANgIADwtBxKESKAIAIAVGBEBBxKESIAM2AgBBuKESQbihEigCACAAaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgAPCyABQXhxIABqIQAgBSgCDCECIAFB/wFNBEAgBSgCCCIEIAJGBEBBsKESQbChEigCAEF+IAFBA3Z3cTYCAAwFCyAEIAI2AgwgAiAENgIIDAQLIAUoAhghBiACIAVHBEAgBSgCCCIBIAI2AgwgAiABNgIIDAMLIAUoAhQiAQR/IAVBFGoFIAUoAhAiAUUNAiAFQRBqCyEEA0AgBCEHIAEiAkEUaiEEIAIoAhQiAQ0AIAJBEGohBCACKAIQIgENAAsgB0EANgIADAILIAUgAUF+cTYCBCADIABBAXI2AgQgACADaiAANgIADAMLQQAhAgsgBkUNAAJAIAUoAhwiAUECdEHgoxJqIgQoAgAgBUYEQCAEIAI2AgAgAg0BQbShEkG0oRIoAgBBfiABd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAI2AgAgAkUNAQsgAiAGNgIYIAUoAhAiAQRAIAIgATYCECABIAI2AhgLIAUoAhQiAUUNACACIAE2AhQgASACNgIYCyADIABBAXI2AgQgACADaiAANgIAIANBxKESKAIARw0AQbihEiAANgIADwsgAEH/AU0EQCAAQXhxQdihEmohAQJ/QbChEigCACIEQQEgAEEDdnQiAHFFBEBBsKESIAAgBHI2AgAgAQwBCyABKAIICyEAIAEgAzYCCCAAIAM2AgwgAyABNgIMIAMgADYCCA8LQR8hAiAAQf///wdNBEAgAEEmIABBCHZnIgFrdkEBcSABQQF0a0E+aiECCyADIAI2AhwgA0IANwIQIAJBAnRB4KMSaiEHAn8CQAJ/QbShEigCACIBQQEgAnQiBHFFBEBBtKESIAEgBHI2AgBBGCECIAchBEEIDAELIABBGSACQQF2a0EAIAJBH0cbdCECIAcoAgAhBANAIAQiASgCBEF4cSAARg0CIAJBHXYhBCACQQF0IQIgASAEQQRxakEQaiIHKAIAIgQNAAtBGCECIAEhBEEICyEAIAMiAQwBCyABKAIIIgQgAzYCDEEIIQIgAUEIaiEHQRghAEEACyEFIAcgAzYCACACIANqIAQ2AgAgAyABNgIMIAAgA2ogBTYCAEHQoRJB0KESKAIAQQFrIgBBfyAAGzYCAAsLJgEBfyMAQRBrIgIkACACIAE2AgxB0JwLIAAgARC4ASACQRBqJAALJAEBfyMAQRBrIgMkACADIAI2AgwgACABIAIQuAEgA0EQaiQAC00BAn8gAS0AACECAkAgAC0AACIDRQ0AIAIgA0cNAANAIAEtAAEhAiAALQABIgNFDQEgAUEBaiEBIABBAWohACACIANGDQALCyADIAJrC5EEAgR/An4CQCACRQRAIAFBADYCAAwBCwJAIAAoAiRFDQAgACgCKCIDQX9GDQAgAiADSwRAIABBfzYCKEEADwsgACADIAJrNgIoCwJAA0AgACgCCCIFIAAoAhAiBGtBBnQgACgCDEEDdGogACgCFCIDayACTw0BIAAQZg0AC0EADwsgBCAFSQRAIAMEQEJ/IAOtiEIAIANBwABJGyEHIAAoAgAiBiAEQQN0aikDACEIQcAAIANrIgMgAksEQCABIAcgCIMgAyACayIBrYinQQAgAUHAAEkbNgIAIAAgACgCFCACajYCFAwDCyABIAcgCIM+AgBBACEEIABBADYCFCAAIAAoAhBBAWo2AhAgAiADRg0CQcAAIAIgA2siAmshAyACQR9NBEAgASgCACACdCEECyABIAQ2AgBBACEFIAEgA0E/TQR/IAYgACgCEEEDdGopAwAgA62IpwVBAAsgBHI2AgAgACACNgIUQQEPCyAAKAIAIARBA3RqKQMAIQcgAkE/TQRAIAEgB0HAACACa62IPgIAIAAgAjYCFAwCCyABIAc+AgAgACAAKAIQQQFqNgIQQQEPCyAAKAIAIARBA3RqKQMAIQcgAwRAIAEgB0J/IAOtiINBwAAgAiADamutiD4CACAAIAAoAhQgAmo2AhQMAQsgASAHQcAAIAJrrYg+AgAgACAAKAIUIAJqNgIUC0EBC8AoAQt/IwBBEGsiCiQAAkACQAJAAkACQAJAAkACQAJAAkAgAEH0AU0EQEGwoRIoAgAiBEEQIABBC2pB+ANxIABBC0kbIgZBA3YiAHYiAUEDcQRAAkAgAUF/c0EBcSAAaiICQQN0IgFB2KESaiIAIAFB4KESaigCACIBKAIIIgVGBEBBsKESIARBfiACd3E2AgAMAQsgBSAANgIMIAAgBTYCCAsgAUEIaiEAIAEgAkEDdCICQQNyNgIEIAEgAmoiASABKAIEQQFyNgIEDAsLIAZBuKESKAIAIghNDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIBQQN0IgBB2KESaiICIABB4KESaigCACIAKAIIIgVGBEBBsKESIARBfiABd3EiBDYCAAwBCyAFIAI2AgwgAiAFNgIICyAAIAZBA3I2AgQgACAGaiIHIAFBA3QiASAGayIFQQFyNgIEIAAgAWogBTYCACAIBEAgCEF4cUHYoRJqIQFBxKESKAIAIQICfyAEQQEgCEEDdnQiA3FFBEBBsKESIAMgBHI2AgAgAQwBCyABKAIICyEDIAEgAjYCCCADIAI2AgwgAiABNgIMIAIgAzYCCAsgAEEIaiEAQcShEiAHNgIAQbihEiAFNgIADAsLQbShEigCACILRQ0BIAtoQQJ0QeCjEmooAgAiAigCBEF4cSAGayEDIAIhAQNAAkAgASgCECIARQRAIAEoAhQiAEUNAQsgACgCBEF4cSAGayIBIAMgASADSSIBGyEDIAAgAiABGyECIAAhAQwBCwsgAigCGCEJIAIgAigCDCIARwRAIAIoAggiASAANgIMIAAgATYCCAwKCyACKAIUIgEEfyACQRRqBSACKAIQIgFFDQMgAkEQagshBQNAIAUhByABIgBBFGohBSAAKAIUIgENACAAQRBqIQUgACgCECIBDQALIAdBADYCAAwJC0F/IQYgAEG/f0sNACAAQQtqIgFBeHEhBkG0oRIoAgAiB0UNAEEfIQhBACAGayEDIABB9P//B00EQCAGQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQgLAkACQAJAIAhBAnRB4KMSaigCACIBRQRAQQAhAAwBC0EAIQAgBkEZIAhBAXZrQQAgCEEfRxt0IQIDQAJAIAEoAgRBeHEgBmsiBCADTw0AIAEhBSAEIgMNAEEAIQMgASEADAMLIAAgASgCFCIEIAQgASACQR12QQRxaigCECIBRhsgACAEGyEAIAJBAXQhAiABDQALCyAAIAVyRQRAQQAhBUECIAh0IgBBACAAa3IgB3EiAEUNAyAAaEECdEHgoxJqKAIAIQALIABFDQELA0AgACgCBEF4cSAGayICIANJIQEgAiADIAEbIQMgACAFIAEbIQUgACgCECIBBH8gAQUgACgCFAsiAA0ACwsgBUUNACADQbihEigCACAGa08NACAFKAIYIQggBSAFKAIMIgBHBEAgBSgCCCIBIAA2AgwgACABNgIIDAgLIAUoAhQiAQR/IAVBFGoFIAUoAhAiAUUNAyAFQRBqCyECA0AgAiEEIAEiAEEUaiECIAAoAhQiAQ0AIABBEGohAiAAKAIQIgENAAsgBEEANgIADAcLIAZBuKESKAIAIgVNBEBBxKESKAIAIQACQCAFIAZrIgFBEE8EQCAAIAZqIgIgAUEBcjYCBCAAIAVqIAE2AgAgACAGQQNyNgIEDAELIAAgBUEDcjYCBCAAIAVqIgEgASgCBEEBcjYCBEEAIQJBACEBC0G4oRIgATYCAEHEoRIgAjYCACAAQQhqIQAMCQsgBkG8oRIoAgAiAkkEQEG8oRIgAiAGayIBNgIAQcihEkHIoRIoAgAiACAGaiICNgIAIAIgAUEBcjYCBCAAIAZBA3I2AgQgAEEIaiEADAkLQQAhACAGQS9qIgMCf0GIpRIoAgAEQEGQpRIoAgAMAQtBlKUSQn83AgBBjKUSQoCggICAgAQ3AgBBiKUSIApBDGpBcHFB2KrVqgVzNgIAQZylEkEANgIAQeykEkEANgIAQYAgCyIBaiIEQQAgAWsiB3EiASAGTQ0IQeikEigCACIFBEBB4KQSKAIAIgggAWoiCSAITQ0JIAUgCUkNCQsCQEHspBItAABBBHFFBEACQAJAAkACQEHIoRIoAgAiBQRAQfCkEiEAA0AgACgCACIIIAVNBEAgBSAIIAAoAgRqSQ0DCyAAKAIIIgANAAsLQQAQTyICQX9GDQMgASEEQYylEigCACIAQQFrIgUgAnEEQCABIAJrIAIgBWpBACAAa3FqIQQLIAQgBk0NA0HopBIoAgAiAARAQeCkEigCACIFIARqIgcgBU0NBCAAIAdJDQQLIAQQTyIAIAJHDQEMBQsgBCACayAHcSIEEE8iAiAAKAIAIAAoAgRqRg0BIAIhAAsgAEF/Rg0BIAZBMGogBE0EQCAAIQIMBAtBkKUSKAIAIgIgAyAEa2pBACACa3EiAhBPQX9GDQEgAiAEaiEEIAAhAgwDCyACQX9HDQILQeykEkHspBIoAgBBBHI2AgALIAEQTyECQQAQTyEAIAJBf0YNBSAAQX9GDQUgACACTQ0FIAAgAmsiBCAGQShqTQ0FC0HgpBJB4KQSKAIAIARqIgA2AgBB5KQSKAIAIABJBEBB5KQSIAA2AgALAkBByKESKAIAIgMEQEHwpBIhAANAIAIgACgCACIBIAAoAgQiBWpGDQIgACgCCCIADQALDAQLQcChEigCACIAQQAgACACTRtFBEBBwKESIAI2AgALQQAhAEH0pBIgBDYCAEHwpBIgAjYCAEHQoRJBfzYCAEHUoRJBiKUSKAIANgIAQfykEkEANgIAA0AgAEEDdCIBQeChEmogAUHYoRJqIgU2AgAgAUHkoRJqIAU2AgAgAEEBaiIAQSBHDQALQbyhEiAEQShrIgBBeCACa0EHcSIBayIFNgIAQcihEiABIAJqIgE2AgAgASAFQQFyNgIEIAAgAmpBKDYCBEHMoRJBmKUSKAIANgIADAQLIAIgA00NAiABIANLDQIgACgCDEEIcQ0CIAAgBCAFajYCBEHIoRIgA0F4IANrQQdxIgBqIgE2AgBBvKESQbyhEigCACAEaiICIABrIgA2AgAgASAAQQFyNgIEIAIgA2pBKDYCBEHMoRJBmKUSKAIANgIADAMLQQAhAAwGC0EAIQAMBAtBwKESKAIAIAJLBEBBwKESIAI2AgALIAIgBGohBUHwpBIhAAJAA0AgBSAAKAIAIgFHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQMLQfCkEiEAA0ACQCAAKAIAIgEgA00EQCADIAEgACgCBGoiBUkNAQsgACgCCCEADAELC0G8oRIgBEEoayIAQXggAmtBB3EiAWsiBzYCAEHIoRIgASACaiIBNgIAIAEgB0EBcjYCBCAAIAJqQSg2AgRBzKESQZilEigCADYCACADIAVBJyAFa0EHcWpBL2siACAAIANBEGpJGyIBQRs2AgQgAUH4pBIpAgA3AhAgAUHwpBIpAgA3AghB+KQSIAFBCGo2AgBB9KQSIAQ2AgBB8KQSIAI2AgBB/KQSQQA2AgAgAUEYaiEAA0AgAEEHNgIEIABBCGogAEEEaiEAIAVJDQALIAEgA0YNACABIAEoAgRBfnE2AgQgAyABIANrIgJBAXI2AgQgASACNgIAAn8gAkH/AU0EQCACQXhxQdihEmohAAJ/QbChEigCACIBQQEgAkEDdnQiAnFFBEBBsKESIAEgAnI2AgAgAAwBCyAAKAIICyEBIAAgAzYCCCABIAM2AgxBDCECQQgMAQtBHyEAIAJB////B00EQCACQSYgAkEIdmciAGt2QQFxIABBAXRrQT5qIQALIAMgADYCHCADQgA3AhAgAEECdEHgoxJqIQECQAJAQbShEigCACIFQQEgAHQiBHFFBEBBtKESIAQgBXI2AgAgASADNgIADAELIAJBGSAAQQF2a0EAIABBH0cbdCEAIAEoAgAhBQNAIAUiASgCBEF4cSACRg0CIABBHXYhBSAAQQF0IQAgASAFQQRxaiIEKAIQIgUNAAsgBCADNgIQCyADIAE2AhhBCCECIAMiASEAQQwMAQsgASgCCCIAIAM2AgwgASADNgIIIAMgADYCCEEAIQBBGCECQQwLIANqIAE2AgAgAiADaiAANgIAC0G8oRIoAgAiACAGTQ0AQbyhEiAAIAZrIgE2AgBByKESQcihEigCACIAIAZqIgI2AgAgAiABQQFyNgIEIAAgBkEDcjYCBCAAQQhqIQAMBAtBnI4SQTA2AgBBACEADAMLIAAgAjYCACAAIAAoAgQgBGo2AgQgAkF4IAJrQQdxaiIIIAZBA3I2AgQgAUF4IAFrQQdxaiIEIAYgCGoiA2shBwJAQcihEigCACAERgRAQcihEiADNgIAQbyhEkG8oRIoAgAgB2oiADYCACADIABBAXI2AgQMAQtBxKESKAIAIARGBEBBxKESIAM2AgBBuKESQbihEigCACAHaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgAMAQsgBCgCBCIAQQNxQQFGBEAgAEF4cSEJIAQoAgwhAgJAIABB/wFNBEAgBCgCCCIBIAJGBEBBsKESQbChEigCAEF+IABBA3Z3cTYCAAwCCyABIAI2AgwgAiABNgIIDAELIAQoAhghBgJAIAIgBEcEQCAEKAIIIgAgAjYCDCACIAA2AggMAQsCQCAEKAIUIgAEfyAEQRRqBSAEKAIQIgBFDQEgBEEQagshAQNAIAEhBSAAIgJBFGohASAAKAIUIgANACACQRBqIQEgAigCECIADQALIAVBADYCAAwBC0EAIQILIAZFDQACQCAEKAIcIgBBAnRB4KMSaiIBKAIAIARGBEAgASACNgIAIAINAUG0oRJBtKESKAIAQX4gAHdxNgIADAILIAZBEEEUIAYoAhAgBEYbaiACNgIAIAJFDQELIAIgBjYCGCAEKAIQIgAEQCACIAA2AhAgACACNgIYCyAEKAIUIgBFDQAgAiAANgIUIAAgAjYCGAsgByAJaiEHIAQgCWoiBCgCBCEACyAEIABBfnE2AgQgAyAHQQFyNgIEIAMgB2ogBzYCACAHQf8BTQRAIAdBeHFB2KESaiEAAn9BsKESKAIAIgFBASAHQQN2dCICcUUEQEGwoRIgASACcjYCACAADAELIAAoAggLIQEgACADNgIIIAEgAzYCDCADIAA2AgwgAyABNgIIDAELQR8hAiAHQf///wdNBEAgB0EmIAdBCHZnIgBrdkEBcSAAQQF0a0E+aiECCyADIAI2AhwgA0IANwIQIAJBAnRB4KMSaiEAAkACQEG0oRIoAgAiAUEBIAJ0IgVxRQRAQbShEiABIAVyNgIAIAAgAzYCAAwBCyAHQRkgAkEBdmtBACACQR9HG3QhAiAAKAIAIQEDQCABIgAoAgRBeHEgB0YNAiACQR12IQEgAkEBdCECIAAgAUEEcWoiBSgCECIBDQALIAUgAzYCEAsgAyAANgIYIAMgAzYCDCADIAM2AggMAQsgACgCCCIBIAM2AgwgACADNgIIIANBADYCGCADIAA2AgwgAyABNgIICyAIQQhqIQAMAgsCQCAIRQ0AAkAgBSgCHCIBQQJ0QeCjEmoiAigCACAFRgRAIAIgADYCACAADQFBtKESIAdBfiABd3EiBzYCAAwCCyAIQRBBFCAIKAIQIAVGG2ogADYCACAARQ0BCyAAIAg2AhggBSgCECIBBEAgACABNgIQIAEgADYCGAsgBSgCFCIBRQ0AIAAgATYCFCABIAA2AhgLAkAgA0EPTQRAIAUgAyAGaiIAQQNyNgIEIAAgBWoiACAAKAIEQQFyNgIEDAELIAUgBkEDcjYCBCAFIAZqIgQgA0EBcjYCBCADIARqIAM2AgAgA0H/AU0EQCADQXhxQdihEmohAAJ/QbChEigCACIBQQEgA0EDdnQiAnFFBEBBsKESIAEgAnI2AgAgAAwBCyAAKAIICyEBIAAgBDYCCCABIAQ2AgwgBCAANgIMIAQgATYCCAwBC0EfIQAgA0H///8HTQRAIANBJiADQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAAsgBCAANgIcIARCADcCECAAQQJ0QeCjEmohAQJAAkAgB0EBIAB0IgJxRQRAQbShEiACIAdyNgIAIAEgBDYCACAEIAE2AhgMAQsgA0EZIABBAXZrQQAgAEEfRxt0IQAgASgCACEBA0AgASICKAIEQXhxIANGDQIgAEEddiEBIABBAXQhACACIAFBBHFqIgcoAhAiAQ0ACyAHIAQ2AhAgBCACNgIYCyAEIAQ2AgwgBCAENgIIDAELIAIoAggiACAENgIMIAIgBDYCCCAEQQA2AhggBCACNgIMIAQgADYCCAsgBUEIaiEADAELAkAgCUUNAAJAIAIoAhwiAUECdEHgoxJqIgUoAgAgAkYEQCAFIAA2AgAgAA0BQbShEiALQX4gAXdxNgIADAILIAlBEEEUIAkoAhAgAkYbaiAANgIAIABFDQELIAAgCTYCGCACKAIQIgEEQCAAIAE2AhAgASAANgIYCyACKAIUIgFFDQAgACABNgIUIAEgADYCGAsCQCADQQ9NBEAgAiADIAZqIgBBA3I2AgQgACACaiIAIAAoAgRBAXI2AgQMAQsgAiAGQQNyNgIEIAIgBmoiBSADQQFyNgIEIAMgBWogAzYCACAIBEAgCEF4cUHYoRJqIQBBxKESKAIAIQECf0EBIAhBA3Z0IgcgBHFFBEBBsKESIAQgB3I2AgAgAAwBCyAAKAIICyEEIAAgATYCCCAEIAE2AgwgASAANgIMIAEgBDYCCAtBxKESIAU2AgBBuKESIAM2AgALIAJBCGohAAsgCkEQaiQAIAALfQEDfwJAAkAgACIBQQNxRQ0AIAEtAABFBEBBAA8LA0AgAUEBaiIBQQNxRQ0BIAEtAAANAAsMAQsDQCABIgJBBGohAUGAgoQIIAIoAgAiA2sgA3JBgIGChHhxQYCBgoR4Rg0ACwNAIAIiAUEBaiECIAEtAAANAAsLIAEgAGsLrwEBA38gAygCTBogASACbCEFIAMgAygCSCIEQQFrIARyNgJIIAMoAgQiBiADKAIIIgRGBH8gBQUgACAGIAQgBmsiBCAFIAQgBUkbIgQQHhogAyADKAIEIARqNgIEIAAgBGohACAFIARrCyIEBEADQAJAIAMQyQFFBEAgAyAAIAQgAygCIBEAACIGDQELIAUgBGsgAW4PCyAAIAZqIQAgBCAGayIEDQALCyACQQAgARsLggQBA38gAkGABE8EQCAAIAEgAhAGIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAEEDcUUEQCAAIQIMAQsgAkUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQEgAiADSQ0ACwsgA0F8cSEEAkAgA0HAAEkNACACIARBQGoiBUsNAANAIAIgASgCADYCACACIAEoAgQ2AgQgAiABKAIINgIIIAIgASgCDDYCDCACIAEoAhA2AhAgAiABKAIUNgIUIAIgASgCGDYCGCACIAEoAhw2AhwgAiABKAIgNgIgIAIgASgCJDYCJCACIAEoAig2AiggAiABKAIsNgIsIAIgASgCMDYCMCACIAEoAjQ2AjQgAiABKAI4NgI4IAIgASgCPDYCPCABQUBrIQEgAkFAayICIAVNDQALCyACIARPDQEDQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiAESQ0ACwwBCyADQQRJBEAgACECDAELIANBBGsiBCAASQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAiABLQABOgABIAIgAS0AAjoAAiACIAEtAAM6AAMgAUEEaiEBIAJBBGoiAiAETQ0ACwsgAiADSQRAA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0cNAAsLIAAL8gICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBBGsgATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQQhrIAE2AgAgAkEMayABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkEQayABNgIAIAJBFGsgATYCACACQRhrIAE2AgAgAkEcayABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa1CgYCAgBB+IQUgAyAEaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLIAALWgIBfwF+AkACf0EAIABFDQAaIACtIAGtfiIDpyICIAAgAXJBgIAESQ0AGkF/IAIgA0IgiKcbCyICEBsiAEUNACAAQQRrLQAAQQNxRQ0AIABBACACEB8aCyAAC34BAX8jAEFAaiICJAAgAkIANwM4IAJCADcDMCACQgA3AyggAkIANwMIIAJCADcDECACQgA3AxggAkIANwMgIAIgATYCICACIAIpAyA3AwAgACACEDYgACAAKAI0QQFqNgI0IAAoAiwhASAAKAIoIAJBQGskACABQQV0akEgawu7CgIFfw9+IwBB4ABrIgUkACAEQv///////z+DIQwgAiAEhUKAgICAgICAgIB/gyEKIAJC////////P4MiDUIgiCEOIARCMIinQf//AXEhBwJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAdB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiC0KAgICAgIDA//8AVCALQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQoMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhCiADIQEMAgsgASALQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhCkIAIQEM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BEAgASACIAAQkgEaCwt1AQF+IAAgASAEfiACIAN+fCADQiCIIgIgAUIgiCIEfnwgA0L/////D4MiAyABQv////8PgyIBfiIFQiCIIAMgBH58IgNCIIh8IAEgAn4gA0L/////D4N8IgFCIIh8NwMIIAAgBUL/////D4MgAUIghoQ3AwALawEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABIAIgA2siA0GAAiADQYACSSIBGxAfGiABRQRAA0AgACAFQYACECsgA0GAAmsiA0H/AUsNAAsLIAAgBSADECsLIAVBgAJqJAALIAECfyAAEBxBAWoiARAbIgJFBEBBAA8LIAIgACABEB4LUAEBfgJAIANBwABxBEAgASADQUBqrYYhAkIAIQEMAQsgA0UNACACIAOtIgSGIAFBwAAgA2utiIQhAiABIASGIQELIAAgATcDACAAIAI3AwgLyAkCBH8EfiMAQfAAayIGJAAgBEL///////////8AgyEJAkACQCABUCIFIAJC////////////AIMiCkKAgICAgIDA//8AfUKAgICAgIDAgIB/VCAKUBtFBEAgA0IAUiAJQoCAgICAgMD//wB9IgtCgICAgICAwICAf1YgC0KAgICAgIDAgIB/URsNAQsgBSAKQoCAgICAgMD//wBUIApCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhBCABIQMMAgsgA1AgCUKAgICAgIDA//8AVCAJQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQQMAgsgASAKQoCAgICAgMD//wCFhFAEQEKAgICAgIDg//8AIAIgASADhSACIASFQoCAgICAgICAgH+FhFAiBRshBEIAIAEgBRshAwwCCyADIAlCgICAgICAwP//AIWEUA0BIAEgCoRQBEAgAyAJhEIAUg0CIAEgA4MhAyACIASDIQQMAgsgAyAJhEIAUg0AIAEhAyACIQQMAQsgAyABIAEgA1QgCSAKViAJIApRGyIIGyEKIAQgAiAIGyIMQv///////z+DIQkgAiAEIAgbIgtCMIinQf//AXEhByAMQjCIp0H//wFxIgVFBEAgBkHgAGogCiAJIAogCSAJUCIFG3kgBUEGdK18pyIFQQ9rEC8gBikDaCEJIAYpA2AhCkEQIAVrIQULIAEgAyAIGyEDIAtC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fiMAQeAAayIBJABBnH8gACABQQAQXCEAIAEpAxghAiABQeAAaiQAQn8gAiAAGwvPAQEFfyAAKAIAIgJFBEBBAA8LAkAgAi0AACIBRQ0AAkADQCABQf8BcUE/Sw0BQgEgAa2GQoHMgIAQg1ANASAAIAJBAWoiAzYCACACLQABIQEgAyECIAENAAsMAQsgAiEDAkACQANAAkAgAUH/AXFBP0sNAEIBIAGthkKBzICAEINQDQAgAiEBDAILIAAgA0EBaiIENgIAIAMtAAEhASAEIQMgAQ0ACwwBCyADQQA6AAAgACgCAEEBaiEFCyAAIAU2AgAgAg8LIABBADYCAEEAC/MDAgJ+BX8jAEEgayIFJAAgAUL///////8/gyECAn4gAUIwiEL//wGDIgOnIgRBgfgAa0H9D00EQCACQgSGIABCPIiEIQIgBEGA+ABrrSEDAkAgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAAQoCAgICAgICACFINACACQgGDIAJ8IQILQgAgAiACQv////////8HViIEGyEAIAStIAN8DAELAkAgACAChFANACADQv//AVINACACQgSGIABCPIiEQoCAgICAgIAEhCEAQv8PDAELIARB/ocBSwRAQgAhAEL/DwwBC0GA+ABBgfgAIANQIgcbIgggBGsiBkHwAEoEQEIAIQBCAAwBCyAFQRBqIAAgAiACQoCAgICAgMAAhCAHGyICQYABIAZrEC8gBSAAIAIgBhBNIAUpAwhCBIYgBSkDACICQjyIhCEAAkAgBCAIRyAFKQMQIAUpAxiEQgBSca0gAkL//////////w+DhCICQoGAgICAgICACFoEQCAAQgF8IQAMAQsgAkKAgICAgICAgAhSDQAgAEIBgyAAfCEACyAAQoCAgICAgIAIhSAAIABC/////////wdWIgQbIQAgBK0LIQIgBUEgaiQAIAFCgICAgICAgICAf4MgAkI0hoQgAIS/C4gBAQR/IwBBEGsiByQAAkAgAUUEQCADRQ0BA0AgACACIAZBA3RqIAQgBRBDIAZBAWoiBiADRw0ACwwBCyABEBwhCCADRQ0AA0AgByACIAZBA3RqIgkpAgA3AwggB0EIaiABIAgQmwEEQCAAIAkgBCAFEEMLIAZBAWoiBiADRw0ACwsgB0EQaiQAC6kPAgV/D34jAEHQAmsiBSQAIARC////////P4MhCiACQv///////z+DIQsgAiAEhUKAgICAgICAgIB/gyEMIARCMIinQf//AXEhCAJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAhB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiDUKAgICAgIDA//8AVCANQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQwMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhDCADIQEMAgsgASANQoCAgICAgMD//wCFhFAEQCADIAJCgICAgICAwP//AIWEUARAQgAhAUKAgICAgIDg//8AIQwMAwsgDEKAgICAgIDA//8AhCEMQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAQgAhAQwCCyABIA2EUARAQoCAgICAgOD//wAgDCACIAOEUBshDEIAIQEMAgsgAiADhFAEQCAMQoCAgICAgMD//wCEIQxCACEBDAILIA1C////////P1gEQCAFQcACaiABIAsgASALIAtQIgYbeSAGQQZ0rXynIgZBD2sQL0EQIAZrIQYgBSkDyAIhCyAFKQPAAiEBCyACQv///////z9WDQAgBUGwAmogAyAKIAMgCiAKUCIHG3kgB0EGdK18pyIHQQ9rEC8gBiAHakEQayEGIAUpA7gCIQogBSkDsAIhAwsgBUGgAmogCkKAgICAgIDAAIQiEkIPhiADQjGIhCICQgBCgICAgLDmvIL1ACACfSIEQgAQLCAFQZACakIAIAUpA6gCfUIAIARCABAsIAVBgAJqIAUpA5gCQgGGIAUpA5ACQj+IhCIEQgAgAkIAECwgBUHwAWogBEIAQgAgBSkDiAJ9QgAQLCAFQeABaiAFKQP4AUIBhiAFKQPwAUI/iIQiBEIAIAJCABAsIAVB0AFqIARCAEIAIAUpA+gBfUIAECwgBUHAAWogBSkD2AFCAYYgBSkD0AFCP4iEIgRCACACQgAQLCAFQbABaiAEQgBCACAFKQPIAX1CABAsIAVBoAFqIAJCACAFKQO4AUIBhiAFKQOwAUI/iIRCAX0iAkIAECwgBUGQAWogA0IPhkIAIAJCABAsIAVB8ABqIAJCAEIAIAUpA6gBIAUpA6ABIg0gBSkDmAF8IgQgDVStfCAEQgFWrXx9QgAQLCAFQYABakIBIAR9QgAgAkIAECwgBiAJIAhraiEGAn8gBSkDcCITQgGGIg4gBSkDiAEiD0IBhiAFKQOAAUI/iIR8IhBC5+wAfSIUQiCIIgIgC0KAgICAgIDAAIQiFUIBhiIWQiCIIgR+IhEgAUIBhiINQiCIIgogECAUVq0gDiAQVq0gBSkDeEIBhiATQj+IhCAPQj+IfHx8QgF9IhNCIIgiEH58Ig4gEVStIA4gDiATQv////8PgyITIAFCP4giFyALQgGGhEL/////D4MiC358Ig5WrXwgBCAQfnwgBCATfiIRIAsgEH58Ig8gEVStQiCGIA9CIIiEfCAOIA4gD0IghnwiDlatfCAOIA4gFEL/////D4MiFCALfiIRIAIgCn58Ig8gEVStIA8gDyATIA1C/v///w+DIhF+fCIPVq18fCIOVq18IA4gBCAUfiIYIBAgEX58IgQgAiALfnwiCyAKIBN+fCIQQiCIIAsgEFatIAQgGFStIAQgC1atfHxCIIaEfCIEIA5UrXwgBCAPIAIgEX4iAiAKIBR+fCIKQiCIIAIgClatQiCGhHwiAiAPVK0gAiAQQiCGfCACVK18fCICIARUrXwiBEL/////////AFgEQCAWIBeEIRUgBUHQAGogAiAEIAMgEhAsIAFCMYYgBSkDWH0gBSkDUCIBQgBSrX0hCkIAIAF9IQsgBkH+/wBqDAELIAVB4ABqIARCP4YgAkIBiIQiAiAEQgGIIgQgAyASECwgAUIwhiAFKQNofSAFKQNgIg1CAFKtfSEKQgAgDX0hCyABIQ0gBkH//wBqCyIGQf//AU4EQCAMQoCAgICAgMD//wCEIQxCACEBDAELAn4gBkEASgRAIApCAYYgC0I/iIQhASAEQv///////z+DIAatQjCGhCEKIAtCAYYMAQsgBkGPf0wEQEIAIQEMAgsgBUFAayACIARBASAGaxBNIAVBMGogDSAVIAZB8ABqEC8gBUEgaiADIBIgBSkDQCICIAUpA0giChAsIAUpAzggBSkDKEIBhiAFKQMgIgFCP4iEfSAFKQMwIgQgAUIBhiINVK19IQEgBCANfQshBCAFQRBqIAMgEkIDQgAQLCAFIAMgEkIFQgAQLCAKIAIgAiADIAQgAkIBgyIEfCIDVCABIAMgBFStfCIBIBJWIAEgElEbrXwiAlatfCIEIAIgAiAEQoCAgICAgMD//wBUIAMgBSkDEFYgASAFKQMYIgRWIAEgBFEbca18IgJWrXwiBCACIARCgICAgICAwP//AFQgAyAFKQMAViABIAUpAwgiA1YgASADURtxrXwiASACVK18IAyEIQwLIAAgATcDACAAIAw3AwggBUHQAmokAAvAAQIBfwJ+QX8hAwJAIABCAFIgAUL///////////8AgyIEQoCAgICAgMD//wBWIARCgICAgICAwP//AFEbDQAgAkL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFJxDQAgACAEIAWEhFAEQEEADwsgASACg0IAWQRAIAEgAlIgASACU3ENASAAIAEgAoWEQgBSDwsgAEIAUiABIAJVIAEgAlEbDQAgACABIAKFhEIAUiEDCyADC5wLAQZ/IAAgAWohBQJAAkAgACgCBCICQQFxDQAgAkECcUUNASAAKAIAIgIgAWohAQJAAkACQCAAIAJrIgBBxKESKAIARwRAIAAoAgwhAyACQf8BTQRAIAMgACgCCCIERw0CQbChEkGwoRIoAgBBfiACQQN2d3E2AgAMBQsgACgCGCEGIAAgA0cEQCAAKAIIIgIgAzYCDCADIAI2AggMBAsgACgCFCIEBH8gAEEUagUgACgCECIERQ0DIABBEGoLIQIDQCACIQcgBCIDQRRqIQIgAygCFCIEDQAgA0EQaiECIAMoAhAiBA0ACyAHQQA2AgAMAwsgBSgCBCICQQNxQQNHDQNBuKESIAE2AgAgBSACQX5xNgIEIAAgAUEBcjYCBCAFIAE2AgAPCyAEIAM2AgwgAyAENgIIDAILQQAhAwsgBkUNAAJAIAAoAhwiAkECdEHgoxJqIgQoAgAgAEYEQCAEIAM2AgAgAw0BQbShEkG0oRIoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECAARhtqIAM2AgAgA0UNAQsgAyAGNgIYIAAoAhAiAgRAIAMgAjYCECACIAM2AhgLIAAoAhQiAkUNACADIAI2AhQgAiADNgIYCwJAAkACQAJAIAUoAgQiAkECcUUEQEHIoRIoAgAgBUYEQEHIoRIgADYCAEG8oRJBvKESKAIAIAFqIgE2AgAgACABQQFyNgIEIABBxKESKAIA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IAEQlQECQAJAAkACQCABIABBAUEAQQIgCEGQAWoQlgEEQCAIIAEoAgAoAgBBAnRB4JkLaigCADYChAEgCCAANgKAAUHoswIoAgBBvM0BIAhBgAFqEBgMAQsgARB0RQRAIAggASgCACgCAEECdEHgmQtqKAIANgJEIAggADYCQEHoswIoAgBBjM0BIAhBQGsQGAwBCyABIAhBoAFqENIBDQEgCCAANgJQQeizAigCAEGwgAEgCEHQAGoQGAsgCCAIKQOgATcDqAEMAQsgCCAIKQOgATcDqAEgARDOAUUEQCAIIAEoAgAoAgBBAnRB4JkLaigCADYCZCAIIAA2AmBB6LMCKAIAQYzNASAIQeAAahAYDAELIAgoArQBRQ0BIAggADYCcCAIIAgoArgBIgA2AnQgCCAAQQJ0QZCaC2ooAgA2AnhB6LMCKAIAQfLLASAIQfAAahAYCyAEQQE2AgAgARAzDAELQQEhByAEQQE2AgAgARAzIAIQowEaCyAIQcABaiQADAMLIAMoAgghBUEBQQgQICIBRQRAQfIRECMLIAEgAjYCACABIAIoAgg2AgQDQEEAIQMCQCABKAIEIgZFDQAgBigCCCIGRQ0AIAEgBjYCBEEBIQMLIAMNAAtBARA9IgNFBEBBmxoQIwsgAyAFNgIIIAEgAxBGDQEgGyAANgIAIAJB7CQgGxBAIAMQJyABEBYLQQAhBwwBCyABEBYgBEEBNgIACyAbQRBqJAAgBws8ACAAIAFBA3EiAUEBc2otAABBEHQgACABai0AAEEYdHIgACABQQJzai0AAEEIdHIgACABQQNzai0AAHILDwAgACABIAJBAEEAEG0aC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRBgALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC28BBX8gACgCACIDLAAAQTBrIgFBCUsEQEEADwsDQEF/IQQgAkHMmbPmAE0EQEF/IAEgAkEKbCIFaiABIAVB/////wdzSxshBAsgACADQQFqIgU2AgAgAywAASAEIQIgBSEDQTBrIgFBCkkNAAsgAguBEwISfwJ+IwBBQGoiCCQAIAggATYCPCAIQSdqIRYgCEEoaiERAkACQAJAAkADQEEAIQcDQCABIQ0gByAOQf////8Hc0oNAiAHIA5qIQ4CQAJAAkACQCABIgctAAAiCwRAA0ACQAJAIAtB/wFxIgFFBEAgByEBDAELIAFBJUcNASAHIQsDQCALLQABQSVHBEAgCyEBDAILIAdBAWohByALLQACIAtBAmoiASELQSVGDQALCyAHIA1rIgcgDkH/////B3MiF0oNCSAABEAgACANIAcQKwsgBw0HIAggATYCPCABQQFqIQdBfyEQAkAgASwAAUEwayIKQQlLDQAgAS0AAkEkRw0AIAFBA2ohB0EBIRIgCiEQCyAIIAc2AjxBACEMAkAgBywAACILQSBrIgFBH0sEQCAHIQoMAQsgByEKQQEgAXQiAUGJ0QRxRQ0AA0AgCCAHQQFqIgo2AjwgASAMciEMIAcsAAEiC0EgayIBQSBPDQEgCiEHQQEgAXQiAUGJ0QRxDQALCwJAIAtBKkYEQAJ/AkAgCiwAAUEwayIBQQlLDQAgCi0AAkEkRw0AAn8gAEUEQCAEIAFBAnRqQQo2AgBBAAwBCyADIAFBA3RqKAIACyEPIApBA2ohAUEBDAELIBINBiAKQQFqIQEgAEUEQCAIIAE2AjxBACESQQAhDwwDCyACIAIoAgAiB0EEajYCACAHKAIAIQ9BAAshEiAIIAE2AjwgD0EATg0BQQAgD2shDyAMQYDAAHIhDAwBCyAIQTxqELoBIg9BAEgNCiAIKAI8IQELQQAhB0F/IQkCf0EAIAEtAABBLkcNABogAS0AAUEqRgRAAn8CQCABLAACQTBrIgpBCUsNACABLQADQSRHDQAgAUEEaiEBAn8gAEUEQCAEIApBAnRqQQo2AgBBAAwBCyADIApBA3RqKAIACwwBCyASDQYgAUECaiEBQQAgAEUNABogAiACKAIAIgpBBGo2AgAgCigCAAshCSAIIAE2AjwgCUEATgwBCyAIIAFBAWo2AjwgCEE8ahC6ASEJIAgoAjwhAUEBCyETA0AgByEUQRwhCiABIhgsAAAiB0H7AGtBRkkNCyABQQFqIQEgByAUQTpsakG/xQJqLQAAIgdBAWtBCEkNAAsgCCABNgI8AkAgB0EbRwRAIAdFDQwgEEEATgRAIABFBEAgBCAQQQJ0aiAHNgIADAwLIAggAyAQQQN0aikDADcDMAwCCyAARQ0IIAhBMGogByACIAYQuQEMAQsgEEEATg0LQQAhByAARQ0ICyAALQAAQSBxDQsgDEH//3txIgsgDCAMQYDAAHEbIQxBACEQQdmEAiEVIBEhCgJAAkACfwJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkAgGCwAACIHQVNxIAcgB0EPcUEDRhsgByAUGyIHQdgAaw4hBBYWFhYWFhYWEBYJBhAQEBYGFhYWFgIFAxYWChYBFhYEAAsCQCAHQcEAaw4HEBYLFhAQEAALIAdB0wBGDQsMFQsgCCkDMCEaQdmEAgwFC0EAIQcCQAJAAkACQAJAAkACQCAUQf8BcQ4IAAECAwQcBQYcCyAIKAIwIA42AgAMGwsgCCgCMCAONgIADBoLIAgoAjAgDqw3AwAMGQsgCCgCMCAOOwEADBgLIAgoAjAgDjoAAAwXCyAIKAIwIA42AgAMFgsgCCgCMCAOrDcDAAwVC0EIIAkgCUEITRshCSAMQQhyIQxB+AAhBwsgESEBIAdBIHEhCyAIKQMwIhoiGUIAUgRAA0AgAUEBayIBIBmnQQ9xQdDJAmotAAAgC3I6AAAgGUIPViAZQgSIIRkNAAsLIAEhDSAaUA0DIAxBCHFFDQMgB0EEdkHZhAJqIRVBAiEQDAMLIBEhASAIKQMwIhoiGUIAUgRAA0AgAUEBayIBIBmnQQdxQTByOgAAIBlCB1YgGUIDiCEZDQALCyABIQ0gDEEIcUUNAiAJIBEgAWsiAUEBaiABIAlIGyEJDAILIAgpAzAiGkIAUwRAIAhCACAafSIaNwMwQQEhEEHZhAIMAQsgDEGAEHEEQEEBIRBB2oQCDAELQduEAkHZhAIgDEEBcSIQGwshFSAaIBEQUSENCyATIAlBAEhxDREgDEH//3txIAwgExshDAJAIBpCAFINACAJDQAgESENQQAhCQwOCyAJIBpQIBEgDWtqIgEgASAJSBshCQwNCyAILQAwIQcMCwsgCCgCMCIBQfaGAiABGyINQQBB/////wcgCSAJQf////8HTxsiBxBSIgEgDWsgByABGyIBIA1qIQogCUEATgRAIAshDCABIQkMDAsgCyEMIAEhCSAKLQAADQ8MCwsgCCkDMCIZQgBSDQFBACEHDAkLIAkEQCAIKAIwDAILQQAhByAAQSAgD0EAIAwQLQwCCyAIQQA2AgwgCCAZPgIIIAggCEEIaiIHNgIwQX8hCSAHCyELQQAhBwNAAkAgCygCACINRQ0AIAhBBGogDRBrIg1BAEgNDyANIAkgB2tLDQAgC0EEaiELIAcgDWoiByAJSQ0BCwtBPSEKIAdBAEgNDCAAQSAgDyAHIAwQLSAHRQRAQQAhBwwBC0EAIQogCCgCMCELA0AgCygCACINRQ0BIAhBBGoiCSANEGsiDSAKaiIKIAdLDQEgACAJIA0QKyALQQRqIQsgByAKSw0ACwsgAEEgIA8gByAMQYDAAHMQLSAPIAcgByAPSBshBwwICyATIAlBAEhxDQlBPSEKIAAgCCsDMCAPIAkgDCAHIAUREQAiB0EATg0HDAoLIActAAEhCyAHQQFqIQcMAAsACyAADQkgEkUNA0EBIQcDQCAEIAdBAnRqKAIAIgAEQCADIAdBA3RqIAAgAiAGELkBQQEhDiAHQQFqIgdBCkcNAQwLCwsgB0EKTwRAQQEhDgwKCwNAIAQgB0ECdGooAgANAUEBIQ4gB0EBaiIHQQpHDQALDAkLQRwhCgwGCyAIIAc6ACdBASEJIBYhDSALIQwLIAkgCiANayILIAkgC0obIgEgEEH/////B3NKDQNBPSEKIA8gASAQaiIJIAkgD0gbIgcgF0oNBCAAQSAgByAJIAwQLSAAIBUgEBArIABBMCAHIAkgDEGAgARzEC0gAEEwIAEgC0EAEC0gACANIAsQKyAAQSAgByAJIAxBgMAAcxAtIAgoAjwhAQwBCwsLQQAhDgwDC0E9IQoLQZyOEiAKNgIAC0F/IQ4LIAhBQGskACAOC6kzAxV/B34BfCMAQRBrIhUkACMAQaABayIRJAAgESAANgI8IBEgADYCFCARQX82AhggEUEQaiICQgA3A3AgAiACKAIsIAIoAgRrrDcDeCACIAIoAgg2AmgjAEEwayIPJABB8MUCKAIAIRRB5MUCKAIAIRMDQAJ/IAIoAgQiBCACKAJoRwRAIAIgBEEBajYCBCAELQAADAELIAIQKAsiCiIEQSBGIARBCWtBBUlyDQALQQEhBAJAAkAgCkEraw4DAAEAAQtBf0EBIApBLUYbIQQgAigCBCIGIAIoAmhHBEAgAiAGQQFqNgIEIAYtAAAhCgwBCyACECghCgsCQAJAAkAgCkFfcUHJAEYEQANAIAdBB0YNAgJ/IAIoAgQiBiACKAJoRwRAIAIgBkEBajYCBCAGLQAADAELIAIQKAshCiAHQdGEAmogB0EBaiEHLAAAIApBIHJGDQALCyAHQQNHBEAgB0EIRiIGDQEgB0EESQ0CIAYNAQsgAikDcCIXQgBZBEAgAiACKAIEQQFrNgIECyAHQQRJDQAgF0IAUyEGA0AgBkUEQCACIAIoAgRBAWs2AgQLIAdBAWsiB0EDSw0ACwtCACEXIwBBEGsiByQAIASyQwAAgH+UvCIGQf///wNxIQgCfyAGQRd2IgRB/wFxIgIEQCACQf8BRwRAIAitQhmGIRcgBEH/AXFBgP8AagwCCyAIrUIZhiEXQf//AQwBC0EAIAhFDQAaIAcgCK1CACAIZyICQdEAahAvIAcpAwhCgICAgICAwACFIRcgBykDACEYQYn/ACACawshAiAPIBg3AwAgDyACrUIwhiAGQR92rUI/hoQgF4Q3AwggB0EQaiQAIA8pAwghFyAPKQMAIRgMAQsCQAJAAkACQCAHDQBBACEHIApBX3FBzgBHDQADQCAHQQJGDQICfyACKAIEIgYgAigCaEcEQCACIAZBAWo2AgQgBi0AAAwBCyACECgLIQogB0HYhQJqIAdBAWohBywAACAKQSByRg0ACwsgBw4EAgEBAAELAkACfyACKAIEIgQgAigCaEcEQCACIARBAWo2AgQgBC0AAAwBCyACECgLQShGBEBBASEHDAELQoCAgICAgOD//wAhFyACKQNwQgBTDQMgAiACKAIEQQFrNgIEDAMLA0ACfyACKAIEIgQgAigCaEcEQCACIARBAWo2AgQgBC0AAAwBCyACECgLIgZBwQBrIQQCQAJAIAZBMGtBCkkNACAEQRpJDQAgBkHfAEYNACAGQeEAa0EaTw0BCyAHQQFqIQcMAQsLQoCAgICAgOD//wAhFyAGQSlGDQIgAikDcCIaQgBZBEAgAiACKAIEQQFrNgIECyAHRQ0CA0AgGkIAWQRAIAIgAigCBEEBazYCBAsgB0EBayIHDQALDAILIAIpA3BCAFkEQCACIAIoAgRBAWs2AgQLQZyOEkEcNgIAIAJCADcDcCACIAIoAiwgAigCBGusNwN4IAIgAigCCDYCaAwBCwJAIApBMEcNAAJ/IAIoAgQiBiACKAJoRwRAIAIgBkEBajYCBCAGLQAADAELIAIQKAtBX3FB2ABGBEAgBCEGIwBBsANrIgUkAAJ/IAIoAgQiBCACKAJoRwRAIAIgBEEBajYCBCAELQAADAELIAIQKAshBAJAAn8DQCAEQTBHBEACQCAEQS5HDQQgAigCBCIEIAIoAmhGDQAgAiAEQQFqNgIEIAQtAAAMAwsFIAIoAgQiBCACKAJoRwR/QQEhEiACIARBAWo2AgQgBC0AAAVBASESIAIQKAshBAwBCwsgAhAoCyIEQTBHBEBBASEMDAELA0AgGkIBfSEaAn8gAigCBCIEIAIoAmhHBEAgAiAEQQFqNgIEIAQtAAAMAQsgAhAoCyIEQTBGDQALQQEhDEEBIRILQoCAgICAgMD/PyEYA0ACQCAEIQgCQAJAIARBMGsiEEEKSQ0AIARBLkciByAEQSByIghB4QBrQQVLcQ0CIAcNACAMDQJBASEMIBchGgwBCyAIQdcAayAQIARBOUobIQQCQCAXQgdXBEAgBCAJQQR0aiEJDAELIBdCHFgEQCAFQTBqIAQQMSAFQSBqIBwgGEIAQoCAgICAgMD9PxAiIAVBEGogBSkDMCAFKQM4IAUpAyAiHCAFKQMoIhgQIiAFIAUpAxAgBSkDGCAZIBsQMCAFKQMIIRsgBSkDACEZDAELIARFDQAgDQ0AIAVB0ABqIBwgGEIAQoCAgICAgID/PxAiIAVBQGsgBSkDUCAFKQNYIBkgGxAwIAUpA0ghG0EBIQ0gBSkDQCEZCyAXQgF8IRdBASESCyACKAIEIgQgAigCaEcEfyACIARBAWo2AgQgBC0AAAUgAhAoCyEEDAELCwJ+IBJFBEAgAikDcEIAWQRAAkAgAiACKAIEIgRBAWs2AgQgAiAEQQJrNgIEIAxFDQAgAiAEQQNrNgIECwsgBUHgAGpEAAAAAAAAAAAgBremEDsgBSkDYCEZIAUpA2gMAQsgF0IHVwRAIBchGANAIAlBBHQhCSAYQgF8IhhCCFINAAsLAkACQAJAIARBX3FB0ABGBEAgAhC9ASIYQoCAgICAgICAgH9SDQMgAikDcEIAWQ0BDAILQgAhGCACKQNwQgBTDQILIAIgAigCBEEBazYCBAtCACEYCyAJRQRAIAVB8ABqRAAAAAAAAAAAIAa3phA7IAUpA3AhGSAFKQN4DAELIBogFyAMG0IChiAYfEIgfSIXQQAgFGutVQRAQZyOEkHEADYCACAFQaABaiAGEDEgBUGQAWogBSkDoAEgBSkDqAFCf0L///////+///8AECIgBUGAAWogBSkDkAEgBSkDmAFCf0L///////+///8AECIgBSkDgAEhGSAFKQOIAQwBCyAUQeIBa6wgF1cEQCAJQQBOBEADQCAFQaADaiAZIBtCAEKAgICAgIDA/79/EDAgGSAbQoCAgICAgID/PxCzASECIAVBkANqIBkgGyAFKQOgAyAZIAJBAE4iBBsgBSkDqAMgGyAEGxAwIAQgCUEBdCICciEJIBdCAX0hFyAFKQOYAyEbIAUpA5ADIRkgAkEATg0ACwsCfiAXQSAgFGutfCIYpyICQQAgAkEAShsgEyAYIBOtUxsiAkHxAE8EQCAFQYADaiAGEDEgBSkDiAMhGiAFKQOAAyEcQgAMAQsgBUHgAmpBkAEgAmsQkAEQOyAFQdACaiAGEDEgBSkD0AIhHCAFQfACaiAFKQPgAiAFKQPoAiAFKQPYAiIaEMABIAUpA/gCIR0gBSkD8AILIRggBUHAAmogCSAJQQFxRSAZIBtCAEIAEElBAEcgAkEgSXFxIgJyEE4gBUGwAmogHCAaIAUpA8ACIAUpA8gCECIgBUGQAmogBSkDsAIgBSkDuAIgGCAdEDAgBUGgAmogHCAaQgAgGSACG0IAIBsgAhsQIiAFQYACaiAFKQOgAiAFKQOoAiAFKQOQAiAFKQOYAhAwIAVB8AFqIAUpA4ACIAUpA4gCIBggHRCBASAFKQPwASIaIAUpA/gBIhhCAEIAEElFBEBBnI4SQcQANgIACyAFQeABaiAaIBggF6cQvwEgBSkD4AEhGSAFKQPoAQwBC0GcjhJBxAA2AgAgBUHQAWogBhAxIAVBwAFqIAUpA9ABIAUpA9gBQgBCgICAgICAwAAQIiAFQbABaiAFKQPAASAFKQPIAUIAQoCAgICAgMAAECIgBSkDsAEhGSAFKQO4AQshFyAPIBk3AxAgDyAXNwMYIAVBsANqJAAgDykDGCEXIA8pAxAhGAwCCyACKQNwQgBTDQAgAiACKAIEQQFrNgIECyACIQYgBCEQQQAhByMAQZDGAGsiAyQAQQAgFGsiCCATayEWAkACfwNAIApBMEcEQAJAIApBLkcNBCAGKAIEIgIgBigCaEYNACAGIAJBAWo2AgQgAi0AAAwDCwUgBigCBCICIAYoAmhHBH8gBiACQQFqNgIEIAItAAAFIAYQKAshCkEBIQcMAQsLIAYQKAsiCkEwRgRAA0AgF0IBfSEXAn8gBigCBCICIAYoAmhHBEAgBiACQQFqNgIEIAItAAAMAQsgBhAoCyIKQTBGDQALQQEhBwtBASENCyADQQA2ApAGIApBMGshBAJ+AkACQAJAAkACQCAKQS5GIgINACAEQQlNDQAMAQsDQAJAIAJBAXEEQCANRQRAIBghF0EBIQ0MAgsgB0UhAgwECyAYQgF8IRggCUH8D0wEQCAOIBinIApBMEYbIQ4gA0GQBmogCUECdGoiAiALBH8gCiACKAIAQQpsakEwawUgBAs2AgBBASEHQQAgC0EBaiICIAJBCUYiAhshCyACIAlqIQkMAQsgCkEwRg0AIAMgAygCgEZBAXI2AoBGQdyPASEOCwJ/IAYoAgQiAiAGKAJoRwRAIAYgAkEBajYCBCACLQAADAELIAYQKAsiCkEwayEEIApBLkYiAg0AIARBCkkNAAsLIBcgGCANGyEXAkAgB0UNACAKQV9xQcUARw0AAkAgBhC9ASIZQoCAgICAgICAgH9SDQBCACEZIAYpA3BCAFMNACAGIAYoAgRBAWs2AgQLIBcgGXwhFwwDCyAHRSECIApBAEgNAQsgBikDcEIAUw0AIAYgBigCBEEBazYCBAsgAkUNAEGcjhJBHDYCACAGQgA3A3AgBiAGKAIsIAYoAgRrrDcDeCAGIAYoAgg2AmhCACEXQgAMAQsgAygCkAYiAkUEQCADRAAAAAAAAAAAIBC3phA7IAMpAwghFyADKQMADAELAkAgGEIJVQ0AIBcgGFINACATQR5NQQAgAiATdhsNACADQTBqIBAQMSADQSBqIAIQTiADQRBqIAMpAzAgAykDOCADKQMgIAMpAygQIiADKQMYIRcgAykDEAwBCyAIQQF2rSAXUwRAQZyOEkHEADYCACADQeAAaiAQEDEgA0HQAGogAykDYCADKQNoQn9C////////v///ABAiIANBQGsgAykDUCADKQNYQn9C////////v///ABAiIAMpA0ghFyADKQNADAELIBRB4gFrrCAXVQRAQZyOEkHEADYCACADQZABaiAQEDEgA0GAAWogAykDkAEgAykDmAFCAEKAgICAgIDAABAiIANB8ABqIAMpA4ABIAMpA4gBQgBCgICAgICAwAAQIiADKQN4IRcgAykDcAwBCyALBEAgC0EITARAIANBkAZqIAlBAnRqIgIoAgAhCANAIAhBCmwhCCALQQFqIgtBCUcNAAsgAiAINgIACyAJQQFqIQkLIBenIQsCQCAOQQlODQAgF0IRVQ0AIAsgDkgNACAXQglRBEAgA0HAAWogEBAxIANBsAFqIAMoApAGEE4gA0GgAWogAykDwAEgAykDyAEgAykDsAEgAykDuAEQIiADKQOoASEXIAMpA6ABDAILIBdCCFcEQCADQZACaiAQEDEgA0GAAmogAygCkAYQTiADQfABaiADKQOQAiADKQOYAiADKQOAAiADKQOIAhAiIANB4AFqQQAgC2tBAnRB4MUCaigCABAxIANB0AFqIAMpA/ABIAMpA/gBIAMpA+ABIAMpA+gBELIBIAMpA9gBIRcgAykD0AEMAgsgEyALQX1sakEbaiIEQR5MQQAgAygCkAYiAiAEdhsNACADQeACaiAQEDEgA0HQAmogAhBOIANBwAJqIAMpA+ACIAMpA+gCIAMpA9ACIAMpA9gCECIgA0GwAmogC0ECdEGYxQJqKAIAEDEgA0GgAmogAykDwAIgAykDyAIgAykDsAIgAykDuAIQIiADKQOoAiEXIAMpA6ACDAELA0AgA0GQBmogCSICQQFrIglBAnRqKAIARQ0AC0EAIQ4CQCALQQlvIgRFBEBBACEEDAELIARBCWogBCAXQgBTGyEFAkAgAkUEQEEAIQRBACECDAELQYCU69wDQQAgBWtBAnRB4MUCaigCACIMbSESQQAhCkEAIQhBACEEA0AgA0GQBmoiDSAIQQJ0aiIGIAogBigCACIJIAxuIgdqIgY2AgAgBEEBakH/D3EgBCAGRSAEIAhGcSIGGyEEIAtBCWsgCyAGGyELIBIgCSAHIAxsa2whCiAIQQFqIgggAkcNAAsgCkUNACACQQJ0IA1qIAo2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EElBAEwEQCABIAogAyAJEEkEQCABIQQMAgsgBUHwAGogASACQgBCABAiIAUpA3ghAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEHIAYEfiABBSAFQeAAaiABIApCAEKAgICAgIDAu8AAECIgBSkDaCIKQjCIp0H4AGshBiAFKQNgCyEEIAdFBEAgBUHQAGogAyAJQgBCgICAgICAwLvAABAiIAUpA1giCUIwiKdB+ABrIQcgBSkDUCEDCyAJQv///////z+DQoCAgICAgMAAhCELIApC////////P4NCgICAgICAwACEIQogBiAHSgRAA0ACfiAKIAt9IAMgBFatfSIJQgBZBEAgCSAEIAN9IgSEUARAIAVBIGogASACQgBCABAiIAUpAyghAiAFKQMgIQQMBQsgCUIBhiAEQj+IhAwBCyAKQgGGIARCP4iECyEKIARCAYYhBCAGQQFrIgYgB0oNAAsgByEGCwJAIAogC30gAyAEVq19IglCAFMEQCAKIQkMAQsgCSAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAECIgBSkDOCECIAUpAzAhBAwBCyAJQv///////z9YBEADQCAEQj+IIAZBAWshBiAEQgGGIQQgCUIBhoQiCUKAgICAgIDAAFQNAAsLIAhBgIACcSEHIAZBAEwEQCAFQUBrIAQgCUL///////8/gyAGQfgAaiAHcq1CMIaEQgBCgICAgICAwMM/ECIgBSkDSCECIAUpA0AhBAwBCyAJQv///////z+DIAYgB3KtQjCGhCECCyAAIAQ3AwAgACACNwMIIAVBgAFqJAALvwIBAX8jAEHQAGsiBCQAAkAgA0GAgAFOBEAgBEEgaiABIAJCAEKAgICAgICA//8AECIgBCkDKCECIAQpAyAhASADQf//AUkEQCADQf//AGshAwwCCyAEQRBqIAEgAkIAQoCAgICAgID//wAQIkH9/wIgAyADQf3/Ak8bQf7/AWshAyAEKQMYIQIgBCkDECEBDAELIANBgYB/Sg0AIARBQGsgASACQgBCgICAgICAgDkQIiAEKQNIIQIgBCkDQCEBIANB9IB+SwRAIANBjf8AaiEDDAELIARBMGogASACQgBCgICAgICAgDkQIkHogX0gAyADQeiBfU0bQZr+AWohAyAEKQM4IQIgBCkDMCEBCyAEIAEgAkIAIANB//8A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A0AgASACQQJ0aiIGKAIMIgwgDEEfdSIMcyAMayAEIAYoAgAiDCAMQR91IgxzIAxraiAGKAIEIgQgBEEfdSIEcyAEa2ogBigCCCIEIARBH3UiBHMgBGtqaiEEIAJBBGohAiAOQQRqIg4gA0cNAAsLIAdBA3EiBkUNAANAIAQgASACQQJ0aigCACIDIANBH3UiA3MgA2tqIQQgAkEBaiECIApBAWoiCiAGRw0ACwtBASAEIARBAU0brRCpASAFakEgSw0AIAAoAgQiAiALQQJ0aiIEKAJQIQwgAigC6AggB2shCiANKAIUIQ0gBCgCMCAHQQJ0aiEDQQAhBkEAIQQCQCAHQQ1PBEAgCkEATA0BIANBOGshDiADQTxrIQ8gA0FAaiEQIANBxABrIREgA0HIAGshEiADQcwAayETIANB0ABrIRUgA0HUAGshFiADQdgAayEXIANB3ABrIRggA0HgAGshGSADQeQAayEbIANB6ABrIRwgA0HsAGshHSADQfAAayEeIANB9ABrIR8gA0H4AGshICADQfwAayEiIANBgAFrISMgB0ENayEHA0BBACEEQQAhAgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAHDhQTEhEQDw4NDAsKCQgHBgUEAwIBABQLICMgBkECdGooAgAgASgCfGwhAgsgIiAGQQJ0aigCACABKAJ4bCACaiECCyAgIAZBAnRqKAIAIAEoAnRsIAJqIQILIB8gBkECdGooAgAgASgCcGwgAmohAgsgHiAGQQJ0aigCACABKAJsbCACaiECCyAdIAZBAnRqKAIAIAEoAmhsIAJqIQILIBwgBkECdGooAgAgASgCZGwgAmohAgsgGyAGQQJ0aigCACABKAJgbCACaiECCyAZIAZBAnRqKAIAIAEoAlxsIAJqIQILIBggBkECdGooAgAgASgCWGwgAmohAgsgFyAGQQJ0aigCACABKAJUbCACaiECCyAWIAZBAnRqKAIAIAEoAlBsIAJqIQILIBUgBkECdGooAgAgASgCTGwgAmohAgsgEyAGQQJ0aigCACABKAJIbCACaiECCyASIAZBAnRqKAIAIAEoAkRsIAJqIQILIBEgBkECdGooAgAgASgCQGwgAmohAgsgECAGQQJ0aigCACABKAI8bCACaiEECyAPIAZBAnRqKAIAIAEoAjhsIARqIQQLIA4gBkECdGooAgAgASgCNGwgBGohAgsgAiADIAZBAnRqIgRBNGsoAgAgASgCMGxqIARBMGsoAgAgASgCLGxqIARBLGsoAgAgASgCKGxqIARBKGsoAgAgASgCJGxqIARBJGsoAgAgASgCIGxqIARBIGsoAgAgASgCHGxqIARBHGsoAgAgASgCGGxqIARBGGsoAgAgASgCFGxqIARBFGsoAgAgASgCEGxqIARBEGsoAgAgASgCDGxqIARBDGsoAgAgASgCCGxqIARBCGsoAgAgASgCBGxqIARBBGsoAgAgASgCAGxqIQILIAMgBkECdCIEaiAEIAxqKAIAIAIgDXVqNgIAIAZBAWoiBiAKRw0ACwwBCyAHQQlPBEAgB0ELTwRAIAdBDEcEQCAKQQBMDQMgA0EEaygCACECIAEoAgAhBCABKAIEIQcgASgCCCEOIAEoAgwhDyABKAIQIRAgASgCFCERIAEoAhghEiABKAIcIRMgASgCICEVIAEoAiQhFiABKAIoIRcDQCADIAZBAnQiGGoiASAMIBhqKAIAIAFBKGsoAgAgFmwgAUEsaygCACAXbGogAUEkaygCACAVbGogAUEgaygCACATbGogAUEcaygCACASbGogAUEYaygCACARbGogAUEUaygCACAQbGogAUEQaygCACAPbGogAUEMaygCACAObGogAUEIaygCACAHbGogAiAEbGogDXVqIgI2AgAgBkEBaiIGIApHDQALDAMLIApBAEwNAiADQQRrKAIAIQIgASgCACEEIAEoAgQhByABKAIIIQ4gASgCDCEPIAEoAhAhECABKAIUIREgASgCGCESIAEoAhwhEyABKAIgIRUgASgCJCEWIAEoAighFyABKAIsIRgDQCADIAZBAnQiGWoiASAMIBlqKAIAIAFBLGsoAgAgF2wgAUEwaygCACAYbGogAUEoaygCACAWbGogAUEkaygCACAVbGogAUEgaygCACATbGogAUEcaygCACASbGogAUEYaygCACARbGogAUEUaygCACAQbGogAUEQaygCACAPbGogAUEMaygCACAObGogAUEIaygCACAHbGogAiAEbGogDXVqIgI2AgAgBkEBaiIGIApHDQALDAILIAdBCkcEQCAKQQBMDQIgA0EEaygCACECIAEoAgAhBCABKAIEIQcg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ATQCGH58IAZBGGs0AgAgATQCFH58IAZBFGs0AgAgATQCEH58IAZBEGs0AgAgATQCDH58IAZBDGs0AgAgATQCCH58IAZBCGs0AgAgATQCBH58IAZBBGs0AgAgATQCAH58ITALIAIgBEECdCIGaiAGIAxqKAIAIDAgMYenajYCACAEQQFqIgQgA0cNAAsMAQsgB0EJTwRAIAdBC08EQCAHQQxHBEAgA0EATA0DIAJBBGsoAgAhBiAErSEwIAE0AgAhMSABNAIEITIgATQCCCEzIAE0AgwhNCABNAIQITUgATQCFCE2IAE0AhghNyABNAIcITggATQCICE5IAE0AiQhOiABNAIoITtBACEEA0AgAiAEQQJ0IgdqIgEgByAMaigCACABQShrNAIAIDp+IAFBLGs0AgAgO358IAFBJGs0AgAgOX58IAFBIGs0AgAgOH58IAFBHGs0AgAgN358IAFBGGs0AgAgNn58IAFBFGs0AgAgNX58IAFBEGs0AgAgNH58IAFBDGs0AgAgM358IAFBCGs0AgAgMn58IAasIDF+fCAwh6dqIgY2AgAgBEEBaiIEIANHDQALDAMLIANBAEwNAiACQQRrKAIAIQYgBK0hMCABNAIAITEgATQCBCEyIAE0AgghMyABNAIMITQgATQCECE1IAE0AhQhNiABNAIYITcgATQCHCE4IAE0AiAhOSABNAIkITogATQCKCE7IAE0AiwhPEEAIQQDQCACIARBAnQiB2oiASAHIAxqKAIAIAFBLGs0AgAgO34gAUEwazQCACA8fnwgAUEoazQCACA6fnwgAUEkazQCACA5fnwgAUEgazQCACA4fnwgAUEcazQCACA3fnwgAUEYazQCACA2fnwgAUEUazQCACA1fnwgAUEQazQCACA0fnwgAUEMazQCACAzfnwgAUEIazQCACAyfnwgBqwgMX58IDCHp2oiBjYCACAEQQFqIgQgA0cNAAsMAgsgB0EKRwRAIANBAEwNAiACQQRrKAIAIQYgBK0hMCABNAIAITEgATQCBCEyIAE0AgghMyABNAIMITQgATQCECE1IAE0AhQhNiABNAIYITcgATQCHCE4IAE0AiAhOUEAIQQDQCACIARBAnQiB2oiASAHIAxqKAIAIAFBIGs0AgAgOH4gAUEkazQCACA5fnwgAUEcazQCACA3fnwgAUEYazQCACA2fnwgAUEUazQCACA1fnwgAUEQazQCACA0fnwgAUEMazQCACAzfnwgAUEIazQCACAyfnwgBqwgMX58IDCHp2oiBjYCACAEQQFqIgQgA0cNAAsMAgsgA0EATA0BIAJBBGsoAgAhBiAErSEwIAE0AgAhMSABNAIEITIgATQCCCEzIAE0AgwhNCABNAIQITUgATQCFCE2IAE0AhghNyABNAIcITggATQCICE5IAE0AiQhOkEAIQQDQCACIARBAnQiB2oiASAHIAxqKAIAIAFBJGs0AgAgOX4gAUEoazQCACA6fnwgAUEgazQCACA4fnwgAUEcazQCACA3fnwgAUEYazQCACA2fnwgAUEUazQCACA1fnwgAUEQazQCACA0fnwgAUEMazQCACAzfnwgAUEIazQCACAyfnwgBqwgMX58IDCHp2oiBjYCACAEQQFqIgQgA0cNAAsMAQsgB0EFTwRAIAdBB08EQCAHQQhHBEAgA0EATA0DIAJBBGsoAgAhBiAErSEwIAE0AgAhMSABNAIEITIgATQCCCEzIAE0AgwhNCABNAIQITUgATQCFCE2IAE0AhghN0EAIQQDQCACIARBAnQiB2oiASAHIAxqKAIAIAFBGGs0AgAgNn4gAUEcazQCACA3fnwgAUEUazQCACA1fnwgAUEQazQCACA0fnwgAUEMazQCACAzfnwgAUEIazQCACAyfnwgBqwgMX58IDCHp2oiBjYCACAEQQFqIgQgA0cNAAsMAwsgA0EATA0CIAJBBGsoAgAhBiAErSEwIAE0AgAhMSABNAIEITIgATQCCCEzIAE0AgwhNCABNAIQITUgATQCFCE2IAE0AhghNyABNAIcIThBACEEA0AgAiAEQQJ0IgdqIgEgByAMaigCACABQRxrNAIAIDd+IAFBIGs0AgAgOH58IAFBGGs0AgAgNn58IAFBFGs0AgAgNX58IAFBEGs0AgAgNH58IAFBDGs0AgAgM358IAFBCGs0AgAgMn58IAasIDF+fCAwh6dqIgY2AgAgBEEBaiIEIANHDQALDAILIAdBBkcEQCADQQBMDQIgAkEEaygCACEGIAStITAgATQCACExIAE0AgQhMiABNAIIITMgATQCDCE0IAE0AhAhNUEAIQQDQCACIARBAnQiB2oiASAHIAxqKAIAIAFBEGs0AgAgNH4gAUEUazQCACA1fnwgAUEMazQCACAzfnwgAUEIazQCACAyfnwgBqwgMX58IDCHp2oiBjYCACAEQQFqIgQgA0cNAAsMAgsgA0EATA0BIAJBBGsoAgAhBiAErSEwIAE0AgAhMSABNAIEITIgATQCCCEzIAE0AgwhNCABNAIQITUgATQCFCE2QQAhBANAIAIgBEECdCIHaiIBIAcgDGooAgAgAUEUazQCACA1fiABQRhrNAIAIDZ+fCABQRBrNAIAIDR+fCABQQxrNAIAIDN+fCABQQhrNAIAIDJ+fCAGrCAxfnwgMIenaiIGNgIAIARBAWoiBCADRw0ACwwBCyAHQQNPBEAgB0EERwRAIANBAEwNAiACQQRrKAIAIQYgBK0hMCABNAIAITEgATQCBCEyIAE0AgghM0EAIQoDQCACIApBAnQiBGoiASAEIAxqKAIAIAFBCGs0AgAgMn4gAUEMazQCACAzfnwgBqwgMX58IDCHp2oiBjYCACAKQQFqIgogA0cNAAsMAgsgA0EATA0BIAJBBGsoAgAhBiAErSEwIAE0AgAhMSABNAIEITIgATQCCCEzIAE0AgwhNEEAIQQDQCACIARBAnQiB2oiASAHIAxqKAIAIAFBDGs0AgAgM34gAUEQazQCACA0fnwgAUEIazQCACAyfnwgBqwgMX58IDCHp2oiBjYCACAEQQFqIgQgA0cNAAsMAQsgB0ECRwRAIANBAEwNASACQQRrKAIAIQYgBK0hMCABNAIAITFBACEKIANBAUcEQCADQf7///8HcSEEQQAhDgNAIAIgCkECdCIBaiABIAxqKAIAIAasIDF+IDCHp2oiBjYCACACIAFBBHIiAWogASAMaigCACAGrCAxfiAwh6dqIgY2AgAgCkECaiEKIA5BAmoiDiAERw0ACwsgA0EBcUUNASACIApBAnQiAWogASAMaigCACAGrCAxfiAwh6dqNgIADAELIANBAEwNACACQQRrKAIAIQYgBK0hMCABNAIAITEgATQCBCEyQQAhCiADQQFHBEAgA0H+////B3EhBEEAIQ4DQCACIApBAnQiAWoiByABIAxqKAIAIAasIDF+IAdBCGs0AgAgMn58IDCHp2oiBjYCACACIAFBBHIiAWoiByABIAxqKAIAIAasIDF+IAdBCGs0AgAgMn58IDCHp2oiBjYCACAKQQJqIQogDkECaiIOIARHDQALCyADQQFxRQ0AIAIgCkECdCIBaiICIAEgDGooAgAgBqwgMX4gAkEIazQCACAyfnwgMIenajYCAAsMAQsgAkEBNgJ0IAIoAnAgBCAHQQN0IgQQHhogACgCBCICIAtBAnRqKAJQIQYgDSgCFCEDIAIoAnAgBGohBCACKALoCCAHayIKQQBKBEAgBEEIayEMIARBEGshDSAEQRhrIQ4gBEEgayEPIARBKGshECAEQTBrIREgBEE4ayESIARBQGohEyAEQcgAayEVIARB0ABrIRYgBEHYAGshFyAEQeAAayEYIARB6ABrIRkgBEHwAGshGyAEQfgAayEcIARBgAFrIR0gBEGIAWshHiAEQZABayEfIARBmAFrISAgBEGgAWshIiAEQagBayEjIARBsAFrISUgBEG4AWshJiAEQcABayEnIARByAFrISggBEHQAWshKSAEQdgBayEqIARB4AFrISsgBEHoAWshLCAEQfABayEtIARB+AFrIS4gBEGAAmshLyADrSExQQAhAiAHQQFrIQMDQEIAITACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAw4gHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAgCyAvIAJBA3RqKQMAIAE0Anx+ITALIC4gAkEDdGopAwAgATQCeH4gMHwhMAsgLSACQQN0aikDACABNAJ0fiAwfCEwCyAsIAJBA3RqKQMAIAE0AnB+IDB8ITALICsgAkEDdGopAwAgATQCbH4gMHwhMAsgKiACQQN0aikDACABNAJofiAwfCEwCyApIAJBA3RqKQMAIAE0AmR+IDB8ITALICggAkEDdGopAwAgATQCYH4gMHwhMAsgJyACQQN0aikDACABNAJcfiAwfCEwCyAmIAJBA3RqKQMAIAE0Alh+IDB8ITALICUgAkEDdGopAwAgATQCVH4gMHwhMAsgIyACQQN0aikDACABNAJQfiAwfCEwCyAiIAJBA3RqKQMAIAE0Akx+IDB8ITALICAgAkEDdGopAwAgATQCSH4gMHwhMAsgHyACQQN0aikDACABNAJEfiAwfCEwCyAeIAJBA3RqKQMAIAE0AkB+IDB8ITALIB0gAkEDdGopAwAgATQCPH4gMHwhMAsgHCACQQN0aikD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AvAGQZXLACADQfAGahAXIAMgBTYC4AZBkCsgA0HgBmoQFyADIAIoAhQ2AtAGQfTKACADQdAGahAXIAMgBTYCwAZBkCsgA0HABmoQFyADIAIoAhg2ArAGQdrJACADQbAGahAXIAMgBTYCoAZBkCsgA0GgBmoQFyADIAIoAhw2ApAGQbvJACADQZAGahAXIAMgBTYCgAZBkCsgA0GABmoQFyADIAIoAiA2AvAFQYYwIANB8AVqEBcgAyAFNgLgBUGQKyADQeAFahAXIAMgAigCJDYC0AVB7DcgA0HQBWoQFyADIAU2AsAFQZArIANBwAVqEBcgAyACKAIoNgKwBUHlOCADQbAFahAXIAMgBTYCoAVBkCsgA0GgBWoQFyADIAIpAzA3A5AFQe8zIANBkAVqEBcgAyAFNgKABUGQKyADQYAFahAXDAELIAMgAigCEDYC8ARBlcsAIANB8ARqEBcgAyACKAIUNgLgBEH0ygAgA0HgBGoQFyADIAIoAhg2AtAEQdrJACADQdAEahAXIAMgAigCHDYCwARBu8kAIANBwARqEBcgAyACKAIgNgKwBEGGMCADQbAEahAXIAMgAigCJDYCoARB7DcgA0GgBGoQFyADIAIoAig2ApAEQeU4IANBkARqEBcgAyACKQMwNwOABEHvMyADQYAEahAXC0H6LkEAEBcgAyACLQA4NgLwA0GpCiADQfADahAXIAMgAi0AOTYC4ANBqQogA0HgA2oQFyADIAItADo2AtADQakKIANB0ANqEBcgAyACLQA7NgLAA0GpCiADQcADahAXIAMgAi0APDYCsANBqQogA0GwA2oQFyADIAItAD02AqADQakKIANBoANqEBcgAyACLQA+NgKQA0GpCiADQZADahAXIAMgAi0APzYCgANBqQogA0GAA2oQFyADIAItAEA2AvACQakKIANB8AJqEBcgAyACLQBBNgLgAkGpCiADQeACahAXIAMgAi0AQjYC0AJBqQogA0HQAmoQFyADIAItAEM2AsACQakKIANBwAJqEBcgAyACLQBENgKwAkGpCiADQbACahAXIAMgAi0ARTYCoAJBqQogA0GgAmoQFyADIAItAEY2ApACQakKIANBkAJqEBcgAyACLQBHNgKAAkGpCiADQYACahAXEIUBDAcLIAUEQCADIAU2AuAHQZArIANB4AdqEBcLQZ4v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ZXh0cmFjdCByZXNvbHV0aW9uIGFuZCBjb2xvciBpbmZvIGZyb20gZmlsZSwgdXNlciBtdXN0IHNldCBleHBsaWNpdGx5AHVuYWJsZSB0byBndWVzcyBNSU1FIHR5cGUgZnJvbSBmaWxlLCB1c2VyIG11c3Qgc2V0IGV4cGxpY2l0bHkAdW5hYmxlIHRvIGV4dHJhY3QgcmVzb2x1dGlvbiBhbmQgY29sb3IgaW5mbyBmcm9tIFVSTCwgdXNlciBtdXN0IHNldCBleHBsaWNpdGx5ADAxMjM0NTY3ODkuWHN4ACUwMngAMHgAdwB0ZXh0AEZMQUNfX2xlYWQtb3V0AFRSQUNLIG51bWJlciAyNTUgaXMgcmVzZXJ2ZWQgZm9yIHRoZSBsZWFkLW91dABvdXQgb2YgbWVtb3J5IGFsbG9jYXRpbmcgc3BhY2UgZm9yIGZpbGUgbmFtZXMgbGlzdABvdXQgb2YgbWVtb3J5IGFsbG9jYXRpbmcgc3BhY2UgZm9yIG9wdGlvbiBsaXN0AG5vLXV0ZjgtY29udmVydABpbnZhbGlkIHBpY3R1cmUgc3BlY2lmaWNhdGlvbjogY2FuJ3QgcGFyc2UgcmVzb2x1dGlvbi9jb2xvciBwYXJ0AHJlbW92ZS1hbGwtdGFncy1leGNlcHQAYWRkLXNlZWtwb2ludABpbGxlZ2FsIEZMQUNfX2xlYWQtb3V0IG9mZnNldABpbGxlZ2FsIEZMQUNfX2xlYWQtaW4gb2Zmc2V0AEZMQUNfX2xlYWQtb3V0IG9mZnNldCBkb2VzIG5vdCBtYXRjaCBlbmQtb2Ytc3RyZWFtIG9mZnNldABGTEFDX19sZWFkLW91dCBpcyBtaXNzaW5nIG9mZnNldABGTEFDX19sZWFkLWluIGlzIG1pc3Npbmcgb2Zmc2V0AGlsbGVnYWwgSU5ERVggb2Zmc2V0AGFwcGxpY2F0aW9uLWRhdGEtZm9ybWF0AG5vLWN1ZWQtc2Vla3BvaW50cwBDRC1EQSBDQVRBTE9HIG51bWJlciBtdXN0IGJlIDEzIGRlY2ltYWwgZGlnaXRzAGJpbmFyeS1oZWFkZXJsZXNzAHNob3ctYnBzAHNldC1icHMAc2hvdy1jaGFubmVscwBzZXQtY2hhbm5lbHMAb3V0IG9mIG1lbW9yeSBhbGxvY2F0aW5nIHNwYWNlIGZvciB0aXRsZSBnYWlucy9wZWFrcwBzaG93LWFsbC10YWdzAHJlbW92ZS1hbGwtdGFncwBzaG93LXRvdGFsLXNhbXBsZXMAc2V0LXRvdGFsLXNhbXBsZXMAaWxsZWdhbCBDRC1EQSBGTEFDX19sZWFkLWluIG9mZnNldCwgbXVzdCBiZSBldmVuIG11bHRpcGxlIG9mIDU4OCBzYW1wbGVzAG11bHRpcGxlIEZMQUNfX2xlYWQtb3V0IGNvbW1hbmRzAGZvdW5kIG11bHRpcGxlIEZMQUdTIGNvbW1hbmRzAGZvdW5kIG11bHRpcGxlIENBVEFMT0cgY29tbWFuZHMAZm91bmQgbXVsdGlwbGUgSVNSQyBjb21tYW5kcwAlcyVzAG91dCBvZiBtZW1vcnkgYWxsb2NhdGluZyBpdGVyYXRvcgBtZW1vcnkgYWxsb2NhdGlvbiBlcnJvcgByZWFkIGVycm9yAHNwZWNpZmljYXRpb24gY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXIAZmllbGQgbmFtZSBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcgBmaWVsZCBjb250YWlucyBubyAnPScgY2hhcmFjdGVyAG91dCBvZiBtZW1vcnkgYWxsb2NhdGluZyByZWFkIGJ1ZmZlcgBpbml0aWFsaXppbmcgZGVjb2RlcgBibG9jay1udW1iZXIASU5ERVggaXMgbWlzc2luZyBpbmRleCBudW1iZXIASU5ERVggaXMgbWlzc2luZyBhbiBvZmZzZXQgYWZ0ZXIgdGhlIGluZGV4IG51bWJlcgBJTkRFWCBoYXMgaW52YWxpZCBpbmRleCBudW1iZXIAaWxsZWdhbCBGTEFDX19sZWFkLW91dCB0cmFjayBudW1iZXIARkxBQ19fbGVhZC1vdXQgaXMgbWlzc2luZyB0cmFjayBudW1iZXIAVFJBQ0sgaXMgbWlzc2luZyB0cmFjayBudW1iZXIAVFJBQ0sgaXMgbWlzc2luZyBhIHRyYWNrIHR5cGUgYWZ0ZXIgdGhlIHRyYWNrIG51bWJlcgBUUkFDSyBoYXMgaW52YWxpZCB0cmFjayBudW1iZXIAQ0FUQUxPRyBpcyBtaXNzaW5nIGNhdGFsb2cgbnVtYmVyAElTUkMgaXMgbWlzc2luZyBJU1JDIG51bWJlcgBpbnZhbGlkIElTUkMgbnVtYmVyAGhleGR1bXAAaGVscABleHBvcnQtY3Vlc2hlZXQtdG8AZXhwb3J0LXRhZ3MtdG8AZXhwb3J0LXBpY3R1cmUtdG8AaW52YWxpZCBwaWN0dXJlIHNwZWNpZmljYXRpb24AZ2FyYmxlZCBzcGVjaWZpY2F0aW9uAHZlcnNpb24Ab3V0IG9mIG1lbW9yeSBhbGxvY2F0aW5nIGNoYWluAHNjYW4tcmVwbGF5LWdhaW4AcmVtb3ZlLXJlcGxheS1nYWluAGFkZC1yZXBsYXktZ2FpbgBGTEFDX19sZWFkLWluAHNob3ctbWQ1c3VtAHNldC1tZDVzdW0AaW1wb3J0LWN1ZXNoZWV0LWZyb20AaW1wb3J0LXRhZ3MtZnJvbQBpbXBvcnQtcGljdHVyZS1mcm9tAHJlbW92ZS1hbGwASU5ERVggbnVtYmVycyBtdXN0IGJlIHNlcXVlbnRpYWwAQ0QtREEgVFJBQ0sgbnVtYmVycyBtdXN0IGJlIHNlcXVlbnRpYWwAb3V0IG9mIG1lbW9yeSBhbGxvY2F0aW5nIFZPUkJJU19DT01NRU5UIGJsb2NrAG91dCBvZiBtZW1vcnkgYWxsb2NhdGluZyBQQURESU5HIGJsb2NrACVzOiBFUlJPUjogRkxBQyBzdHJlYW0gY2FuIG9ubHkgaGF2ZSBvbmUgaWNvbiAodHlwZT0yKSBQSUNUVVJFIGJsb2NrACVzOiBFUlJPUjogRkxBQyBzdHJlYW0gY2FuIG9ubHkgaGF2ZSBvbmUgMzJ4MzIgc3RhbmRhcmQgaWNvbiAodHlwZT0xKSBQSUNUVVJFIGJsb2NrAG91dCBvZiBtZW1vcnkgYWxsb2NhdGluZyBTRUVLVEFCTEUgYmxvY2sAaW1hZ2UvcG5nAENBVEFMT0cgbnVtYmVyIGlzIHRvbyBsb25nAGxpbmUgdG9vIGxvbmcAb3V0IG9mIG1lbW9yeSBncm93aW5nIHN0cmluZwBzb3J0LXBhZGRpbmcAZG9udC11c2UtcGFkZGluZwBtZXJnZS1wYWRkaW5nAGFkZC1wYWRkaW5nAC5vZ2cAaW1hZ2UvanBlZwBzaG93LXRhZwByZW1vdmUtZmlyc3QtdGFnAHNldC10YWcAc2hvdy12ZW5kb3ItdGFnAHJlbW92ZS10YWcAaW1hZ2UvZ2lmADAxMjM0NTY3ODlBQkNERUZhYmNkZWYAJXM9JTEuOGYAc2hvdy1tYXgtYmxvY2tzaXplAHNldC1tYXgtYmxvY2tzaXplAHNob3ctbWluLWJsb2Nrc2l6ZQBzZXQtbWluLWJsb2Nrc2l6ZQBzaG93LW1heC1mcmFtZXNpemUAc2V0LW1heC1mcmFtZXNpemUAc2hvdy1taW4tZnJhbWVzaXplAHNldC1taW4tZnJhbWVzaXplAHJlbW92ZQBDRC1EQSBUUkFDSyBudW1iZXIgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDk5LCBpbmNsdXNpdmUAQ0QtREEgSU5ERVggbnVtYmVyIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA5OSwgaW5jbHVzaXZlAFRSQUNLIG51bWJlciBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMjU0LCBpbmNsdXNpdmUAdHJ1ZQBvdXQgb2YgbWVtb3J5IGFsbG9jYXRpbmcgdGFnIHZhbHVlAHNob3ctc2FtcGxlLXJhdGUAc2V0LXNhbXBsZS1yYXRlAENELURBIGN1ZXNoZWV0IG9ubHkgYWxsb3dlZCB3aXRoIDQ0LjFrSHogc2FtcGxlIHJhdGUAZmFsc2UAZXhjZXB0LWJsb2NrLXR5cGUAaW52YWxpZCBwaWN0dXJlIHR5cGUAcHJlc2VydmUtbW9kdGltZQBDRC1EQSBJTkRFWCBvZmZzZXRzIG11c3QgaW5jcmVhc2UgaW4gdGltZQBuby1maWxlbmFtZQB3aXRoLWZpbGVuYW1lAHNldC10YWctZnJvbS1maWxlAGVtcHR5IGZpbGUAZGVjb2RpbmcgZmlsZQBlcnJvciBvcGVuaW5nIHBpY3R1cmUgZmlsZQBlcnJvciByZWFkaW5nIHBpY3R1cmUgZmlsZQAlczogRVJST1I6IHdyaXRpbmcgRkxBQyBmaWxlAGZpbGUgaXMgdG9vIGxhcmdlAGFwcGVuZAB0aGVyZSBtdXN0IGJlIGF0IGxlYXN0IG9uZSBUUkFDSyBjb21tYW5kAHdiAHJiACVzOiBFUlJPUjogYWRkaW5nIG5ldyBWT1JCSVNfQ09NTUVOVCBibG9jayB0byBtZXRhZGF0YQAlczogRVJST1I6IGFkZGluZyBuZXcgQ1VFU0hFRVQgYmxvY2sgdG8gbWV0YWRhdGEAJXM6IEVSUk9SOiBhZGRpbmcgbmV3IFBBRERJTkcgYmxvY2sgdG8gbWV0YWRhdGEAJXM6IEVSUk9SOiBhZGRpbmcgbmV3IFBJQ1RVUkUgYmxvY2sgdG8gbWV0YWRhdGEAJXM6IEVSUk9SOiBhZGRpbmcgbmV3IFNFRUtUQUJMRSBibG9jayB0byBtZXRhZGF0YQAlczogRVJST1I6IHJlYWRpbmcgbWV0YWRhdGEALm9nYQBHSUY4OWEAR0lGODdhAFBPU0lYAEZMQUdTIGNvbW1hbmQgbXVzdCBjb21lIGFmdGVyIFRSQUNLIGJ1dCBiZWZvcmUgSU5ERVgASVNSQyBjb21tYW5kIG11c3QgY29tZSBhZnRlciBUUkFDSyBidXQgYmVmb3JlIElOREVYAHByZXZpb3VzIFRSQUNLIG11c3Qgc3BlY2lmeSBhdCBsZWFzdCBvbmUgSU5ERVgATEVBRC1PVVQAVk9SQklTX0NPTU1FTlQAJXMvL1RSQU5TTElUAENIQVJTRVQAQ1VFU0hFRVQAUE9TSVhMWV9DT1JSRUNUAFJFUExBWUdBSU5fUkVGRVJFTkNFX0xPVURORVNTAEZMQUdTAEFVRElPAFNUUkVBTUlORk8AVU5LTk9XTgBBUFBMSUNBVElPTgBSRVBMQVlHQUlOX0FMQlVNX0dBSU4AUkVQTEFZR0FJTl9UUkFDS19HQUlOAFJFTQBMQ19BTEwAZm91bmQgSU5ERVggYmVmb3JlIGFueSBUUkFDSwBSRVBMQVlHQUlOX0FMQlVNX1BFQUsAUkVQTEFZR0FJTl9UUkFDS19QRUFLAFVTLUFTQ0lJAENBVEFMT0cAdHlwZSAxIGljb24gbXVzdCBiZSBhIDMyeDMyIHBpeGVsIFBORwBQQURESU5HAExBTkcAUElDVFVSRQBQUkUAU0VFS1RBQkxFAElOVkFMSUQAVU5ERUZJTkVEAElTUkMAIiVzIiBGTEFDACVzPSUrMi4yZiBkQgAlcz0lMi4xZiBkQgBEQVRBAD8ALS0+ACVsbHU7ACAgZGF0YSBjb250ZW50czoAJXM6ACAgZGF0YToAQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5AHV0ZjgAQy5VVEYtOABwcmV2aW91cyBUUkFDSyBtdXN0IHNwZWNpZnkgYXQgbGVhc3Qgb25lIElOREVYIDAxAGZpcnN0IElOREVYIG51bWJlciBvZiBhIFRSQUNLIG11c3QgYmUgMCBvciAxADEyMzQ1Njc4OTAAZmlyc3QgSU5ERVggb2YgZmlyc3QgVFJBQ0sgbXVzdCBoYXZlIGFuIG9mZnNldCBvZiAwMDowMDowMABUUkFDSyBudW1iZXIgbXVzdCBiZSBncmVhdGVyIHRoYW4gMAAwMTIzNDU2Nzg5LgAtACAodW5pbmRleGVkKQBpbGxlZ2FsIElOREVYIG9mZnNldCAobm90IG9mIHRoZSBmb3JtIE1NOlNTOkZGKQBpbGxlZ2FsIElOREVYIG9mZnNldCAoTU06U1M6RkYgZm9ybSBub3QgYWxsb3dlZCBpZiBzYW1wbGUgcmF0ZSBpcyBub3QgYSBtdWx0aXBsZSBvZiA3NSkAb3V0IG9mIG1lbW9yeSBkdXJpbmcgc3RyZHVwKCkAICAgIElOREVYICUwMnUgACAgdmVuZG9yIHN0cmluZzogACAgTUQ1IHNpZ25hdHVyZTogACAgICBjb21tZW50WyV1XTogACAgYXBwbGljYXRpb24gSUQ6IAAgICAgACAgICAgICAgICAgICAgICAgICAgICBTUEVDSUZJQ0FUSU9OIGlzIGEgc3RyaW5nIHdob3NlIHBhcnRzIGFyZSBzZXBhcmF0ZWQgYnkgfAoAICBzYW1wbGVfcmF0ZTogJXUgSHoKACVzOiBFUlJPUjogc2FtcGxlIHJhdGUgb2YgJXUgSHogZG9lcyBub3QgbWF0Y2ggcHJldmlvdXMgZmlsZXMnICV1IEh6CgAgICAgICAgICAgICAgICAgICAgICAgLS1zZXQtdGFnLWZyb20tZmlsZT0iQ1VFU0hFRVQ9aW1hZ2UuY3VlIikuICBEbyBub3QgdHJ5CgAlczogRVJST1I6IGFsbG9jYXRpbmcgbWVtb3J5CgAgICAgICAgICAgICAgICAgICAgICAgc3BlYywgb2YgdGhlIGZvcm0gIk5BTUU9VkFMVUUiLiAgSWYgdGhlcmUgaXMgY3VycmVudGx5CgAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBiZSBvZiB0aGUgZm9ybSBOQU1FPVZBTFVFLiAgU3BlY2lmeQoAICAgICAgICAgICAgICAgICAgICAgIGFsbCBzdWNoIHZhbHVlcy4gIEV4YW1wbGU6IC0tYWRkLXNlZWtwb2ludD0xMDB4CgBSRU0gRkxBQ19fbGVhZC1vdXQgJXUgJWxsdQoAUkVNIEZMQUNfX2xlYWQtaW4gJWxsdQoAICAgICAgICAgIG9mZnNldDogJWxsdQoAICB0b3RhbCBzYW1wbGVzOiAlbGx1CgAgIGxlYWQtaW46ICVsbHUKACUwMnU6JTAydTolMDJ1CgBFUlJPUiAoLS0lcyk6IGlsbGVnYWwgbGVuZ3RoICIlcyIsIGxlbmd0aCBtdXN0IGJlID49IDAgYW5kIDwgMl4ldQoAICAgIHBvaW50ICV1OiBzYW1wbGVfbnVtYmVyPSVsbHUsIHN0cmVhbV9vZmZzZXQ9JWxsdSwgZnJhbWVfc2FtcGxlcz0ldQoARVJST1I6IGNvdWxkbid0IHBhcnNlIHN1cHBsaWVkIG1ldGFkYXRhIGJsb2NrICMldQoATUVUQURBVEEgYmxvY2sgIyV1CgAlczogRVJST1I6IHJlc29sdXRpb24gKCV1KSBpcyBub3Qgc3VwcG9ydGVkLCBtdXN0IGJlIGJldHdlZW4gJXUgYW5kICV1CgBFUlJPUiAoLS0lcyk6IHZhbHVlIG11c3QgYmUgPj0gJXUgYW5kIDw9ICV1CgBFUlJPUiAoLS0lcyk6IHZhbHVlIG11c3QgYmUgPiAwIGFuZCA8PSAldQoAICBoZWlnaHQ6ICV1CgAgICAgICBudW1iZXIgb2YgaW5kZXggcG9pbnRzOiAldQoAICBzZWVrIHBvaW50czogJXUKACAgY29tbWVudHM6ICV1CgAgIGNoYW5uZWxzOiAldQoAICBudW1iZXIgb2YgdHJhY2tzOiAldQoAICAgICAgICAgIG51bWJlcjogJXUKACAgZGVwdGg6ICV1CgAgIGRhdGEgbGVuZ3RoOiAldQoAICBsZW5ndGg6ICV1CgAgIHdpZHRoOiAldQoAICBiaXRzLXBlci1zYW1wbGU6ICV1CgAgICAgLS1kYXRhLWZvcm1hdD1iaW5hcnl8YmluYXJ5LWhlYWRlcmxlc3N8dGV4dAoAICAgIC0tYXBwbGljYXRpb24tZGF0YS1mb3JtYXQ9aGV4ZHVtcHx0ZXh0CgBFUlJPUjogdW5hYmxlIHRvIGZpbmQgYSBtZXRhZGF0YSBibG9jayBpbiB0aGUgc3VwcGxpZWQgaW5wdXQKACAgICBBbiBvcHRpb25hbCBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBibG9jayBudW1iZXJzIHRvIGRpc3BsYXkuICBUaGUgZmlyc3QKACAgICAgICAgICAgICAgNzogTGVhZCBhcnRpc3QvbGVhZCBwZXJmb3JtZXIvc29sb2lzdAoALS1saXN0CgAgICAgICAgIyAgOiBhIHNwZWNpZmljIHNhbXBsZSBudW1iZXIgZm9yIGEgc2VlayBwb2ludAoAJXM6IG9wdGlvbiBgJWMlcycgZG9lc24ndCBhbGxvdyBhbiBhcmd1bWVudAoAJXM6IG9wdGlvbiBgLS0lcycgZG9lc24ndCBhbGxvdyBhbiBhcmd1bWVudAoAJXM6IG9wdGlvbiBgLVcgJXMnIGRvZXNuJ3QgYWxsb3cgYW4gYXJndW1lbnQKACVzOiBvcHRpb24gYCVzJyByZXF1aXJlcyBhbiBhcmd1bWVudAoALS1zZXQtdGFnPUZJRUxEICAgICAgIEFkZCBhIHRhZy4gIFRoZSBGSUVMRCBtdXN0IGNvbXBseSB3aXRoIHRoZSBWb3JiaXMgY29tbWVudAoAJXM6IEVSUk9SOiBGTEFDIGZpbGUgbXVzdCBoYXZlIHRvdGFsX3NhbXBsZXMgc2V0IGluIFNUUkVBTUlORk8gaW4gb3JkZXIgdG8gaW1wb3J0L2V4cG9ydCBjdWVzaGVldAoAICAgICAgICAgICAgICAgICAgICAgIHByZWNlZGVkIGJ5IGEgLS1ibG9jay1udW1iZXI9IyBvcHRpb24gdG8gc3BlY2lmeSB0aGUgZXhhY3QKACAgICAgICAgICAgICAgICAgICAgICBTaW5jZSB0aGlzIG9wZXJhdGlvbiByZXF1aXJlcyB0d28gcGFzc2VzLCBpdCBpcyBhbHdheXMKACVzOiBvcHRpb24gYCVzJyBpcyBhbWJpZ3VvdXMKACVzOiBvcHRpb24gYC1XICVzJyBpcyBhbWJpZ3VvdXMKACVzOiBFUlJPUiAoaW50ZXJuYWwpIHByZXBhcmluZyBzZWVrdGFibGUgd2l0aCBzZWVrcG9pbnRzCgAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIGJlIG9mIHRoZSBmb3JtIE5BTUU9VkFMVUUuICBNdWx0aS1saW5lIGNvbW1lbnRzCgAtLXByZXNlcnZlLW1vZHRpbWUgICAgUHJlc2VydmUgdGhlIG9yaWdpbmFsIG1vZGlmaWNhdGlvbiB0aW1lIGluIHNwaXRlIG9mIGVkaXRzCgAgICAgUmVtb3ZlIG9uZSBvciBtb3JlIG1ldGFkYXRhIGJsb2NrcyBmcm9tIHRoZSBtZXRhZGF0YS4gIFVubGVzcwoAICAgICAgICAgICAgIGFuZCBjb2xvciBkZXB0aCBpbiBiaXRzLXBlci1waXhlbC4gIElmIHRoZSBpbWFnZSBoYXMgaW5kZXhlZCBjb2xvcnMKACVzOiBFUlJPUjogcmVzb2x1dGlvbiBvZiAldSBicHMgZG9lcyBub3QgbWF0Y2ggcHJldmlvdXMgZmlsZXMnICV1IGJwcwoAICAgIGFsbCBtZXRhZGF0YSBibG9ja3MgYXJlIGxpc3RlZCBpbiB0ZXh0IGZvcm1hdC4gIFVzZSB0aGUgZm9sbG93aW5nIG9wdGlvbnMKAEVSUk9SOiB5b3UgbWF5IG5vdCBtaXggc2hvcnRoYW5kIGFuZCBtYWpvciBvcGVyYXRpb25zCgAgICAgVk9SQklTX0NPTU1FTlQuICBZb3UgbWF5IG5hcnJvdyBkb3duIHRoZSB0eXBlcyBvZiBBUFBMSUNBVElPTiBibG9ja3MKACAgICBleHBvcnRlZCB3aXRoIC0tbGlzdCAtLWRhdGEtZm9ybWF0PWJpbmFyeS4gVGhlIGluc2VydGlvbiBwb2ludCBpcwoAICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhIGJsb2NrIHRvIGV4dHJhY3QuICBOb3RlIHRoYXQgdGhlIGJsb2NrIG51bWJlciBpcwoAICAgICAgICAgICAgICAgICAgICAgIGJsb2NrIHdpbGwgYmUgZXhwb3J0ZWQgdW5sZXNzIC0tZXhwb3J0LXBpY3R1cmUtdG8gaXMKACAgICAgICAgICAgICBtZWFuIHRoYXQgRklMRSBpcyBhY3R1YWxseSBhIFVSTCB0byBhbiBpbWFnZSwgdGhvdWdoIHRoaXMgdXNlIGlzCgAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZGlhbiByZXByZXNlbnRhdGlvbiBvZiB0aGUgNC1ieXRlIElEIGlzCgAgICAgICAgICAgICAgICAgICAgICAgYXJlIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkLiAgU3BlY2lmeSAtLXJlbW92ZS1hbGwtdGFncwoAICAgICAgICAgICAgICAgICAgICAgIHRoZW4gc3RvcmVzIHRoZW0gaW4gdGhlIFZPUkJJU19DT01NRU5UIGJsb2NrLiAgVGhlIHRhZ3MKACAgbWF4aW11bSBmcmFtZXNpemU6ICV1IGJ5dGVzCgAgIG1pbmltdW0gZnJhbWVzaXplOiAldSBieXRlcwoAJXM6IEVSUk9SOiB0b28gbWFueSBmaWVsZCBuYW1lcwoAJXM6IEVSUk9SOiBjYW5ub3QgYWRkIHNlZWtwb2ludHMgYmVjYXVzZSBTVFJFQU1JTkZPIGJsb2NrIGRvZXMgbm90IHNwZWNpZnkgdG90YWxfc2FtcGxlcwoAICBtYXhpbXVtIGJsb2Nrc2l6ZTogJXUgc2FtcGxlcwoAICBtaW5pbXVtIGJsb2Nrc2l6ZTogJXUgc2FtcGxlcwoALS1zY2FuLXJlcGxheS1nYWluICAgIExpa2UgLS1hZGQtcmVwbGF5LWdhaW4sIGJ1dCBvbmx5IGFuYWx5emVzIHRoZSBmaWxlcwoAICAgIEluc2VydCBhIG1ldGFkYXRhIGJsb2NrIGZyb20gYSBmaWxlLiBUaGlzIG11c3QgYmUgYSBiaW5hcnkgYmxvY2sgYXMKACVzOiBFUlJPUjogZmlsZSAnJXMnIGZvciAnJXMnIHRhZyB2YWx1ZSBoYXMgZW1iZWRkZWQgTlVMcwoAICBjb2xvcnM6ICV1JXMKACAgVFJBQ0sgJTAydSAlcwoAbWV0YWZsYWMgLSBDb21tYW5kLWxpbmUgRkxBQyBtZXRhZGF0YSBlZGl0b3IgdmVyc2lvbiAlcwoAbWV0YWZsYWMgJXMKAENBVEFMT0cgJXMKAEZJTEUgJXMKACAgICBJU1JDICVzCgAlczogRVJST1I6IHdoaWxlIHBhcnNpbmcgY3Vlc2hlZXQgIiVzIiBvbiBsaW5lICV1OiAlcwoAICBpcyBsYXN0OiAlcwoAJXM6IFdBUk5JTkcgY3Vlc2hlZXQgIiVzIiBpcyBub3QgYXVkaW8gQ0QgY29tcGxpYW50OiAlcwoAICAgICAgcHJlLWVtcGhhc2lzOiAlcwoAJXM6IEVSUk9SOiBjYW4ndCBvcGVuIGV4cG9ydCBmaWxlICVzOiAlcwoAJXM6IEVSUk9SOiBjYW4ndCBvcGVuIGltcG9ydCBmaWxlICVzOiAlcwoAICBtZWRpYSBjYXRhbG9nIG51bWJlcjogJXMKACAgZGVzY3JpcHRpb246ICVzCgAlczogRVJST1I6IG5ldyBQSUNUVVJFIGJsb2NrIGZvciAiJXMiIGlzIGlsbGVnYWw6ICVzCgAlczogRVJST1I6IHdoaWxlIHJlYWRpbmcgZmlsZSAnJXMnIGZvciAnJXMnIHRhZyB2YWx1ZTogJXMKACAgTUlNRSB0eXBlOiAlcwoAICAgICAgdHlwZTogJXMKAEVSUk9SOiAlcwoAICBpcyBDRDogJXMKACAgICAgIElTUkM6ICVzCgAlczogRVJST1IgcGFyc2luZyBjdWVzaGVldCAiJXMiOiAlcwoAJXM6IEVSUk9SOiB3aGlsZSBwYXJzaW5nIHBpY3R1cmUgc3BlY2lmaWNhdGlvbiAiJXMiOiAlcwoARVJST1IgKC0tJXMpOiBtYWxmb3JtZWQgc2Vla3BvaW50IHNwZWNpZmljYXRpb24gIiVzIiwKICAgICAgICVzCgBFUlJPUiAoLS0lcyk6IG1hbGZvcm1lZCB2b3JiaXMgY29tbWVudCBmaWVsZCBuYW1lICIlcyIsCiAgICAgICAlcwoAJXM6IEVSUk9SOiBtYWxmb3JtZWQgdm9yYmlzIGNvbW1lbnQgZmllbGQgIiVzIiwKICAgICAgICVzCgBFUlJPUiAoLS0lcyk6IG1hbGZvcm1lZCB2b3JiaXMgY29tbWVudCBmaWVsZCAiJXMiLAogICAgICAgJXMKACAgICBJZiB0aGUgYXBwbGljYXRpb24gYmxvY2sgeW91IGFyZSBkaXNwbGF5aW5nIGNvbnRhaW5zIGJpbmFyeSBkYXRhIGJ1dCB5b3VyCgAgICAgICAgICAgICAgIDk6IENvbmR1Y3RvcgoAaW50ZXJuYWwgZXJyb3IKACAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IHZhbHVlcy4gIEZJTEVOQU1FIGlzIGp1c3Qgc2hvcnRoYW5kIGZvcgoALS1yZW1vdmUtYWxsLXRhZ3MtZXhjZXB0PU5BTUUxWz1OQU1FMls9Li4uXV0gUmVtb3ZlIGFsbCB0YWdzLCBleGNlcHQgdGhlIHZlbmRvcgoAVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vcgoAICAgICAgICAgICAgICAgICAgICAgIFBJQ1RVUkUgYmxvY2suICBFaXRoZXIgYSBmaWxlbmFtZSBmb3IgdGhlIHBpY3R1cmUgZmlsZSBvcgoAICAgICAgICAgICAgIDEyOiBMeXJpY2lzdC90ZXh0IHdyaXRlcgoAICAgICAgICAgICAgIDExOiBDb21wb3NlcgoAICAgICAgICAgICAgICA4OiBBcnRpc3QvcGVyZm9ybWVyCgAgICAgb2YgYSBibG9jayBiZWZvcmUgdGhlIGZpcnN0IFNUUkVBTUlORk8gYmxvY2suICBZb3UgbWF5IG5vdCAtLWFwcGVuZCBhbm90aGVyCgAgICAgYmVmb3JlIHRoZSBmaXJzdCBTVFJFQU1JTkZPIGJsb2NrLiAgWW91IG1heSBub3QgLS1hcHBlbmQgYW5vdGhlcgoAICAgICAgICAgICAgICAwOiBPdGhlcgoARVJST1IgKC0tJXMpOiB2YWx1ZSBtdXN0IGJlIGEgJXUtYml0IHVuc2lnbmVkIGludGVnZXIKACAgICAgICAgICAgICAgICAgICAgICB0YWJsZSwgYW5kIGFueSBkdXBsaWNhdGVzIHdpbGwgYmUgdHVybmVkIGludG8gcGxhY2Vob2xkZXIKACAgICAgICAjcyA6IGEgc2Vla3BvaW50IGV2ZXJ5ICMgc2Vjb25kczsgIyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgd2hvbGUgbnVtYmVyCgAgICAgICAgICAgICAgICAgICAgICAgbXVzdCBoYXZlIHRoZSBzYW1lIHJlc29sdXRpb24sIHNhbXBsZSByYXRlLCBhbmQgbnVtYmVyCgAgICAgY29udGVudHMgaW5zdGVhZCB1c2luZyAtLWFwcGxpY2F0aW9uLWRhdGEtZm9ybWF0PWhleGR1bXAKACAgICBUaGUgb3V0cHV0IGNhbiBiZSByZWFkIGluIHVzaW5nIGEgc3Vic2VxdWVudCBjYWxsIHRvCgAgICAgICAgICAgICAgdHlwZSBpbWFnZS9qcGVnIG9yIGltYWdlL3BuZy4gIFRoZSBNSU1FIHR5cGUgY2FuIGFsc28gYmUgLS0+IHRvCgAlczogRVJST1I6IGNhbm5vdCBwYXJzZSBjdWVzaGVldCB3aGVuIHNhbXBsZSByYXRlIGlzIHVua25vd24KAENvcHlyaWdodCAoQykgMjAwMS0yMDA5ICBKb3NoIENvYWxzb24KACAgICBiZSBhZGRlZCBhZnRlciB0aGUgZ2l2ZW4gYmxvY2sgbnVtYmVyLiAgVGhpcyBwcmV2ZW50cyB0aGUgaWxsZWdhbCBpbnNlcnRpb24KACAgICAgICAgICAgICAxODogSWxsdXN0cmF0aW9uCgBDb3B5cmlnaHQgKEMpIDIwMTEtMjAyMyAgWGlwaC5PcmcgRm91bmRhdGlvbgoAICAgICAgICAgICAgIDEzOiBSZWNvcmRpbmcgTG9jYXRpb24KAEVSUk9SICgtLSVzKTogbWlzc2luZyBzcGVjaWZpY2F0aW9uCgAlczogRVJST1I6IGVtcHR5IHBpY3R1cmUgc3BlY2lmaWNhdGlvbgoALS12ZXJzaW9uCgAgICAgICAgICAgICAgIDI6IE90aGVyIGZpbGUgaWNvbgoARVJST1I6IGNvdWxkbid0IHJlYWQgbWV0YWRhdGEgYmxvY2sgIyV1IGZyb20gc3RkaW4KACVzOiBFUlJPUjogY291bGRuJ3QgZ2V0IGJsb2NrIGZyb20gY2hhaW4KAC0tYWRkLXJlcGxheS1nYWluICAgICBDYWxjdWxhdGVzIHRoZSB0aXRsZSBhbmQgYWxidW0gZ2FpbnMvcGVha3Mgb2YgdGhlIGdpdmVuCgAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZWQgbGFzdCwgYWZ0ZXIgYWxsIG90aGVyIG9wZXJhdGlvbnMgaGF2ZSBiZWVuCgAgICAgICAgICAgICAgdGhlIE1JTUUtVFlQRSBpcyBpbWFnZS9qcGVnLCBpbWFnZS9wbmcsIG9yIGltYWdlL2dpZiwgeW91IGNhbgoAICAgICAgICAgICAgICAgICAgICAgIGJlIGNvbnZlcnRlZCB0byBVVEYtOCBmcm9tIHRoZSBsb2NhbCBjaGFyc2V0LiAgVGhpcyBjYW4KAEVSUk9SICgtLSVzKTogYmFkIE1ENSBzdW0KACVzOiBFUlJPUjogY291bGRuJ3QgZ2V0IGJsb2NrIGluIHJhdyBmb3JtCgAgICAgICAgICAgICAgICAgICAgICAgVW5sZXNzIC0tbm8tdXRmOC1jb252ZXJ0IGlzIHNwZWNpZmllZCwgdGhlIGNvbnRlbnRzIHdpbGwKACAgICBTcGVjaWZ5IHRoZSBpbnNlcnRpb24gcG9pbnQgKGRlZmF1bHRzIHRvIGxhc3QgYmxvY2spLiAgVGhlIG5ldyBibG9jayB3aWxsCgAtLXJlbW92ZS1hbGwKACAgICBnaXZlbiBibG9jayBudW1iZXIuICBUaGlzIHByZXZlbnRzIHRoZSBpbGxlZ2FsIGluc2VydGlvbiBvZiBhIGJsb2NrCgAlczogRVJST1I6IEZMQUMgZmlsZSBhbHJlYWR5IGhhcyBDVUVTSEVFVCBibG9jawoAJXM6IEVSUk9SOiBGTEFDIGZpbGUgaGFzIG5vIENVRVNIRUVUIGJsb2NrCgAlczogRVJST1I6IGNhbid0IG9wZW4gZmlsZSBvciBnZXQgU1RSRUFNSU5GTyBibG9jawoAJXM6IEVSUk9SOiBGTEFDIHN0cmVhbSBoYXMgbm8gU1RSRUFNSU5GTyBibG9jawoAV0FSTklORzogdW5kb2N1bWVudGVkIG9wdGlvbiAtLSVzIHNob3VsZCBiZSB1c2VkIHdpdGggY2F1dGlvbiwKICAgICAgICAgb25seSBmb3IgcmVwYWlyaW5nIGEgZGFtYWdlZCBTVFJFQU1JTkZPIGJsb2NrCgAlczogRVJST1I6IEZMQUMgZmlsZSBoYXMgbm8gUElDVFVSRSBibG9jawoALS1hZGQtc2Vla3BvaW50PXsjfFh8I3h8I3N9ICBBZGQgc2VlayBwb2ludHMgdG8gYSBTRUVLVEFCTEUgYmxvY2sKACAgICBtZXRhZmxhYyAtLWxpc3QgLS1kYXRhLWZvcm1hdD1iaW5hcnkgLS1ibG9jay1udW1iZXI9NiBmaWxlLmZsYWMgPiBibG9jawoAICAgIG1ldGFmbGFjIC0tYXBwZW5kIGFub3RoZXJmaWxlLmZsYWMgPCBibG9jawoAICAgIHRvIGV4cG9ydCB0aGUgYmxvY2ssIGFuZCB0aGVuIGltcG9ydCBpdCB3aXRoCgAgICAgICAgICAgICAgMTc6IEEgYnJpZ2h0IGNvbG91cmVkIGZpc2gKACAgICBZb3UgbWF5IHNwZWNpZnkgLS1kYXRhLWZvcm1hdD1iaW5hcnkgdG8gZHVtcCB0aGUgcmF3IGJpbmFyeSBmb3JtIG9mIGVhY2gKACAgICAgICAgICAgICBUaGUgZGVmYXVsdCBpcyAzIChmcm9udCBjb3ZlcikuICBUaGVyZSBtYXkgb25seSBiZSBvbmUgcGljdHVyZSBlYWNoCgBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZwoAICAgICAgICAgICAgICAgICAgICAgIG9yIHZpY2UgdmVyc2EuICBUaGlzIGlzIHVzZWZ1bCBmb3Igc2NyaXB0cywgYW5kIHNldHRpbmcKACAgICAgICAgICAgICAgICAgICAgICBvbmUgYWxyZWFkeSBleGlzdHMsIHBvaW50cyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBleGlzdGluZwoAICAgICAgICAgICAgICAgICAgICAgIGFyZSB0aGUgc2FtZSBhcyB0aG9zZSB1c2VkIGJ5IHZvcmJpc2dhaW4uICBFeGlzdGluZwoAJXM6IEVSUk9SOiBsaW5lIHRvbyBsb25nLCBhYm9ydGluZwoAICAgICAgICAgICBERVNDUklQVElPTiBpcyBvcHRpb25hbDsgdGhlIGRlZmF1bHQgaXMgYW4gZW1wdHkgc3RyaW5nCgAgICAgICAgICAgICAgMTQ6IER1cmluZyByZWNvcmRpbmcKAC0tc29ydC1wYWRkaW5nCgAtLW1lcmdlLXBhZGRpbmcKAGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mCgAgICAgbWV0YWRhdGEgYmxvY2suIFNwZWNpZnkgLS1kYXRhLWZvcm1hdD1iaW5hcnktaGVhZGVybGVzcyB0byBvbWl0IG91dHB1dCBvZgoAICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZyBTRUVLVEFCTEUgd2lsbCBiZSB0aGUgdW5pcXVlLWlmaWVkIHVuaW9uIG9mCgAgICAgICAgICAgICAgICAgICAgICAgYW5kL29yIC0tbm8tdXRmOC1jb252ZXJ0IGJlZm9yZSAtLWltcG9ydC10YWdzLWZyb20gaWYKACAgICAgICAgICAgRklMRSBpcyB0aGUgcGF0aCB0byB0aGUgcGljdHVyZSBmaWxlIHRvIGJlIGltcG9ydGVkLCBvciB0aGUgVVJMIGlmCgAgICAgICAgICAgIFRoZSBuZXh0IHBhcnQgc3BlY2lmaWVzIHRoZSByZXNvbHV0aW9uIGFuZCBjb2xvciBpbmZvcm1hdGlvbi4gIElmCgAgICAgICAgICAgICAgICAgICAgICAgSWYgbm8gU0VFS1RBQkxFIGJsb2NrIGV4aXN0cywgb25lIHdpbGwgYmUgY3JlYXRlZC4gIElmCgAlczogJWYgJWYgJWYgJWYKACAgICAgICAgICAgICAgICAgICAgICB0byBhdm9pZCByZXdyaXRpbmcgdGhlIGVudGlyZSBmaWxlIGlmIHRoZSBtZXRhZGF0YSBzaXplCgAtLXJlbW92ZQoAJXM6IEVSUk9SOiBjb252ZXJ0aW5nIGZpbGUgJyVzJyBjb250ZW50cyB0byBVVEYtOCBmb3IgdGFnIHZhbHVlCgAlczogRVJST1I6IGNhbid0IG9wZW4gZmlsZSAnJXMnIGZvciAnJXMnIHRhZyB2YWx1ZQoARVJST1IgKC0tJXMpOiBpbnZhbGlkIHNhbXBsZSByYXRlCgAgICAgZmlsZSB0byBhbm90aGVyIHdpdGggdGhpcyBvcHRpb24uIEZvciBleGFtcGxlIHVzZQoAbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UKACAgICAgICAgICAgICAxNjogTW92aWUvdmlkZW8gc2NyZWVuIGNhcHR1cmUKACVzOiBFUlJPUjogbWVtb3J5IGFsbG9jYXRpb24gZmFpbHVyZQoAICAgICAgICAgICAgIDE5OiBCYW5kL2FydGlzdCBsb2dvdHlwZQoAICAgICAgICAgICAgIDIwOiBQdWJsaXNoZXIvU3R1ZGlvIGxvZ290eXBlCgAgICAgICAgbWV0YWZsYWMgY2Fubm90IGJlIHVzZWQgYXMgYSBwaXBlCgBFUlJPUjogY2FuJ3QgYWRkIGFub3RoZXIgdm9yYmlzIGNvbW1lbnQgYmxvY2sgdG8gZmlsZSwgaXQgYWxyZWFkeSBoYXMgb25lCgAgICAgU1RSRUFNSU5GTyBibG9jay4gSXQgaXMgcG9zc2libGUgdG8gY29weSBhIG1ldGFkYXRhIGJsb2NrIGZyb20gb25lCgAtLWV4cG9ydC10YWdzLXRvPUZJTEUgRXhwb3J0IHRhZ3MgdG8gYSBmaWxlLiAgVXNlICctJyBmb3Igc3Rkb3V0LiAgRWFjaCBsaW5lCgAtLWltcG9ydC10YWdzLWZyb209RklMRSBJbXBvcnQgdGFncyBmcm9tIGEgZmlsZS4gIFVzZSAnLScgZm9yIHN0ZGluLiAgRWFjaCBsaW5lCgBFUlJPUjogeW91IG1heSBvbmx5IHNwZWNpZnkgb25lIG1ham9yIG9wZXJhdGlvbiBhdCBhIHRpbWUKACAgICBJbnNlcnQgYSBtZXRhZGF0YSBibG9jayBmcm9tIGEgZmlsZS4gIFRoZSBpbnB1dCBmaWxlIG11c3QgYmUgaW4gdGhlIHNhbWUKAEVSUk9SICgtLSVzKTogbWlzc2luZyBmaWxlbmFtZQoALS1zZXQtdGFnLWZyb20tZmlsZT1GSUVMRCAgIExpa2UgLS1zZXQtdGFnLCBleGNlcHQgdGhlIFZBTFVFIGlzIGEgZmlsZW5hbWUKACVzOiBFUlJPUjogZW1wdHkgZXhwb3J0IGZpbGUgbmFtZQoAJXM6IEVSUk9SOiBlbXB0eSBpbXBvcnQgZmlsZSBuYW1lCgAtLW5vLWZpbGVuYW1lICAgICAgICAgRG8gbm90IHByZWZpeCBlYWNoIG91dHB1dCBsaW5lIHdpdGggdGhlIEZMQUMgZmlsZSBuYW1lCgAtLXdpdGgtZmlsZW5hbWUgICAgICAgUHJlZml4IGVhY2ggb3V0cHV0IGxpbmUgd2l0aCB0aGUgRkxBQyBmaWxlIG5hbWUKAEVSUk9SOiBjb3VsZG4ndCBhZGQgc3VwcGxpZWQgbWV0YWRhdGEgYmxvY2sgIyV1IHRvIGZpbGUKAEVSUk9SOiBjYW4ndCBhZGQgc3RyZWFtaW5mbyB0byBmaWxlCgAlczogRVJST1I6IHdyaXRpbmcgUElDVFVSRSBkYXRhIHRvIGZpbGUKACVzOiBFUlJPUiAoLS1hZGQtc2Vla3BvaW50KSBkZWNvZGluZyBmaWxlCgAgICAgICAgICAgICAgICAgICAgICAgUmVwbGF5R2FpbiB0YWdzIHdpbGwgYmUgcmVwbGFjZWQuICBJZiBvbmx5IG9uZSBGTEFDIGZpbGUKACAgICAgICAgICAgICAgICAgICAgICBuZWNlc3NhcnkuICBJZiBGSUxFIGlzICctJyAoc3RkaW4pLCBvbmx5IG9uZSBGTEFDIGZpbGUKAC0tZG9udC11c2UtcGFkZGluZyAgICBCeSBkZWZhdWx0IG1ldGFmbGFjIHRyaWVzIHRvIHVzZSBwYWRkaW5nIHdoZXJlIHBvc3NpYmxlCgAtLWV4cG9ydC1jdWVzaGVldC10bz1GSUxFICBFeHBvcnQgQ1VFU0hFRVQgYmxvY2sgdG8gYSBjdWVzaGVldCBmaWxlLCBzdWl0YWJsZQoAICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcnMuICBTb21lIHBhcnRzIG1heSBiZSBsZWZ0IGVtcHR5IHRvIGludm9rZQoAICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMuICBVc2UgdGhpcyBvcHRpb24gdG8gdGVsbCBtZXRhZmxhYyB0byBub3QgdGFrZQoAICAgIGRlZmluZWQgd2l0aCAtLWJsb2NrLW51bWJlcj0jLiAgVGhlIG5ldyBibG9jayB3aWxsIGJlIGFkZGVkIGFmdGVyIHRoZQoAICAgICAgICAgICAgICAgICAgICAgIGFkZGVkIGZvciBlYWNoIGluZGV4IHBvaW50IGluIHRoZSBjdWVzaGVldCB0byB0aGUKACAgICAgICAgICAgTUlNRS1UWVBFIGlzIG9wdGlvbmFsOyBpZiBsZWZ0IGJsYW5rLCBpdCB3aWxsIGJlIGRldGVjdGVkIGZyb20gdGhlCgAgICAgUmVtb3ZlIGFsbCBtZXRhZGF0YSBibG9ja3MgKGV4Y2VwdCB0aGUgU1RSRUFNSU5GTyBibG9jaykgZnJvbSB0aGUKACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIjB4WFhYWFhYWFgiLiAgRm9yIHRoZSBleGFtcGxlICJhYmNkIiBhYm92ZSB0aGUKAE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUKACAgICAgICAgICAgICAgICAgICAgICBwb2ludHMuICBZb3UgbWF5IHVzZSBtYW55IC0tYWRkLXNlZWtwb2ludCBvcHRpb25zOyB0aGUKACAgICAgICAgICAgICAgICAgICAgICBhIG1vcmUgY29tcGxldGUgc3BlY2lmaWNhdGlvbiBmb3JtIGNhbiBiZSB1c2VkLiAgVGhlCgAlczogRVJST1I6IGZpbGUgJyVzJyBmb3IgJyVzJyB0YWcgdmFsdWUgaXMgdG9vIGxhcmdlCgAgICAgICAgICAgICAgIDU6IExlYWZsZXQgcGFnZQoARVJST1IgKC0tJXMpOiBtYXkgYmUgc3BlY2lmaWVkIG9ubHkgb25jZQoAJXM6IEVSUk9SICgtLWFkZC1zZWVrcG9pbnQpIGNyZWF0aW5nIHRoZSBkZWNvZGVyIGluc3RhbmNlCgAgICAgICAgICAgICAgMTU6IER1cmluZyBwZXJmb3JtYW5jZQoAICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyBhbmQgdGhlIHRhZyBuYW1lcyBzcGVjaWZpZWQuIFRhZyBuYW1lcyBtdXN0IGJlCgAgICAgICAgICAgICAgICAgICAgICAgT25seSBvbmUgRkxBQyBmaWxlIG1heSBiZSBzcGVjaWZpZWQuICBBIHNlZWtwb2ludCB3aWxsIGJlCgAgICAgbWV0YWRhdGEuICBVbmxlc3MgLS1kb250LXVzZS1wYWRkaW5nIGlzIHNwZWNpZmllZCwgdGhlIGJsb2NrcyB3aWxsIGJlCgBFUlJPUjogbW9yZSB0aGFuIG9uZSBibG9jayBudW1iZXIgc3BlY2lmaWVkIHdpdGggLS1hcHBlbmQKACVzOiBFUlJPUjogc2FtcGxlIHJhdGUgb2YgJXUgSHogaXMgbm90IHN1cHBvcnRlZAoAICAgIEFuIG9wdGlvbmFsIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGJsb2NrIHR5cGVzIHRvIGJlIGluY2x1ZGVkIG9yIGlnbm9yZWQKACAgICAgICAgICAg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bmVyYXRlZCB3aXRoIC0tbGlzdC4KACAgICAgICAgICAgICAgICAgICAgICBibG9ja3MgZm9yIHRoYXQuCgAgICAgICAgICAgdGhlIHJlc3VsdCBpcyB0aGUgbG9naWNhbCBBTkQgb2YgYm90aCBhcmd1bWVudHMuCgAKVGhlIG1ldGFkYXRhIHRvIGJlIHdyaXR0ZW4gZG9lcyBub3QgY29uZm9ybSB0byB0aGUgRkxBQyBtZXRhZGF0YQpzcGVjaWZpY2F0aW9ucy4KAApUaGUgRkxBQyBmaWxlIGRvZXMgbm90IGhhdmUgd3JpdGUgcGVybWlzc2lvbnMuCgBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLgoAICAgIE1lcmdlIGFkamFjZW50IFBBRERJTkcgYmxvY2tzIGludG8gc2luZ2xlIGJsb2Nrcy4KACAgICBtZXRhZGF0YSBibG9jayBoZWFkZXJzLCBpbmNsdWRpbmcgdGhlIGlkIG9mIEFQUExJQ0FUSU9OIG1ldGFkYXRhIGJsb2Nrcy4KACAgICAgICAgICAgICAgICAgICAgICByYXRoZXIgdGhhbiB3cml0aW5nIHRoZW0gdG8gdGFncy4KAC0tcmVtb3ZlLXJlcGxheS1nYWluICBSZW1vdmVzIHRoZSBSZXBsYXlHYWluIHRhZ3MuCgBVc2UgbWV0YWZsYWMgdG8gbGlzdCwgYWRkLCByZW1vdmUsIG9yIGVkaXQgbWV0YWRhdGEgaW4gb25lIG9yIG1vcmUgRkxBQyBmaWxlcy4KACAgICAgICAgICAgICAgICAgICAgICBzZWVrcG9pbnRzIGFuZCBhIHNlZWtwb2ludCBldmVyeSAzLjUgc2Vjb25kcy4KACAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0ZWQgYnkgYW4gPSBjaGFyYWN0ZXIuCgAgICAgICAgICAgICAgICAgICAgICAgdGhlIGV4dHJhIDQgYnl0ZXMgaXMgZm9yIHRoZSBtZXRhZGF0YSBibG9jayBoZWFkZXIuCgAgICAgU2hvdyB0aGUgbWV0YWZsYWMgdmVyc2lvbiBudW1iZXIuCgAgICAgICAgICAgICAgICAgICAgICAgZmlsZSwgbGlrZSAtLWV4cG9ydC10YWdzLXRvLgoAb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uCgAtLWltcG9ydC1jdWVzaGVldC1mcm9tPUZJTEUgIEltcG9ydCBhIGN1ZXNoZWV0IGZyb20gYSBmaWxlLiAgVXNlICctJyBmb3Igc3RkaW4uCgAKVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHdyaXRpbmcgRkxBQyBmaWxlOyBtb3N0IHByb2JhYmx5IHRoZSBkaXNrIGlzCmZ1bGwuCgAgICAgc2luZ2xlIGJsb2NrLgoALS1zaG93LXZlbmRvci10YWcgICAgIFNob3cgdGhlIHZlbmRvciBzdHJpbmcgZnJvbSB0aGUgVk9SQklTX0NPTU1FTlQgYmxvY2suCgAtLXNob3ctY2hhbm5lbHMgICAgICAgU2hvdyB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctdG90YWwtc2FtcGxlcyAgU2hvdyB0aGUgdG90YWwgIyBvZiBzYW1wbGVzIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctbWF4LWJsb2Nrc2l6ZSAgU2hvdyB0aGUgbWF4aW11bSBibG9jayBzaXplIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctbWluLWJsb2Nrc2l6ZSAgU2hvdyB0aGUgbWluaW11bSBibG9jayBzaXplIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctbWF4LWZyYW1lc2l6ZSAgU2hvdyB0aGUgbWF4aW11bSBmcmFtZSBzaXplIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctbWluLWZyYW1lc2l6ZSAgU2hvdyB0aGUgbWluaW11bSBmcmFtZSBzaXplIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctc2FtcGxlLXJhdGUgICAgU2hvdyB0aGUgc2FtcGxlIHJhdGUgZnJvbSB0aGUgU1RSRUFNSU5GTyBibG9jay4KAC0tc2hvdy1tZDVzdW0gICAgICAgICBTaG93IHRoZSBNRDUgc2lnbmF0dXJlIGZyb20gdGhlIFNUUkVBTUlORk8gYmxvY2suCgAtLXNob3ctYnBzICAgICAgICAgICAgU2hvdyB0aGUgIyBvZiBiaXRzIHBlciBzYW1wbGUgZnJvbSB0aGUgU1RSRUFNSU5GTyBibG9jay4KACAgICBZb3UgbWF5IG5vdCByZW1vdmUgdGhlIFNUUkVBTUlORk8gYmxvY2suCgAgICAgU1RSRUFNSU5GTyBibG9jay4KACAgICAgICAgICAgICAgICAgICAgICB0YWdzIGluIHNpdHVhdGlvbnMgd2hlcmUgdGhlIGxvY2FsZSBpcyB3cm9uZy4KAC0tcmVtb3ZlLWFsbC10YWdzICAgICBSZW1vdmUgYWxsIHRhZ3MsIGxlYXZpbmcgb25seSB0aGUgdmVuZG9yIHN0cmluZy4KACAgICAtLWRvbnQtdXNlLXBhZGRpbmcgaXMgc3BlY2lmaWVkLCB0aGUgYmxvY2tzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBwYWRkaW5nLgoAICAgIHJlcGxhY2VkIHdpdGggcGFkZGluZy4KACAgICAgICAgICAgICAgICAgICAgICBiZSB1c2VkIHRvIHN0b3JlIGEgY3Vlc2hlZXQgaW4gYSB0YWcgKGUuZy4KACAgICAgICAgICAgICAgICAgICAgICB3aG9zZSBjb250ZW50cyB3aWxsIGJlIHJlYWQgdmVyYmF0aW0gdG8gc2V0IHRoZSB0YWcgdmFsdWUuCgAgICAgd2l0aCB0aGlzIG9wdGlvbi4gIFVzZSBvbmx5IG9uZSBvZiAtLWJsb2NrLXR5cGUgb3IgLS1leGNlcHQtYmxvY2stdHlwZS4KACAgICAgICAgICAgICAgICAgICAgICBPbmx5IG9uZSBGTEFDIGZpbGUgbWF5IGJlIHNwZWNpZmllZCBvbiB0aGUgY29tbWFuZCBsaW5lLgoAWW91IG1heSBwZXJmb3JtIG9uZSBtYWpvciBvcGVyYXRpb24sIG9yIG1hbnkgc2hvcnRoYW5kIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgoAICAgICAgICAgICAgICAgICAgICAgIGlzIGdpdmVuLCB0aGUgYWxidW0gYW5kIHRpdGxlIGdhaW5zIHdpbGwgYmUgdGhlIHNhbWUuCgAgICAgICAgICAgICAgdXN1YWxseSBsZWF2ZSB0aGlzIGVtcHR5IGFuZCB0aGV5IGNhbiBiZSBkZXRlY3RlZCBmcm9tIHRoZSBmaWxlLgoAICAgICAgICAgICAgIG9mIHR5cGUgMSBhbmQgMiBpbiBhIGZpbGUuCgAKVGhlcmUgd2FzIGFuIGVycm9yIHJlbW92aW5nIHRoZSB0ZW1wb3JhcnkgRkxBQyBmaWxlLgoAClRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSByZWFkaW5nIHRoZSBGTEFDIGZpbGUuCgAKVGhlIGZpbGUgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgRkxBQyBmaWxlLgoAClRoZSBGTEFDIGZpbGUgY291bGQgbm90IGJlIG9wZW5lZC4gIE1vc3QgbGlrZWx5IHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0Cm9yIGlzIG5vdCByZWFkYWJsZS4KACAgICBTZWUgLS1saXN0IGFib3ZlIGZvciB1c2FnZS4KACAgICBCeSBkZWZhdWx0IGEgaHVtYW4tcmVhZGFibGUgdGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGF0YSBpcyBkaXNwbGF5ZWQuCgAgICAgICAgICAgICAgICAgICAgICAgbm8gdGFnIGJsb2NrLCBvbmUgd2lsbCBiZSBjcmVhdGVkLgoAICAgICAgICAgICAgIHlvdSBzaG91bGQgYWxzbyBzcGVjaWZ5IHRoZSBudW1iZXIgb2YgY29sb3JzIHVzZWQuCgAgICAgICAgICAgICAgICAgICAgICAgU0VFS1RBQkxFIHVubGVzcyAtLW5vLWN1ZWQtc2Vla3BvaW50cyBpcyBzcGVjaWZpZWQuCgAgICAgICAgICAgICAgICAgICAgICAgbWF5IGJlIHNwZWNpZmllZC4KACAgICAgICAgICAgICBkaXNjb3VyYWdlZC4KADUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0EuCgAgICAgYmxvY2ssIHRoZSBTVFJFQU1JTkZPIGJsb2NrLCBpcyBibG9jayAwLgoALS1zaG93LWFsbC10YWdzICAgICAgIFNob3cgYWxsIHRhZ3MuIFRoaXMgaXMgYW4gYWxpYXMgZm9yIC0tZXhwb3J0LXRhZ3MtdG89LS4KAC0tYWRkLXBhZGRpbmc9bGVuZ3RoICBBZGQgYSBwYWRkaW5nIGJsb2NrIG9mIHRoZSBnaXZlbiBsZW5ndGggKGluIGJ5dGVzKS4KACAgICAgICAgICAgICAgICAgICAgICAodGhlIGRlZmF1bHQgaWYgbW9yZSB0aGFuIG9uZSBGTEFDIGZpbGUgaXMgc3BlY2lmaWVkKS4KAC0tcmVtb3ZlLXRhZz1OQU1FICAgICBSZW1vdmUgYWxsIHRhZ3Mgd2hvc2UgZmllbGQgbmFtZSBpcyAnTkFNRScuCgAtLXJlbW92ZS1maXJzdC10YWc9TkFNRSAgUmVtb3ZlIGZpcnN0IHRhZyB3aG9zZSBmaWVsZCBuYW1lIGlzICdOQU1FJy4KAC0tc2hvdy10YWc9TkFNRSAgICAgICBTaG93IGFsbCB0YWdzIHdoZXJlIHRoZSBmaWVsZCBuYW1lIG1hdGNoZXMgJ05BTUUnLgoAICAgICAgICBBUFBMSUNBVElPTjoweFhYWFhYWFhYICBUaGUgQVBQTElDQVRJT04gYmxvY2socykgd2hvc2UgaGV4YWRlY2ltYWwgYmlnLQoAICAgICAgICBBUFBMSUNBVElPTjphYmNkICAgICAgICBUaGUgQVBQTElDQVRJT04gYmxvY2socykgd2hvc2UgdGV4dHVhbCByZXByZS0KACAgICBMaXN0IHRoZSBjb250ZW50cyBvZiBvbmUgb3IgbW9yZSBtZXRhZGF0YSBibG9ja3MgdG8gc3Rkb3V0LiAgQnkgZGVmYXVsdCwKAC0tbm8tdXRmOC1jb252ZXJ0ICAgICBEbyBub3QgY29udmVydCB0YWdzIGZyb20gVVRGLTggdG8gbG9jYWwgY2hhcnNldCwKACAgICAgICAgICAgICBPdGhlcndpc2UsIHlvdSBtdXN0IHNwZWNpZnkgdGhlIHdpZHRoIGluIHBpeGVscywgaGVpZ2h0IGluIHBpeGVscywKACAgICAgICAgICAgICAgICAgICAgICBGTEFDIGZpbGVzIGFzIGlmIGFsbCB0aGUgZmlsZXMgd2VyZSBwYXJ0IG9mIG9uZSBhbGJ1bSwKAFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLAoAICAgICAgICAgICAgICAgICAgICAgIG9mIGNoYW5uZWxzLiAgT25seSBtb25vIGFuZCBzdGVyZW8gZmlsZXMgYXJlIGFsbG93ZWQsCgAgICAgTk9URTogaWYgYm90aCAtLWJsb2NrLW51bWJlciBhbmQgLS1bZXhjZXB0LV1ibG9jay10eXBlIGFyZSBzcGVjaWZpZWQsCgAgICAgVGhlIHZhbGlkIGJsb2NrIHR5cGVzIGFyZTogU1RSRUFNSU5GTywgUEFERElORywgQVBQTElDQVRJT04sIFNFRUtUQUJMRSwKACAgICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIHNhbXBsZSByYXRlIG11c3QgYmUgOCwgMTEuMDI1LCAxMiwgMTYsIDE4LjksCgAgICAgICAgICAgICAgICAgICAgICAgODguMiwgOTYsIDExMiwgMTI4LCAxNDQsIDE1MS4yLCAxNzYuNCwgMTkyLCAyMjQsIDI1NiwKACAgICAgICAgICAgICAgICAgICAgICAyMi4wNSwgMjQsIDI4LCAzMiwgMzYsIDM3LjgsIDQ0LjEsIDQ4LCA1NiwgNjQsIDcyLCA3NS42LAoAd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgSW5jLiwKACAgICAgICAgICAgICAgMTogMzJ4MzIgcGl4ZWxzICdmaWxlIGljb24nIChQTkcgb25seSkKACVzOiBFUlJPUjogIyBjaGFubmVscyAoJXUpIGRvZXMgbm90IG1hdGNoIHByZXZpb3VzIGZpbGVzJyAoJXUpCgAgICAgICAgICAgICAgIDM6IENvdmVyIChmcm9udCkKACVzOiBFUlJPUiAoLS1hZGQtc2Vla3BvaW50KSBkZWNvZGluZyBmaWxlICgldTolcykKACAgICAgIG51bWJlcjogJXUgKCVzKQoAICB0eXBlOiAldSAoJXMpCgAlczogRVJST1I6IGR1cmluZyBhbmFseXNpcyAoJXMpCgAlczogRVJST1I6IHdyaXRpbmcgdGFncyAoJXMpCgAlczogRVJST1IgKC0tYWRkLXNlZWtwb2ludCkgZGVjb2RpbmcgZmlsZSAoJXMpCgAlczogRVJST1IgKC0tYWRkLXNlZWtwb2ludCkgaW5pdGlhbGl6aW5nIHRoZSBkZWNvZGVyIGluc3RhbmNlICglcykKACAgICAgICAgICAgICAgNDogQ292ZXIgKGJhY2spCgAgICAgICAgICAgICAgICAgICAgICAgKHRoZSBkZWZhdWx0IGlmIG9ubHkgb25lIEZMQUMgZmlsZSBpcyBzcGVjaWZpZWQpCgAgICAgICAgWCAgOiBhIHBsYWNlaG9sZGVyIHBvaW50IChhbHdheXMgZ29lcyBhdCB0aGUgZW5kIG9mIHRoZSBTRUVLVEFCTEUpCgAgICAgICAgICAgICAgIDY6IE1lZGlhIChlLmcuIGxhYmVsIHNpZGUgb2YgQ0QpCgAlczogdW5yZWNvZ25pemVkIG9wdGlvbiBgJWMlcycKACVzOiB1bnJlY29nbml6ZWQgb3B0aW9uIGAtLSVzJwoAVGhpcyBpcyB0aGUgc2hvcnQgaGVscDsgZm9yIGZ1bGwgaGVscCB1c2UgJ21ldGFmbGFjIC0taGVscCcKAEVSUk9SOiB5b3UgbWF5IG9ubHkgc3BlY2lmeSBvbmUgRkxBQyBmaWxlIHdoZW4gdXNpbmcgJy0tZXhwb3J0LWN1ZXNoZWV0LXRvJwoARVJST1I6IHlvdSBtYXkgb25seSBzcGVjaWZ5IG9uZSBGTEFDIGZpbGUgd2hlbiB1c2luZyAnLS1leHBvcnQtcGljdHVyZS10bycKAEVSUk9SOiB5b3UgbWF5IG9ubHkgc3BlY2lmeSBvbmUgRkxBQyBmaWxlIHdoZW4gdXNpbmcgJy0taW1wb3J0LWN1ZXNoZWV0LWZyb20nCgBFUlJPUjogeW91IG1heSBub3Qgc3BlY2lmeSBib3RoICctLWJsb2NrLXR5cGUnIGFuZCAnLS1leGNlcHQtYmxvY2stdHlwZScKAEVSUk9SOiB5b3UgbWF5IG9ubHkgc3BlY2lmeSBvbmUgRkxBQyBmaWxlIHdoZW4gdXNpbmcgJy0taW1wb3J0LXRhZ3MtZnJvbT0tJwoAICAgIC0tYmxvY2stbnVtYmVyPSMKAEVSUk9SICgtLSVzKTogaWxsZWdhbCBhcHBsaWNhdGlvbiBkYXRhIGZvcm1hdCAiJXMiCgBFUlJPUiAoLS0lcyk6IGlsbGVn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YW4ARkxBQ19fTUVUQURBVEFfU0lNUExFX0lURVJBVE9SX1NUQVRVU19JTExFR0FMX0lOUFVUAEZMQUNfX1NUUkVBTV9FTkNPREVSX1VOSU5JVElBTElaRUQARkxBQ19fU1RSRUFNX0RFQ09ERVJfUkVBRF9NRVRBREFUQQByZWZlcmVuY2UgbGliRkxBQyAxLjQuMyAyMDIzMDYyMwAobnVsbCkAZkxhQwAAABAAAAAQAAAAGAAAABgAAAAUAAAAAwAAAAUAAAAkAAAAIAAAAEAAAABAAAAAEAAAAAAAAAD//////////yAAAAAgAAAAQAAAAAgAAAAYAAAAQAAAAAgAAABgAAAAAQAAAAEAAABuAAAACAAAAAAEAABAAAAAAQAAABcIAAAIAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAABAAAABwAAABgAAAAQAAAAAgAAAAQAAAAEAAAABQAAAAUAAAAPAAAAHwAAAEZMQUNfX1NUUkVBTV9FTkNPREVSX09HR19FUlJPUgBGTEFDX19NRVRBREFUQV9TSU1QTEVfSVRFUkFUT1JfU1RBVFVTX0VSUk9SX09QRU5JTkdfRklMRQBQQVJUSVRJT05FRF9SSUNFAEZMQUNfX1NUUkVBTV9ERUNPREVSX1NFQVJDSF9GT1JfRlJBTUVfU1lOQwAtMFgrMFggMFgtMHgrMHggMHgARkxBQ19fU1RSRUFNX0VOQ09ERVJfVkVSSUZZX0RFQ09ERVJfRVJST1IARkxBQ19fU1RSRUFNX0RFQ09ERVJfUkVBRF9GUkFNRQBGTEFDX19NRVRBREFUQV9TSU1QTEVfSVRFUkFUT1JfU1RBVFVTX05PVF9BX0ZMQUNfRklMRQBQQVJUSVRJT05FRF9SSUNFMgAAAAAEAAAABQAAAGluZgBDT05TVEFOVABGTEFDX19TVFJFQU1fREVDT0RFUl9FTkRfT0ZfU1RSRUFNAEZMQUNfX01FVEFEQVRBX1NJTVBMRV9JVEVSQVRPUl9TVEFUVVNfTk9UX1dSSVRBQkxFAEZMQUNfX1NUUkVBTV9FTkNPREVSX1ZFUklGWV9NSVNNQVRDSF9JTl9BVURJT19EQVRBAEZMQUNfX1NUUkVBTV9FTkNPREVSX0NMSUVOVF9FUlJPUgBGTEFDX19TVFJFQU1fREVDT0RFUl9PR0dfRVJST1IAVkVSQkFUSU0ASU5GAEZMQUNfX01FVEFEQVRBX1NJTVBMRV9JVEVSQVRPUl9TVEFUVVNfQkFEX01FVEFEQVRBAG5hbgBGTEFDX19TVFJFQU1fRU5DT0RFUl9JT19FUlJPUgBGTEFDX19TVFJFQU1fREVDT0RFUl9TRUVLX0VSUk9SAEZMQUNfX01FVEFEQVRBX1NJTVBMRV9JVEVSQVRPUl9TVEFUVVNfUkVBRF9FUlJPUgBGSVhFRABGTEFDX19NRVRBREFUQV9TSU1QTEVfSVRFUkFUT1JfU1RBVFVTX1NFRUtfRVJST1IARkxBQ19fU1RSRUFNX0VOQ09ERVJfRlJBTUlOR19FUlJPUgBOQU4ARkxBQ19fU1RSRUFNX0RFQ09ERVJfQUJPUlRFRABMUEMASU5ERVBFTkRFTlQARkxBQ19fU1RSRUFNX0VOQ09ERVJfTUVNT1JZX0FMTE9DQVRJT05fRVJST1IARkxBQ19fU1RSRUFNX0RFQ09ERVJfTUVNT1JZX0FMTE9DQVRJT05fRVJST1IARkxBQ19fTUVUQURBVEFfU0lNUExFX0lURVJBVE9SX1NUQVRVU19XUklURV9FUlJPUgAuAEZMQUNfX01FVEFEQVRBX1NJTVBMRV9JVEVSQVRPUl9TVEFUVVNfUkVOQU1FX0VSUk9SAEZMQUNfX1NUUkVBTV9FTkNPREVSX0lOSVRfU1RBVFVTX09LAExFRlRfU0lERQBGTEFDX19TVFJFQU1fREVDT0RFUl9VTklOSVRJQUxJWkVEAEZMQUNfX1NUUkVBTV9FTkNPREVSX0lOSVRfU1RBVFVTX0lOVkFMSURfTlVNQkVSX09GX0NIQU5ORUxTAEZMQUNfX1NUUkVBTV9ERUNPREVSX0lOSVRfU1RBVFVTX01FTU9SWV9BTExPQ0FUSU9OX0VSUk9SAEZSQU1FX05VTUJFUl9UWVBFX1NBTVBMRV9OVU1CRVIARkxBQ19fTUVUQURBVEFfQ0hBSU5fU1RBVFVTX09LAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19JTExFR0FMX0lOUFVUAFNUUkVBTUlORk8ARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfSU5WQUxJRF9CSVRTX1BFUl9TQU1QTEUARkxBQ19fU1RSRUFNX0RFQ09ERVJfSU5JVF9TVEFUVVNfRVJST1JfT1BFTklOR19GSUxFAFBBRERJTkcARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfSU5WQUxJRF9TQU1QTEVfUkFURQBGTEFDX19NRVRBREFUQV9DSEFJTl9TVEFUVVNfRVJST1JfT1BFTklOR19GSUxFAEZMQUNfX1NUUkVBTV9ERUNPREVSX0lOSVRfU1RBVFVTX0FMUkVBRFlfSU5JVElBTElaRUQAQVBQTElDQVRJT04ARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfSU5WQUxJRF9CTE9DS19TSVpFAEZMQUNfX1NUUkVBTV9ERUNPREVSX1JFQURfU1RBVFVTX0NPTlRJTlVFAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19OT1RfQV9GTEFDX0ZJTEUARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfSU5WQUxJRF9NQVhfTFBDX09SREVSAEZMQUNfX1NUUkVBTV9ERUNPREVSX1JFQURfU1RBVFVTX0VORF9PRl9TVFJFQU0AU0VFS1RBQkxFAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19OT1RfV1JJVEFCTEUARkxBQ19fU1RSRUFNX0RFQ09ERVJfUkVBRF9TVEFUVVNfQUJPUlQAVk9SQklTX0NPTU1FTlQARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfSU5WQUxJRF9RTFBfQ09FRkZfUFJFQ0lTSU9OAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19CQURfTUVUQURBVEEAQ1VFU0hFRVQARkxBQ19fTUVUQURBVEFfQ0hBSU5fU1RBVFVTX1JFQURfRVJST1IARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfQkxPQ0tfU0laRV9UT09fU01BTExfRk9SX0xQQ19PUkRFUgBGTEFDX19TVFJFQU1fREVDT0RFUl9TRUVLX1NUQVRVU19PSwBGTEFDX19TVFJFQU1fREVDT0RFUl9TRUVLX1NUQVRVU19FUlJPUgBGTEFDX19NRVRBREFUQV9DSEFJTl9TVEFUVVNfU0VFS19FUlJPUgBQSUNUVVJFAEZMQUNfX1NUUkVBTV9FTkNPREVSX0lOSVRfU1RBVFVTX05PVF9TVFJFQU1BQkxFAE90aGVyAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19XUklURV9FUlJPUgBGTEFDX19TVFJFQU1fREVDT0RFUl9TRUVLX1NUQVRVU19VTlNVUFBPUlRFRABGTEFDX19TVFJFQU1fRU5DT0RFUl9JTklUX1NUQVRVU19JTlZBTElEX01FVEFEQVRBAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19SRU5BTUVfRVJST1IARkxBQ19fU1RSRUFNX0RFQ09ERVJfVEVMTF9TVEFUVVNfT0sARkxBQ19fU1RSRUFNX0VOQ09ERVJfSU5JVF9TVEFUVVNfQUxSRUFEWV9JTklUSUFMSVpFRAAzMngzMiBwaXhlbHMgJ2ZpbGUgaWNvbicgKFBORyBvbmx5KQBPdGhlciBmaWxlIGljb24ARkxBQ19fU1RSRUFNX0RFQ09ERVJfVEVMTF9TVEFUVVNfRVJST1IARkxBQ19fTUVUQURBVEFfQ0hBSU5fU1RBVFVTX1VOTElOS19FUlJPUgBGTEFDX19TVFJFQU1fRU5DT0RFUl9SRUFEX1NUQVRVU19DT05USU5VRQBGTEFDX19NRVRBREFUQV9DSEFJTl9TVEFUVVNfTUVNT1JZX0FMTE9DQVRJT05fRVJST1IARkxBQ19fU1RSRUFNX0VOQ09ERVJfUkVBRF9TVEFUVVNfRU5EX09GX1NUUkVBTQBGTEFDX19TVFJFQU1fREVDT0RFUl9URUxMX1NUQVRVU19VTlNVUFBPUlRFRABDb3ZlciAoZnJvbnQpAEZMQUNfX1NUUkVBTV9FTkNPREVSX1JFQURfU1RBVFVTX0FCT1JUAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19JTlRFUk5BTF9FUlJPUgBGTEFDX19TVFJFQU1fREVDT0RFUl9MRU5HVEhfU1RBVFVTX09LAENvdmVyIChiYWNrKQBMZWFmbGV0IHBhZ2UARkxBQ19fTUVUQURBVEFfQ0hBSU5fU1RBVFVTX0lOVkFMSURfQ0FMTEJBQ0tTAEZMQUNfX1NUUkVBTV9ERUNPREVSX0xFTkdUSF9TVEFUVVNfRVJST1IARkxBQ19fU1RSRUFNX0VOQ09ERVJfUkVBRF9TVEFUVVNfVU5TVVBQT1JURUQARkxBQ19fU1RSRUFNX0VOQ09ERVJfV1JJVEVfU1RBVFVTX09LAEZMQUNfX01FVEFEQVRBX0NIQUlOX1NUQVRVU19SRUFEX1dSSVRFX01JU01BVENIAEZMQUNfX1NUUkVBTV9ERUNPREVSX0xFTkdUSF9TVEFUVVNfVU5TVVBQT1JURUQATWVkaWEgKGUuZy4gbGFiZWwgc2lkZSBvZiBDRCkATGVhZCBhcnRpc3QvbGVhZCBwZXJmb3JtZXIvc29sb2lzdABGTEFDX19TVFJFQU1fRU5DT0RFUl9XUklURV9TVEFUVVNfRkFUQUxfRVJST1IARkxBQ19fTUVUQURBVEFfQ0hBSU5fU1RBVFVTX1dST05HX1dSSVRFX0NBTEwARkxBQ19fU1RSRUFNX0RFQ09ERVJfV1JJVEVfU1RBVFVTX0NPTlRJTlVFAEFydGlzdC9wZXJmb3JtZXIAcitiAEZMQUNfX1NUUkVBTV9ERUNPREVSX1dSSVRFX1NUQVRVU19BQk9SVABGTEFDX19TVFJFQU1fRU5DT0RFUl9TRUVLX1NUQVRVU19PSwBDb25kdWN0b3IAcmIARkxBQ19fU1RSRUFNX0VOQ09ERVJfU0VFS19TVEFUVVNfRVJST1IARkxBQ19fU1RSRUFNX0RFQ09ERVJfRVJST1JfU1RBVFVTX0xPU1RfU1lOQwBCYW5kL09yY2hlc3RyYQBGTEFDX19TVFJFQU1fREVDT0RFUl9FUlJPUl9TVEFUVVNfQkFEX0hFQURFUgBGTEFDX19TVFJFQU1fRU5DT0RFUl9TRUVLX1NUQVRVU19VTlNVUFBPUlRFRABJRDMALm1ldGFkYXRhX2VkaXQAQ29tcG9zZXIARkxBQ19fU1RSRUFNX0VOQ09ERVJfVEVMTF9TVEFUVVNfT0sARkxBQ19fU1RSRUFNX0RFQ09ERVJfRVJST1JfU1RBVFVTX0ZSQU1FX0NSQ19NSVNNQVRDSAAlcyVzAEx5cmljaXN0L3RleHQgd3JpdGVyAEZMQUNfX1NUUkVBTV9FTkNPREVSX1RFTExfU1RBVFVTX0VSUk9SAEZMQUNfX1NUUkVBTV9ERUNPREVSX0VSUk9SX1NUQVRVU19VTlBBUlNFQUJMRV9TVFJFQU0AJXMvJXMlcwBSZWNvcmRpbmcgTG9jYXRpb24ARkxBQ19fU1RSRUFNX0VOQ09ERVJfVEVMTF9TVEFUVVNfVU5TVVBQT1JURUQARkxBQ19fU1RSRUFNX0RFQ09ERVJfRVJST1JfU1RBVFVTX0JBRF9NRVRBREFUQQBiYXJ0bGV0dABEdXJpbmcgcmVjb3JkaW5nAHJiAHcrYgBiYXJ0bGV0dF9oYW5uAER1cmluZyBwZXJmb3JtYW5jZQAlcyA6ICVzCgBBv6oCC8kZYmxhY2ttYW4ATW92aWUvdmlkZW8gc2NyZWVuIGNhcHR1cmUAY2hvd24oZmlsZW5hbWUsIHN0YXRzLT5zdF91aWQsIC0xKQBBIGJyaWdodCBjb2xvdXJlZCBmaXNoAGJsYWNrbWFuX2hhcnJpc180dGVybV85MmRiAGNob3duKGZpbGVuYW1lLCAtMSwgc3RhdHMtPnN0X2dpZCkAY29ubmVzAElsbHVzdHJhdGlvbgBmbGF0dG9wAEJhbmQvYXJ0aXN0IGxvZ290eXBlAFB1Ymxpc2hlci9TdHVkaW8gbG9nb3R5cGUAZ2F1c3MoAENELURBIGN1ZSBzaGVldCBtdXN0IGhhdmUgYSBsZWFkLWluIGxlbmd0aCBvZiBhdCBsZWFzdCAyIHNlY29uZHMAaGFtbWluZwBDRC1EQSBjdWUgc2hlZXQgbGVhZC1pbiBsZW5ndGggbXVzdCBiZSBldmVubHkgZGl2aXNpYmxlIGJ5IDU4OCBzYW1wbGVzAGhhbm4Aa2Fpc2VyX2Jlc3NlbABjdWUgc2hlZXQgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSB0cmFjayAodGhlIGxlYWQtb3V0KQBudXR0YWxsAENELURBIGN1ZSBzaGVldCBtdXN0IGhhdmUgYSBsZWFkLW91dCB0cmFjayBudW1iZXIgMTcwICgweEFBKQByZWN0YW5nbGUAY3VlIHNoZWV0IG1heSBub3QgaGF2ZSBhIHRyYWNrIG51bWJlciAwAHRyaWFuZ2xlAENELURBIGN1ZSBzaGVldCB0cmFjayBudW1iZXIgbXVzdCBiZSAxLTk5IG9yIDE3MABDRC1EQSBjdWUgc2hlZXQgbGVhZC1vdXQgb2Zmc2V0IG11c3QgYmUgZXZlbmx5IGRpdmlzaWJsZSBieSA1ODggc2FtcGxlcwB0dWtleSgAQ0QtREEgY3VlIHNoZWV0IHRyYWNrIG9mZnNldCBtdXN0IGJlIGV2ZW5seSBkaXZpc2libGUgYnkgNTg4IHNhbXBsZXMAcGFydGlhbF90dWtleSgAY3VlIHNoZWV0IHRyYWNrIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgaW5kZXggcG9pbnQAcHVuY2hvdXRfdHVrZXkoAGN1ZSBzaGVldCB0cmFjaydzIGZpcnN0IGluZGV4IG51bWJlciBtdXN0IGJlIDAgb3IgMQBzdWJkaXZpZGVfdHVrZXkoAENELURBIGN1ZSBzaGVldCB0cmFjayBpbmRleCBvZmZzZXQgbXVzdCBiZSBldmVubHkgZGl2aXNpYmxlIGJ5IDU4OCBzYW1wbGVzAHdlbGNoAGltYWdlL3BuZwBjdWUgc2hlZXQgdHJhY2sgaW5kZXggbnVtYmVycyBtdXN0IGluY3JlYXNlIGJ5IDEALS0+AE1JTUUgdHlwZSBzdHJpbmcgbXVzdCBjb250YWluIG9ubHkgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcnMgKDB4MjAtMHg3ZSkAdytiAGRlc2NyaXB0aW9uIHN0cmluZyBtdXN0IGJlIHZhbGlkIFVURi04AAAozQIAwM0CAFDOAgBObyBlcnJvciBpbmZvcm1hdGlvbgBJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBNdWx0aWhvcCBhdHRlbXB0ZWQAUmVxdWlyZWQga2V5IG5vdCBhdmFpbGFibGUAS2V5IGhhcyBleHBpcmVkAEtleSBoYXMgYmVlbiByZXZva2VkAEtleSB3YXMgcmVqZWN0ZWQgYnkgc2VydmljZQAAAAAApQJbAPABtQWMBSUBgwYdA5QE/wDHAzEDCwa8AY8BfwPKBCsA2gavAEIDTgPcAQ4EFQChBg0BlAILAjgGZAK8Av8CXQPnBAsHzwLLBe8F2wXhAh4GRQKFAIICbANvBPEA8wMYBdkA2gNMBlQCewGdA70EAABRABUCuwCzA20A/wGFBC8F+QQ4AGUBRgGfALcGqAFzAlMBAEG4xAILDCEEAAAAAAAAAAAvAgBB2MQCCwY1BEcEVgQAQe7EAgsCoAQAQYLFAgsiRgVgBW4FYQYAAM8BAAAAAAAAAADJBukG+QYeBzkHSQdeBwBBsMUCC5EB0XSeAFedvSqAcFIP//8+JwoAAABkAAAA6AMAABAnAACghgEAQEIPAICWmAAA4fUFGAAAADUAAABxAAAAa////877//+Sv///AAAAAAAAAAAZAAsAGRkZAAAAAAUAAAAAAAAJAAAAAAsAAAAAAAAAABkACgoZGRkDCgcAAQAJCxgAAAkGCwAACwAGGQAAABkZGQBB0cYCCyEOAAAAAAAAAAAZAAsNGRkZAA0AAAIACQ4AAAAJAA4AAA4AQYvHAgsBDABBl8cCCxUTAAAAABMAAAAACQwAAAAAAAwAAAwAQcXHAgsBEABB0ccCCxUPAAAABA8AAAAACRAAAAAAABAAABAAQf/HAgsBEgBBi8gCCx4RAAAAABEAAAAACRIAAAAAABIAABIAABoAAAAaGhoAQcLIAgsOGgAAABoaGgAAAAAAAAkAQfPIAgsBFABB/8gCCxUXAAAAABcAAAAACRQAAAAAABQAABQAQa3JAgsBFgBBuckCC0oVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUbeEgSVAAAAAP///////////////+CkAAAUAAAAQy5VVEYtOABBmMoCCwL0pABBsMoCC8gGdXRmOABjaGFyAADId2NoYXJ0AADGdWNzMmJlAADEdWNzMmxlAADFdXRmMTZiZQAAwnV0ZjE2bGUAAMF1Y3M0YmUAdXRmMzJiZQAAwHVjczRsZQB1dGYzMmxlAADDYXNjaWkAdXNhc2NpaQBpc282NDYAaXNvNjQ2dXMAAMd1dGYxNgAAynVjczQAdXRmMzIAAMt1Y3MyAADMZXVjanAAANBzaGlmdGppcwBzamlzAGNwOTMyAADRaXNvMjAyMmpwAADSZ2IxODAzMAAA2GdiawAA2WdiMjMxMgAA2mJpZzUAYmlnZml2ZQBjcDk1MABiaWc1aGtzY3MAAOBldWNrcgBrc2M1NjAxAGtzeDEwMDEAY3A5NDkAAOhpc284ODU5MQBsYXRpbjEAAEBpc284ODU5MgAAKKAQ9FdOpNz01CmoVDVVVm61IhdcsBQUmE604ASVX7hYRZVWbw02V1xJBSOMQMTMZNAxDCVj0TIYNeOMQxDt9NM01BRlzTVNjaVNWdx0c9U3SoUjzkDk0HTQOQ2lc9E6GbXjzkMR8QTUPPQYZc89TpGlj1n89IMVYGlzbzg4NTkzAAAooJD01yikACDSKaiwNBVHLrUCAFywlCTLLLTUMtItuLREVUcv9QJAXMAEIwwAxCiE0DHIJKPMMsw048wzAEQjzTTUeGTNNRplo8023IQV1TfghCMOAOQslNA56KSjzjrstOPOOwDEI8889Hxkzz0b5aPPPvyIJRVgaXNvODg1OTQAACigECTTUqSYVNMpqFQlEUhbtSLXK7AUFBhTtJxkk1+4WDVRSFwFNZdQAAUjzDDEFGOMSgwlY9EyFDXjDEoQ9TQUTNRUY8012JylzTbcdPXVNwGFI8445JRjzkoNpXPROhW1405KEflEVEz01GPPPfigpc8+/HgFFmBpc284ODU5NQAAKKBEJ9101FVn3XXYZafddty10p1334EXnnjjkVeeeeehl55667HXnnvvwReffPPRV5999+GXn3778deff/8BGKCAAxJYoIEHIpigggsy2KCDD0IYoYQTUlihhRdimKGGG3LYoYcmfwhiiCKOSGKJJp6IYooqnrIii2lzbzg4NTk2AAAooAAAAACkAEGB0QILA2K2AgBBk9ECC0fAmAAAAACZAJRp5plopqnmmmy26eabcMYp55x01mnnnXjmqeeefPbpJwAAAAAAAH8CGqiggxJaqKGHIpqooosy2qijj0IaKQBB6tECC7UBaXNvODg1OTcAACigTEzxKCSXbMopqKSS2CqstAJAxLDEIsssii3G2C2NOfbYLpD1Eplkk1FWmWWXYZaZZptx1plnn4EWmmijkQZAaaadhlpqqq3GWmuuvQZbbLLNRltttt2GW2667cZbb779Blxwwg1HXHHGHYdccsotx1xzzj0HHQBpc284ODU5OAAAKKAAIMoopJRiyimopHLNKqy04sorsMQiyyy01GLLLbjkcs8uvPTiCwBBxtMCC5aVA4DEQg5JZJFGHolkkkouyWSTTj4JZZRSTklllVZeiWWWWm7JJQAANOwwAGlzbzg4NTk5AAA0HEUjzTTUVGPNNdhko8023LA01TfghCPOOOSUY8456KSjzjrstOPOOx3FI8889NRjzz345KPPPvy0RNU/aXNvODg1OTEwAAAooBAkEUgomQTTKTVBVNVWcrXyVVCwFDRRSCmdFNMtNkVkFVdzRQyWUAAFI8wwxBRjjEoMJWPRMhQ148wz0PQ01DTUVGNNV9icpc023HTjzTcBhSPOOOSUY85KDaVz0ToVtePOO/D4RNQ89NRjj1f4oKXPPvz0449MaXNvODg1OTExAHRpczYyMAAAKKB4+imooYo6Kqmlmnoqqqmquiqrrbr6KqyxyjorrbXaeiuuueq6K6+9+vorsMEKOyyxxRp7LLLJKrsss806+yy00Uo7LbXVWnstAAAAAAC22Wq7LbfdevstuOGKOy655Zp7Lrrpqrsuu+26+y688co7L70AAAAAAGlzbzg4NTkxMwAAKKBcLMoopGBsyinYpLLUKqy04ooxsMQiyywW12LLLfjkwtQuvPTiizkEqQSQQcQUY5FEDCXjFkUgwYRSTVXt1NM0Q1VjzTVn5fTUV9zAJdc3Ba0U0EHklHPRRA2l81ZFIcWUkk1W8eTTPETVY889aOkEFVj8xDUXxWlzbzg4NTkxNAAAKKDUa+8oCi107ykDp1Iwvgm34kpb+err0Uf78mtLvwT7a/C/Ch+MMMDABCPMMMQUY8wxyCSjzDLMNOPMM2lFI8001FRjTcDYZKPNNtx0s9Y34IQjzjjklGPOOeiko8467LTjzjtqxSPPPPTUY4/A+OSjzz789MPWP2lzbzg4NTkxNQBsYXRpbjkAACkkl1LVKValosoqrLTiyiuwxCLLLHLVYsstc+Wiyy5HIdXWL8AEI8wwxBRjzDHIJKPMMsw048wz0EQjzTTUVGPNNdhko8023HTjzTfghCPOOOSUY8456KSjzjrstOPOO/DEI8889NRjzz345KPPPvz0488/aXNvODg1OTE2AAAooBBUUE4kY1zVKValktcqbrXyFlywxMKQTnJdbMstczWk1y5HIdVWXMAEI4xAxBhkzDHIJKPMMsw048wzEO0kzTTUFGXNU2Vlo8023Fi01zfghCPOQOQcZM456KSjzjrstOPOOxHxJM889BhlD1Rm5aPPPvxcxNc/Y3AxMjUwAHdpbmRvd3MxMjUwAAAgJANQMQAYc5yxxgB0XJXHT2Ull1sATEyxxRdv/DDEAJxs1cdQaTXXW6D49VdOpBBkyimopDLVKqy04gpcsMQSmE601GLLLbgURNUuNw2GU1xJBSOMQMTMZNAxDCVj0TIYNeOMQxDt9NM01BRlzTVNjaVNWdx0c9U3SoUjzkDk0HTQOQ2lc9E6GbXjzkMR8QTUPPQYZc89TpGlj1n89IMVYGNwMTI1MQB3aW5kb3dzMTI1MQAAINJNV3GIGHOcscYkd5ydx9pxt513IE5MscUXb/wwxACcfOLHKKqYIougdLcidqS0aMop0aVC3SqstOLKdbDEYh2JLtZiyy0fmiziLiZWN2KJ34EXnnjjkVeeeeehl55667HXnnvvwReffPPRV5999+GXn3778deff/8BGKCAAxJYoIEHIpigggsy2KCDD0IYoYQTUlihhRdimKGGG3LYoYdjcDEyNTIAd2luZG93czEyNTIAACAkA1AxXRhznLHGfXVclcdHASAXAABMTLHFF2/8MMSCnWzVx0gBMFdboIQiyiiklGLKKaikosoqrLTiyiuwxCLLLLTUYsstuOSiyy689OLLL8AEI8wwxBRjzDHIJKPMMsw048wz0EQjzTTUVGPNNdhko8023HTjzTfghCPOOOSUY8456KSjzjrstOPOO/DEI8889NRjzz345KPPPvz0488/Y3AxMjUzAHdpbmRvd3MxMjUzAAAgJANQMV0Yc5yxxgB0DIDHAAAAAAAATEyxxRdv/DDEAJwMwMcAAAAAAKAsxtgopJRiyimopALAKqy04krEsMQiyyyK1WLLLY059tgukPUSmWSTUVaZZZdhlplmm3HWmWefgRaaaKORBkBppp2GWmqqrcZaa669Bltsss1GW2223YZbbrrtxltvvv0GXHDCDUdcccYdh1xyyi3HXHPOPQcdAGNwMTI1NAB3aW5kb3dzMTI1NAAAICQDUDFdGHOcscZ9dVyVx0cBAAAAAExMscUXb/wwxIKdbNXHSAEAQFughCLKKKSUYsopqKSiyiqstOLKK7DEIssstNRiyy245KLLLrz04ssvwAQjzDDEFGPMMcgko8wyzDTjzDMcRSPNNNRUY8012GSjzTbcsDTVN+CEI8445JRjzjnopKPOOuy04847HcUjzzz01GPPPfjko88+/LRE1T9jcDEyNTUAd2luZG93czEyNTUAACAkA1AxXRhznLHGfXUMgMcAAAAAAABMTLHFF2/8MMSCnQzAxwAAAAAAoIQiyigil2LKKaikcs0qrLTiyiuwxCLLLLTUYsstuORyzy689OLLLy/CGKOMM9JYo4034ghAjjruyGOPPv4IZJBdevklmGECAAAAAAAAAABCDklkkUYeiWSSSi7JZJNOPglllFJOSWWVVl6JZZZabsklAAA07DAAY3AxMjU2AHdpbmRvd3MxMjU2AAAgJE9aMV0Yc5yxxn11LKnHR1F6aaWZTkyxxRdv/DDEmJ5s6cdILcywpqCIKcoopJRiyimopLLpKqy04sorsMQiyyy01GLLLbjkMuYuvPTiC5mclmnmmWimqeaabLbp5ptwxinnnHTWaeedeOap5zV78tmnn38CGqig4AwqDqGFGnroOeiko846iCbqzjuKLspoo/Q4+ug9kOYT6T78NOxwp2NwMTI1NwB3aW5kb3dzMTI1NwAAICQDUDEAGHOcscYAdAyAxwCg4hcuAExMscUXb/wwxACcDMDHALwSGACgACDKKKQAYMop2KSy1CqstOKKMbDEIssstNRiyy345MLULrz04os5BKkEkEHEFGORRAwl4xZFIMGEUk1V7dTTNENVY801Z+X01FfcwCXXNwWtFNBB5JRz0UQNpfNWRSHFlJJNVvHk0zxE1WPPPWjpBBVY/MQ1F2BjcDEyNTgAd2luZG93czEyNTgAACAkA1AxXRhznLHGfXUMgMdHAQAAAABMTLHFF2/8MMSCnQzAx0gBAEBboIQiyiiklGLKKaikosoqrLTiyiuwxCLLLLTUYsstuOSiyy689OLLL8AEI4xAxBRjzDHIJKPMMoQ148wzEEVz2DTU1GXNNdhko8023Nxl2DfghCPOQOSUY8456KSjzjqFtePOOxHFg9g89Nhlzz345KPPPvzgNfI/a29pOHIAACAz01yzzTfjnLPOO/Pc89Zcd+3112CHLXbMY6OcMssuvwyKzLDIcss9Pv8M9IdBCz000UUbfTTSSSu9NNNNO/10dFBHLfXUVFdt9dVYZ611Kh3+B2CFAxI4oYAUHohgggouyGCDDnr4IIQRSlhggBtqaOCFHGJoYYb9fQdefeORN5949J2HXnrqrcdee+759x588clXXnj76WfeffzhZ19+a29pOHUAACAz01yzzTfjnLPOO/Pc89Zcd+3112CHLXbMY6OcMssuvwyKzLDIcss9Pv8M9IciCk1iiUUbfTTSSbu4NNNNO/10dNRFbd11VFdt9dVYt6h1Kh3+B2CFAxI4oYAUHohgggouyGCDDnr4IIQRSlhggBtqaOCFHGJoYYb9fQdefeORN5949J2HXnrqrcdee+759x588clXXnj76WfeffzhZ19+Y3A0MzcAACDH8JOOOOSAU8456qyDzjvusENMMcmYYww99sizTz7/WMONKKOUEjJd4bQzjz7xRKOKLr/AzEovvISyyi5ghy02zTo/DTXRQ0f9c9FLK520zTfzvHPOM/fMdNNIC3011U77rHXVVks99dFGAx101ljjXHPXXHv99dazfWOZcKUVV4txqG22mm0qI3fbyi3H8rLLMct8D8uwoHxLyiDLMjYoY3A4NTAAACDH8JOOOOSAU8456qyDzjvusENMMcmYYww99sizTz7/WMMNPqNgcw1d4bQzjz7xRKOKLr+4wkovvISyyi5ghy02zToHIwwwqUT9c9FLi1KKzTfzvHPOM/c8zjBIC3011U77rDUp8ECjzDLItNSMM8/gXHPXXJvCzNbTfEONNPVUU4s/3mizTTb9dPMKLa3EIrEvtpxyDy6woHJLLrPIMjYoY3A4NjYAACDfgReeeOORV55556GXnnrrsdeee+/BF59889FXn3334Zeffvvx159//wEYoIADEliggQcimKCCCzLYoINghy02zTo/DTXRQ0f9c9FLK520zTfzvHPOM/fMdNNIC3011U77rHXVVks99dFGAx101ljjXHPXXHv99dYPQhihhBNSWKGFF2KYoYYbctihh9F9SJ2I15XY3YqwoHxLyiaTMjYoaWJtMTA0NwBjcDEwNDcAAAGcJGDIH5c04sgCDDTgwAMQRCDBBJ0UgsAhGGQgySMcdODBB4AEIsgghChwwQaIJKLIIowUYMABkERiwSSUVGIJAZhkoskmFFTgiQYggCIOOeCEM04558Qjigs8oLACHyako8466LTjzjvsfBMCCSqksIMXLbwgDDHABDNMMcdEYwoLJXzhww/4JKPMMsg048wzzIChwwhAnNCDCNiEIcYYZJRhxhlopLHKLvD0408ssKixBhttuPEGHHHIoYou5uBiDCm1+DEHHXXYcQceeegRyi/QbOGNK6yMUsotqZxiCy+9+NINKq90Qcs1ewQhxBBEFGHEEUgk0Qo99sgzTz19KLEEE0048QQUUUiRyz785KPPP1zcMwUVVVhxBRZZaCELNdZIM001MMQgwww01GDDDTjkMMs23GSjzScAAAAAAAAAAk4ETgVOBk4PThJOF04fTiBOIU4jTiZOKU4uTi9OMU4zTjVON048TkBOQU5CTkRORk5KTlFOVU5XTlpOW05iTmNOZE5lTmdOaE5qTmtObE5tTm5Ob05yTnROdU52TndOeE55TnpOe058Tn1Of06AToFOgk6DToROhU6HTopOkE6WTpdOmU6cTp1Onk6jTqpOr06wTrFOtE62TrdOuE65TrxOvU6+TshOzE7PTtBO0k7aTttO3E7gTuJO5k7nTulO7U7uTu9O8U70TvhO+U76TvxO/k4ATwJPA08ETwVPBk8HTwhPC08MTxJPE08UTxVPFk8cTx1PIU8jTyhPKU8sTy1PLk8xTzNPNU83TzlPO08+Tz9PQE9BT0JPRE9FT0dPSE9JT0pPS09MT1JPVE9WT2FPYk9mT2hPak9rT21Pbk9xT3JPdU93T3hPeU96T31PgE+BT4JPhU+GT4dPik+MT45PkE+ST5NPlU+WT5hPmU+aT5xPnk+fT6FPok+kT6tPrU+wT7FPsk+zT7RPtk+3T7hPuU+6T7tPvE+9T75PwE/BT8JPxk/HT8hPyU/LT8xPzU/ST9NP1E/VT9ZP2U/bT+BP4k/kT+VP50/rT+xP8E/yT/RP9U/2T/dP+U/7T/xP/U//TwBQAVACUANQBFAFUAZQB1AIUAlQClALUA5QEFARUBNQFVAWUBdQG1AdUB5QIFAiUCNQJFAnUCtQL1AwUDFQMlAzUDRQNVA2UDdQOFA5UDtQPVA/UEBQQVBCUERQRVBGUElQSlBLUE1QUFBRUFJQU1BUUFZQV1BYUFlQW1BdUF5QX1BgUGFQYlBjUGRQZlBnUGhQaVBqUGtQbVBuUG9QcFBxUHJQc1B0UHVQeFB5UHpQfFB9UIFQglCDUIRQhlCHUIlQilCLUIxQjlCPUJBQkVCSUJNQlFCVUJZQl1CYUJlQmlCbUJxQnVCeUJ9QoFChUKJQpFCmUKpQq1CtUK5Qr1CwULFQs1C0ULVQtlC3ULhQuVC8UL1QvlC/UMBQwVDCUMNQxFDFUMZQx1DIUMlQylDLUMxQzVDOUNBQ0VDSUNNQ1FDVUNdQ2FDZUNtQ3FDdUN5Q31DgUOFQ4lDjUORQ5VDoUOlQ6lDrUO9Q8FDxUPJQ9FD2UPdQ+FD5UPpQ/FD9UP5Q/1AAUQFRAlEDUQRRBVEIUQlRClEMUQ1RDlEPURBREVETURRRFVEWURdRGFEZURpRG1EcUR1RHlEfUSBRIlEjUSRRJVEmUSdRKFEpUSpRK1EsUS1RLlEvUTBRMVEyUTNRNFE1UTZRN1E4UTlROlE7UTxRPVE+UUJRR1FKUUxRTlFPUVBRUlFTUVdRWFFZUVtRXVFeUV9RYFFhUWNRZFFmUWdRaVFqUW9RclF6UX5Rf1GDUYRRhlGHUYpRi1GOUY9RkFGRUZNRlFGYUZpRnVGeUZ9RoVGjUaZRp1GoUalRqlGtUa5RtFG4UblRulG+Ub9RwVHCUcNRxVHIUcpRzVHOUdBR0lHTUdRR1VHWUddR2FHZUdpR3FHeUd9R4lHjUeVR5lHnUehR6VHqUexR7lHxUfJR9FH3Uf5RBFIFUglSC1IMUg9SEFITUhRSFVIcUh5SH1IhUiJSI1IlUiZSJ1IqUixSL1IxUjJSNFI1UjxSPlJEUkVSRlJHUkhSSVJLUk5ST1JSUlNSVVJXUlhSWVJaUltSXVJfUmBSYlJjUmRSZlJoUmtSbFJtUm5ScFJxUnNSdFJ1UnZSd1J4UnlSelJ7UnxSflKAUoNShFKFUoZSh1KJUopSi1KMUo1SjlKPUpFSklKUUpVSllKXUphSmVKaUpxSpFKlUqZSp1KuUq9SsFK0UrVStlK3UrhSuVK6UrtSvFK9UsBSwVLCUsRSxVLGUshSylLMUs1SzlLPUtFS01LUUtVS11LZUtpS21LcUt1S3lLgUuFS4lLjUuVS5lLnUuhS6VLqUutS7FLtUu5S71LxUvJS81L0UvVS9lL3UvhS+1L8Uv1SAVMCUwNTBFMHUwlTClMLUwxTDlMRUxJTE1MUUxhTG1McUx5TH1MiUyRTJVMnUyhTKVMrUyxTLVMvUzBTMVMyUzNTNFM1UzZTN1M4UzxTPVNAU0JTRFNGU0tTTFNNU1BTVFNYU1lTW1NdU2VTaFNqU2xTbVNyU3ZTeVN7U3xTfVN+U4BTgVODU4dTiFOKU45Tj1OQU5FTklOTU5RTllOXU5lTm1OcU55ToFOhU6RTp1OqU6tTrFOtU69TsFOxU7JTs1O0U7VTt1O4U7lTulO8U71TvlPAU8NTxFPFU8ZTx1POU89T0FPSU9NT1VPaU9xT3VPeU+FT4lPnU/RT+lP+U/9TAFQCVAVUB1QLVBRUGFQZVBpUHFQiVCRUJVQqVDBUM1Q2VDdUOlQ9VD9UQVRCVERURVRHVElUTFRNVE5UT1RRVFpUXVReVF9UYFRhVGNUZVRnVGlUalRrVGxUbVRuVG9UcFR0VHlUelR+VH9UgVSDVIVUh1SIVIlUilSNVJFUk1SXVJhUnFSeVJ9UoFShVKJUpVSuVLBUslS1VLZUt1S5VLpUvFS+VMNUxVTKVMtU1lTYVNtU4FThVOJU41TkVOtU7FTvVPBU8VT0VPVU9lT3VPhU+VT7VP5UAFUCVQNVBFUFVQhVClULVQxVDVUOVRJVE1UVVRZVF1UYVRlVGlUcVR1VHlUfVSFVJVUmVShVKVUrVS1VMlU0VTVVNlU4VTlVOlU7VT1VQFVCVUVVR1VIVUtVTFVNVU5VT1VRVVJVU1VUVVdVWFVZVVpVW1VdVV5VX1VgVWJVY1VoVWlVa1VvVXBVcVVyVXNVdFV5VXpVfVV/VYVVhlWMVY1VjlWQVZJVk1WVVZZVl1WaVZtVnlWgVaFVolWjVaRVpVWmVahVqVWqVatVrFWtVa5Vr1WwVbJVtFW2VbhVulW8Vb9VwFXBVcJVw1XGVcdVyFXKVctVzlXPVdBV1VXXVdhV2VXaVdtV3lXgVeJV51XpVe1V7lXwVfFV9FX2VfhV+VX6VftV/FX/VQJWA1YEVgVWBlYHVgpWC1YNVhBWEVYSVhNWFFYVVhZWF1YZVhpWHFYdViBWIVYiViVWJlYoVilWKlYrVi5WL1YwVjNWNVY3VjhWOlY8Vj1WPlZAVkFWQlZDVkRWRVZGVkdWSFZJVkpWS1ZPVlBWUVZSVlNWVVZWVlpWW1ZdVl5WX1ZgVmFWY1ZlVmZWZ1ZtVm5Wb1ZwVnJWc1Z0VnVWd1Z4VnlWelZ9Vn5Wf1aAVoFWglaDVoRWh1aIVolWilaLVoxWjVaQVpFWklaUVpVWllaXVphWmVaaVptWnFadVp5Wn1agVqFWolakVqVWplanVqhWqVaqVqtWrFatVq5WsFaxVrJWs1a0VrVWtla4VrlWula7Vr1Wvla/VsBWwVbCVsNWxFbFVsZWx1bIVslWy1bMVs1WzlbPVtBW0VbSVtNW1VbWVthW2VbcVuNW5VbmVudW6FbpVupW7FbuVu9W8lbzVvZW91b4VvtW/FYAVwFXAlcFVwdXC1cMVw1XDlcPVxBXEVcSVxNXFFcVVxZXF1cYVxlXGlcbVx1XHlcgVyFXIlckVyVXJlcnVytXMVcyVzRXNVc2VzdXOFc8Vz1XP1dBV0NXRFdFV0ZXSFdJV0tXUldTV1RXVVdWV1hXWVdiV2NXZVdnV2xXbldwV3FXcld0V3VXeFd5V3pXfVd+V39XgFeBV4dXiFeJV4pXjVeOV49XkFeRV5RXlVeWV5dXmFeZV5pXnFedV55Xn1elV6hXqlesV69XsFexV7NXtVe2V7dXuVe6V7tXvFe9V75Xv1fAV8FXxFfFV8ZXx1fIV8lXylfMV81X0FfRV9NX1lfXV9tX3FfeV+FX4lfjV+VX5lfnV+hX6VfqV+tX7FfuV/BX8VfyV/NX9Vf2V/dX+1f8V/5X/1cBWANYBFgFWAhYCVgKWAxYDlgPWBBYElgTWBRYFlgXWBhYGlgbWBxYHVgfWCJYI1glWCZYJ1goWClYK1gsWC1YLlgvWDFYMlgzWDRYNlg3WDhYOVg6WDtYPFg9WD5YP1hAWEFYQlhDWEVYRlhHWEhYSVhKWEtYTlhPWFBYUlhTWFVYVlhXWFlYWlhbWFxYXVhfWGBYYVhiWGNYZFhmWGdYaFhpWGpYbVhuWG9YcFhxWHJYc1h0WHVYdlh3WHhYeVh6WHtYfFh9WH9YgliEWIZYh1iIWIpYi1iMWI1YjliPWJBYkViUWJVYlliXWJhYm1icWJ1YoFihWKJYo1ikWKVYplinWKpYq1isWK1YrlivWLBYsViyWLNYtFi1WLZYt1i4WLlYuli7WL1Yvli/WMBYwljDWMRYxljHWMhYyVjKWMtYzFjNWM5Yz1jQWNJY01jUWNZY11jYWNlY2ljbWNxY3VjeWN9Y4FjhWOJY41jlWOZY51joWOlY6ljtWO9Y8VjyWPRY9Vj3WPhY+lj7WPxY/Vj+WP9YAFkBWQNZBVkGWQhZCVkKWQtZDFkOWRBZEVkSWRNZF1kYWRtZHVkeWSBZIVkiWSNZJlkoWSxZMFkyWTNZNVk2WTtZPVk+WT9ZQFlDWUVZRllKWUxZTVlQWVJZU1lZWVtZXFldWV5ZX1lhWWNZZFlmWWdZaFlpWWpZa1lsWW1ZbllvWXBZcVlyWXVZd1l6WXtZfFl+WX9ZgFmFWYlZi1mMWY5Zj1mQWZFZlFmVWZhZmlmbWZxZnVmfWaBZoVmiWaZZp1msWa1ZsFmxWbNZtFm1WbZZt1m4WbpZvFm9Wb9ZwFnBWcJZw1nEWcVZx1nIWclZzFnNWc5Zz1nVWdZZ2VnbWd5Z31ngWeFZ4lnkWeZZ51npWepZ61ntWe5Z71nwWfFZ8lnzWfRZ9Vn2WfdZ+Fn6WfxZ/Vn+WQBaAloKWgtaDVoOWg9aEFoSWhRaFVoWWhdaGVoaWhtaHVoeWiFaIlokWiZaJ1ooWipaK1osWi1aLlovWjBaM1o1WjdaOFo5WjpaO1o9Wj5aP1pBWkJaQ1pEWkVaR1pIWktaTFpNWk5aT1pQWlFaUlpTWlRaVlpXWlhaWVpbWlxaXVpeWl9aYFphWmNaZFplWmZaaFppWmtabFptWm5ab1pwWnFaclpzWnhaeVp7WnxafVp+WoBagVqCWoNahFqFWoZah1qIWolailqLWoxajVqOWo9akFqRWpNalFqVWpZal1qYWplanFqdWp5an1qgWqFaolqjWqRapVqmWqdaqFqpWqtarFqtWq5ar1qwWrFatFq2WrdauVq6WrtavFq9Wr9awFrDWsRaxVrGWsdayFrKWstazVrOWs9a0FrRWtNa1VrXWtla2lrbWt1a3lrfWuJa5FrlWuda6FrqWuxa7VruWu9a8FryWvNa9Fr1WvZa91r4Wvla+lr7Wvxa/Vr+Wv9aAFsBWwJbA1sEWwVbBlsHWwhbClsLWwxbDVsOWw9bEFsRWxJbE1sUWxVbGFsZWxpbG1scWx1bHlsfWyBbIVsiWyNbJFslWyZbJ1soWylbKlsrWyxbLVsuWy9bMFsxWzNbNVs2WzhbOVs6WztbPFs9Wz5bP1tBW0JbQ1tEW0VbRltHW0hbSVtKW0tbTFtNW05bT1tSW1ZbXltgW2FbZ1toW2tbbVtuW29bclt0W3Zbd1t4W3lbe1t8W35bf1uCW4ZbiluNW45bkFuRW5JblFuWW59bp1uoW6lbrFutW65br1uxW7Jbt1u6W7tbvFvAW8Fbw1vIW8lbylvLW81bzlvPW9Fb1FvVW9Zb11vYW9lb2lvbW9xb4FviW+Nb5lvnW+lb6lvrW+xb7VvvW/Fb8lvzW/Rb9Vv2W/db/Vv+WwBcAlwDXAVcB1wIXAtcDFwNXA5cEFwSXBNcF1wZXBtcHlwfXCBcIVwjXCZcKFwpXCpcK1wtXC5cL1wwXDJcM1w1XDZcN1xDXERcRlxHXExcTVxSXFNcVFxWXFdcWFxaXFtcXFxdXF9cYlxkXGdcaFxpXGpca1xsXG1ccFxyXHNcdFx1XHZcd1x4XHtcfFx9XH5cgFyDXIRchVyGXIdciVyKXItcjlyPXJJck1yVXJ1cnlyfXKBcoVykXKVcplynXKhcqlyuXK9csFyyXLRctly5XLpcu1y8XL5cwFzCXMNcxVzGXMdcyFzJXMpczFzNXM5cz1zQXNFc01zUXNVc1lzXXNhc2lzbXNxc3VzeXN9c4FziXONc51zpXOtc7FzuXO9c8VzyXPNc9Fz1XPZc91z4XPlc+lz8XP1c/lz/XABdAV0EXQVdCF0JXQpdC10MXQ1dD10QXRFdEl0TXRVdF10YXRldGl0cXR1dH10gXSFdIl0jXSVdKF0qXStdLF0vXTBdMV0yXTNdNV02XTddOF05XTpdO108XT9dQF1BXUJdQ11EXUVdRl1IXUldTV1OXU9dUF1RXVJdU11UXVVdVl1XXVldWl1cXV5dX11gXWFdYl1jXWRdZV1mXWddaF1qXW1dbl1wXXFdcl1zXXVddl13XXhdeV16XXtdfF19XX5df12AXYFdg12EXYVdhl2HXYhdiV2KXYtdjF2NXY5dj12QXZFdkl2TXZRdlV2WXZddmF2aXZtdnF2eXZ9doF2hXaJdo12kXaVdpl2nXahdqV2qXatdrF2tXa5dr12wXbFdsl2zXbRdtV22XbhduV26XbtdvF29Xb5dv13AXcFdwl3DXcRdxl3HXchdyV3KXctdzF3OXc9d0F3RXdJd013UXdVd1l3XXdhd2V3aXdxd313gXeNd5F3qXexd7V3wXfVd9l34Xfld+l37Xfxd/10AXgReB14JXgpeC14NXg5eEl4TXhdeHl4fXiBeIV4iXiNeJF4lXiheKV4qXiteLF4vXjBeMl4zXjReNV42XjleOl4+Xj9eQF5BXkNeRl5HXkheSV5KXkteTV5OXk9eUF5RXlJeU15WXldeWF5ZXlpeXF5dXl9eYF5jXmReZV5mXmdeaF5pXmpea15sXm1ebl5vXnBecV51XndeeV5+XoFegl6DXoVeiF6JXoxejV6OXpJemF6bXp1eoV6iXqNepF6oXqleql6rXqxerl6vXrBesV6yXrReul67XrxevV6/XsBewV7CXsNexF7FXsZex17IXstezF7NXs5ez17QXtRe1V7XXthe2V7aXtxe3V7eXt9e4F7hXuJe417kXuVe5l7nXule617sXu1e7l7vXvBe8V7yXvNe9V74Xvle+178Xv1eBV8GXwdfCV8MXw1fDl8QXxJfFF8WXxlfGl8cXx1fHl8hXyJfI18kXyhfK18sXy5fMF8yXzNfNF81XzZfN184XztfPV8+Xz9fQV9CX0NfRF9FX0ZfR19IX0lfSl9LX0xfTV9OX09fUV9UX1lfWl9bX1xfXl9fX2BfY19lX2dfaF9rX25fb19yX3RfdV92X3hfel99X35ff1+DX4ZfjV+OX49fkV+TX5Rfll+aX5tfnV+eX59foF+iX6NfpF+lX6Zfp1+pX6tfrF+vX7BfsV+yX7NftF+2X7hfuV+6X7tfvl+/X8BfwV/CX8dfyF/KX8tfzl/TX9Rf1V/aX9tf3F/eX99f4l/jX+Vf5l/oX+lf7F/vX/Bf8l/zX/Rf9l/3X/lf+l/8XwdgCGAJYAtgDGAQYBFgE2AXYBhgGmAeYB9gImAjYCRgLGAtYC5gMGAxYDJgM2A0YDZgN2A4YDlgOmA9YD5gQGBEYEVgRmBHYEhgSWBKYExgTmBPYFFgU2BUYFZgV2BYYFtgXGBeYF9gYGBhYGVgZmBuYHFgcmB0YHVgd2B+YIBggWCCYIVghmCHYIhgimCLYI5gj2CQYJFgk2CVYJdgmGCZYJxgnmChYKJgpGClYKdgqWCqYK5gsGCzYLVgtmC3YLlgumC9YL5gv2DAYMFgwmDDYMRgx2DIYMlgzGDNYM5gz2DQYNJg02DUYNZg12DZYNtg3mDhYOJg42DkYOVg6mDxYPJg9WD3YPhg+2D8YP1g/mD/YAJhA2EEYQVhB2EKYQthDGEQYRFhEmETYRRhFmEXYRhhGWEbYRxhHWEeYSFhImElYShhKWEqYSxhLWEuYS9hMGExYTJhM2E0YTVhNmE3YThhOWE6YTthPGE9YT5hQGFBYUJhQ2FEYUVhRmFHYUlhS2FNYU9hUGFSYVNhVGFWYVdhWGFZYVphW2FcYV5hX2FgYWFhY2FkYWVhZmFpYWpha2FsYW1hbmFvYXFhcmFzYXRhdmF4YXlhemF7YXxhfWF+YX9hgGGBYYJhg2GEYYVhhmGHYYhhiWGKYYxhjWGPYZBhkWGSYZNhlWGWYZdhmGGZYZphm2GcYZ5hn2GgYaFhomGjYaRhpWGmYaphq2GtYa5hr2GwYbFhsmGzYbRhtWG2YbhhuWG6YbthvGG9Yb9hwGHBYcNhxGHFYcZhx2HJYcxhzWHOYc9h0GHTYdVh1mHXYdhh2WHaYdth3GHdYd5h32HgYeFh4mHjYeRh5WHnYehh6WHqYeth7GHtYe5h72HwYfFh8mHzYfRh9mH3Yfhh+WH6Yfth/GH9Yf5hAGIBYgJiA2IEYgViB2IJYhNiFGIZYhxiHWIeYiBiI2ImYidiKGIpYitiLWIvYjBiMWIyYjViNmI4YjliOmI7YjxiQmJEYkViRmJKYk9iUGJVYlZiV2JZYlpiXGJdYl5iX2JgYmFiYmJkYmViaGJxYnJidGJ1YndieGJ6YntifWKBYoJig2KFYoZih2KIYotijGKNYo5ij2KQYpRimWKcYp1inmKjYqZip2KpYqpirWKuYq9isGKyYrNitGK2YrdiuGK6Yr5iwGLBYsNiy2LPYtFi1WLdYt5i4GLhYuRi6mLrYvBi8mL1Yvhi+WL6YvtiAGMDYwRjBWMGYwpjC2MMYw1jD2MQYxJjE2MUYxVjF2MYYxljHGMmYydjKWMsYy1jLmMwYzFjM2M0YzVjNmM3YzhjO2M8Yz5jP2NAY0FjRGNHY0hjSmNRY1JjU2NUY1ZjV2NYY1ljWmNbY1xjXWNgY2RjZWNmY2hjamNrY2xjb2NwY3Jjc2N0Y3VjeGN5Y3xjfWN+Y39jgWODY4RjhWOGY4tjjWORY5NjlGOVY5djmWOaY5tjnGOdY55jn2OhY6RjpmOrY69jsWOyY7VjtmO5Y7tjvWO/Y8BjwWPCY8NjxWPHY8hjymPLY8xj0WPTY9Rj1WPXY9hj2WPaY9tj3GPdY99j4mPkY+Vj5mPnY+hj62PsY+5j72PwY/Fj82P1Y/dj+WP6Y/tj/GP+YwNkBGQGZAdkCGQJZApkDWQOZBFkEmQVZBZkF2QYZBlkGmQdZB9kImQjZCRkJWQnZChkKWQrZC5kL2QwZDFkMmQzZDVkNmQ3ZDhkOWQ7ZDxkPmRAZEJkQ2RJZEtkTGRNZE5kT2RQZFFkU2RVZFZkV2RZZFpkW2RcZF1kX2RgZGFkYmRjZGRkZWRmZGhkamRrZGxkbmRvZHBkcWRyZHNkdGR1ZHZkd2R7ZHxkfWR+ZH9kgGSBZINkhmSIZIlkimSLZIxkjWSOZI9kkGSTZJRkl2SYZJpkm2ScZJ1kn2SgZKFkomSjZKVkpmSnZKhkqmSrZK9ksWSyZLNktGS2ZLlku2S9ZL5kv2TBZMNkxGTGZMdkyGTJZMpky2TMZM9k0WTTZNRk1WTWZNlk2mTbZNxk3WTfZOBk4WTjZOVk52ToZOlk6mTrZOxk7WTuZO9k8GTxZPJk82T0ZPVk9mT3ZPhk+WT6ZPtk/GT9ZP5k/2QBZQJlA2UEZQVlBmUHZQhlCmULZQxlDWUOZQ9lEGURZRNlFGUVZRZlF2UZZRplG2UcZR1lHmUfZSBlIWUiZSNlJGUmZSdlKGUpZSplLGUtZTBlMWUyZTNlN2U6ZTxlPWVAZUFlQmVDZURlRmVHZUplS2VNZU5lUGVSZVNlVGVXZVhlWmVcZV9lYGVhZWRlZWVnZWhlaWVqZW1lbmVvZXFlc2V1ZXZleGV5ZXple2V8ZX1lfmV/ZYBlgWWCZYNlhGWFZYZliGWJZYpljWWOZY9lkmWUZZVllmWYZZplnWWeZaBlomWjZaZlqGWqZaxlrmWxZbJls2W0ZbVltmW3ZbhlumW7Zb5lv2XAZcJlx2XIZcllymXNZdBl0WXTZdRl1WXYZdll2mXbZdxl3WXeZd9l4WXjZeRl6mXrZfJl82X0ZfVl+GX5Zftl/GX9Zf5l/2UBZgRmBWYHZghmCWYLZg1mEGYRZhJmFmYXZhhmGmYbZhxmHmYhZiJmI2YkZiZmKWYqZitmLGYuZjBmMmYzZjdmOGY5ZjpmO2Y9Zj9mQGZCZkRmRWZGZkdmSGZJZkpmTWZOZlBmUWZYZllmW2ZcZl1mXmZgZmJmY2ZlZmdmaWZqZmtmbGZtZnFmcmZzZnVmeGZ5ZntmfGZ9Zn9mgGaBZoNmhWaGZohmiWaKZotmjWaOZo9mkGaSZpNmlGaVZphmmWaaZptmnGaeZp9moGahZqJmo2akZqVmpmapZqpmq2asZq1mr2awZrFmsmazZrVmtma3Zrhmuma7ZrxmvWa/ZsBmwWbCZsNmxGbFZsZmx2bIZslmymbLZsxmzWbOZs9m0GbRZtJm02bUZtVm1mbXZthm2mbeZt9m4GbhZuJm42bkZuVm52boZupm62bsZu1m7mbvZvFm9Wb2Zvhm+mb7Zv1mAWcCZwNnBGcFZwZnB2cMZw5nD2cRZxJnE2cWZxhnGWcaZxxnHmcgZyFnImcjZyRnJWcnZylnLmcwZzJnM2c2ZzdnOGc5ZztnPGc+Zz9nQWdEZ0VnR2dKZ0tnTWdSZ1RnVWdXZ1hnWWdaZ1tnXWdiZ2NnZGdmZ2dna2dsZ25ncWd0Z3ZneGd5Z3pne2d9Z4BngmeDZ4VnhmeIZ4pnjGeNZ45nj2eRZ5Jnk2eUZ5ZnmWebZ59noGehZ6RnpmepZ6xnrmexZ7JntGe5Z7pnu2e8Z71nvme/Z8BnwmfFZ8Znx2fIZ8lnymfLZ8xnzWfOZ9Vn1mfXZ9tn32fhZ+Nn5GfmZ+dn6GfqZ+tn7WfuZ/Jn9Wf2Z/dn+Gf5Z/pn+2f8Z/5nAWgCaANoBGgGaA1oEGgSaBRoFWgYaBloGmgbaBxoHmgfaCBoImgjaCRoJWgmaCdoKGgraCxoLWguaC9oMGgxaDRoNWg2aDpoO2g/aEdoS2hNaE9oUmhWaFdoWGhZaFpoW2hcaF1oXmhfaGpobGhtaG5ob2hwaHFocmhzaHVoeGh5aHpoe2h8aH1ofmh/aIBogmiEaIdoiGiJaIpoi2iMaI1ojmiQaJFokmiUaJVolmiYaJlommibaJxonWieaJ9ooGihaKNopGilaKloqmiraKxormixaLJotGi2aLdouGi5aLpou2i8aL1ovmi/aMFow2jEaMVoxmjHaMhoymjMaM5oz2jQaNFo02jUaNZo12jZaNto3GjdaN5o32jhaOJo5GjlaOZo52joaOlo6mjraOxo7WjvaPJo82j0aPZo92j4aPto/Wj+aP9oAGkCaQNpBGkGaQdpCGkJaQppDGkPaRFpE2kUaRVpFmkXaRhpGWkaaRtpHGkdaR5pIWkiaSNpJWkmaSdpKGkpaSppK2ksaS5pL2kxaTJpM2k1aTZpN2k4aTppO2k8aT5pQGlBaUNpRGlFaUZpR2lIaUlpSmlLaUxpTWlOaU9pUGlRaVJpU2lVaVZpWGlZaVtpXGlfaWFpYmlkaWVpZ2loaWlpamlsaW1pb2lwaXJpc2l0aXVpdml6aXtpfWl+aX9pgWmDaYVpimmLaYxpjmmPaZBpkWmSaZNplmmXaZlpmmmdaZ5pn2mgaaFpommjaaRppWmmaalpqmmsaa5pr2mwabJps2m1abZpuGm5abppvGm9ab5pv2nAacJpw2nEacVpxmnHachpyWnLac1pz2nRadJp02nVadZp12nYadlp2mncad1p3mnhaeJp42nkaeVp5mnnaehp6Wnqaetp7Gnuae9p8GnxafNp9Gn1afZp92n4aflp+mn7afxp/mkAagFqAmoDagRqBWoGagdqCGoJagtqDGoNag5qD2oQahFqEmoTahRqFWoWahlqGmobahxqHWoeaiBqImojaiRqJWomaidqKWoraixqLWouajBqMmozajRqNmo3ajhqOWo6ajtqPGo/akBqQWpCakNqRWpGakhqSWpKaktqTGpNak5qT2pRalJqU2pUalVqVmpXalpqXGpdal5qX2pgamJqY2pkamZqZ2poamlqampramxqbWpuam9qcGpyanNqdGp1anZqd2p4anpqe2p9an5qf2qBaoJqg2qFaoZqh2qIaolqimqLaoxqjWqPapJqk2qUapVqlmqYaplqmmqbapxqnWqeap9qoWqiaqNqpGqlaqZqp2qoaqpqrWquaq9qsGqxarJqs2q0arVqtmq3arhquWq6artqvGq9ar5qv2rAasFqwmrDasRqxWrGasdqyGrJaspqy2rMas1qzmrPatBq0WrSatNq1GrVatZq12rYatlq2mrbatxq3Wreat9q4GrhauJq42rkauVq5mrnauhq6Wrqautq7Grtau5q72rwavFq8mrzavRq9Wr2avdq+Gr5avpq+2r8av1q/mr/agBrAWsCawNrBGsFawZrB2sIawlrCmsLawxrDWsOaw9rEGsRaxJrE2sUaxVrFmsXaxhrGWsaaxtrHGsdax5rH2slayZrKGspayprK2ssay1rLmsvazBrMWszazRrNWs2azhrO2s8az1rP2tAa0FrQmtEa0VrSGtKa0trTWtOa09rUGtRa1JrU2tUa1VrVmtXa1hrWmtba1xrXWtea19rYGtha2hraWtra2xrbWtua29rcGtxa3Jrc2t0a3Vrdmt3a3hremt9a35rf2uAa4VriGuMa45rj2uQa5FrlGuVa5drmGuZa5xrnWuea59roGuia6NrpGula6Zrp2uoa6lrq2usa61rrmuva7BrsWuya7ZruGu5a7pru2u8a71rvmvAa8NrxGvGa8dryGvJa8przGvOa9Br0WvYa9pr3Gvda95r32vga+Jr42vka+Vr5mvna+hr6Wvsa+1r7mvwa/Fr8mv0a/Zr92v4a/pr+2v8a/5r/2sAbAFsAmwDbARsCGwJbApsC2wMbA5sEmwXbBxsHWwebCBsI2wlbCtsLGwtbDFsM2w2bDdsOWw6bDtsPGw+bD9sQ2xEbEVsSGxLbExsTWxObE9sUWxSbFNsVmxYbFlsWmxibGNsZWxmbGdsa2xsbG1sbmxvbHFsc2x1bHdseGx6bHtsfGx/bIBshGyHbIpsi2yNbI5skWySbJVslmyXbJhsmmycbJ1snmygbKJsqGysbK9ssGy0bLVstmy3bLpswGzBbMJsw2zGbMdsyGzLbM1szmzPbNFs0mzYbNls2mzcbN1s32zkbOZs52zpbOxs7WzybPRs+Wz/bABtAm0DbQVtBm0IbQltCm0NbQ9tEG0RbRNtFG0VbRZtGG0cbR1tH20gbSFtIm0jbSRtJm0obSltLG0tbS9tMG00bTZtN204bTptP21AbUJtRG1JbUxtUG1VbVZtV21YbVttXW1fbWFtYm1kbWVtZ21obWttbG1tbXBtcW1ybXNtdW12bXltem17bX1tfm1/bYBtgW2DbYRthm2HbYpti22NbY9tkG2SbZZtl22YbZltmm2cbaJtpW2sba1tsG2xbbNttG22bbdtuW26bbttvG29bb5twW3CbcNtyG3JbcptzW3Obc9t0G3SbdNt1G3Vbddt2m3bbdxt323ibeNt5W3nbeht6W3qbe1t723wbfJt9G31bfZt+G36bf1t/m3/bQBuAW4CbgNuBG4GbgduCG4JbgtuD24SbhNuFW4YbhluG24cbh5uH24ibiZuJ24obipuLG4ubjBuMW4zbjVuNm43bjluO248bj1uPm4/bkBuQW5CbkVuRm5HbkhuSW5KbktuTG5PblBuUW5SblVuV25ZblpuXG5dbl5uYG5hbmJuY25kbmVuZm5nbmhuaW5qbmxubW5vbnBucW5ybnNudG51bnZud254bnluem57bnxufW6AboFugm6EboduiG6KbotujG6Nbo5ukW6SbpNulG6VbpZul26Zbppum26dbp5uoG6hbqNupG6mbqhuqW6rbqxurW6ubrBus261brhuuW68br5uv27AbsNuxG7FbsZuyG7JbspuzG7Nbs5u0G7SbtZu2G7Zbttu3G7dbuNu527qbutu7G7tbu5u727wbvFu8m7zbvVu9m73bvhu+m77bvxu/W7+bv9uAG8BbwNvBG8FbwdvCG8KbwtvDG8Nbw5vEG8RbxJvFm8XbxhvGW8abxtvHG8dbx5vH28hbyJvI28lbyZvJ28obyxvLm8wbzJvNG81bzdvOG85bzpvO288bz1vP29Ab0FvQm9Db0RvRW9Ib0lvSm9Mb05vT29Qb1FvUm9Tb1RvVW9Wb1dvWW9ab1tvXW9fb2BvYW9jb2RvZW9nb2hvaW9qb2tvbG9vb3BvcW9zb3Vvdm93b3lve299b35vf2+Ab4Fvgm+Db4Vvhm+Hb4pvi2+Pb5BvkW+Sb5NvlG+Vb5Zvl2+Yb5lvmm+bb51vnm+fb6Bvom+jb6RvpW+mb6hvqW+qb6tvrG+tb65vr2+wb7Fvsm+0b7Vvt2+4b7pvu2+8b71vvm+/b8Fvw2/Eb8Vvxm/Hb8hvym/Lb8xvzW/Ob89v0G/Tb9Rv1W/Wb9dv2G/Zb9pv22/cb91v32/ib+Nv5G/lb+Zv52/ob+lv6m/rb+xv7W/wb/Fv8m/zb/Rv9W/2b/dv+G/5b/pv+2/8b/1v/m//bwBwAXACcANwBHAFcAZwB3AIcAlwCnALcAxwDXAOcA9wEHAScBNwFHAVcBZwF3AYcBlwHHAdcB5wH3AgcCFwInAkcCVwJnAncChwKXAqcCtwLHAtcC5wL3AwcDFwMnAzcDRwNnA3cDhwOnA7cDxwPXA+cD9wQHBBcEJwQ3BEcEVwRnBHcEhwSXBKcEtwTXBOcFBwUXBScFNwVHBVcFZwV3BYcFlwWnBbcFxwXXBfcGBwYXBicGNwZHBlcGZwZ3BocGlwanBucHFwcnBzcHRwd3B5cHpwe3B9cIFwgnCDcIRwhnCHcIhwi3CMcI1wj3CQcJFwk3CXcJhwmnCbcJ5wn3CgcKFwonCjcKRwpXCmcKdwqHCpcKpwsHCycLRwtXC2cLpwvnC/cMRwxXDGcMdwyXDLcMxwzXDOcM9w0HDRcNJw03DUcNVw1nDXcNpw3HDdcN5w4HDhcOJw43DlcOpw7nDwcPFw8nDzcPRw9XD2cPhw+nD7cPxw/nD/cABxAXECcQNxBHEFcQZxB3EIcQtxDHENcQ5xD3ERcRJxFHEXcRtxHHEdcR5xH3EgcSFxInEjcSRxJXEncShxKXEqcStxLHEtcS5xMnEzcTRxNXE3cThxOXE6cTtxPHE9cT5xP3FAcUFxQnFDcURxRnFHcUhxSXFLcU1xT3FQcVFxUnFTcVRxVXFWcVdxWHFZcVpxW3FdcV9xYHFhcWJxY3FlcWlxanFrcWxxbXFvcXBxcXF0cXVxdnF3cXlxe3F8cX5xf3GAcYFxgnGDcYVxhnGHcYhxiXGLcYxxjXGOcZBxkXGScZNxlXGWcZdxmnGbcZxxnXGecaFxonGjcaRxpXGmcadxqXGqcatxrXGuca9xsHGxcbJxtHG2cbdxuHG6cbtxvHG9cb5xv3HAccFxwnHEccVxxnHHcchxyXHKcctxzHHNcc9x0HHRcdJx03HWcddx2HHZcdpx23Hccd1x3nHfceFx4nHjceRx5nHocelx6nHrcexx7XHvcfBx8XHycfNx9HH1cfZx93H4cfpx+3H8cf1x/nH/cQByAXICcgNyBHIFcgdyCHIJcgpyC3IMcg1yDnIPchByEXISchNyFHIVchZyF3IYchlyGnIbchxyHnIfciByIXIiciNyJHIlciZyJ3IpcityLXIuci9yMnIzcjRyOnI8cj5yQHJBckJyQ3JEckVyRnJJckpyS3JOck9yUHJRclNyVHJVcldyWHJaclxyXnJgcmNyZHJlcmhyanJrcmxybXJwcnFyc3J0cnZyd3J4cntyfHJ9coJyg3KFcoZyh3KIcolyjHKOcpBykXKTcpRylXKWcpdymHKZcppym3Kccp1ynnKgcqFyonKjcqRypXKmcqdyqHKpcqpyq3KucrFysnKzcrVyunK7crxyvXK+cr9ywHLFcsZyx3LJcspyy3LMcs9y0XLTctRy1XLWcthy2nLbcsbkx+TI5MnkyuTL5MzkzeTO5M/k0OTR5NLk0+TU5NXk1uTX5Njk2eTa5Nvk3OTd5N7k3+Tg5OHk4uTj5OTk5eTm5Ofk6OTp5Ork6+Ts5O3k7uTv5PDk8eTy5PPk9OT15Pbk9+T45Pnk+uT75Pzk/eT+5P/kAOUB5QLlA+UE5QXlBuUH5QjlCeUK5QvlDOUN5Q7lD+UQ5RHlEuUT5RTlFeUW5RflGOUZ5RrlG+Uc5R3lHuUf5SDlIeUi5SPlJOUl5QAwATACMLcAyQLHAqgAAzAFMBQgXv8WICYgGCAZIBwgHSAUMBUwCDAJMAowCzAMMA0wDjAPMBYwFzAQMBEwsQDXAPcANiInIigiESIPIioiKSIIIjciGiKlIiUiICISI5kiKyIuImEiTCJIIj0iHSJgIm4ibyJkImUiHiI1IjQiQiZAJrAAMiAzIAMhBP+kAOD/4f8wIKcAFiEGJgUmyyXPJc4lxyXGJaEloCWzJbIlOyCSIZAhkSGTIRMwJuUn5SjlKeUq5SvlLOUt5S7lL+Uw5THlMuUz5TTlNeU25TflOOU55TrlO+U85T3lPuU/5UDlQeVC5UPlROVF5UblR+VI5UnlSuVL5UzlTeVO5U/lUOVR5VLlU+VU5VXlVuVX5VjlWeVa5VvlXOVd5V7lX+Vg5WHlYuVj5WTlZeVm5WflaOVp5Wrla+Vs5W3lbuVv5XDlceVy5XPldOV15Xbld+V45XnleuV75XzlfeV+5X/lgOWB5YLlg+WE5YXlcCFxIXIhcyF0IXUhdiF3IXgheSFm52fnaOdp52rna+eIJIkkiiSLJIwkjSSOJI8kkCSRJJIkkySUJJUkliSXJJgkmSSaJJskdCR1JHYkdyR4JHkkeiR7JHwkfSR+JH8kgCSBJIIkgySEJIUkhiSHJGAkYSRiJGMkZCRlJGYkZyRoJGkkrCBt5yAyITIiMiMyJDIlMiYyJzIoMikybudv52AhYSFiIWMhZCFlIWYhZyFoIWkhaiFrIXDnceeG5YfliOWJ5Yrli+WM5Y3ljuWP5ZDlkeWS5ZPllOWV5Zbll+WY5ZnlmuWb5ZzlneWe5Z/loOWh5aLlo+Wk5aXlpuWn5ajlqeWq5avlrOWt5a7lr+Ww5bHlsuWz5bTlteW25bfluOW55brlu+W85b3lvuW/5cDlweXC5cPlxOXF5cblx+XI5cnlyuXL5czlzeXO5c/l0OXR5dLl0+XU5dXl1uXX5djl2eXa5dvl3OXd5d7l3+Xg5eHl4uXj5eTl5eUB/wL/A//l/wX/Bv8H/wj/Cf8K/wv/DP8N/w7/D/8Q/xH/Ev8T/xT/Ff8W/xf/GP8Z/xr/G/8c/x3/Hv8f/yD/If8i/yP/JP8l/yb/J/8o/yn/Kv8r/yz/Lf8u/y//MP8x/zL/M/80/zX/Nv83/zj/Of86/zv/PP89/z7/P/9A/0H/Qv9D/0T/Rf9G/0f/SP9J/0r/S/9M/03/Tv9P/1D/Uf9S/1P/VP9V/1b/V/9Y/1n/Wv9b/1z/Xf/j/+bl5+Xo5enl6uXr5ezl7eXu5e/l8OXx5fLl8+X05fXl9uX35fjl+eX65fvl/OX95f7l/+UA5gHmAuYD5gTmBeYG5gfmCOYJ5grmC+YM5g3mDuYP5hDmEeYS5hPmFOYV5hbmF+YY5hnmGuYb5hzmHeYe5h/mIOYh5iLmI+Yk5iXmJuYn5ijmKeYq5ivmLOYt5i7mL+Yw5jHmMuYz5jTmNeY25jfmOOY55jrmO+Y85j3mPuY/5kDmQeZC5kPmROZF5kEwQjBDMEQwRTBGMEcwSDBJMEowSzBMME0wTjBPMFAwUTBSMFMwVDBVMFYwVzBYMFkwWjBbMFwwXTBeMF8wYDBhMGIwYzBkMGUwZjBnMGgwaTBqMGswbDBtMG4wbzBwMHEwcjBzMHQwdTB2MHcweDB5MHowezB8MH0wfjB/MIAwgTCCMIMwhDCFMIYwhzCIMIkwijCLMIwwjTCOMI8wkDCRMJIwkzBy53PndOd153bnd+d453nneud753znRuZH5kjmSeZK5kvmTOZN5k7mT+ZQ5lHmUuZT5lTmVeZW5lfmWOZZ5lrmW+Zc5l3mXuZf5mDmYeZi5mPmZOZl5mbmZ+Zo5mnmauZr5mzmbeZu5m/mcOZx5nLmc+Z05nXmduZ35njmeeZ65nvmfOZ95n7mf+aA5oHmguaD5oTmheaG5ofmiOaJ5ormi+aM5o3mjuaP5pDmkeaS5pPmlOaV5pbml+aY5pnmmuab5pzmneae5p/moOah5qLmo+ak5qXmoTCiMKMwpDClMKYwpzCoMKkwqjCrMKwwrTCuMK8wsDCxMLIwszC0MLUwtjC3MLgwuTC6MLswvDC9ML4wvzDAMMEwwjDDMMQwxTDGMMcwyDDJMMowyzDMMM0wzjDPMNAw0TDSMNMw1DDVMNYw1zDYMNkw2jDbMNww3TDeMN8w4DDhMOIw4zDkMOUw5jDnMOgw6TDqMOsw7DDtMO4w7zDwMPEw8jDzMPQw9TD2MH3nfud/54DngeeC54PnhOem5qfmqOap5qrmq+as5q3mruav5rDmseay5rPmtOa15rbmt+a45rnmuua75rzmvea+5r/mwObB5sLmw+bE5sXmxubH5sjmyebK5svmzObN5s7mz+bQ5tHm0ubT5tTm1ebW5tfm2ObZ5trm2+bc5t3m3ubf5uDm4ebi5uPm5Obl5ubm5+bo5unm6ubr5uzm7ebu5u/m8Obx5vLm8+b05vXm9ub35vjm+eb65vvm/Ob95v7m/+YA5wHnAucD5wTnBeeRA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdA54DnwOgA6EDowOkA6UDpgOnA6gDqQOF54bnh+eI54nniueL54znsQOyA7MDtAO1A7YDtwO4A7kDugO7A7wDvQO+A78DwAPBA8MDxAPFA8YDxwPIA8kDjeeO54/nkOeR55Lnk+c1/jb+Of46/j/+QP49/j7+Qf5C/kP+RP6U55XnO/48/jf+OP4x/pbnM/40/pfnmOeZ55rnm+ec553nnuef5wbnB+cI5wnnCucL5wznDecO5w/nEOcR5xLnE+cU5xXnFucX5xjnGeca5xvnHOcd5x7nH+cg5yHnIucj5yTnJecm5yfnKOcp5yrnK+cs5y3nLucv5zDnMecy5zPnNOc15zbnN+c45znnOuc75zznPec+5z/nQOdB50LnQ+dE50XnRudH50jnSedK50vnTOdN507nT+dQ51HnUudT51TnVedW51fnWOdZ51rnW+dc513nXudf52DnYedi52PnZOdl5xAEEQQSBBMEFAQVBAEEFgQXBBgEGQQaBBsEHAQdBB4EHwQgBCEEIgQjBCQEJQQmBCcEKAQpBCoEKwQsBC0ELgQvBKDnoeei56PnpOel56bnp+eo56nnquer56znreeu5zAEMQQyBDMENAQ1BFEENgQ3BDgEOQQ6BDsEPAQ9BD4EPwRABEEEQgRDBEQERQRGBEcESARJBEoESwRMBE0ETgRPBK/nsOex57Lns+e057Xntue357jnuee657vnygLLAtkCEyAVICUgNSAFIQkhliGXIZghmSEVIh8iIyJSImYiZyK/IlAlUSVSJVMlVCVVJVYlVyVYJVklWiVbJVwlXSVeJV8lYCVhJWIlYyVkJWUlZiVnJWglaSVqJWslbCVtJW4lbyVwJXElciVzJYElgiWDJYQlhSWGJYcliCWJJYoliyWMJY0ljiWPJZMllCWVJbwlvSXiJeMl5CXlJQkmlSISMB0wHjC8573nvue/58DnwefC58PnxOfF58bnAQHhAM4B4AATAekAGwHoACsB7QDQAewATQHzANIB8gBrAfoA1AH5ANYB2AHaAdwB/ADqAFECx+dEAUgB+QFhAsnnyufL58znBTEGMQcxCDEJMQoxCzEMMQ0xDjEPMRAxETESMRMxFDEVMRYxFzEYMRkxGjEbMRwxHTEeMR8xIDEhMSIxIzEkMSUxJjEnMSgxKTHN587nz+fQ59Hn0ufT59Tn1efW59fn2OfZ59rn2+fc593n3uff5+Dn4echMCIwIzAkMCUwJjAnMCgwKTCjMo4zjzOcM50znjOhM8QzzjPRM9Iz1TMw/uL/5P/i5yEhMTLj5xAg5Ofl5+bn/DCbMJww/TD+MAYwnTCeMEn+Sv5L/kz+Tf5O/k/+UP5R/lL+VP5V/lb+V/5Z/lr+W/5c/l3+Xv5f/mD+Yf5i/mP+ZP5l/mb+aP5p/mr+a/4+MPAv8S/yL/Mv9C/1L/Yv9y/4L/kv+i/7Lwcw9Of15/bn9+f45/nn+uf75/zn/ef+5//nAOgAJQElAiUDJQQlBSUGJQclCCUJJQolCyUMJQ0lDiUPJRAlESUSJRMlFCUVJRYlFyUYJRklGiUbJRwlHSUeJR8lICUhJSIlIyUkJSUlJiUnJSglKSUqJSslLCUtJS4lLyUwJTElMiUzJTQlNSU2JTclOCU5JTolOyU8JT0lPiU/JUAlQSVCJUMlRCVFJUYlRyVIJUklSiVLJQHoAugD6AToBegG6AfoCOgJ6AroC+gM6A3oDugP6Nxy3XLfcuJy43LkcuVy5nLncupy63L1cvZy+XL9cv5y/3IAcwJzBHMFcwZzB3MIcwlzC3MMcw1zD3MQcxFzEnMUcxhzGXMacx9zIHMjcyRzJnMncyhzLXMvczBzMnMzczVzNnM6cztzPHM9c0BzQXNCc0NzRHNFc0ZzR3NIc0lzSnNLc0xzTnNPc1FzU3NUc1VzVnNYc1lzWnNbc1xzXXNec19zYXNic2NzZHNlc2ZzZ3Noc2lzanNrc25zcHNxcwDgAeAC4APgBOAF4AbgB+AI4AngCuAL4AzgDeAO4A/gEOAR4BLgE+AU4BXgFuAX4BjgGeAa4BvgHOAd4B7gH+Ag4CHgIuAj4CTgJeAm4CfgKOAp4CrgK+As4C3gLuAv4DDgMeAy4DPgNOA14DbgN+A44DngOuA74DzgPeA+4D/gQOBB4ELgQ+BE4EXgRuBH4EjgSeBK4EvgTOBN4E7gT+BQ4FHgUuBT4FTgVeBW4FfgWOBZ4FrgW+Bc4F3gcnNzc3RzdXN2c3dzeHN5c3pze3N8c31zf3OAc4FzgnODc4VzhnOIc4pzjHONc49zkHOSc5NzlHOVc5dzmHOZc5pznHOdc55zoHOhc6NzpHOlc6Zzp3Ooc6pzrHOtc7FztHO1c7ZzuHO5c7xzvXO+c79zwXPDc8RzxXPGc8dzy3PMc85z0nPTc9Rz1XPWc9dz2HPac9tz3HPdc99z4XPic+Nz5HPmc+hz6nPrc+xz7nPvc/Bz8XPzc/Rz9XP2c/dzXuBf4GDgYeBi4GPgZOBl4GbgZ+Bo4GngauBr4GzgbeBu4G/gcOBx4HLgc+B04HXgduB34HjgeeB64HvgfOB94H7gf+CA4IHgguCD4ITgheCG4IfgiOCJ4Irgi+CM4I3gjuCP4JDgkeCS4JPglOCV4Jbgl+CY4JngmuCb4JzgneCe4J/goOCh4KLgo+Ck4KXgpuCn4KjgqeCq4KvgrOCt4K7gr+Cw4LHgsuCz4LTgteC24LfguOC54Lrgu+D4c/lz+nP7c/xz/XP+c/9zAHQBdAJ0BHQHdAh0C3QMdA10DnQRdBJ0E3QUdBV0FnQXdBh0GXQcdB10HnQfdCB0IXQjdCR0J3QpdCt0LXQvdDF0MnQ3dDh0OXQ6dDt0PXQ+dD90QHRCdEN0RHRFdEZ0R3RIdEl0SnRLdEx0TXROdE90UHRRdFJ0U3RUdFZ0WHRddGB0YXRidGN0ZHRldGZ0Z3RodGl0anRrdGx0bnRvdHF0cnRzdHR0dXR4dHl0enS84L3gvuC/4MDgweDC4MPgxODF4Mbgx+DI4MngyuDL4MzgzeDO4M/g0ODR4NLg0+DU4NXg1uDX4Njg2eDa4Nvg3ODd4N7g3+Dg4OHg4uDj4OTg5eDm4Ofg6ODp4Org6+Ds4O3g7uDv4PDg8eDy4PPg9OD14Pbg9+D44Png+uD74Pzg/eD+4P/gAOEB4QLhA+EE4QXhBuEH4QjhCeEK4QvhDOEN4Q7hD+EQ4RHhEuET4RThFeEW4RfhGOEZ4Xt0fHR9dH90gnSEdIV0hnSIdIl0inSMdI10j3SRdJJ0k3SUdJV0lnSXdJh0mXSadJt0nXSfdKB0oXSidKN0pHSldKZ0qnSrdKx0rXSudK90sHSxdLJ0s3S0dLV0tnS3dLh0uXS7dLx0vXS+dL90wHTBdMJ0w3TEdMV0xnTHdMh0yXTKdMt0zHTNdM50z3TQdNF003TUdNV01nTXdNh02XTadNt03XTfdOF05XTndOh06XTqdOt07HTtdPB08XTydBrhG+Ec4R3hHuEf4SDhIeEi4SPhJOEl4SbhJ+Eo4SnhKuEr4SzhLeEu4S/hMOEx4TLhM+E04TXhNuE34TjhOeE64TvhPOE94T7hP+FA4UHhQuFD4UThReFG4UfhSOFJ4UrhS+FM4U3hTuFP4VDhUeFS4VPhVOFV4VbhV+FY4VnhWuFb4VzhXeFe4V/hYOFh4WLhY+Fk4WXhZuFn4WjhaeFq4WvhbOFt4W7hb+Fw4XHhcuFz4XThdeF24Xfh83T1dPh0+XT6dPt0/HT9dP50AHUBdQJ1A3UFdQZ1B3UIdQl1CnULdQx1DnUQdRJ1FHUVdRZ1F3UbdR11HnUgdSF1InUjdSR1JnUndSp1LnU0dTZ1OXU8dT11P3VBdUJ1Q3VEdUZ1R3VJdUp1TXVQdVF1UnVTdVV1VnVXdVh1XXVedV91YHVhdWJ1Y3VkdWd1aHVpdWt1bHVtdW51b3VwdXF1c3V1dXZ1d3V6dXt1fHV9dX51gHWBdYJ1hHWFdYd1eOF54Xrhe+F84X3hfuF/4YDhgeGC4YPhhOGF4Ybhh+GI4YnhiuGL4YzhjeGO4Y/hkOGR4ZLhk+GU4ZXhluGX4ZjhmeGa4ZvhnOGd4Z7hn+Gg4aHhouGj4aThpeGm4afhqOGp4arhq+Gs4a3hruGv4bDhseGy4bPhtOG14bbht+G44bnhuuG74bzhveG+4b/hwOHB4cLhw+HE4cXhxuHH4cjhyeHK4cvhzOHN4c7hz+HQ4dHh0uHT4dTh1eGIdYl1inWMdY11jnWQdZN1lXWYdZt1nHWedaJ1pnWndah1qXWqda11tnW3dbp1u3W/dcB1wXXGdct1zHXOdc910HXRddN113XZddp13HXddd914HXhdeV16XXsde117nXvdfJ183X1dfZ193X4dfp1+3X9df51AnYEdgZ2B3YIdgl2C3YNdg52D3YRdhJ2E3YUdhZ2GnYcdh12HnYhdiN2J3Yodix2LnYvdjF2MnY2djd2OXY6djt2PXZBdkJ2RHbW4dfh2OHZ4drh2+Hc4d3h3uHf4eDh4eHi4ePh5OHl4ebh5+Ho4enh6uHr4ezh7eHu4e/h8OHx4fLh8+H04fXh9uH34fjh+eH64fvh/OH94f7h/+EA4gHiAuID4gTiBeIG4gfiCOIJ4griC+IM4g3iDuIP4hDiEeIS4hPiFOIV4hbiF+IY4hniGuIb4hziHeIe4h/iIOIh4iLiI+Ik4iXiJuIn4ijiKeIq4iviLOIt4i7iL+Iw4jHiMuIz4kV2RnZHdkh2SXZKdkt2TnZPdlB2UXZSdlN2VXZXdlh2WXZadlt2XXZfdmB2YXZidmR2ZXZmdmd2aHZpdmp2bHZtdm52cHZxdnJ2c3Z0dnV2dnZ3dnl2enZ8dn92gHaBdoN2hXaJdop2jHaNdo92kHaSdpR2lXaXdph2mnabdpx2nXaedp92oHahdqJ2o3aldqZ2p3aodql2qnardqx2rXavdrB2s3a1drZ2t3a4drl2una7drx2vXa+dsB2wXbDdkpVP5bDVyhjzlQJVcBUkXZMdjyF7nd+go14MXKYlo2XKGyJW/pPCWOXZrhc+oBIaK6AAmbOdvlRVmWscfF/hIiyUGVZymGzb62CTGNSYu1TJ1QGe2tRpHX0XdRiy412l4piGYBdVziXYn84cn12z2d+dkZkcE8ljdxiF3qRZe1zLGRzYiyCgZh/Z0hybmLMYjRP43RKU55Syn6mkC5ehmicaYCB0X7SaMV4jIZRlY1QJIzegt6ABVMSiWVSxHbHdsl2y3bMdtN21XbZdtp23Hbddt524HbhduJ243bkduZ253bodul26nbrdux27XbwdvN29Xb2dvd2+nb7dv12/3YAdwJ3A3cFdwZ3CncMdw53D3cQdxF3EncTdxR3FXcWdxd3GHcbdxx3HXcedyF3I3ckdyV3J3cqdyt3LHcudzB3MXcydzN3NHc5dzt3PXc+dz93QndEd0V3RndId0l3SndLd0x3TXdOd093UndTd1R3VXdWd1d3WHdZd1x3hIX5lt1PIVhxmZ1bsWKlYrRmeYyNnAZyb2eReLJgUVMXU4iPzIAdjaGUDVDIcgdZ62AZcauIVFnvgixnKHspXfd+LXX1bGaO+I88kDuf1GsZkRR7fF+neNaEPYXVa9lr1msBXode+XXtlV1lCl/FX5+PwVjCgX+QW5atl7mPFn8sjUFiv0/YU15TqI+pj6uPTZAHaGpfmIFoiNaci2ErUip2bF+MZdJv6G6+W0hkdVGwUcRnGU7JeXyZs3Bdd153X3dgd2R3Z3dpd2p3bXdud293cHdxd3J3c3d0d3V3dnd3d3h3end7d3x3gXeCd4N3hneHd4h3iXeKd4t3j3eQd5N3lHeVd5Z3l3eYd5l3mnebd5x3nXeed6F3o3ekd6Z3qHerd613rnevd7F3sne0d7Z3t3e4d7l3une8d753wHfBd8J3w3fEd8V3xnfHd8h3yXfKd8t3zHfOd8930HfRd9J303fUd9V31nfYd9l32nfdd95333fgd+F35HfFdXZeu3Pgg61k6GK1lOJsWlPDUg9kwpSUey9PG142ghaBioEkbspsc5pVY1xT+lRliOBXDU4DXmVrP3zokBZg5mQcc8GIUGdNYiKNbHcpjseRaV/cgyGFEJnCU5WGi2vtYOhgf3DNgjGC006nbM+FzWTZfP1p+WZJg5VTVnunT4xRS21CXG2O0mPJUyyDNoPlZ7R4PWTfW5Rc7l3ni8Zi9Gd6jABkumNJh4uZF4wgf/KUp04QlqSYDGYWc+Z36Hfqd+938Hfxd/J39Hf1d/d3+Xf6d/t3/HcDeAR4BXgGeAd4CHgKeAt4DngPeBB4E3gVeBl4G3geeCB4IXgieCR4KHgqeCt4LngveDF4MngzeDV4Nng9eD94QXhCeEN4RHhGeEh4SXhKeEt4TXhPeFF4U3hUeFh4WXhaeFt4XHheeF94YHhheGJ4Y3hkeGV4ZnhneGh4aXhveHB4cXhyeHN4dHh1eHZ4eHh5eHp4e3h9eH54f3iAeIF4gniDeDpXHVw4Xn+Vf1CggIJTXmVFdTFVIVCFjYRinpQdZzJWbm/iXTVUknBmj29ipGSjY3tfiG/0kOOBsI8YXGhm8V+JbEiWgY1siJFk8HnOV1lqEGJIVFhOC3rpYIRv2ot/Yh6Qi5rkeQNU9HUBYxlTYGzfjxtfcJo7gH+fiE86XGSNxX+lZb1wRVGyUWuGB12gW71ibJF0dQyOIHoBYXl7x074foV3EU7tgR1S+lFxaqhTh44Elc+WwW5kllpphHiFeIZ4iHiKeIt4j3iQeJJ4lHiVeJZ4mXideJ54oHiieKR4pnioeKl4qnireKx4rXiueK94tXi2eLd4uHi6eLt4vHi9eL94wHjCeMN4xHjGeMd4yHjMeM14znjPeNF40njTeNZ413jYeNp423jceN143njfeOB44XjieON45HjleOZ453jpeOp463jteO5473jwePF483j1ePZ4+Hj5ePt4/Hj9eP54/3gAeQJ5A3kEeQZ5B3kIeQl5CnkLeQx5QHioUNd3EGTmiQRZ42PdXX96PWkgTzmCmFUyTq51l3piXope75UbUjlUinB2YySVglclZj9ph5EHVfNtr34iiDNi8H61dSiDwXjMlp6PSGH3dM2LZGs6UlCNIWtqgHGE8VYGU85OG07RUZd8i5EHfMNPf47he5x6Z2QUXaxQBoEBdrl87G3gf1FnWFv4W8t4rmQTZKpjK2MZlS1kvo9Ueyl2U2InWUZUeWujUDRiJl6Ga+NON42LiIVfLpANeQ55D3kQeRF5EnkUeRV5FnkXeRh5GXkaeRt5HHkdeR95IHkheSJ5I3kleSZ5J3koeSl5KnkreSx5LXkueS95MHkxeTJ5M3k1eTZ5N3k4eTl5PXk/eUJ5Q3lEeUV5R3lKeUt5THlNeU55T3lQeVF5UnlUeVV5WHlZeWF5Y3lkeWZ5aXlqeWt5bHlueXB5cXlyeXN5dHl1eXZ5eXl7eXx5fXl+eX95gnmDeYZ5h3mIeYl5i3mMeY15jnmQeZF5knkgYD2AxWI5TlVT+JC4Y8aA5mUubEZP7mDhbd6LOV/LhlNfIWNaUWGDY2gAUmNjSI4SUJtcd3n8WzBSO3q8YFOQ13a3X5dfhHZsjm9we3ZJe6p381GTkCRYTk/0buqPTGUbe8RypG3ff+FatWKVXjBXgoQsex1eH18SkBR/oJiCY8dumHi5cHhRW5erVzV1Q084dZde5mBgWcBtv2uJePxT1ZbLUQFSiWMKVJOUA4zMjTlyn3h2h+2PDYzgU5N5lHmVeZZ5l3mYeZl5m3mceZ15nnmfeaB5oXmieaN5pHmleaZ5qHmpeap5q3msea15rnmvebB5sXmyebR5tXm2ebd5uHm8eb95wnnEecV5x3nIecp5zHnOec950HnTedR51nnXedl52nnbedx53XneeeB54XnieeV56Hnqeex57nnxefJ583n0efV59nn3efl5+nn8ef55/3kBegR6BXoHegh6CXoKegx6D3oQehF6EnoTehV6FnoYehl6G3ocegFO73buU4mUdpgOny2VmluiiyJOHE6sUWOEwmGoUgtol09rYLtRHm1cUZZil2VhlkaMF5DYdf2QY3fSa4py7HL7izVYeXdMjVxnQJWagKZeIW6SWe967Xc7lbVrrWUOfwZYUVEflvlbqVgoVHKOZmV/mORWnZT+dkGQh2PGVBpZOlmbV7KONWf6jTWCQVLwYBVY/oboXEWexE+dmLmLJVp2YIRTfGJPkAKRf5lpYAyAP1EzgBRcdZkxbYxOHXofeiF6InokeiV6Jnoneih6KXoqeit6LHotei56L3owejF6Mno0ejV6Nno4ejp6PnpAekF6QnpDekR6RXpHekh6SXpKekt6THpNek56T3pQelJ6U3pUelV6VnpYell6Wnpbelx6XXpeel96YHphemJ6Y3pkemV6Znpnemh6aXpqemt6bHptem56b3pxenJ6c3p1ent6fHp9en56gnqFeod6iXqKeot6jHqOeo96kHqTepR6mXqaept6nnqheqJ6MI3RU1p/T3sQT09OAJbVbNBz6YUGXmp1+38Kav53kpRBfuFR5nDNU9SPA4Mpja9ybZnbbEpXs4K5ZaqAP2IylqhZ/06/i7p+PmXyg16XYVXemKWAKlP9iyBUuoCfXrhsOY2sglqRKVQbbAZSt35fVxpxfmyJfEtZ/U7/XyRhqnwwTgFcq2cCh/BcC5XOmK91/XAikK9RHX+9i0lZ5FFbTyZUK1l3ZaSAdVt2YsJikI9FXh9sJnsPT9hPDWejeqR6p3qpeqp6q3queq96sHqxerJ6tHq1erZ6t3q4erl6unq7erx6vXq+esB6wXrCesN6xHrFesZ6x3rIesl6ynrMes16znrPetB60XrSetN61HrVetd62Hraett63HrdeuF64nrkeud66Hrpeup663rseu568HrxevJ683r0evV69nr3evh6+3r8ev56AHsBewJ7BXsHewl7DHsNew57EHsSexN7FnsXexh7Gnscex17H3sheyJ7I3sneyl7LXtubaptj3mxiBdfK3WaYoWP70/ckadlL4FRgZxeUIF0jW9SholLjQ1ZhVDYThyWNnJ5gR+NzFuji0SWh1kaf5BUdlYOVuWLOWWCaZmU1naJbnJeGHVGZ9Fn/3qdgHaNH2HGeWJlY42IURpSopQ4f5uAsn6XXC9uYGfZe4t22JqPgZR/1XweZFCVP3pKVOVUTGsBZAhiPZ7zgJl1clJpl1uEPGjkhgGWlJbslCpOBFTZfjlo340VgPRmml65fy97MHsyezR7NXs2ezd7OXs7ez17P3tAe0F7QntDe0R7RntIe0p7TXtOe1N7VXtXe1l7XHtee197YXtje2R7ZXtme2d7aHtpe2p7a3tse217b3twe3N7dHt2e3h7ent8e317f3uBe4J7g3uEe4Z7h3uIe4l7inuLe4x7jnuPe5F7knuTe5Z7mHuZe5p7m3uee597oHuje6R7pXuue697sHuye7N7tXu2e7d7uXu6e7t7vHu9e757v3vAe8J7w3vEe8JXP4CXaOVdO2WfUm1gmp+bT6yObFGrWxNf6V1ebPFiIY1xUamU/lKfbN+C13KiV4RnLY0fWZyPx4OVVI17ME+9bGRb0VkTn+RTyoaomjeMoYBFZX6Y+lbHli5S3HRQUuFbAmMCiVZO0GIqYPpoc1GYW6BRwomhe4aZUH/vYExwL41JUX9eG5BwdMSJLVdFeFJfn5/6lWiPPJvhi3h2QmjcZ+qNNY09UoqP2m7NaAWV7ZD9Vpxn+YjHj8hUxXvIe8l7ynvLe817znvPe9B70nvUe9V71nvXe9h723vce95733vge+J743vke+d76Hvpe+t77Hvte+978Hvye/N79Hv1e/Z7+Hv5e/p7+3v9e/97AHwBfAJ8A3wEfAV8BnwIfAl8CnwNfA58EHwRfBJ8E3wUfBV8F3wYfBl8GnwbfBx8HXwefCB8IXwifCN8JHwlfCh8KXwrfCx8LXwufC98MHwxfDJ8M3w0fDV8Nnw3fDl8Onw7fDx8PXw+fEJ8uJppW3dtJmylTrNbh5pjkahhr5DplytUtW3SW/1RilVVf/B/vGRNY/FlvmGNYApxV2xJbC9ZbWcqgtVYjlZqjOtr3ZB9WReA91NpbXVUnVV3g8+DOGi+eYxUVU8IVNJ2iYwClrNsuG1rjRCJZJ46jT9W0Z7VdYhf4HJoYPxUqE4qamGIUmBwj8RU2HB5hj+eKm2PWxhfon6JVa9PNHM8VJpTGVAOVHxUTk79X1p09lhrhOGAdIfQcsp8Vm5DfER8RXxGfEd8SHxJfEp8S3xMfE58T3xQfFF8UnxTfFR8VXxWfFd8WHxZfFp8W3xcfF18XnxffGB8YXxifGN8ZHxlfGZ8Z3xofGl8anxrfGx8bXxufG98cHxxfHJ8dXx2fHd8eHx5fHp8fnx/fIB8gXyCfIN8hHyFfIZ8h3yIfIp8i3yMfI18jnyPfJB8k3yUfJZ8mXyafJt8oHyhfKN8pnynfKh8qXyrfKx8rXyvfLB8tHy1fLZ8t3y4fLp8u3wnX06GLFWkYpJOqmw3YrGC11ROUz5z0W47dRJSFlPdi9Bpil8AYO5tT1cia69zU2jYjxN/YmOjYCRV6nVijBVxo22mW3teUoNMYcSe+nhXhyd8h3bwUfZgTHFDZkxeTWAOjHBwJWOJj71fYmDUht5WwWuUYGdhSVPgYGZmP439eRpP6XBHbLOL8ovYfmSDD2ZaWkKbUW33bUGMO20ZT2twt4MWYtFgDZcnjXh5+1E+V/pXOmd4dT1673mVe798wHzCfMN8xHzGfMl8y3zOfM980HzRfNJ803zUfNh82nzbfN183nzhfOJ843zkfOV85nznfOl86nzrfOx87XzufPB88XzyfPN89Hz1fPZ893z5fPp8/Hz9fP58/3wAfQF9An0DfQR9BX0GfQd9CH0JfQt9DH0NfQ59D30QfRF9En0TfRR9FX0WfRd9GH0ZfRp9G30cfR19Hn0ffSF9I30kfSV9Jn0ofSl9Kn0sfS19Ln0wfTF9Mn0zfTR9NX02fYyAZZn5j8BvpYshnuxZ6X4JfwlUgWfYaJGPTXzGlspTJWC+dXJsc1PJWqd+JGPgUQqB8V3fhIBigFFjWw5PbXlCUrhgTm3EW8JboYuwi+JlzF9FlpNZ536qfglWt2c5WXNPtlugUlqDipg+jTJ1vpRHUDx69062Z36awVp8a9F2WlcWXDp79JVOcXxRqYBwgnhZBH8ng8Bo7GexeHd442JhY4B77U9qUs9RUIPbaXSS9Y0xjcGJLpWte/ZON304fTl9On07fTx9PX0+fT99QH1BfUJ9Q31EfUV9Rn1HfUh9SX1KfUt9TH1NfU59T31QfVF9Un1TfVR9VX1WfVd9WH1ZfVp9W31cfV19Xn1ffWB9YX1ifWN9ZH1lfWZ9Z31ofWl9an1rfWx9bX1vfXB9cX1yfXN9dH11fXZ9eH15fXp9e318fX19fn1/fYB9gX2CfYN9hH2FfYZ9h32IfYl9in2LfYx9jX2OfY99kH2RfZJ9k32UfZV9ln2XfZh9ZVAwglFSb5kQboVup236XvVQ3FkGXEZtX2yGdYuEaGhWWbKLIFNxkU2WSYUSaQF5JnH2gKROypBHbYSaB1q8VgVk8JTrd6VPGoHhctKJepk0f95+f1JZZXWRf4+Dj+tTlnrtY6Vjhnb4eVeINpYqYqtSgoJUaHBnd2Nrd+16AW3TfuOJ0FkSYsmFpYJMdR9Qy06ldeuLSlz+XUt7pGXRkcpOJW1fiSd9JpXFTiiM249zl0tmgXnRj+xweG2ZfZp9m32cfZ19nn2ffaB9oX2ifaN9pH2lfad9qH2pfap9q32sfa19r32wfbF9sn2zfbR9tX22fbd9uH25fbp9u328fb19vn2/fcB9wX3CfcN9xH3FfcZ9x33Ifcl9yn3Lfcx9zX3Ofc990H3RfdJ9033UfdV91n3Xfdh92X3afdt93H3dfd59333gfeF94n3jfeR95X3mfed96H3pfep9633sfe197n3vffB98X3yffN99H31ffZ99334ffl9+n09XLJSRoNiUQ6DW3d2ZricrE7KYL58s3zPfpVOZotvZoiYWZeDWGxlXJWEX8l1Vpffet56wFGvcJh66mN2eqB+lnPtl0VOeHBdTlKRqVNRZedl/IEFgo5UMVyadaCX2GLZcr11RVx5msqDQFyAVOl3Pk6ubFqA0mJuY+hdd1HdjR6OL5XxT+VT52CscGdSUGNDnh9aJlA3d3dT4n6FZCtliWKYYxRQNXLJibNRwIvdfkdXzIOnlJtRG1T7XPt9/H39ff59/30AfgF+An4DfgR+BX4Gfgd+CH4Jfgp+C34Mfg1+Dn4PfhB+EX4SfhN+FH4VfhZ+F34Yfhl+Gn4bfhx+HX4efh9+IH4hfiJ+I34kfiV+Jn4nfih+KX4qfit+LH4tfi5+L34wfjF+Mn4zfjR+NX42fjd+OH45fjp+PH49fj5+P35AfkJ+Q35EfkV+Rn5Ifkl+Sn5Lfkx+TX5Ofk9+UH5RflJ+U35UflV+Vn5Xflh+WX5aflt+XH5dfspP43pabeGQj5qAVZZUYVOvVABf6WN3ae9RaGEKUipY2FJOVw14C3e3Xndh4HxbYpdiok6VcAOA92LkcGCXd1fbgu9n9WjVeJeY0XnzWLNU71M0bktRO1KiW/6Lr4BDVaZXc2BRVy1UenpQYFRbp2OgYuNTY2LHW69n7VSfeuaCd5GTXuSIOFmuVw5j6I3vgFdXd3upT+tfvVs+ayFTUHvCckZo/3c2d/dltVGPTtR2v1ylenWETllBm4BQXn5ffmB+YX5ifmN+ZH5lfmZ+Z35ofml+an5rfmx+bX5ufm9+cH5xfnJ+c350fnV+dn53fnh+eX56fnt+fH59fn5+f36AfoF+g36EfoV+hn6Hfoh+iX6Kfot+jH6Nfo5+j36QfpF+kn6TfpR+lX6Wfpd+mH6Zfpp+nH6dfp5+rn60frt+vH7WfuR+7H75fgp/EH8efzd/OX87fzx/PX8+fz9/QH9Bf0N/Rn9Hf0h/SX9Kf0t/TH9Nf05/T39Sf1N/iJknYYNuZFcGZkZj8FbsYmli014UloNXyWKHVSGHSoGjj2ZVsYNlZ1aN3YRqWg9o5mLuexGWcFGcbzCM/WPIidJhBn/CcOVuBXSUafxyyl7OkBdnam1eY7NSYnIBgGxP5VlqkdlwnW3SUlBO95ZtlX6FyngvfSFRklfCZIuAe3zqbPFoXmm3UZhTqGiBcs6e8Xv4crt5E28GdE5nzJGknDx5iYNUgw9UF2g9TolTsVI+eIZTKVKIUItP0E9Wf1l/W39cf11/Xn9gf2N/ZH9lf2Z/Z39rf2x/bX9vf3B/c391f3Z/d394f3p/e398f31/f3+Af4J/g3+Ef4V/hn+Hf4h/iX+Lf41/j3+Qf5F/kn+Tf5V/ln+Xf5h/mX+bf5x/oH+if6N/pX+mf6h/qX+qf6t/rH+tf65/sX+zf7R/tX+2f7d/un+7f75/wH/Cf8N/xH/Gf8d/yH/Jf8t/zX/Pf9B/0X/Sf9N/1n/Xf9l/2n/bf9x/3X/ef+J/43/idct6knylbLaWm1KDdOlU6U9UgLKD3o9wlcleHGCfbRheW2U4gf6US2C8cMN+rnzJUYFosXxvgiROho/PkX5mrk4FjKlkSoDaUJd1znHlW72PZm+GToJkY5XWXpllF1LCiMhwo1IOczN0l2f3eBaXNE67kN6cy23bUUGNHVTOYrJz8YP2loSfw5Q2T5p/zFF1cHWWrVyGmOZT5E6cbgl0tGlreI+ZWXUYUiR2QW3zZ21RmZ9LgJlUPHu/euR/53/of+p/63/sf+1/73/yf/R/9X/2f/d/+H/5f/p//X/+f/9/AoAHgAiACYAKgA6AD4ARgBOAGoAbgB2AHoAfgCGAI4AkgCuALIAtgC6AL4AwgDKANIA5gDqAPIA+gECAQYBEgEWAR4BIgEmAToBPgFCAUYBTgFWAVoBXgFmAW4BcgF2AXoBfgGCAYYBigGOAZIBlgGaAZ4BogGuAbIBtgG6Ab4BwgHKAc4B0gHWAdoB3gHiAeYB6gHuAfIB9gIaWhFfiYkeWfGkEWgJk03sPb0uWpoJiU4WYkF6JcLNjZFNPhoGck56MeDKX741CjX+eXm+EeVVfRpYuYnSaFVTdlKNPxWVlXGFcFX9Rhi9si1+Hc+Ru/37mXBtjalvmbnVTcU6gY2V1oWJujyZP0U6mbLZ+uosdhLqHV387kCOVqXuhmviIPYQbbYaa3H6IWbuem3MBeIKGbJqCmhtWF1TLV3BOpp5WU8iPCYGSd5KZ7obhbhOF/GZiYStvfoCBgIKAhYCIgIqAjYCOgI+AkICRgJKAlICVgJeAmYCegKOApoCngKiArICwgLOAtYC2gLiAuYC7gMWAx4DIgMmAyoDLgM+A0IDRgNKA04DUgNWA2IDfgOCA4oDjgOaA7oD1gPeA+YD7gP6A/4AAgQGBA4EEgQWBB4EIgQuBDIEVgReBGYEbgRyBHYEfgSCBIYEigSOBJIElgSaBJ4EogSmBKoErgS2BLoEwgTOBNIE1gTeBOYE6gTuBPIE9gT+BKYySgiuD8nYTbNlfvYMrcwWDGpXba9t3xpRvUwKDklE9XoyMOI1ITqtzmmeFaHaRCZdkcaFsCXeSWkGVz2uOfydm0Fu5WZpa6JX3lexODISZhKxq33YwlRtzpmhfWy93mpFhl9x8948cjCVfc3zYecWJzGwch8ZbQl7JaCB39X6VUU1RyVIpWgV/YpfXgs9jhHfQhdJ5Om6ZXplZEYVtcBFsv2K/dk9lr2D9lQ5mn4cjnu2UDVR9VCyMeGRAgUGBQoFDgUSBRYFHgUmBTYFOgU+BUoFWgVeBWIFbgVyBXYFegV+BYYFigWOBZIFmgWiBaoFrgWyBb4FygXOBdYF2gXeBeIGBgYOBhIGFgYaBh4GJgYuBjIGNgY6BkIGSgZOBlIGVgZaBl4GZgZqBnoGfgaCBoYGigaSBpYGngamBq4Gsga2BroGvgbCBsYGygbSBtYG2gbeBuIG5gbyBvYG+gb+BxIHFgceByIHJgcuBzYHOgc+B0IHRgdKB04F5ZBGGIWqcgeh4aWRUm7liK2erg6hY2J6rbCBv3ltMlguMX3LQZ8diYXKpTsZZzWuTWK5mVV7fUlVhKGfudmZ3Z3JGev9i6lRQVKCUo5AcWrN+FmxDTnZZEIBIWVdTN3W+lspWIGMRgXxg+ZXWbWJUgZmFUela/YCuWROXKlDlbDxc32JgTz9Te4EGkLpuK4XIYnRevni1ZHtj9V8YWn+RH54/XE9jQoB9W25VSpVNlYVtqGDgZ95y3VGBW9SB1YHWgdeB2IHZgdqB24Hcgd2B3oHfgeCB4YHigeSB5YHmgeiB6YHrge6B74HwgfGB8oH1gfaB94H4gfmB+oH9gf+BA4IHggiCCYIKgguCDoIPghGCE4IVghaCF4IYghmCGoIdgiCCJIIlgiaCJ4Ipgi6CMoI6gjyCPYI/gkCCQYJCgkOCRYJGgkiCSoJMgk2CToJQglGCUoJTglSCVYJWgleCWYJbglyCXYJegmCCYYJigmOCZIJlgmaCZ4Jpgudi3mxbcm1irpS9fhOBU22cUQRfdFmqUhJgc1mWZlCGn3UqY+Zh73z6i+ZUJ2slnrRr1YVVVHZQpGxqVbSNLHIVXhVgNnTNYpJjTHKYX0NuPm0AZVhv2HbQePx2VHUkUttTU06eXsFlKoDWgJtihlQoUq5wjYjRjeFseFTagPlX9IhUjWqWTZFpT5tst1XGdjB4qGL5cI5vbV/shNpofHj3e6iBC2dPnmdjsHhvVxJ4OZd5YqtiiFI1dNdraoJrgmyCbYJxgnWCdoJ3gniCe4J8goCCgYKDgoWChoKHgomCjIKQgpOClIKVgpaCmoKbgp6CoIKigqOCp4KygrWCtoK6gruCvIK/gsCCwoLDgsWCxoLJgtCC1oLZgtqC3YLigueC6ILpguqC7ILtgu6C8ILygvOC9YL2gviC+oL8gv2C/oL/ggCDCoMLgw2DEIMSgxODFoMYgxmDHYMegx+DIIMhgyKDI4MkgyWDJoMpgyqDLoMwgzKDN4M7gz2DZFU+gbJ1rnY5U951+1BBXGyLx3tPUEdyl5rYmAJv4nRoeYdkpXf8YpGYK43BVFiAUk5qV/mCDYRzXu1R9nTEi09cYVf8bIeYRlo0eESb64+VfFZSUWL6lMZOhoNhhOmDsoTUVzRnA1duZmZtMYzdZhFwH2c6axZoGmK7WQNOxFEGb9Jnj2x2UctoR1lna2Z1Dl0QgVCf12VIeUF5kZp3jYJcXk4BTy9UUVkMeGhWFGzEjwNffWzjbKuLkGM+gz+DQYNCg0SDRYNIg0qDS4NMg02DToNTg1WDVoNXg1iDWYNdg2KDcINxg3KDc4N0g3WDdoN5g3qDfoN/g4CDgYOCg4ODhIOHg4iDioOLg4yDjYOPg5CDkYOUg5WDloOXg5mDmoOdg5+DoYOig6ODpIOlg6aDp4Osg62DroOvg7WDu4O+g7+DwoPDg8SDxoPIg8mDy4PNg86D0IPRg9KD04PVg9eD2YPag9uD3oPig+OD5IPmg+eD6IPrg+yD7YNwYD1tdXJmYo6UxZRDU8GPfnvfTiaMfk7UnrGUs5RNUlxvY5BFbTSMEVhMXSBrSWuqZ1tUVIGMf5lYN4U6X6JiR2o5lXJlhGBlaKd3VE6oT+ddmJesZNh/7VzPT416B1IEgxROL2CDeqaUtU+yTuZ5NHTkUrmC0mS9ed1bgWxSl3uPImw+UH9TBW7OZHRmMGzFYHeY94uGXjx0d3rLeRhOsZADdEJs2lZLkcVsi406U8aG8mavjkhccZogbu6D74Pzg/SD9YP2g/eD+oP7g/yD/oP/gwCEAoQFhAeECIQJhAqEEIQShBOEFIQVhBaEF4QZhBqEG4QehB+EIIQhhCKEI4QphCqEK4QshC2ELoQvhDCEMoQzhDSENYQ2hDeEOYQ6hDuEPoQ/hECEQYRChEOERIRFhEeESIRJhEqES4RMhE2EToRPhFCEUoRThFSEVYRWhFiEXYRehF+EYIRihGSEZYRmhGeEaIRqhG6Eb4RwhHKEdIR3hHmEe4R8hNZTNlqLn6ONu1MIV6eYQ2ebkclsaFHKdfNirHI4Up1SOn+UcDh2dFNKnrdpbnjAltmIpH82ccNxiVHTZ+R05FgYZbdWqYt2mXBi1X75YO1w7FjBTrpOzV/nl/tOpIsDUopZq35UYs1O5WUOYjiDyYRjg42HlHG2brlb0n6XUclj1GeJgDmDFYgSUXpbglmxj3NOXWxlUSWJb48ulkqFXnQQlfCVpm3lgjFfkmQSbSiEboHDnF5YW40JTsFTfYR+hH+EgISBhIOEhISFhIaEioSNhI+EkISRhJKEk4SUhJWEloSYhJqEm4SdhJ6En4SghKKEo4SkhKWEpoSnhKiEqYSqhKuErISthK6EsISxhLOEtYS2hLeEu4S8hL6EwITChMOExYTGhMeEyITLhMyEzoTPhNKE1ITVhNeE2ITZhNqE24TchN6E4YTihOSE54TohOmE6oTrhO2E7oTvhPGE8oTzhPSE9YT2hPeE+IT5hPqE+4T9hP6EAIUBhQKFHk9jZVFo01UnThRkmpprYsJaX3Rygqlt7mjnUI6DAnhAZzlSmWyxfrtQZVVecVt7UmbKc+uCSWdxXCBSfXFriOqVVZbFZGGNs4GEVVVsR2Iuf5JYJE9GVU+NTGYKThpc84iiaE5jDXrncI2C+lL2lxFc6FS1kM1+YllKjceGDIINgmaNRGQEXFFhiW0+eb6LN3gzdXtUOE+rjvFtIFrFfl55iGyhW3ZaGnW+gE5hF27wWB91JXVyckdT834DhQSFBYUGhQeFCIUJhQqFC4UNhQ6FD4UQhRKFFIUVhRaFGIUZhRuFHIUdhR6FIIUihSOFJIUlhSaFJ4UohSmFKoUthS6FL4UwhTGFMoUzhTSFNYU2hT6FP4VAhUGFQoVEhUWFRoVHhUuFTIVNhU6FT4VQhVGFUoVThVSFVYVXhViFWoVbhVyFXYVfhWCFYYVihWOFZYVmhWeFaYVqhWuFbIVthW6Fb4VwhXGFc4V1hXaFd4V4hXyFfYV/hYCFgYUBd9t2aVLcgCNXCF4xWe5yvWV/bteLOFxxhkFT83f+YvZlwE7fmICGnlvGi/JT4nd/T05cdprLWQ9fOnnrWBZO/2eLTu1ik4odkL9SL2bcVWxWApDVTo1PypFwmQ9sAl5DYKRbxonVizZlS2KWmYhb/1uIYy5V11Mmdn1RLIWiZ7NoimuSYpOP1FMSgtFtj3VmTk6NcFufca+FkWbZZnJ/AIfNniCfXlwvZ/CPEWhfZw1i1nqFWLZecGUxb4KFg4WGhYiFiYWKhYuFjIWNhY6FkIWRhZKFk4WUhZWFloWXhZiFmYWahZ2FnoWfhaCFoYWihaOFpYWmhaeFqYWrhayFrYWxhbKFs4W0hbWFtoW4hbqFu4W8hb2FvoW/hcCFwoXDhcSFxYXGhceFyIXKhcuFzIXNhc6F0YXShdSF1oXXhdiF2YXahduF3YXehd+F4IXhheKF44XlheaF54XoheqF64Xshe2F7oXvhfCF8YXyhfOF9IX1hfaF94X4hVVgN1INgFRkcIgpdQVeE2j0YhyXzFM9cgGMNGxhdw56LlSsd3qYHIL0i1V4FGfBcK9llWQ2Vh1gwXn4Ux1Oe2uGgPpb41XbVjpPPE9ymfNdfmc4gAJggpgBkItbvIv1ixxkWILeZP1Vz4JlkddPIH0fkJ9881BRWK9uv1vJi4OAeJGchJd7fYaLlo+W5X7Tmo54gVxXekKQp5ZfeVlbX2MLe9GErWgGVSl/EHQifQGVQGJMWNZOg1t5WVRY+YX6hfyF/YX+hQCGAYYChgOGBIYGhgeGCIYJhgqGC4YMhg2GDoYPhhCGEoYThhSGFYYXhhiGGYYahhuGHIYdhh6GH4YghiGGIoYjhiSGJYYmhiiGKoYrhiyGLYYuhi+GMIYxhjKGM4Y0hjWGNoY3hjmGOoY7hj2GPoY/hkCGQYZChkOGRIZFhkaGR4ZIhkmGSoZLhkyGUoZThlWGVoZXhliGWYZbhlyGXYZfhmCGYYZjhmSGZYZmhmeGaIZphmqGbXMeY0uOD47OgNSCrGLwU/BsXpEqWQFgcGxNV0pkKo0rduluW1eAavB1bW8tjAiMZlfva5KIs3iiY/lTrXBkbFhYKmQCWOBom4EQVdZ8GFC6jsxtn43rcI9jm23UbuZ+BIRDaAOQ2G12lqiLV1l5cuSFfoG8dYqKr2hUUiKOEZXQY5iYRI58VVNP/2aPVtVglW1DUklcKVn7bWtYMHUcdWxgFIJGgRFjYWfijzp38400jcGUFl6FUyxUw3Bthm+GcIZyhnOGdIZ1hnaGd4Z4hoOGhIaFhoaGh4aIhomGjoaPhpCGkYaShpSGloaXhpiGmYaahpuGnoafhqCGoYaihqWGpoarhq2GroayhrOGt4a4hrmGu4a8hr2Gvoa/hsGGwobDhsWGyIbMhs2G0obThtWG1obXhtqG3IbdhuCG4YbihuOG5YbmhueG6IbqhuuG7IbvhvWG9ob3hvqG+4b8hv2G/4YBhwSHBYcGhwuHDIcOhw+HEIcRhxSHFodAbPdeXFCtTq1eOmNHghqQUGhukbN3DFTclGRf5Xp2aEVjUnvfftt1d1CVYjRZD5D4UcN5gXr+VpJfFJCCbWBcH1cQVFRRTW7iVqhjk5h/gRWHKokAkB5Ub1zAgdZiWGIxgTWeQJZumnyaLWmlWdNiPlUWY8dU2YY8bQNa5nSciGprFllMjC9ffm6pc32YOE73cIxbl3g9Y1pmlnbLYJtbSVoHTlWBamyLc6FOiWdRf4Bf+mUbZ9hfhFkBWhmHG4cdhx+HIIckhyaHJ4cohyqHK4cshy2HL4cwhzKHM4c1hzaHOIc5hzqHPIc9h0CHQYdCh0OHRIdFh0aHSodLh02HT4dQh1GHUodUh1WHVodYh1qHW4dch12HXodfh2GHYodmh2eHaIdph2qHa4dsh22Hb4dxh3KHc4d1h3eHeId5h3qHf4eAh4GHhIeGh4eHiYeKh4yHjoePh5CHkYeSh5SHlYeWh5iHmYeah5uHnIedh56HoIehh6KHo4ekh81drl9xU+aX3Y9FaPRWL1XfYDpOTW/0fseCDoTUWR9PKk8+XKx+KmcahXNUT3XDgIJVT5tNTy1uE4wJXHBha1MfdiluioaHZfuVuX47VDN6Cn3uleFVwX/udB1jF4ehbZ16EWKhZWdT4WODbOtdXFSolExOYWzsi0tc4GWcgqdoPlQ0VMtrZmuUTkJjSFMegg1Prk9eVwpi/pZkZmly/1KhUp9g74sUZplxkGd/iVJ4/XdwZjtWOFQhlXpypYemh6eHqYeqh66HsIexh7KHtIe2h7eHuIe5h7uHvIe+h7+HwYfCh8OHxIfFh8eHyIfJh8yHzYfOh8+H0IfUh9WH1ofXh9iH2Yfah9yH3Yfeh9+H4Yfih+OH5Ifmh+eH6Ifph+uH7Ifth++H8Ifxh/KH84f0h/WH9of3h/iH+of7h/yH/Yf/hwCIAYgCiASIBYgGiAeICIgJiAuIDIgNiA6ID4gQiBGIEogUiBeIGIgZiBqIHIgdiB6IH4ggiCOIAHpvYAxeiWCdgRVZ3GCEce9wqm5QbIByhGqtiC1eYE6zWpxV45QXbft8mZYPYsZ+jnd+hiNTHpeWj4dm4VygT+1yC06mUw9ZE1SAYyiVSFHZTpycpH64VCSNVIg3gvKVjm0mX8xaPmZplrBzLnO/U3qBhZmhf6pbd5ZQlr9++HaiU3aVmZmxe0SJWG5hTtR/ZXnmi/NgzVSrTnmY911has9QEVRhjCeEXXgEl0pS7lSjVgCViG21W8ZtU2YkiCWIJogniCiIKYgqiCuILIgtiC6IL4gwiDGIM4g0iDWINog3iDiIOog7iD2IPog/iEGIQohDiEaIR4hIiEmISohLiE6IT4hQiFGIUohTiFWIVohYiFqIW4hciF2IXohfiGCIZohniGqIbYhviHGIc4h0iHWIdoh4iHmIeoh7iHyIgIiDiIaIh4iJiIqIjIiOiI+IkIiRiJOIlIiViJeImIiZiJqIm4idiJ6In4igiKGIo4iliKaIp4ioiKmIqogPXF1bIWiWgHhVEXtIZVRpm05Ha06Hi5dPUx9jOmSqkJxlwYAQjJlRsGh4U/mHyGHEbPtsIoxRXKqFr4IMlSNrm4+wZftfw1/hT0WIH2ZlgSlz+mB0URFSi1diX6KQTIiSkXheT2cnYNNZRFH2UfiACFN5bMSWinERT+5Pnn89Z8VVCJXAeZaI436fWAxiAJdahhhWe5iQX7iLxIRXkdlT7WWPXlx1ZGBufX9a6n7tfmmPp1WjW6xgy2WEc6yIroiviLCIsoiziLSItYi2iLiIuYi6iLuIvYi+iL+IwIjDiMSIx4jIiMqIy4jMiM2Iz4jQiNGI04jWiNeI2ojbiNyI3YjeiOCI4YjmiOeI6YjqiOuI7IjtiO6I74jyiPWI9oj3iPqI+4j9iP+IAIkBiQOJBIkFiQaJB4kIiQmJC4kMiQ2JDokPiRGJFIkViRaJF4kYiRyJHYkeiR+JIIkiiSOJJIkmiSeJKIkpiSyJLYkuiS+JMYkyiTOJNYk3iQmQY3Ypd9p+dJebhWZbdHrqlkCIy1KPcapf7GXii/tbb5rhXYlrW2yti6+LCpDFj4tTvGImni2eQFQrTr2CWXKchhZdWYivbcWW0VSaTraLCXG9VAmW33D5bdB2JU4UeBKHqVz2XgCKnJgOlo5wv2xEWaljPHdNiBRvc4IwWNVxjFMaeMGWAVVmXzBxtFsajIyag2suWS+e53loZ2xib0+hdYp/C20zlids8E7SdXtRN2g+b4CQcIGWWXZ0OIk5iTqJO4k8iT2JPok/iUCJQolDiUWJRolHiUiJSYlKiUuJTIlNiU6JT4lQiVGJUolTiVSJVYlWiVeJWIlZiVqJW4lciV2JYIlhiWKJY4lkiWWJZ4loiWmJaolriWyJbYluiW+JcIlxiXKJc4l0iXWJdol3iXiJeYl6iXyJfYl+iYCJgomEiYWJh4mIiYmJiomLiYyJjYmOiY+JkImRiZKJk4mUiZWJlomXiZiJmYmaiZuJnImdiZ6Jn4mgiaGJR2QnXGWQkXojjNpZrFQAgm+DgYkAgDBpTlY2gDdyzpG2UV9OdZiWYxpO9lPzZkuBHFmybQBO+Vg7U9Zj8ZSdTwpPY4iQmDdZV5D7eepO8ICRdYJsnFvoWV1fBWmBhhpQ8l1ZTuN35U56gpFiE2aRkHlcv055X8aBOJCEgKt1pk7UiA9hxWvGX0lOynaibuOLrosKjNGLAl/8f8x/zn41g2uD4Fa3a/OXNJb7WR9U9pTrbcVbbpk5XBVfkJaiiaOJpImliaaJp4moiamJqomriayJrYmuia+JsImxibKJs4m0ibWJtom3ibiJuYm6ibuJvIm9ib6Jv4nAicOJzYnTidSJ1YnXidiJ2Ynbid2J34ngieGJ4onkieeJ6InpieqJ7Intie6J8InxifKJ9In1ifaJ94n4ifmJ+on7ifyJ/Yn+if+JAYoCigOKBIoFigaKCIoJigqKC4oMig2KDooPihCKEYoSihOKFIoVihaKF4oYihmKGoobihyKHYpwU/GCMWp0WnCelF4of7mDJIQlhGeDR4fOj2KNyHZxX5aYbHggZt9U5WJjT8OByHW4Xs2WCo75ho9U82yMbThsf2DHUih1fV4YT6Bg518kXDF1rpDAlLlyuWw4bkmRCWfLU/NTUU/JkfGLyFN8XsKP5G2OTsJ2hmlehhphBoJZT95PPpB8nAlhHW4UboWWiE4xWuiWDk5/XLl5h1vti71/iXPfV4uCwZABVEeQu1XqXKFfCGEya/FysoCJih6KH4ogiiGKIoojiiSKJYomiieKKIopiiqKK4osii2KLoovijCKMYoyijOKNIo1ijaKN4o4ijmKOoo7ijyKPYo/ikCKQYpCikOKRIpFikaKR4pJikqKS4pMik2KTopPilCKUYpSilOKVIpVilaKV4pYilmKWopbilyKXYpeil+KYIphimKKY4pkimWKZopnimiKaYpqimuKbIptim6Kb4pwinGKcopzinSKdYp2ineKeIp6inuKfIp9in6Kf4qAinRt01vViISYa4xtmjOeCm6kUUNRo1eBiJ9T9GOVj+1WWFQGVz9zkG4Yf9yP0YI/YShgYpbwZqZ+io3DjaWUs1ykfAhnpmAFlhiAkU7nkABTaJZBUdCPdIVdkVVm9ZdVWx1TOHhCZz1oyVR+cLBbfY+NUShXsVQSZYJmXo1DjQ+BbIRtkN98/1H7haNn6WWhb6SGgY5qViCQgnZ2cOVxI43pYhlS/Ww8jQ5gnliOYf5mYI1OYrNVI24tZ2ePgYqCioOKhIqFioaKh4qIiouKjIqNio6Kj4qQipGKkoqUipWKloqXipiKmYqaipuKnIqdip6Kn4qgiqGKooqjiqSKpYqmiqeKqIqpiqqKq4qsiq2KroqvirCKsYqyirOKtIq1iraKt4q4irmKuoq7iryKvYq+ir+KwIrBisKKw4rEisWKxorHisiKyYrKisuKzIrNis6Kz4rQitGK0orTitSK1YrWiteK2IrZitqK24rcit2K3orfiuCK4YriiuOK4ZT4lSh3BWioaYtUTU64cMiLWGSLZYVbhHo6UOhbu3fha3mKmHy+bM92qWWXjy1dVVw4hghoYFMYYtl6W279fh9q4HpwXzNvIF+MY6htVmcIThBeJo3XTsCANHaclttiLWZ+YrxsdY1ncWl/RlGHgOxTbpCYYvJU8IaZjwWAF5UXhdmPWW3Nc59lH3cEdSd4+4EejYiUpk+VZ7l1yosHly9jR5U1lriEI2NBd4Ff8HKJThRgdGXvYmNrP2XkiuWK5orniuiK6YrqiuuK7Irtiu6K74rwivGK8orzivSK9Yr2iveK+Ir5ivqK+4r8iv2K/or/igCLAYsCiwOLBIsFiwaLCIsJiwqLC4sMiw2LDosPixCLEYsSixOLFIsVixaLF4sYixmLGosbixyLHYseix+LIIshiyKLI4skiyWLJ4soiymLKosriyyLLYsuiy+LMIsxizKLM4s0izWLNos3iziLOYs6izuLPIs9iz6LP4tAi0GLQotDi0SLRYsnXsd10ZDBi52CnWcvZTFUGIfld6KAAoFBbEtOx35MgPR2DWmWa2diPFCET0BXB2Nia76N6lPoZbh+118aY7dj84H0gW5/HF7ZXDZSembpeRp6KI2ZcNR13m67bJJ6LU7FduBfn5R3iMh+zXm/gM2R8k4XTx+CaFTeXTJtzIulfHSPmIAaXpJUsXaZWzxmpJrgcypo24YxZypz+IvbixCQ+XrbcG5xxGKpdzFWO05XhPFnqVLAhi6N+JRRe0aLR4tIi0mLSotLi0yLTYtOi0+LUItRi1KLU4tUi1WLVotXi1iLWYtai1uLXItdi16LX4tgi2GLYotji2SLZYtni2iLaYtqi2uLbYtui2+LcItxi3KLc4t0i3WLdot3i3iLeYt6i3uLfIt9i36Lf4uAi4GLgouDi4SLhYuGi4eLiIuJi4qLi4uMi42LjouPi5CLkYuSi5OLlIuVi5aLl4uYi5mLmoubi5yLnYuei5+LrIuxi7uLx4vQi+qLCYwejE9P6GxdeXuak2Iqcv1iE04WeGyPsGRajcZ7aWiEXsWIhlmeZO5YtnIOaSWV/Y9YjWBXAH8GjMZRSWPZYlNTTGgidAGDTJFEVUB3fHBKbXlRqFREjf9Zy27EbVxbK33UTn18025QW+qBDW5XWwOb1Wgqjpdb/H47YLV+uZBwjU9ZzWPfebONUlPPZVZ5xYs7lsR+u5SCfjRWiZEAZ2p/Clx1kChm5l1QT95nWlBcT1BXp14Q6BHoEugT6BToOIw5jDqMO4w8jD2MPow/jECMQoxDjESMRYxIjEqMS4xNjE6MT4xQjFGMUoxTjFSMVoxXjFiMWYxbjFyMXYxejF+MYIxjjGSMZYxmjGeMaIxpjGyMbYxujG+McIxxjHKMdIx1jHaMd4x7jHyMfYx+jH+MgIyBjIOMhIyGjIeMiIyLjI2MjoyPjJCMkYySjJOMlYyWjJeMmYyajJuMnIydjJ6Mn4ygjKGMooyjjKSMpYymjKeMqIypjKqMq4ysjK2MjU4MTkBREE7/XkVTFU6YTh5OMptsW2lWKE66eT9OFVNHTi1ZO3JuUxBs31bkgJeZ02t+dxefNk6fThCfXE5pTpNOiIJbW2xVD1bETo1TnVOjU6VTrlNll12NGlP1UyZTLlM+U1yNZlNjUwJSCFIOUi1SM1I/UkBSTFJeUmFSXFKvhH1SglKBUpBSk1KCUVR/u07DTslOwk7oTuFO607eThtP804iT2RP9U4lTydPCU8rT15PZ084ZVpPXU+ujK+MsIyxjLKMs4y0jLWMtoy3jLiMuYy6jLuMvIy9jL6Mv4zAjMGMwozDjMSMxYzGjMeMyIzJjMqMy4zMjM2MzozPjNCM0YzSjNOM1IzVjNaM14zYjNmM2ozbjNyM3YzejN+M4IzhjOKM44zkjOWM5oznjOiM6YzqjOuM7IztjO6M74zwjPGM8ozzjPSM9Yz2jPeM+Iz5jPqM+4z8jP2M/oz/jACNAY0CjQONBI0FjQaNB40IjQmNCo0LjQyNDY1fT1dPMk89T3ZPdE+RT4lPg0+PT35Pe0+qT3xPrE+UT+ZP6E/qT8VP2k/jT9xP0U/fT/hPKVBMUPNPLFAPUC5QLVD+TxxQDFAlUChQflBDUFVQSFBOUGxQe1ClUKdQqVC6UNZQBlHtUOxQ5lDuUAdRC1HdTj1sWE9lT85PoJ9GbHR8blH9XcmemJmBURRZ+VINUweKEFPrURlZVVGgTlZRs05uiKSItU4UgdKIgHk0WwOIuH+rUbFRvVG8UQ6ND40QjRGNEo0TjRSNFY0WjReNGI0ZjRqNG40cjSCNUY1SjVeNX41ljWiNaY1qjWyNbo1vjXGNco14jXmNeo17jXyNfY1+jX+NgI2CjYONho2HjYiNiY2MjY2Njo2PjZCNko2TjZWNlo2XjZiNmY2ajZuNnI2djZ6NoI2hjaKNpI2ljaaNp42ojamNqo2rjayNrY2uja+NsI2yjbaNt425jbuNvY3AjcGNwo3FjceNyI3JjcqNzY3QjdKN043UjcdRllGiUaVRoIumi6eLqou0i7WLt4vCi8OLy4vPi86L0ovTi9SL1ovYi9mL3Ivfi+CL5Ivoi+mL7ovwi/OL9ov5i/yL/4sAjAKMBIwHjAyMD4wRjBKMFIwVjBaMGYwbjBiMHYwfjCCMIYwljCeMKowrjC6ML4wyjDOMNYw2jGlTelMdliKWIZYxliqWPZY8lkKWSZZUll+WZ5ZslnKWdJaIlo2Wl5awlpeQm5CdkJmQrJChkLSQs5C2kLqQ1Y3YjdmN3I3gjeGN4o3ljeaN543pje2N7o3wjfGN8o30jfaN/I3+jf+NAI4BjgKOA44EjgaOB44IjguODY4OjhCOEY4SjhOOFY4WjheOGI4ZjhqOG44cjiCOIY4kjiWOJo4njiiOK44tjjCOMo4zjjSONo43jjiOO448jj6OP45DjkWORo5Mjk2OTo5PjlCOU45UjlWOVo5XjliOWo5bjlyOXY5ejl+OYI5hjmKOY45kjmWOZ45ojmqOa45ujnGOuJCwkM+QxZC+kNCQxJDHkNOQ5pDikNyQ15DbkOuQ75D+kASRIpEekSORMZEvkTmRQ5FGkQ1SQlmiUqxSrVK+Uv9U0FLWUvBS31Pucc139F71UfxRL5u2UwFfWnXvXUxXqVehV35YvFjFWNFYKVcsVypXM1c5Vy5XL1dcVztXQldpV4VXa1eGV3xXe1doV21XdldzV61XpFeMV7JXz1enV7RXk1egV9VX2FfaV9lX0le4V/RX71f4V+RX3VdzjnWOd454jnmOeo57jn2Ofo6AjoKOg46EjoaOiI6JjoqOi46Mjo2Ojo6RjpKOk46VjpaOl46YjpmOmo6bjp2On46gjqGOoo6jjqSOpY6mjqeOqI6pjqqOrY6ujrCOsY6zjrSOtY62jreOuI65jruOvI69jr6Ov47AjsGOwo7DjsSOxY7GjseOyI7JjsqOy47Mjs2Oz47QjtGO0o7TjtSO1Y7WjteO2I7ZjtqO247cjt2O3o7fjuCO4Y7ijuOO5I4LWA1Y/VftVwBYHlgZWERYIFhlWGxYgViJWJpYgFiomRmf/2F5gn2Cf4KPgoqCqIKEgo6CkYKXgpmCq4K4gr6CsILIgsqC44KYgreCroLLgsyCwYKpgrSCoYKqgp+CxILOgqSC4YIJg/eC5IIPgweD3IL0gtKC2IIMg/uC04IRgxqDBoMUgxWD4ILVghyDUYNbg1yDCIOSgzyDNIMxg5uDXoMvg0+DR4NDg1+DQIMXg2CDLYM6gzODZoNlg+WO5o7njuiO6Y7qjuuO7I7tju6O747wjvGO8o7zjvSO9Y72jveO+I75jvqO+478jv2O/o7/jgCPAY8CjwOPBI8FjwaPB48IjwmPCo8LjwyPDY8Ojw+PEI8RjxKPE48UjxWPFo8XjxiPGY8ajxuPHI8djx6PH48gjyGPIo8jjySPJY8mjyePKI8pjyqPK48sjy2PLo8vjzCPMY8yjzOPNI81jzaPN484jzmPOo87jzyPPY8+jz+PQI9Bj0KPQ49Ej2iDG4Npg2yDaoNtg26DsIN4g7ODtIOgg6qDk4Ocg4WDfIO2g6mDfYO4g3uDmIOeg6iDuoO8g8GDAYTlg9iDB1gYhAuE3YP9g9aDHIQ4hBGEBoTUg9+DD4QDhPiD+YPqg8WDwIMmhPCD4YNchFGEWoRZhHOEh4SIhHqEiYR4hDyERoRphHaEjISOhDGEbYTBhM2E0ITmhL2E04TKhL+EuoTghKGEuYS0hJeE5YTjhAyFDXU4hfCEOYUfhTqFRY9Gj0ePSI9Jj0qPS49Mj02PTo9Pj1CPUY9Sj1OPVI9Vj1aPV49Yj1mPWo9bj1yPXY9ej1+PYI9hj2KPY49kj2WPao+Aj4yPko+dj6CPoY+ij6SPpY+mj6ePqo+sj62Pro+vj7KPs4+0j7WPt4+4j7qPu4+8j7+PwI/Dj8aPyY/Kj8uPzI/Nj8+P0o/Wj9eP2o/gj+GP44/nj+yP74/xj/KP9I/1j/aP+o/7j/yP/o//jweQCJAMkA6QE5AVkBiQVoU7hf+E/IRZhUiFaIVkhV6FeoWid0OFcoV7haSFqIWHhY+FeYWuhZyFhYW5hbeFsIXThcGF3IX/hSeGBYYphhaGPIb+XghfPFlBWTeAVVlaWVhZD1MiXCVcLFw0XExiamKfYrtiymLaYtdi7mIiY/ZiOWNLY0NjrWP2Y3FjemOOY7RjbWOsY4pjaWOuY7xj8mP4Y+Bj/2PEY95jzmNSZMZjvmNFZEFkC2QbZCBkDGQmZCFkXmSEZG1klmQZkByQI5AkkCWQJ5AokCmQKpArkCyQMJAxkDKQM5A0kDeQOZA6kD2QP5BAkEOQRZBGkEiQSZBKkEuQTJBOkFSQVZBWkFmQWpBckF2QXpBfkGCQYZBkkGaQZ5BpkGqQa5BskG+QcJBxkHKQc5B2kHeQeJB5kHqQe5B8kH6QgZCEkIWQhpCHkImQipCMkI2QjpCPkJCQkpCUkJaQmJCakJyQnpCfkKCQpJClkKeQqJCpkKuQrZCykLeQvJC9kL+QwJB6ZLdkuGSZZLpkwGTQZNdk5GTiZAllJWUuZQtf0l8ZdRFfX1PxU/1T6VPoU/tTElQWVAZUS1RSVFNUVFRWVENUIVRXVFlUI1QyVIJUlFR3VHFUZFSaVJtUhFR2VGZUnVTQVK1UwlS0VNJUp1SmVNNU1FRyVKNU1VS7VL9UzFTZVNpU3FSpVKpUpFTdVM9U3lQbVedUIFX9VBRV81QiVSNVD1URVSdVKlVnVY9VtVVJVW1VQVVVVT9VUFU8VcKQw5DGkMiQyZDLkMyQzZDSkNSQ1ZDWkNiQ2ZDakN6Q35DgkOOQ5JDlkOmQ6pDskO6Q8JDxkPKQ85D1kPaQ95D5kPqQ+5D8kP+QAJEBkQORBZEGkQeRCJEJkQqRC5EMkQ2RDpEPkRCREZESkRORFJEVkRaRF5EYkRqRG5EckR2RH5EgkSGRJJElkSaRJ5EokSmRKpErkSyRLZEukTCRMpEzkTSRNZE2kTeROJE6kTuRPJE9kT6RP5FAkUGRQpFEkTdVVlV1VXZVd1UzVTBVXFWLVdJVg1WxVblViFWBVZ9VflXWVZFVe1XfVb1VvlWUVZlV6lX3VclVH1bRVetV7FXUVeZV3VXEVe9V5VXyVfNVzFXNVehV9VXkVZSPHlYIVgxWAVYkViNW/lUAVidWLVZYVjlWV1YsVk1WYlZZVlxWTFZUVoZWZFZxVmtWe1Z8VoVWk1avVtRW11bdVuFW9VbrVvlW/1YEVwpXCVccVw9eGV4UXhFeMV47XjxeRZFHkUiRUZFTkVSRVZFWkViRWZFbkVyRX5FgkWaRZ5FokWuRbZFzkXqRe5F8kYCRgZGCkYORhJGGkYiRipGOkY+Rk5GUkZWRlpGXkZiRmZGckZ2RnpGfkaCRoZGkkaWRppGnkaiRqZGrkayRsJGxkbKRs5G2kbeRuJG5kbuRvJG9kb6Rv5HAkcGRwpHDkcSRxZHGkciRy5HQkdKR05HUkdWR1pHXkdiR2ZHakduR3ZHekd+R4JHhkeKR45HkkeWRN15EXlReW15eXmFejFx6XI1ckFyWXIhcmFyZXJFcmlycXLVcoly9XKxcq1yxXKNcwVy3XMRc0lzkXMtc5VwCXQNdJ10mXS5dJF0eXQZdG11YXT5dNF09XWxdW11vXV1da11LXUpdaV10XYJdmV2dXXOMt13FXXNfd1+CX4dfiV+MX5VfmV+cX6hfrV+1X7xfYohhX61ysHK0crdyuHLDcsFyznLNctJy6HLvculy8nL0cvdyAXPzcgNz+nLmkeeR6JHpkeqR65Hske2R7pHvkfCR8ZHykfOR9JH1kfaR95H4kfmR+pH7kfyR/ZH+kf+RAJIBkgKSA5IEkgWSBpIHkgiSCZIKkguSDJINkg6SD5IQkhGSEpITkhSSFZIWkheSGJIZkhqSG5Ickh2SHpIfkiCSIZIikiOSJJIlkiaSJ5IokimSKpIrkiySLZIuki+SMJIxkjKSM5I0kjWSNpI3kjiSOZI6kjuSPJI9kj6SP5JAkkGSQpJDkkSSRZL7chdzE3MhcwpzHnMdcxVzInM5cyVzLHM4czFzUHNNc1dzYHNsc29zfnMbgiVZ55gkWQJZY5lnmWiZaZlqmWuZbJl0mXeZfZmAmYSZh5mKmY2ZkJmRmZOZlJmVmYBekV6LXpZepV6gXrletV6+XrNeU43SXtFe217oXupeuoHEX8lf1l/PXwNg7l8EYOFf5F/+XwVgBmDqX+1f+F8ZYDVgJmAbYA9gDWApYCtgCmA/YCFgeGB5YHtgemBCYEaSR5JIkkmSSpJLkkySTZJOkk+SUJJRklKSU5JUklWSVpJXkliSWZJakluSXJJdkl6SX5JgkmGSYpJjkmSSZZJmkmeSaJJpkmqSa5Jskm2SbpJvknCScZJyknOSdZJ2kneSeJJ5knqSe5J8kn2SfpJ/koCSgZKCkoOShJKFkoaSh5KIkomSipKLkoySjZKPkpCSkZKSkpOSlJKVkpaSl5KYkpmSmpKbkpySnZKekp+SoJKhkqKSo5KkkqWSppKnkmpgfWCWYJpgrWCdYINgkmCMYJtg7GC7YLFg3WDYYMZg2mC0YCBhJmEVYSNh9GAAYQ5hK2FKYXVhrGGUYadht2HUYfVh3V+zlumV65XxlfOV9ZX2lfyV/pUDlgSWBpYIlgqWC5YMlg2WD5YSlhWWFpYXlhmWGpYsTj9yFWI1bFRsXGxKbKNshWyQbJRsjGxobGlsdGx2bIZsqWzQbNRsrWz3bPhs8WzXbLJs4GzWbPps62zubLFs02zvbP5sqJKpkqqSq5Kskq2Sr5KwkrGSspKzkrSStZK2kreSuJK5krqSu5K8kr2SvpK/ksCSwZLCksOSxJLFksaSx5LJksqSy5LMks2SzpLPktCS0ZLSktOS1JLVktaS15LYktmS2pLbktyS3ZLekt+S4JLhkuKS45LkkuWS5pLnkuiS6ZLqkuuS7JLtku6S75LwkvGS8pLzkvSS9ZL2kveS+JL5kvqS+5L8kv2S/pL/kgCTAZMCkwOTBJMFkwaTB5MIkwmTOW0nbQxtQ21IbQdtBG0ZbQ5tK21NbS5tNW0abU9tUm1UbTNtkW1vbZ5toG1ebZNtlG1cbWBtfG1jbRpux23Fbd5tDm6/beBtEW7mbd1t2W0WbqttDG6ubStubm5Obmtusm5fboZuU25UbjJuJW5Ebt9usW6YbuBuLW/ibqVup269brtut27XbrRuz26PbsJun25ib0ZvR28kbxVv+W4vbzZvS290bypvCW8pb4lvjW+Mb3hvcm98b3pv0W8KkwuTDJMNkw6TD5MQkxGTEpMTkxSTFZMWkxeTGJMZkxqTG5Mckx2THpMfkyCTIZMikyOTJJMlkyaTJ5MokymTKpMrkyyTLZMuky+TMJMxkzKTM5M0kzWTNpM3kziTOZM6kzuTPJM9kz+TQJNBk0KTQ5NEk0WTRpNHk0iTSZNKk0uTTJNNk06TT5NQk1GTUpNTk1STVZNWk1eTWJNZk1qTW5Nck12TXpNfk2CTYZNik2OTZJNlk2aTZ5Nok2mTa5PJb6dvuW+2b8Jv4W/ub95v4G/vbxpwI3AbcDlwNXBPcF5wgFuEW5Vbk1ulW7hbL3WemjRk5FvuWzCJ8FtHjgeLto/Tj9WP5Y/uj+SP6Y/mj/OP6I8FkASQC5AmkBGQDZAWkCGQNZA2kC2QL5BEkFGQUpBQkGiQWJBikFuQuWZ0kH2QgpCIkIOQi5BQX1dfVl9YXztcq1RQXFlccVtjXGZcvH8qXylfLV90gjxfO5tuXIFZg1mNWalZqlmjWWyTbZNuk2+TcJNxk3KTc5N0k3WTdpN3k3iTeZN6k3uTfJN9k36Tf5OAk4GTgpODk4SThZOGk4eTiJOJk4qTi5OMk42TjpOQk5GTkpOTk5STlZOWk5eTmJOZk5qTm5Ock52TnpOfk6CToZOik6OTpJOlk6aTp5Ook6mTqpOrk6yTrZOuk6+TsJOxk7KTs5O0k7WTtpO3k7iTuZO6k7uTvJO9k76Tv5PAk8GTwpPDk8STxZPGk8eTyJPJk8uTzJPNk5dZylmrWZ5ZpFnSWbJZr1nXWb5ZBVoGWt1ZCFrjWdhZ+VkMWglaMlo0WhFaI1oTWkBaZ1pKWlVaPFpiWnVa7ICqWptad1p6Wr5a61qyWtJa1Fq4WuBa41rxWtZa5lrYWtxaCVsXWxZbMls3W0BbFVwcXFpbZVtzW1FbU1tiW3Wad5p4mnqaf5p9moCagZqFmoiaipqQmpKak5qWmpiam5qcmp2an5qgmqKao5qlmqean36hfqN+pX6ofql+zpPPk9CT0ZPSk9OT1JPVk9eT2JPZk9qT25Pck92T3pPfk+CT4ZPik+OT5JPlk+aT55Pok+mT6pPrk+yT7ZPuk++T8JPxk/KT85P0k/WT9pP3k/iT+ZP6k/uT/JP9k/6T/5MAlAGUApQDlASUBZQGlAeUCJQJlAqUC5QMlA2UDpQPlBCUEZQSlBOUFJQVlBaUF5QYlBmUGpQblByUHZQelB+UIJQhlCKUI5QklCWUJpQnlCiUKZQqlCuULJQtlC6UrX6wfr5+wH7BfsJ+yX7Lfsx+0H7Uftd+237gfuF+6H7rfu5+737xfvJ+DX/2fvp++37+fgF/An8Dfwd/CH8Lfwx/D38RfxJ/F38Zfxx/G38ffyF/In8jfyR/JX8mfyd/Kn8rfyx/LX8vfzB/MX8yfzN/NX96Xn91210+dZWQjnORc65zonOfc89zwnPRc7dzs3PAc8lzyHPlc9lzfJgKdOlz53Pec7pz8nMPdCp0W3QmdCV0KHQwdC50LHQvlDCUMZQylDOUNJQ1lDaUN5Q4lDmUOpQ7lDyUPZQ/lECUQZRClEOURJRFlEaUR5RIlEmUSpRLlEyUTZROlE+UUJRRlFKUU5RUlFWUVpRXlFiUWZRalFuUXJRdlF6UX5RglGGUYpRjlGSUZZRmlGeUaJRplGqUbJRtlG6Ub5RwlHGUcpRzlHSUdZR2lHeUeJR5lHqUe5R8lH2UfpR/lICUgZSClIOUhJSRlJaUmJTHlM+U05TUlNqU5pT7lByVIJUbdBp0QXRcdFd0VXRZdHd0bXR+dJx0jnSAdIF0h3SLdJ50qHSpdJB0p3TSdLp06pfrl+yXTGdTZ15nSGdpZ6Vnh2dqZ3NnmGenZ3VnqGeeZ61ni2d3Z3xn8GcJaNhnCmjpZ7BnDGjZZ7Vn2mezZ91nAGjDZ7hn4mcOaMFn/WcyaDNoYGhhaE5oYmhEaGRog2gdaFVoZmhBaGdoQGg+aEpoSWgpaLVoj2h0aHdok2hraMJobmn8aB9pIGn5aCeVM5U9lUOVSJVLlVWVWpVglW6VdJV1lXeVeJV5lXqVe5V8lX2VfpWAlYGVgpWDlYSVhZWGlYeViJWJlYqVi5WMlY2VjpWPlZCVkZWSlZOVlJWVlZaVl5WYlZmVmpWblZyVnZWelZ+VoJWhlaKVo5WklaWVppWnlaiVqZWqlauVrJWtla6Vr5WwlbGVspWzlbSVtZW2lbeVuJW5lbqVu5W8lb2VvpW/lcCVwZXClcOVxJXFlcaVx5XIlcmVypXLlSRp8GgLaQFpV2njaBBpcWk5aWBpQmldaYRpa2mAaZhpeGk0acxph2mIac5piWlmaWNpeWmbaadpu2mraa1p1GmxacFpymnfaZVp4GmNaf9pL2rtaRdqGGplavJpRGo+aqBqUGpbajVqjmp5aj1qKGpYanxqkWqQaqlql2qrajdzUnOBa4Jrh2uEa5Jrk2uNa5prm2uha6pra49tj3GPco9zj3WPdo94j3ePeY96j3yPfo+Bj4KPhI+Hj4uPzJXNlc6Vz5XQldGV0pXTldSV1ZXWldeV2JXZldqV25Xcld2V3pXfleCV4ZXileOV5JXlleaV55Xslf+VB5YTlhiWG5YeliCWI5YkliWWJpYnliiWKZYrliyWLZYvljCWN5Y4ljmWOpY+lkGWQ5ZKlk6WT5ZRllKWU5ZWlleWWJZZllqWXJZdll6WYJZjlmWWZpZrlm2WbpZvlnCWcZZzlniWeZZ6lnuWfJZ9ln6Wf5aAloGWgpaDloSWh5aJloqWjY+Oj4+PmI+aj86OC2IXYhtiH2IiYiFiJWIkYixi54HvdPR0/3QPdRF1E3U0Ze5l72XwZQpmGWZyZwNmFWYAZoVw92YdZjRmMWY2ZjVmBoBfZlRmQWZPZlZmYWZXZndmhGaMZqdmnWa+Zttm3GbmZulmMo0zjTaNO409jUCNRY1GjUiNSY1HjU2NVY1ZjceJyonLicyJzonPidCJ0Ylucp9yXXJmcm9yfnJ/coRyi3KNco9yknIIYzJjsGOMlo6WkZaSlpOWlZaWlpqWm5adlp6Wn5aglqGWopajlqSWpZamlqiWqZaqlquWrJatlq6Wr5axlrKWtJa1lreWuJa6lruWv5bClsOWyJbKlsuW0JbRltOW1JbWlteW2JbZltqW25bclt2W3pbfluGW4pbjluSW5ZbmlueW65bslu2W7pbwlvGW8pb0lvWW+Jb6lvuW/Jb9lv+WApcDlwWXCpcLlwyXEJcRlxKXFJcVlxeXGJcZlxqXG5cdlx+XIJc/ZNhkBIDqa/Nr/Wv1a/lrBWwHbAZsDWwVbBhsGWwabCFsKWwkbCpsMmw1ZVVla2VNclJyVnIwcmKGFlKfgJyAk4C8gApnvYCxgKuArYC0gLeA54DogOmA6oDbgMKAxIDZgM2A14AQZ92A64DxgPSA7YANgQ6B8oD8gBVnEoFajDaBHoEsgRiBMoFIgUyBU4F0gVmBWoFxgWCBaYF8gX2BbYFngU1YtVqIgYKBkYHVbqOBqoHMgSZnyoG7gSGXIpcjlySXJZcmlyeXKJcplyuXLJculy+XMZczlzSXNZc2lzeXOpc7lzyXPZc/l0CXQZdCl0OXRJdFl0aXR5dIl0mXSpdLl0yXTZdOl0+XUJdRl1SXVZdXl1iXWpdcl12XX5djl2SXZpdnl2iXapdrl2yXbZdul2+XcJdxl3KXdZd3l3iXeZd6l3uXfZd+l3+XgJeBl4KXg5eEl4aXh5eIl4mXipeMl46Xj5eQl5OXlZeWl5eXmZeal5uXnJedl8GBpoEkazdrOWtDa0ZrWWvRmNKY05jVmNmY2piza0BfwmvziZBlUZ+TZbxlxmXEZcNlzGXOZdJl1mWAcJxwlnCdcLtwwHC3cKtwsXDocMpwEHETcRZxL3ExcXNxXHFocUVxcnFKcXhxenGYcbNxtXGocaBx4HHUcedx+XEdcihybHAYcWZxuXE+Yj1iQ2JIYkliO3lAeUZ5SXlbeVx5U3laeWJ5V3lgeW95Z3l6eYV5inmaead5s3nRX9Bfnpefl6GXopekl6WXppenl6iXqZeql6yXrpewl7GXs5e1l7aXt5e4l7mXupe7l7yXvZe+l7+XwJfBl8KXw5fEl8WXxpfHl8iXyZfKl8uXzJfNl86Xz5fQl9GX0pfTl9SX1ZfWl9eX2JfZl9qX25fcl92X3pffl+CX4Zfil+OX5Jfll+iX7pfvl/CX8Zfyl/SX95f4l/mX+pf7l/yX/Zf+l/+XAJgBmAKYA5gEmAWYBpgHmAiYCZgKmAuYDJgNmA6YPGBdYFpgZ2BBYFlgY2CrYAZhDWFdYalhnWHLYdFhBmKAgH+Ak2z2bPxt9nf4dwB4CXgXeBh4EXirZS14HHgdeDl4Ong7eB94PHgleCx4I3gpeE54bXhWeFd4JnhQeEd4THhqeJt4k3iaeId4nHiheKN4sni5eKV41HjZeMl47HjyeAV59HgTeSR5Hnk0eZuf+Z77nvye8XYEdw13+XYHdwh3Gncidxl3LXcmdzV3OHdQd1F3R3dDd1p3aHcPmBCYEZgSmBOYFJgVmBaYF5gYmBmYGpgbmByYHZgemB+YIJghmCKYI5gkmCWYJpgnmCiYKZgqmCuYLJgtmC6YL5gwmDGYMpgzmDSYNZg2mDeYOJg5mDqYO5g8mD2YPpg/mECYQZhCmEOYRJhFmEaYR5hImEmYSphLmEyYTZhOmE+YUJhRmFKYU5hUmFWYVphXmFiYWZhamFuYXJhdmF6YX5hgmGGYYphjmGSYZZhmmGeYaJhpmGqYa5hsmG2Ybphid2V3f3eNd313gHeMd5F3n3egd7B3tXe9dzp1QHVOdUt1SHVbdXJ1eXWDdVh/YX9ff0iKaH90f3F/eX+Bf35/zXbldjKIhZSGlIeUi5SKlIyUjZSPlJCUlJSXlJWUmpSblJyUo5SklKuUqpStlKyUr5SwlLKUtJS2lLeUuJS5lLqUvJS9lL+UxJTIlMmUypTLlMyUzZTOlNCU0ZTSlNWU1pTXlNmU2JTblN6U35TglOKU5JTllOeU6JTqlG+YcJhxmHKYc5h0mIuYjpiSmJWYmZijmKiYqZiqmKuYrJitmK6Yr5iwmLGYspizmLSYtZi2mLeYuJi5mLqYu5i8mL2Yvpi/mMCYwZjCmMOYxJjFmMaYx5jImMmYypjLmMyYzZjPmNCY1JjWmNeY25jcmN2Y4JjhmOKY45jkmOWY5pjpmOqY65jsmO2Y7pjvmPCY8ZjymPOY9Jj1mPaY95j4mPmY+pj7mPyY/Zj+mP+YAJkBmQKZA5kEmQWZBpkHmemU65TulO+U85T0lPWU95T5lPyU/ZT/lAOVApUGlQeVCZUKlQ2VDpUPlRKVE5UUlRWVFpUYlRuVHZUelR+VIpUqlSuVKZUslTGVMpU0lTaVN5U4lTyVPpU/lUKVNZVElUWVRpVJlUyVTpVPlVKVU5VUlVaVV5VYlVmVW5VelV+VXZVhlWKVZJVllWaVZ5VolWmVapVrlWyVb5VxlXKVc5U6led37HfJltV57Xnjeet5BnpHXQN6AnoeehR6CJkJmQqZC5kMmQ6ZD5kRmRKZE5kUmRWZFpkXmRiZGZkamRuZHJkdmR6ZH5kgmSGZIpkjmSSZJZkmmSeZKJkpmSqZK5ksmS2ZL5kwmTGZMpkzmTSZNZk2mTeZOJk5mTqZO5k8mT2ZPpk/mUCZQZlCmUOZRJlFmUaZR5lImUmZSplLmUyZTZlOmU+ZUJlRmVKZU5lWmVeZWJlZmVqZW5lcmV2ZXplfmWCZYZlimWSZZplzmXiZeZl7mX6ZgpmDmYmZOXo3elF6z56lmXB6iHaOdpN2mXakdt504HQsdSCeIp4onimeKp4rniyeMp4xnjaeOJ43njmeOp4+nkGeQp5EnkaeR55InkmeS55Mnk6eUZ5VnleeWp5bnlyeXp5jnmaeZ55onmmeap5rnmyecZ5tnnOeknWUdZZ1oHWddax1o3WzdbR1uHXEdbF1sHXDdcJ11nXNdeN16HXmdeR163XndQN28XX8df91EHYAdgV2DHYXdgp2JXYYdhV2GXaMmY6ZmpmbmZyZnZmemZ+ZoJmhmaKZo5mkmaaZp5mpmaqZq5msma2ZrpmvmbCZsZmymbOZtJm1mbaZt5m4mbmZupm7mbyZvZm+mb+ZwJnBmcKZw5nEmcWZxpnHmciZyZnKmcuZzJnNmc6Zz5nQmdGZ0pnTmdSZ1ZnWmdeZ2JnZmdqZ25ncmd2Z3pnfmeCZ4ZnimeOZ5JnlmeaZ55nomemZ6pnrmeyZ7Znume+Z8JnxmfKZ85n0mfWZ9pn3mfiZ+Zkbdjx2InYgdkB2LXYwdj92NXZDdj52M3ZNdl52VHZcdlZ2a3Zvdsp/5np4enl6gHqGeoh6lXqmeqB6rHqoeq16s3pkiGmIcoh9iH+IgoiiiMaIt4i8iMmI4ojOiOOI5YjxiBqJ/IjoiP6I8IghiRmJE4kbiQqJNIkriTaJQYlmiXuJi3XlgLJ2tHbcdxKAFIAWgByAIIAigCWAJoAngCmAKIAxgAuANYBDgEaATYBSgGmAcYCDiXiYgJiDmPqZ+5n8mf2Z/pn/mQCaAZoCmgOaBJoFmgaaB5oImgmaCpoLmgyaDZoOmg+aEJoRmhKaE5oUmhWaFpoXmhiaGZoamhuaHJodmh6aH5ogmiGaIpojmiSaJZommieaKJopmiqaK5osmi2aLpovmjCaMZoymjOaNJo1mjaaN5o4mjmaOpo7mjyaPZo+mj+aQJpBmkKaQ5pEmkWaRppHmkiaSZpKmkuaTJpNmk6aT5pQmlGaUppTmlSaVZpWmleaWJpZmomYjJiNmI+YlJiamJuYnpifmKGYopilmKaYTYZUhmyGboZ/hnqGfIZ7hqiGjYaLhqyGnYanhqOGqoaThqmGtobEhrWGzoawhrqGsYavhsmGz4a0humG8Ybyhu2G84bQhhOH3ob0ht+G2IbRhgOHB4f4hgiHCocNhwmHI4c7hx6HJYcuhxqHPodIhzSHMYcphzeHP4eChyKHfYd+h3uHYIdwh0yHboeLh1OHY4d8h2SHWYdlh5OHr4eoh9KHWppbmlyaXZpeml+aYJphmmKaY5pkmmWaZppnmmiaaZpqmmuacpqDmomajZqOmpSalZqZmqaaqZqqmquarJqtmq6ar5qymrOatJq1mrmau5q9mr6av5rDmsSaxprHmsiayZrKms2azprPmtCa0prUmtWa1prXmtma2prbmtya3ZremuCa4prjmuSa5Zrnmuia6Zrqmuya7prwmvGa8przmvSa9Zr2mvea+Jr6mvya/Zr+mv+aAJsBmwKbBJsFmwabxoeIh4WHrYeXh4OHq4flh6yHtYezh8uH04e9h9GHwIfKh9uH6ofgh+6HFogTiP6HCogbiCGIOYg8iDZ/Qn9Ef0V/EIL6ev16CHsDewR7FXsKeyt7D3tHezh7KnsZey57MXsgeyV7JHszez57HntYe1p7RXt1e0x7XXtge257e3tie3J7cXuQe6Z7p3u4e6x7nXuoe4V7qnuce6J7q3u0e9F7wXvMe9172nvle+Z76nsMfP57/HsPfBZ8C3wHmwmbCpsLmwybDZsOmxCbEZsSmxSbFZsWmxebGJsZmxqbG5scmx2bHpsgmyGbIpskmyWbJpsnmyibKZsqmyubLJstmy6bMJsxmzObNJs1mzabN5s4mzmbOps9mz6bP5tAm0abSptLm0ybTptQm1KbU5tVm1abV5tYm1mbWptbm1ybXZtem1+bYJthm2KbY5tkm2WbZptnm2ibaZtqm2ubbJttm26bb5twm3Gbcptzm3SbdZt2m3ebeJt5m3qbe5sffCp8Jnw4fEF8QHz+gQGCAoIEguyBRIghgiKCI4Itgi+CKIIrgjiCO4IzgjSCPoJEgkmCS4JPglqCX4Jogn6IhYiIiNiI34heiZ1/n3+nf69/sH+yf3x8SWWRfJ18nHyefKJ8sny8fL18wXzHfMx8zXzIfMV813zofG6CqGa/f85/1X/lf+F/5n/pf+5/83/4fHd9pn2ufUd+m364nrSec42EjZSNkY2xjWeNbY1HjEmMSpFQkU6RT5FkkXybfZt+m3+bgJuBm4Kbg5uEm4WbhpuHm4ibiZuKm4ubjJuNm46bj5uQm5GbkpuTm5SblZuWm5ebmJuZm5qbm5ucm52bnpufm6CboZuim6ObpJulm6abp5uom6mbqpurm6ybrZuum6+bsJuxm7Kbs5u0m7Wbtpu3m7ibuZu6m7ubvJu9m76bv5vAm8GbwpvDm8SbxZvGm8ebyJvJm8qby5vMm82bzpvPm9Cb0ZvSm9Ob1JvVm9ab15vYm9mb2pvbm2KRYZFwkWmRb5F9kX6RcpF0kXmRjJGFkZCRjZGRkaKRo5Gqka2RrpGvkbWRtJG6kVWMfp64jeuNBY5ZjmmOtY2/jbyNuo3EjdaN143ajd6Nzo3PjduNxo3sjfeN+I3jjfmN+43kjQmO/Y0Ujh2OH44sji6OI44vjjqOQI45jjWOPY4xjkmOQY5CjlGOUo5KjnCOdo58jm+OdI6Fjo+OlI6QjpyOno54jIKMioyFjJiMlIybZdaJ3onaidyJ3Jvdm96b35vgm+Gb4pvjm+Sb5Zvmm+eb6Jvpm+qb65vsm+2b7pvvm/Cb8Zvym/Ob9Jv1m/ab95v4m/mb+pv7m/yb/Zv+m/+bAJwBnAKcA5wEnAWcBpwHnAicCZwKnAucDJwNnA6cD5wQnBGcEpwTnBScFZwWnBecGJwZnBqcG5wcnB2cHpwfnCCcIZwinCOcJJwlnCacJ5wonCmcKpwrnCycLZwunC+cMJwxnDKcM5w0nDWcNpw3nDicOZw6nDuc5Ynrie+JPoomi1OX6Zbzlu+WBpcBlwiXD5cOlyqXLZcwlz6XgJ+Dn4Wfhp+Hn4ifiZ+Kn4yf/p4Lnw2fuZa8lr2WzpbSlr934JaOkq6SyJI+k2qTypOPkz6Ua5R/nIKchZyGnIeciJwjeoucjpyQnJGckpyUnJWcmpybnJ6cn5ygnKGcopyjnKWcppynnKicqZyrnK2crpywnLGcspyznLSctZy2nLecupy7nLycvZzEnMWcxpzHnMqcy5w8nD2cPpw/nECcQZxCnEOcRJxFnEacR5xInEmcSpxLnEycTZxOnE+cUJxRnFKcU5xUnFWcVpxXnFicWZxanFucXJxdnF6cX5xgnGGcYpxjnGScZZxmnGecaJxpnGqca5xsnG2cbpxvnHCccZxynHOcdJx1nHacd5x4nHmcepx7nH2cfpyAnIOchJyJnIqcjJyPnJOclpyXnJicmZydnKqcrJyvnLmcvpy/nMCcwZzCnMicyZzRnNKc2pzbnOCc4ZzMnM2czpzPnNCc05zUnNWc15zYnNmc3JzdnN+c4px8l4WXkZeSl5SXr5erl6OXspe0l7GasJq3mlietpq6mryawZrAmsWawprLmsya0ZpFm0ObR5tJm0ibTZtRm+iYDZkumVWZVJnfmuGa5prvmuua+5rtmvmaCJsPmxObH5sjm72evp47foKeh56Inouekp7Wk52en57bntye3Z7gnt+e4p7pnuee5Z7qnu+eIp8sny+fOZ83nz2fPp9En+Oc5JzlnOac55zonOmc6pzrnOyc7ZzunO+c8JzxnPKc85z0nPWc9pz3nPic+Zz6nPuc/Jz9nP6c/5wAnQGdAp0DnQSdBZ0GnQedCJ0JnQqdC50MnQ2dDp0PnRCdEZ0SnROdFJ0VnRadF50YnRmdGp0bnRydHZ0enR+dIJ0hnSKdI50knSWdJp0nnSidKZ0qnSudLJ0tnS6dL50wnTGdMp0znTSdNZ02nTedOJ05nTqdO508nT2dPp0/nUCdQZ1CnTTiNeI24jfiOOI54jriO+I84j3iPuI/4kDiQeJC4kPiROJF4kbiR+JI4kniSuJL4kziTeJO4k/iUOJR4lLiU+JU4lXiVuJX4ljiWeJa4lviXOJd4l7iX+Jg4mHiYuJj4mTiZeJm4mfiaOJp4mria+Js4m3ibuJv4nDiceJy4nPidOJ14nbid+J44nnieuJ74nzifeJ+4n/igOKB4oLig+KE4oXihuKH4ojiieKK4ovijOKN4o7ij+KQ4pHiQ51EnUWdRp1HnUidSZ1KnUudTJ1NnU6dT51QnVGdUp1TnVSdVZ1WnVedWJ1ZnVqdW51cnV2dXp1fnWCdYZ1inWOdZJ1lnWadZ51onWmdap1rnWydbZ1unW+dcJ1xnXKdc510nXWddp13nXideZ16nXudfJ19nX6df52AnYGdgp2DnYSdhZ2GnYediJ2JnYqdi52MnY2djp2PnZCdkZ2SnZOdlJ2VnZadl52YnZmdmp2bnZydnZ2enZ+doJ2hnaKdkuKT4pTileKW4pfimOKZ4prim+Kc4p3inuKf4qDioeKi4qPipOKl4qbip+Ko4qniquKr4qzireKu4q/isOKx4rLis+K04rXituK34rjiueK64rvivOK94r7iv+LA4sHiwuLD4sTixeLG4sfiyOLJ4sriy+LM4s3izuLP4tDi0eLS4tPi1OLV4tbi1+LY4tni2uLb4tzi3eLe4t/i4OLh4uLi4+Lk4uXi5uLn4uji6eLq4uvi7OLt4u7i7+KjnaSdpZ2mnaedqJ2pnaqdq52sna2drp2vnbCdsZ2ynbOdtJ21nbadt524nbmdup27nbydvZ2+nb+dwJ3BncKdw53EncWdxp3HncidyZ3KncudzJ3Nnc6dz53QndGd0p3TndSd1Z3Wnded2J3Zndqd253cnd2d3p3fneCd4Z3ineOd5J3lnead553onemd6p3rneyd7Z3une+d8J3xnfKd8530nfWd9p33nfid+Z36nfud/J39nf6d/50AngGeAp7w4vHi8uLz4vTi9eL24vfi+OL54vri++L84v3i/uL/4gDjAeMC4wPjBOMF4wbjB+MI4wnjCuML4wzjDeMO4w/jEOMR4xLjE+MU4xXjFuMX4xjjGeMa4xvjHOMd4x7jH+Mg4yHjIuMj4yTjJeMm4yfjKOMp4yrjK+Ms4y3jLuMv4zDjMeMy4zPjNOM14zbjN+M44znjOuM74zzjPeM+4z/jQONB40LjQ+NE40XjRuNH40jjSeNK40vjTONN4wOeBJ4FngaeB54IngmeCp4LngyeDZ4Ong+eEJ4RnhKeE54UnhWeFp4XnhieGZ4anhueHJ4dnh6eJJ4nni6eMJ40njuePJ5Ank2eUJ5SnlOeVJ5WnlmeXZ5fnmCeYZ5inmWebp5vnnKedJ51nnaed554nnmeep57nnyefZ6AnoGeg56EnoWehp6JnoqejJ6Nno6ej56QnpGelJ6Vnpael56Ynpmemp6bnpyenp6gnqGeop6jnqSepZ6nnqieqZ6qnk7jT+NQ41HjUuNT41TjVeNW41fjWONZ41rjW+Nc413jXuNf42DjYeNi42PjZONl42bjZ+No42njauNr42zjbeNu42/jcONx43Ljc+N043XjduN343jjeeN643vjfON9437jf+OA44HjguOD44TjheOG44fjiOOJ44rji+OM443jjuOP45DjkeOS45PjlOOV45bjl+OY45njmuOb45zjneOe45/joOOh46Ljo+Ok46XjpuOn46jjqeOq46vjq56snq2erp6vnrCesZ6ynrOetZ62nreeuZ66nryev57AnsGewp7DnsWexp7Hnsieyp7Lnsye0J7SntOe1Z7Wntee2Z7ant6e4Z7jnuSe5p7onuue7J7tnu6e8J7xnvKe8570nvWe9p73nvie+p79nv+eAJ8BnwKfA58EnwWfBp8HnwifCZ8KnwyfD58RnxKfFJ8VnxafGJ8anxufHJ8dnx6fH58hnyOfJJ8lnyafJ58onymfKp8r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khudaVi8ZVpsJXX5US5ZZVmAX9xfvGL6ZSpqJ2u0a4tzwX9WiSydDp3EnqFclmx7gwRRS1y2YcaBdmhhcllO+k94U2lgKW5PevOXC04WU+5OVU89T6FPc0+gUu9TCVYPWcFatlvhW9F5h2acZ7ZnTGuzbGtwwnONeb55PHqHe7GC24IEg3eD74PTg2aHsoopVqiM5o9OkB6XiobET+hcEWJZcjt15YG9gv6GwIzFlhOZ1ZnLThpP44neVkpYylj7XutfKmCUYGJg0GESYtBiOWVBm2ZmsGh3bXBwTHWGdnV9pYL5h4uVjpadjPFRvlIWWbNUs1sWXWhhgmmvbY14y4RXiHKKp5O4mmxtqJnZhqNX/2fOhg6Sg1KHVgRU017hYrlkPGg4aLtrcnO6eGt6monSiWuNA4/tkKOVlJZpl2Zbs1x9aU2YTpibYyB7K2p/arZoDZxfb3JSnVVwYOxiO20HbtFuW4QQiUSPFE45nPZTG2k6aoSXKmhcUcN6soTckYyTW1YonSJoBYMxhKV8CFLFguZ0fk6DT6BR0lsKUthS51L7XZpVKljmWYxbmFvbW3JeeV6jYB9hY2G+YdtjYmXRZ1No+mg+a1NrV2wib5dvRW+wdBh143YLd/96oXshfOl9Nn/wf52AZoKeg7OJzIqrjISQUZSTlZGVopVlltOXKJkYgjhOK1S4XMxdqXNMdjx3qVzrfwuNwZYRmFSYWJgBTw5PcVOcVWhW+ldHWQlbxFuQXAxefl7MX+5jOmfXZeJlH2fLaMRoX2owXsVrF2x9bH91SHljWwB6AH29X4+JGIq0jHeNzI4dj+KYDpo8m4BOfVAAUZNZnFsvYoBi7GQ6a6BykXVHeal/+4e8inCLrGPKg6CXCVQDVKtVVGhYanCKJ3h1Z82edFOiWxqBUIYGkBhORU7HThFPylM4VK5bE18lYFFlPWdCbHJs42x4cAN0dnquegh7Gn3+fGZ952VbcrtTRVzoXdJi4GIZYyBuWoYxit2N+JIBb6Z5WpuoTqtOrE6bT6BP0VBHUfZ6cVH2UVRTIVN/U+tTrFWDWOFcN19KXy9gUGBtYB9jWWVLasFswnLtcu93+IAFgQiCToX3kOGT/5dXmVqa8E7dUS1cgWZtaUBc8mZ1aYlzUGiBfMVQ5FJHV/5dJpOkZSNrPWs0dIF5vXlLe8p9uYLMg3+IX4k5i9GP0ZEfVICSXU42UOVTOlPXcpZz6Xfmgq+OxpnImdKZd1EaYV6GsFV6enZQ01tHkIWWMk7baueRUVxIXJhjn3qTbHSXYY+qeopxiJaCfBdocH5RaGyT8lIbVKuFE4qkf82O4ZBmU4iIQXnCT75QEVJEUVNVLVfqc4tXUVliX4RfdWB2YWdhqWGyYzpkbGVvZkJoE25mdT16+3xMfZl9S35rfw6DSoPNhgiKY4pmi/2OGpiPnbiCzo/om4dSH2KDZMBvmZZBaJFQIGt6bFRvdHpQfUCII4oIZ/ZOOVAmUGVQfFE4UmNSp1UPVwVYzFr6XrJh+GHzYnJjHGkpan1yrHIucxR4b3h5fQx3qYCLiRmL4ozSjmOQdZN6llWYE5p4nkNRn1OzU3teJl8bbpBuhHP+c0N9N4IAivqKUJZOTgtQ5FN8VPpW0VlkW/Fdq14nXzhiRWWvZ1Zu0HLKfLSIoYDhgPCDToaHiuiNN5LHlmeYE5+UTpJODU9IU0lUPlQvWoxfoV+fYKdojmpadIF4noqkineLkJFeTsmbpE58T69PGVAWUElRbFGfUrlS/lKaU+NTEVQOVIlVUVeiV31ZVFtdW49b5V3nXfddeF6DXppet14YX1JgTGGXYthip2M7ZQJmQ2b0Zm1nIWiXaMtpX2wqbWltL26dbjJ1h3ZseD964HwFfRh9Xn2xfRWAA4CvgLGAVIGPgSqCUoNMiGGIG4uijPyMypB1kXGSP3j8kqSVTZYFmJmZ2Jo7nVtSq1L3UwhU1Vj3YuBvaoxfj7meS1E7UkpU/VZAeneRYJ3SnkRzCW9wgRF1/V/aYKia23K8j2RrA5jKTvBWZFe+WFpaaGDHYQ9mBmY5aLFo923VdTp9boJCm5tOUE/JUwZVb13mXe5d+2eZbHN0AnhQipaT34hQV6deK2O1UKxQjVEAZ8lUXli7WbBbaV9NYqFjPWhzawhufXDHkYByFXgmeG15jmUwfdyDwYgJj5uWZFIoV1Bnan+hjLRRQlcqljpYimm0gLJUDl38V5V4+p1cT0pSi1Q+ZChmFGf1Z4R6VnsifS+TXGitmzl7GVOKUTdS31v2Yq5k5mQtZ7prqYXRlpB21ptMYwaTq5u/dlJmCU6YUMJTcVzoYJJkY2VfaOZxynMjdZd7gn6VhoOL24x4kRCZrGWrZotr1U7UTjpPf086UvhT8lPjVdtW61jLWclZ/1lQW01cAl4rXtdfHWAHYy9lXFuvZb1l6GWdZ2Jre2sPbEVzSXnBefh8GX0rfaKAAoHzgZaJXoppimaKjIruiseM3IzMlvyYb2uLTjxPjU9QUVdb+ltIYQFjQmYha8tuu2w+cr101HXBeDp5DIAzgOqBlISej1Bsf54PX1iLK536eviOjVvrlgNO8VP3VzFZyVqkW4lgf24Gb7516oyfWwCF4HtyUPRnnYJhXEqFHn4OgplRBFxoY2aNnGVucT55F30FgB2Lyo5ukMeGqpAfUPpSOlxTZ3xwNXJMkciRK5PlgsJbMV/5YDtO1lOIW0tiMWeKa+ly4HMuemuBo41SkZaZElHXU2pU/1uIYzlqrH0Al9pWzlNoVJdbMVzeXe5PAWH+YjJtwHnLeUJ9TX7Sf+2BH4KQhEaIcomQi3SOL48xkEuRbJHGlpyRwE5PT0VRQVOTXw5i1GdBbAtuY3Mmfs2Rg5LUUxlZv1vRbV15Ln6bfH5Yn3H6UVOI8I/KT/tcJWasd+N6HIL/mcZRql/sZW9piWvzbZZuZG/+dhR94V11kIeRBpjmUR1SQGKRZtlmGm62XtJ9cn/4Zq+F94X4iqlS2VNzWY9ekF9VYOSSZJa3UB9R3VIgU0dT7FPoVEZVMVUXVmhZvlk8WrVbBlwPXBFcGlyEXope4F5wX39ihGLbYoxjd2MHZgxmLWZ2Zn5nomgfajVqvGyIbQluWG48cSZxZ3HHdQF3XXgBeWV58HngehF7p3w5fZaA1oOLhEmFXYjziB+KPIpUinOKYYzejKSRZpJ+kxiUnJaYlwpOCE4eTldOl1FwUs5XNFjMWCJbOF7FYP5kYWdWZ0RttnJzdWN6uIRyi7iRIJMxVvRX/pjtYg1plmvtcVR+d4ByguaJ35hVh7GPO1w4T+FPtU8HVSBa3VvpW8NfTmEvY7BlS2buaJtpeG3xbTN1uXUfd1555nkzfeOBr4KqhaqJOoqrjpuPMpDdkQeXuk7BTgNSdVjsWAtcGnU9XE6BCorFj2OWbZcle8+KCJhikfNWqFMXkDlUglclXqhjNGyKcGF3i3zgf3CIQpBUkRCTGJOPll50xJoHXWldcGWiZ6iN25ZuY0lnGWnFgxeYwJb+iIRvemT4WxZOLHBddS9mxFE2UuJS01mBXydgEGI/ZXRlH2Z0ZvJoFmhjawVucnIfddt2vnxWgPBY/Yh/iaCKk4rLih2QkpFSl1mXiWUOegaBu5YtXtxgGmKlZRRmkGfzd016TXw+fgqBrIxkjeGNX46peAdS2WKlY0JkmGItioN6wHusiuqWdn0MgkmH2U5IUUNTYFOjWwJcFlzdXSZiR2KwZBNoNGjJbEVtF23TZ1xvTnF9cctlf3qte9p9Sn6of3qBG4I5gqaFborOjPWNeJB3kK2SkZKDla6bTVKEVThvNnFoUYV5VX6zgc58TFZRWKhcqmP+Zv1mWmnZco91jnUOeVZ533mXfCB9RH0HhjSKO5ZhkCCf51B1UsxT4lMJUKpV7lhPWT1yi1tkXB1T42DzYFxjg2M/Y7tjzWTpZflm413Naf1pFW/lcYlO6XX4dpN633zPfZx9YYBJg1iDbIS8hPuFxYhwjQGQbZCXkxyXEprPUJdYjmHTgTWFCI0gkMNPdFBHUnNTb2BJY19nLG6zjR+Q109eXMqMz2WafVJTloh2UcNjWFtrWwpcDWRRZ1yQ1k4aWSpZcGxRij5VFVilWfBgU2LBZzWCVWlAlsSZKJpTTwZY/lsQgLFcL16FXyBgS2E0Yv9m8Gzebs6Af4HUgouIuIwAkC6Qipbbntub407wUydZLHuNkUyY+Z3dbidwU1NEVYVbWGKeYtNiomzvbyJ0F4o4lMFv/oo4g+dR+IbqU+lTRk9UkLCPalkxgf1d6nq/j9poN4z4ckicPWqwijlOWFMGVmZXxWKiY+ZlTmvhbVturXDtd+96qnu7fT2AxoDLhpWKW5PjVsdYPl+tZZZmgGq1azd1x4okUOV3MFcbX2VgemZgbPR1Gnpuf/SBGIdFkLOZyXtcdfl6UXvEhBCQ6XmSejaD4VpAdy1O8k6ZW+BfvWI8ZvFn6GxrhneIO4pOkfOS0JkXaiZwKnPngleEr4wBTkZRy1GLVfVbFl4zXoFeFF81X2tftF/yYRFjomYdZ25vUnI6dTp3dIA5gXiBdoe/ityKhY3zjZqSd5UCmOWcxVJXY/R2FWeIbM1zw4yuk3OWJW2cWA5pzGn9j5qT23UakFpYAmi0Y/tpQ08sb9hnu48mhbR9VJM/aXBvalf3WCxbLH0qcgpU45G0na1OTk9cUHVQQ1KejEhUJFiaWx1elV6tXvdeH1+MYLViOmPQY69oQGyHeI55C3rgfUeCAormikSOE5C4kC2R2JEOn+VsWGTiZHVl9G6Edht7aZDRk7pu8lS5X6RkTY/tj0SSeFFrWClZVVyXXvttj34cdbyM4o5bmLlwHU+/a7FvMHX7lk5REFQ1WFdYrFlgXJJfl2VcZyFue3bfg+2MFJD9kE2TJXg6eKpSpl4fV3RZEmASUFpRrFHNUQBSEFVUWFhYV1mVW/Zci128YJViLWRxZ0NovGjfaNd22G1vbpttb3DIcVNf2HV3eUl7VHtSe9Z8cX0wUmOEaYXkhQ6KBItGjA+OA5APkBmUdpYtmDCa2JXNUNVSDFQCWA5cp2GeZB5ts3flevSABIRTkIWS4FwHnT9Tl1+zX5xteXJjd7955HvSa+xyrYoDaGFq+FGBejRpSlz2nOuCxVtJkR5weFZvXMdgZmWMbFqMQZATmFFUx2YNkkhZo5CFUU1O6lGZhQ6LWHB6Y0uTYmm0mQR+d3VXU2Bp347jll1sjE48XBBf6Y8CU9GMiYB5hv9e5WVzTmVRglk/XO6X+06KWc1fjYrhb7B5YnnnW3GEK3OxcXRe9V97Y5pkw3GYfENO/F5LTtxXolapYMNvDX39gDOBv4Gyj5eJpIb0XYpirWSHiXdn4mw+bTZ0NHhGWnV/rYKsmfNPw17dYpJjV2VvZ8N2THLMgLqAKY9NkQ1Q+VeSWoVoc2lkcf1yt4zyWOCMapYZkH+H5HnndymEL09lUlpTzWLPZ8psfXaUe5V8NoKEheuP3WYgbwZyG36rg8GZpp79UbF7cni4e4eASHvoamFejIBRdWB1a1FikoxuenaXkeqaEE9wf5xiT3ullemcelZZWOSGvJY0TyRSSlPNU9tTBl4sZJFlf2c+bE5sSHKvcu1zVHVBfiyC6YWpjMR7xpFpcRKY75g9Y2lmanXkdtB4Q4XuhipTUVMmVINZh158X7JgSWJ5YqtikGXUa8xssnWudpF42HnLfXd/pYCriLmKu4x/kF6X25gLajh8mVA+XK5fh2fYazV0CXeOfzufymcXejlTi3XtmmZfnYHxg5iAPF/FX2J1Rns8kGdo61mbWhB9fnYsi/VPal8ZajdsAm/idGh5aIhVinmM317PY8V10nnXgiiT8pKchO2GLZzBVGxfjGVcbRVwp4zTjDuYT2X2dA1O2E7gVytZZlrMW6hRA16cXhZgdmJ3ZadlbmZubTZyJntQgZqBmYJci6CM5ox0jRyWRJauT6tkZmsegmGEaoXokAFcU2momHqEV4UPT29SqV9FXg1nj3l5gQeJhon1bRdfVWK4bM9OaXKSmwZSO1R0VrNYpGFuYhpxblmJfN58G33wlodlXoAZTnVPdVFAWGNec14KX8RnJk49hYmVW5ZzfAGY+1DBWFZ2p3glUqV3EYWGe09QCVlHcsd76H26j9SPTZC/T8lSKVoBX62X3U8XguqSA1dVY2lrK3XciBSPQnrfUpNYVWEKYq5mzWs/fOmDI1D4TwVTRlQxWElZnVvwXO9cKV2WXrFiZ2M+ZbllC2fVbOFs+XAyeCt+3oCzggyE7IQChxKJKopKjKaQ0pL9mPOcbJ1PTqFOjVBWUkpXqFk9Xthf2V8/YrRmG2fQZ9JoklEhfaqAqIEAi4yMv4x+kjKWIFQsmBdT1VBcU6hYsmQ0Z2dyZndGeuaRw1KhbIZrAFhMXlRZLGf7f+FRxnZpZOh4VJu7nstXuVknZppnzmvpVNlpVV6cgZVnqpv+Z1KcXWimTuNPyFO5Yitnq2zEj61PbX6/ngdOYmGAbitvE4VzVCpnRZvzXZV7rFzGWxyHSm7RhBR6CIGZWY18EWwgd9lSIlkhcV9y23cnl2GdC2l/WhhapVENVH1UDmbfdvePmJL0nOpZXXLFbk1RyWi/fex9Ype6nnhkIWoCg4RZX1vbaxtz8nayfReAmYQyUShn2Z7udmJn/1IFmSRcO2J+fLCMT1W2YAt9gJUBU19OtlEcWTpyNoDOkSVf4neEU3lfBH2shTOKjY5Wl/NnroVTlAlhCGG5bFJ27Yo4jy9VUU8qUcdSy1OlW31eoGCCYdZjCWfaZ2dujG02czdzMXVQedWImIpKkJGQ9ZDElo2HFVmITllPDk6Jij+PEJitUHxellm5W7he2mP6Y8Fk3GZKadhpC222bpRxKHWveop/AIBJhMmEgYkhiwqOZZB9lgqZfmGRYjJrg2x0bcx//H/AbYV/uof4iGVnsYM8mPeWG21hfT2EapFxTnVTUF0Ea+tvzYUthqeJKVIPVGVcTmeoaAZ0g3Tidc+I4YjMkeKWeJaLX4dzy3pOhKBjZXWJUkFtnG4JdFl1a3iSfIaW3HqNn7ZPbmHFZVyGhk6uTtpQIU7MUe5bmWWBaLxtH3NCdq13HHrnfG+C0op8kM+RdZYYmJtS0X0rUJhTl2fLbdBxM3TogSqPo5ZXnJ+eYHRBWJltL31emORONk+LT7dRsVK6XRxgsnM8edOCNJK3lvaWCpeXnmKfpmZ0axdSo1LIcMKIyV5LYJBhI29JcT589H1vgO6EI5Ask0JUb5vTaolwwozvjTKXtFJBWspeBF8XZ3xplGlqbQ9vYnL8cu17AYB+gEuHzpBtUZOehHmLgDKT1ootUIxUcYpqa8SMB4HRYKBn8p2ZTphOEJxrisGFaIUAaX5ul3hVgQBB1PwGC/w0DF8QThVOKk4xTjZOPE4/TkJOVk5YToJOhU5rjIpOEoINX45Onk6fTqBOok6wTrNOtk7OTs1OxE7GTsJO107eTu1O3073TglPWk8wT1tPXU9XT0dPdk+IT49PmE97T2lPcE+RT29Phk+WTxhR1E/fT85P2E/bT9FP2k/QT+RP5U8aUChQFFAqUCVQBVAcT/ZPIVApUCxQ/k/vTxFQBlBDUEdQA2dVUFBQSFBaUFZQbFB4UIBQmlCFULRQslDJUMpQs1DCUNZQ3lDlUO1Q41DuUPlQ9VAJUQFRAlEWURVRFFEaUSFROlE3UTxRO1E/UUBRUlFMUVRRYlH4emlRalFuUYBRglHYVoxRiVGPUZFRk1GVUZZRpFGmUaJRqVGqUatRs1GxUbJRsFG1Ub1RxVHJUdtR4FFVhulR7VHwUfVR/lEEUgtSFFIOUidSKlIuUjNSOVJPUkRSS1JMUl5SVFJqUnRSaVJzUn9SfVKNUpRSklJxUohSkVKoj6ePrFKtUrxStVLBUs1S11LeUuNS5lLtmOBS81L1UvhS+VIGUwhTOHUNUxBTD1MVUxpTI1MvUzFTM1M4U0BTRlNFUxdOSVNNU9ZRXlNpU25TGFl7U3dTglOWU6BTplOlU65TsFO2U8NTEnzZlt9T/Gbuce5T6FPtU/pTAVQ9VEBULFQtVDxULlQ2VClUHVROVI9UdVSOVF9UcVR3VHBUklR7VIBUdlSEVJBUhlTHVKJUuFSlVKxUxFTIVKhUq1TCVKRUvlS8VNhU5VTmVA9VFFX9VO5U7VT6VOJUOVVAVWNVTFUuVVxVRVVWVVdVOFUzVV1VmVWAVa9UilWfVXtVflWYVZ5VrlV8VYNVqVWHVahV2lXFVd9VxFXcVeRV1FUUVvdVFlb+Vf1VG1b5VU5WUFbfcTRWNlYyVjhWa1ZkVi9WbFZqVoZWgFaKVqBWlFaPVqVWrla2VrRWwla8VsFWw1bAVshWzlbRVtNW11buVvlWAFf/VgRXCVcIVwtXDVcTVxhXFlfHVRxXJlc3VzhXTlc7V0BXT1dpV8BXiFdhV39XiVeTV6BXs1ekV6pXsFfDV8ZX1FfSV9NXCljWV+NXC1gZWB1YclghWGJYS1hwWMBrUlg9WHlYhVi5WJ9Yq1i6WN5Yu1i4WK5YxVjTWNFY11jZWNhY5VjcWORY31jvWPpY+Vj7WPxY/VgCWQpZEFkbWaZoJVksWS1ZMlk4WT5Z0npVWVBZTllaWVhZYllgWWdZbFlpWXhZgVmdWV5Pq0+jWbJZxlnoWdxZjVnZWdpZJVofWhFaHFoJWhpaQFpsWklaNVo2WmJaalqaWrxavlrLWsJavVrjWtda5lrpWtZa+lr7WgxbC1sWWzJb0FoqWzZbPltDW0VbQFtRW1VbWltbW2VbaVtwW3NbdVt4W4hleluAW4Nbplu4W8Nbx1vJW9Rb0FvkW+Zb4lveW+Vb61vwW/Zb81sFXAdcCFwNXBNcIFwiXChcOFw5XEFcRlxOXFNcUFxPXHFbbFxuXGJOdlx5XIxckVyUXJtZq1y7XLZcvFy3XMVcvlzHXNlc6Vz9XPpc7VyMXepcC10VXRddXF0fXRtdEV0UXSJdGl0ZXRhdTF1SXU5dS11sXXNddl2HXYRdgl2iXZ1drF2uXb1dkF23XbxdyV3NXdNd0l3WXdtd613yXfVdC14aXhleEV4bXjZeN15EXkNeQF5OXldeVF5fXmJeZF5HXnVedl56Xryef16gXsFewl7IXtBez17WXuNe3V7aXtte4l7hXuhe6V7sXvFe817wXvRe+F7+XgNfCV9dX1xfC18RXxZfKV8tXzhfQV9IX0xfTl8vX1FfVl9XX1lfYV9tX3Nfd1+DX4Jff1+KX4hfkV+HX55fmV+YX6BfqF+tX7xf1l/7X+Rf+F/xX91fs2D/XyFgYGAZYBBgKWAOYDFgG2AVYCtgJmAPYDpgWmBBYGpgd2BfYEpgRmBNYGNgQ2BkYEJgbGBrYFlggWCNYOdgg2CaYIRgm2CWYJdgkmCnYItg4WC4YOBg02C0YPBfvWDGYLVg2GBNYRVhBmH2YPdgAGH0YPpgA2EhYftg8WANYQ5hR2E+YShhJ2FKYT9hPGEsYTRhPWFCYURhc2F3YVhhWWFaYWthdGFvYWVhcWFfYV1hU2F1YZlhlmGHYaxhlGGaYYphkWGrYa5hzGHKYclh92HIYcNhxmG6YctheX/NYeZh42H2Yfph9GH/Yf1h/GH+YQBiCGIJYg1iDGIUYhtiHmIhYipiLmIwYjJiM2JBYk5iXmJjYltiYGJoYnxigmKJYn5ikmKTYpZi1GKDYpRi12LRYrtiz2L/YsZi1GTIYtxizGLKYsJix2KbYsliDGPuYvFiJ2MCYwhj72L1YlBjPmNNYxxkT2OWY45jgGOrY3Zjo2OPY4ljn2O1Y2tjaWO+Y+ljwGPGY+NjyWPSY/ZjxGMWZDRkBmQTZCZkNmQdZRdkKGQPZGdkb2R2ZE5kKmWVZJNkpWSpZIhkvGTaZNJkxWTHZLtk2GTCZPFk52QJguBk4WSsYuNk72QsZfZk9GTyZPpkAGX9ZBhlHGUFZSRlI2UrZTRlNWU3ZTZlOGVLdUhlVmVVZU1lWGVeZV1lcmV4ZYJlg2WKi5tln2WrZbdlw2XGZcFlxGXMZdJl22XZZeBl4WXxZXJnCmYDZvtlc2c1ZjZmNGYcZk9mRGZJZkFmXmZdZmRmZ2ZoZl9mYmZwZoNmiGaOZolmhGaYZp1mwWa5Zslmvma8ZsRmuGbWZtpm4GY/ZuZm6WbwZvVm92YPZxZnHmcmZydnOJcuZz9nNmdBZzhnN2dGZ15nYGdZZ2NnZGeJZ3BnqWd8Z2pnjGeLZ6ZnoWeFZ7dn72e0Z+xns2fpZ7hn5GfeZ91n4mfuZ7lnzmfGZ+dnnGoeaEZoKWhAaE1oMmhOaLNoK2hZaGNod2h/aJ9oj2itaJRonWibaINormq5aHRotWigaLpoD2mNaH5oAWnKaAhp2GgiaSZp4WgMac1o1GjnaNVoNmkSaQRp12jjaCVp+WjgaO9oKGkqaRppI2khacZoeWl3aVxpeGlraVRpfmluaTlpdGk9aVlpMGlhaV5pXWmBaWppsmmuadBpv2nBadNpvmnOaehbymndabtpw2mnaS5qkWmgaZxplWm0ad5p6GkCahtq/2kKa/lp8mnnaQVqsWkeau1pFGrraQpqEmrBaiNqE2pEagxqcmo2anhqR2piallqZmpIajhqImqQao1qoGqEaqJqo2qXaheGu2rDasJquGqzaqxq3mrRat9qqmraaupq+2oFaxaG+moSaxZrMZsfazhrN2vcdjlr7phHa0NrSWtQa1lrVGtba19rYWt4a3lrf2uAa4Rrg2uNa5hrlWuea6Rrqmura69rsmuxa7Nrt2u8a8Zry2vTa99r7Gvra/Nr72u+nghsE2wUbBtsJGwjbF5sVWxibGpsgmyNbJpsgWybbH5saGxzbJJskGzEbPFs02y9bNdsxWzdbK5ssWy+bLps22zvbNls6mwfbU2INm0rbT1tOG0ZbTVtM20SbQxtY22TbWRtWm15bVltjm2VbeRvhW35bRVuCm61bcdt5m24bcZt7G3ebcxt6G3SbcVt+m3ZbeRt1W3qbe5tLW5ubi5uGW5ybl9uPm4jbmtuK252bk1uH25DbjpuTm4kbv9uHW44boJuqm6Ybslut27Tbr1ur27EbrJu1G7Vbo9upW7Cbp9uQW8Rb0xw7G74bv5uP2/ybjFv724yb8xuPm8Tb/duhm96b3hvgW+Ab29vW2/zb21vgm98b1hvjm+Rb8JvZm+zb6NvoW+kb7lvxm+qb99v1W/sb9Rv2G/xb+5v228JcAtw+m8RcAFwD3D+bxtwGnB0bx1wGHAfcDBwPnAycFFwY3CZcJJwr3DxcKxwuHCzcK5w33DLcN1w2XAJcf1wHHEZcWVxVXGIcWZxYnFMcVZxbHGPcftxhHGVcahxrHHXcblxvnHScclx1HHOceBx7HHncfVx/HH5cf9xDXIQchtyKHItcixyMHIycjtyPHI/ckByRnJLclhydHJ+coJygXKHcpJylnKicqdyuXKycsNyxnLEcs5y0nLicuBy4XL5cvdyD1AXcwpzHHMWcx1zNHMvcylzJXM+c05zT3PYnldzanNoc3BzeHN1c3tzenPIc7NzznO7c8Bz5XPuc95zonQFdG90JXT4czJ0OnRVdD90X3RZdEF0XHRpdHB0Y3RqdHZ0fnSLdJ50p3TKdM901HTxc+B043TndOl07nTydPB08XT4dPd0BHUDdQV1DHUOdQ11FXUTdR51JnUsdTx1RHVNdUp1SXVbdUZ1WnVpdWR1Z3VrdW11eHV2dYZ1h3V0dYp1iXWCdZR1mnWddaV1o3XCdbN1w3W1db11uHW8dbF1zXXKddJ12XXjdd51/nX/dfx1AXbwdfp18nXzdQt2DXYJdh92J3YgdiF2InYkdjR2MHY7dkd2SHZGdlx2WHZhdmJ2aHZpdmp2Z3ZsdnB2cnZ2dnh2fHaAdoN2iHaLdo52lnaTdpl2mnawdrR2uHa5drp2wnbNdtZ20nbeduF25Xbndup2L4b7dgh3B3cEdyl3JHcedyV3Jncbdzd3OHdHd1p3aHdrd1t3ZXd/d353eXeOd4t3kXegd553sHe2d7l3v3e8d713u3fHd81313fad9x343fud/x3DHgSeCZ5IHgqeUV4jnh0eIZ4fHiaeIx4o3i1eKp4r3jReMZ4y3jUeL54vHjFeMp47HjneNp4/Xj0eAd5EnkReRl5LHkreUB5YHlXeV95WnlVeVN5enl/eYp5nXmneUufqnmuebN5uXm6ecl51Xnneex54XnjeQh6DXoYehl6IHofeoB5MXo7ej56N3pDeld6SXphemJ6aXqdn3B6eXp9eoh6l3qVeph6lnqpesh6sHq2esV6xHq/eoOQx3rKes16z3rVetN62Xraet164XrieuZ67XrwegJ7D3sKewZ7M3sYexl7Hns1eyh7NntQe3p7BHtNewt7THtFe3V7ZXt0e2d7cHtxe2x7bnude5h7n3uNe5x7mnuLe5J7j3tde5l7y3vBe8x7z3u0e8Z73XvpexF8FHzme+V7YHwAfAd8E3zze/d7F3wNfPZ7I3wnfCp8H3w3fCt8PXxMfEN8VHxPfEB8UHxYfF98ZHxWfGV8bHx1fIN8kHykfK18onyrfKF8qHyzfLJ8sXyufLl8vXzAfMV8wnzYfNJ83HzifDub73zyfPR89nz6fAZ9An0cfRV9Cn1FfUt9Ln0yfT99NX1GfXN9Vn1OfXJ9aH1ufU99Y32TfYl9W32PfX19m326fa59o321fcd9vX2rfT1+on2vfdx9uH2ffbB92H3dfeR93n37ffJ94X0Ffgp+I34hfhJ+MX4ffgl+C34ifkZ+Zn47fjV+OX5Dfjd+Mn46fmd+XX5Wfl5+WX5afnl+an5pfnx+e36DftV9fX6uj39+iH6Jfox+kn6QfpN+lH6Wfo5+m36cfjh/On9Ff0x/TX9Of1B/UX9Vf1R/WH9ff2B/aH9pf2d/eH+Cf4Z/g3+If4d/jH+Uf55/nX+af6N/r3+yf7l/rn+2f7h/cYvFf8Z/yn/Vf9R/4X/mf+l/83/5f9yYBoAEgAuAEoAYgBmAHIAhgCiAP4A7gEqARoBSgFiAWoBfgGKAaIBzgHKAcIB2gHmAfYB/gISAhoCFgJuAk4CagK2AkFGsgNuA5YDZgN2AxIDagNaACYHvgPGAG4EpgSOBL4FLgYuWRoE+gVOBUYH8gHGBboFlgWaBdIGDgYiBioGAgYKBoIGVgaSBo4FfgZOBqYGwgbWBvoG4gb2BwIHCgbqByYHNgdGB2YHYgciB2oHfgeCB54H6gfuB/oEBggKCBYIHggqCDYIQghaCKYIrgjiCM4JAglmCWIJdglqCX4JkgmKCaIJqgmuCLoJxgneCeIJ+go2CkoKrgp+Cu4KsguGC44LfgtKC9ILzgvqCk4MDg/uC+YLeggaD3IIJg9mCNYM0gxaDMoMxg0CDOYNQg0WDL4MrgxeDGIOFg5qDqoOfg6KDloMjg46Dh4OKg3yDtYNzg3WDoIOJg6iD9IMThOuDzoP9gwOE2IMLhMGD94MHhOCD8oMNhCKEIIS9gziEBoX7g22EKoQ8hFqFhIR3hGuErYRuhIKEaYRGhCyEb4R5hDWEyoRihLmEv4SfhNmEzYS7hNqE0ITBhMaE1oShhCGF/4T0hBeFGIUshR+FFYUUhfyEQIVjhViFSIVBhQKGS4VVhYCFpIWIhZGFioWohW2FlIWbheqFh4WchXeFfoWQhcmFuoXPhbmF0IXVhd2F5YXchfmFCoYThguG/oX6hQaGIoYahjCGP4ZNhlVOVIZfhmeGcYaThqOGqYaqhouGjIa2hq+GxIbGhrCGyYYjiKuG1IbehumG7IbfhtuG74YShwaHCIcAhwOH+4YRhwmHDYf5hgqHNIc/hzeHO4clhymHGodgh1+HeIdMh06HdIdXh2iHbodZh1OHY4dqhwWIooefh4KHr4fLh72HwIfQh9aWq4fEh7OHx4fGh7uH74fyh+CHD4gNiP6H9of3hw6I0ocRiBaIFYgiiCGIMYg2iDmIJ4g7iESIQohSiFmIXohiiGuIgYh+iJ6IdYh9iLWIcoiCiJeIkoiuiJmIooiNiKSIsIi/iLGIw4jEiNSI2IjZiN2I+YgCifyI9IjoiPKIBIkMiQqJE4lDiR6JJYkqiSuJQYlEiTuJNok4iUyJHYlgiV6JZolkiW2JaolviXSJd4l+iYOJiImKiZOJmImhiamJpomsia+Jsom6ib2Jv4nAidqJ3IndieeJ9In4iQOKFooQigyKG4odiiWKNopBiluKUopGikiKfIptimyKYoqFioKKhIqoiqGKkYqliqaKmoqjisSKzYrCitqK64rziueK5IrxihSL4IriiveK3orbigyLB4sai+GKFosQixeLIIszi6uXJosriz6LKItBi0yLT4tOi0mLVotbi1qLa4tfi2yLb4t0i32LgIuMi46LkouTi5aLmYuaizqMQYw/jEiMTIxOjFCMVYxijGyMeIx6jIKMiYyFjIqMjYyOjJSMfIyYjB1irYyqjL2MsoyzjK6MtozIjMGM5IzjjNqM/Yz6jPuMBI0FjQqNB40PjQ2NEI1OnxONzYwUjRaNZ41tjXGNc42BjZmNwo2+jbqNz43ajdaNzI3bjcuN6o3rjd+N4438jQiOCY7/jR2OHo4Qjh+OQo41jjCONI5KjkeOSY5MjlCOSI5ZjmSOYI4qjmOOVY52jnKOfI6BjoeOhY6EjouOio6TjpGOlI6ZjqqOoY6sjrCOxo6xjr6OxY7IjsuO247jjvyO+47rjv6OCo8FjxWPEo8ZjxOPHI8fjxuPDI8mjzOPO485j0WPQo8+j0yPSY9Gj06PV49cj2KPY49kj5yPn4+jj62Pr4+3j9qP5Y/ij+qP74+HkPSPBZD5j/qPEZAVkCGQDZAekBaQC5AnkDaQNZA5kPiPT5BQkFGQUpAOkEmQPpBWkFiQXpBokG+QdpColnKQgpB9kIGQgJCKkImQj5CokK+QsZC1kOKQ5JBIYtuQApESkRmRMpEwkUqRVpFYkWORZZFpkXORcpGLkYmRgpGikauRr5GqkbWRtJG6kcCRwZHJkcuR0JHWkd+R4ZHbkfyR9ZH2kR6S/5EUkiySFZIRkl6SV5JFkkmSZJJIkpWSP5JLklCSnJKWkpOSm5Jaks+SuZK3kumSD5P6kkSTLpMZkyKTGpMjkzqTNZM7k1yTYJN8k26TVpOwk6yTrZOUk7mT1pPXk+iT5ZPYk8OT3ZPQk8iT5JMalBSUE5QDlAeUEJQ2lCuUNZQhlDqUQZRSlESUW5RglGKUXpRqlCmScJR1lHeUfZRalHyUfpSBlH+UgpWHlYqVlJWWlZiVmZWglaiVp5WtlbyVu5W5lb6VypX2b8OVzZXMldWV1JXWldyV4ZXlleKVIZYoli6WL5ZClkyWT5ZLlneWXJZell2WX5ZmlnKWbJaNlpiWlZaXlqqWp5axlrKWsJa0lraWuJa5ls6Wy5bJls2WTYnclg2X1Zb5lgSXBpcIlxOXDpcRlw+XFpcZlySXKpcwlzmXPZc+l0SXRpdIl0KXSZdcl2CXZJdm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XPRde17/XhRfFV/DXwhiNmJLYk5iL2WHZZdlpGW5ZeVl8GYIZyhnIGtia3lry2vUa9trD2w0bGtwKnI2cjtyR3JZcltyrHKLcxlOFk4VThROGE47Tk1OT05OTuVO2E7UTtVO1k7XTuNO5E7ZTt5ORVFEUYlRilGsUflR+lH4UQpSoFKfUgVTBlMXUx1T305KU0lTYVNgU29TblO7U+9T5FPzU+xT7lPpU+hT/FP4U/VT61PmU+pT8lPxU/BT5VPtU/tT21baVhZZLlkxWXRZdllVW4NbPFzoXedd5l0CXgNec158XgFfGF8XX8VfCmJTYlRiUmJRYqVl5mUuZyxnKmcrZy1nY2vNaxFsEGw4bEFsQGw+bK9yhHOJc9x05nQYdR91KHUpdTB1MXUydTN1i3V9dq52v3budtt34nfzdzp5vnl0est6Hk4fTlJOU05pTplOpE6mTqVO/04JTxlPCk8VTw1PEE8RTw9P8k72TvtO8E7zTv1OAU8LT0lRR1FGUUhRaFFxUY1RsFEXUhFSElIOUhZSo1IIUyFTIFNwU3FTCVQPVAxUClQQVAFUC1QEVBFUDVQIVANUDlQGVBJU4FbeVt1WM1cwVyhXLVcsVy9XKVcZWRpZN1k4WYRZeFmDWX1ZeVmCWYFZV1tYW4dbiFuFW4lb+lsWXHlc3l0GXnZedF4PXxtf2V/WXw5iDGINYhBiY2JbYlhiNmXpZehl7GXtZfJm82YJZz1nNGcxZzVnIWtka3trFmxdbFdsWWxfbGBsUGxVbGFsW2xNbE5scHBfcl1yfnb5enN8+Hw2f4p/vX8BgAOADIASgDOAf4CJgIuAjIDjgeqB84H8gQyCG4Ifgm6CcoJ+gmuGQIhMiGOIf4khljJOqE5NT09PR09XT15PNE9bT1VPME9QT1FPPU86TzhPQ09UTzxPRk9jT1xPYE8vT05PNk9ZT11PSE9aT0xRS1FNUXVRtlG3USVSJFIpUipSKFKrUqlSqlKsUiNTc1N1Ux1ULVQeVD5UJlROVCdURlRDVDNUSFRCVBtUKVRKVDlUO1Q4VC5UNVQ2VCBUPFRAVDFUK1QfVCxU6lbwVuRW61ZKV1FXQFdNV0dXTlc+V1BXT1c7V+9YPlmdWZJZqFmeWaNZmVmWWY1ZpFmTWYpZpVldW1xbWltbW4xbi1uPWyxcQFxBXD9cPlyQXJFclFyMXOtdDF6PXodeil73XgRfH19kX2Jfd195X9hfzF/XX81f8V/rX/hf6l8SYhFihGKXYpZigGJ2YolibWKKYnxifmJ5YnNikmJvYphibmKVYpNikWKGYjllO2U4ZfFl9GZfZ05nT2dQZ1FnXGdWZ15nSWdGZ2BnU2dXZ2Vrz2tCbF5smWyBbIhsiWyFbJtsamx6bJBscGyMbGhslmySbH1sg2xybH5sdGyGbHZsjWyUbJhsgmx2cHxwfXB4cGJyYXJgcsRywnKWcyx1K3U3dTh1gnbvduN3wXnAeb95dnr7fFV/loCTgJ2AmICbgJqAsoBvgpKCi4KNgouJ0okAijeMRoxVjJ2MZI1wjbONq47KjpuPsI/Cj8aPxY/Ej+FdkZCikKqQppCjkEmRxpHMkTKWLpYxliqWLJYmTlZOc06LTptOnk6rTqxOb0+dT41Pc09/T2xPm0+LT4ZPg09wT3VPiE9pT3tPlk9+T49PkU96T1RRUlFVUWlRd1F2UXhRvVH9UTtSOFI3UjpSMFIuUjZSQVK+UrtSUlNUU1NTUVNmU3dTeFN5U9ZT1FPXU3NUdVSWVHhUlVSAVHtUd1SEVJJUhlR8VJBUcVR2VIxUmlRiVGhUi1R9VI5U+laDV3dXaldpV2FXZldkV3xXHFlJWUdZSFlEWVRZvlm7WdRZuVmuWdFZxlnQWc1Zy1nTWcpZr1mzWdJZxVlfW2RbY1uXW5pbmFucW5lbm1saXEhcRVxGXLdcoVy4XKlcq1yxXLNcGF4aXhZeFV4bXhFeeF6aXpdenF6VXpZe9l4mXydfKV+AX4Fff198X91f4F/9X/Vf/18PYBRgL2A1YBZgKmAVYCFgJ2ApYCtgG2AWYhViP2I+YkBif2LJYsxixGK/YsJiuWLSYttiq2LTYtRiy2LIYqhivWK8YtBi2WLHYs1itWLaYrFi2GLWYtdixmKsYs5iPmWnZbxl+mUUZhNmDGYGZgJmDmYAZg9mFWYKZgdmDWcLZ21ni2eVZ3FnnGdzZ3dnh2edZ5dnb2dwZ39niWd+Z5BndWeaZ5NnfGdqZ3JnI2tma2drf2sTbBts42zobPNssWzMbOVss2y9bL5svGzibKts1WzTbLhsxGy5bMFsrmzXbMVs8Wy/bLts4WzbbMpsrGzvbNxs1mzgbJVwjnCScIpwmXAsci1yOHJIcmdyaXLAcs5y2XLXctByqXOoc59zq3Olcz11nXWZdZp1hHbCdvJ29Hbld/13PnlAeUF5yXnIeXp6eXr6ev58VH+Mf4t/BYC6gKWAooCxgKGAq4CpgLSAqoCvgOWB/oENgrOCnYKZgq2CvYKfgrmCsYKsgqWCr4K4gqOCsIK+greCToZxhh1SaIjLjs6P1I/Rj7WQuJCxkLaQx5HRkXeVgJUclkCWP5Y7lkSWQpa5luiWUpdel59OrU6uTuFPtU+vT79P4E/RT89P3U/DT7ZP2E/fT8pP10+uT9BPxE/CT9pPzk/eT7dPV1GSUZFRoFFOUkNSSlJNUkxSS1JHUsdSyVLDUsFSDVNXU3tTmlPbU6xUwFSoVM5UyVS4VKZUs1THVMJUvVSqVMFUxFTIVK9Uq1SxVLtUqVSnVL9U/1aCV4tXoFejV6JXzleuV5NXVVlRWU9ZTllQWdxZ2Fn/WeNZ6FkDWuVZ6lnaWeZZAVr7WWlbo1umW6RbolulWwFcTlxPXE1cS1zZXNJc910dXiVeH159XqBepl76XghfLV9lX4hfhV+KX4tfh1+MX4lfEmAdYCBgJWAOYChgTWBwYGhgYmBGYENgbGBrYGpgZGBBYtxiFmMJY/xi7WIBY+5i/WIHY/Fi92LvYuxi/mL0YhFjAmM/ZUVlq2W9ZeJlJWYtZiBmJ2YvZh9mKGYxZiRm92b/Z9Nn8WfUZ9Bn7Ge2Z69n9WfpZ+9nxGfRZ7Rn2mflZ7hnz2feZ/NnsGfZZ+Jn3WfSZ2prg2uGa7Vr0mvXax9syWwLbTJtKm1BbSVtDG0xbR5tF207bT1tPm02bRtt9Ww5bSdtOG0pbS5tNW0ObSttq3C6cLNwrHCvcK1wuHCucKRwMHJycm9ydHLpcuBy4XK3c8pzu3Oyc81zwHOzcxp1LXVPdUx1TnVLdat1pHWldaJ1o3V4doZ2h3aIdsh2xnbDdsV2AXf5dvh2CXcLd/52/HYHd9x3AngUeAx4DXhGeUl5SHlHebl5unnRedJ5y3l/eoF6/3r9en18An0FfQB9CX0HfQR9Bn04f45/v38EgBCADYARgDaA1oDlgNqAw4DEgMyA4YDbgM6A3oDkgN2A9IEigueCA4MFg+OC24LmggSD5YICgwmD0oLXgvGCAYPcgtSC0YLegtOC34LvggaDUIZ5hnuGeoZNiGuIgYnUiQiKAooDip6MoIx0jXONtI3NjsyO8I/mj+KP6o/lj+2P64/kj+iPypDOkMGQw5BLkUqRzZGClVCWS5ZMlk2WYpdpl8uX7ZfzlwGYqJjbmN+YlpmZmVhOs04MUA1QI1DvTyZQJVD4TylQFlAGUDxQH1AaUBJQEVD6TwBQFFAoUPFPIVALUBlQGFDzT+5PLVAqUP5PK1AJUHxRpFGlUaJRzVHMUcZRy1FWUlxSVFJbUl1SKlN/U59TnVPfU+hUEFUBVTdV/FTlVPJUBlX6VBRV6VTtVOFUCVXuVOpU5lQnVQdV/VQPVQNXBFfCV9RXy1fDVwlYD1lXWVhZWlkRWhhaHFofWhtaE1rsWSBaI1opWiVaDFoJWmtbWFywW7Nbtlu0W65btVu5W7hbBFxRXFVcUFztXP1c+1zqXOhc8Fz2XAFd9FzuXS1eK16rXq1ep14xX5JfkV+QX1lgY2BlYFBgVWBtYGlgb2CEYJ9gmmCNYJRgjGCFYJZgR2LzYghj/2JOYz5jL2NVY0JjRmNPY0ljOmNQYz1jKmMrYyhjTWNMY0hlSWWZZcFlxWVCZklmT2ZDZlJmTGZFZkFm+GYUZxVnF2chaDhoSGhGaFNoOWhCaFRoKWizaBdoTGhRaD1o9GdQaEBoPGhDaCpoRWgTaBhoQWiKa4lrt2sjbCdsKGwmbCRs8GxqbZVtiG2HbWZteG13bVltk21sbYltbm1abXRtaW2MbYpteW2FbWVtlG3KcNhw5HDZcMhwz3A5cnly/HL5cv1y+HL3coZz7XMJdO5z4HPqc95zVHVddVx1WnVZdb51xXXHdbJ1s3W9dbx1uXXCdbh1i3awdsp2zXbOdil3H3cgdyh36XcweCd4OHgdeDR4N3gleC14IHgfeDJ4VXlQeWB5X3lWeV55XXlXeVp55Hnjeed533nmeel52HmEeoh62XoGexF7iXwhfRd9C30KfSB9In0UfRB9FX0afRx9DX0ZfRt9On9ff5R/xX/BfwaAGIAVgBmAF4A9gD+A8YACgfCABYHtgPSABoH4gPOACIH9gAqB/IDvgO2B7IEAghCCKoIrgiiCLIK7giuDUoNUg0qDOINQg0mDNYM0g0+DMoM5gzaDF4NAgzGDKINDg1SGioaqhpOGpIaphoyGo4achnCId4iBiIKIfYh5iBiKEIoOigyKFYoKiheKE4oWig+KEYpIjHqMeYyhjKKMd42sjtKO1I7PjrGPAZAGkPePAJD6j/SPA5D9jwWQ+I+VkOGQ3ZDikFKRTZFMkdiR3ZHXkdyR2ZGDlWKWY5ZhlluWXZZklliWXpa7luKYrJmomtiaJZsymzybfk56UH1QXFBHUENQTFBaUElQZVB2UE5QVVB1UHRQd1BPUA9Qb1BtUFxRlVHwUWpSb1LSUtlS2FLVUhBTD1MZUz9TQFM+U8NT/GZGVWpVZlVEVV5VYVVDVUpVMVVWVU9VVVUvVWRVOFUuVVxVLFVjVTNVQVVXVQhXC1cJV99XBVgKWAZY4FfkV/pXAlg1WPdX+VcgWWJZNlpBWklaZlpqWkBaPFpiWlpaRlpKWnBbx1vFW8Rbwlu/W8ZbCVwIXAdcYFxcXF1cB10GXQ5dG10WXSJdEV0pXRRdGV0kXSddF13iXTheNl4zXjdet164XrZetV6+XjVfN19XX2xfaV9rX5dfmV+eX5hfoV+gX5xff2CjYIlgoGCoYMtgtGDmYL1gxWC7YLVg3GC8YNhg1WDGYN9guGDaYMdgGmIbYkhioGOnY3JjlmOiY6Vjd2NnY5hjqmNxY6ljiWODY5tja2OoY4RjiGOZY6FjrGOSY49jgGN7Y2ljaGN6Y11lVmVRZVllV2VfVU9lWGVVZVRlnGWbZaxlz2XLZcxlzmVdZlpmZGZoZmZmXmb5ZtdSG2eBaK9oomiTaLVof2h2aLFop2iXaLBog2jEaK1ohmiFaJRonWioaJ9ooWiCaDJrumvra+xrK2yObbxt823ZbbJt4W3MbeRt+236bQVux23Lba9t0W2ubd5t+W24bfdt9W3FbdJtGm61bdpt623Ybept8W3ubehtxm3Ebapt7G2/beZt+XAJcQpx/XDvcD1yfXKBchxzG3MWcxNzGXOHcwV0CnQDdAZ0/nMNdOB09nT3dBx1InVldWZ1YnVwdY911HXVdbV1ynXNdY521HbSdtt2N3c+dzx3Nnc4dzp3a3hDeE54ZXloeW15+3mSepV6IHsoext7LHsmexl7Hnsue5J8l3yVfEZ9Q31xfS59OX08fUB9MH0zfUR9L31CfTJ9MX09f55/mn/Mf85/0n8cgEqARoAvgRaBI4ErgSmBMIEkgQKCNYI3gjaCOYKOg56DmIN4g6KDloO9g6uDkoOKg5ODiYOgg3eDe4N8g4aDp4NVhmpfx4bAhraGxIa1hsaGy4axhq+GyYZTiJ6IiIiriJKIloiNiIuIk4mPiSqKHYojiiWKMYotih+KG4oiikmMWoypjKyMq4yojKqMp4xnjWaNvo26jduO344ZkA2QGpAXkCOQH5AdkBCQFZAekCCQD5AikBaQG5AUkOiQ7ZD9kFeRzpH1keaR45Hnke2R6ZGJlWqWdZZzlniWcJZ0lnaWd5ZslsCW6pbpluB633oCmAOYWpvlnHWef56lnrueolCNUIVQmVCRUIBQllCYUJpQAGfxUXJSdFJ1UmlS3lLdUttSWlOlU3tVgFWnVXxVilWdVZhVglWcVapVlFWHVYtVg1WzVa5Vn1U+VbJVmlW7VaxVsVV+VYlVq1WZVQ1XL1gqWDRYJFgwWDFYIVgdWCBY+Vj6WGBZd1qaWn9aklqbWqdac1txW9JbzFvTW9BbClwLXDFcTF1QXTRdR139XUVePV5AXkNefl7KXsFewl7EXjxfbV+pX6pfqF/RYOFgsmC2YOBgHGEjYfpgFWHwYPtg9GBoYfFgDmH2YAlhAGESYR9iSWKjY4xjz2PAY+ljyWPGY81j0mPjY9Bj4WPWY+1j7mN2Y/Rj6mPbY1Jk2mP5Y15lZmViZWNlkWWQZa9lbmZwZnRmdmZvZpFmemZ+Zndm/mb/Zh9nHWf6aNVo4GjYaNdoBWnfaPVo7mjnaPlo0mjyaONoy2jNaA1pEmkOaclo2mhuaftoPms6az1rmGuWa7xr72subC9sLGwvbjhuVG4hbjJuZ25KbiBuJW4jbhtuW25YbiRuVm5ubi1uJm5vbjRuTW46bixuQ24dbj5uy26JbhluTm5jbkRucm5pbl9uGXEacSZxMHEhcTZxbnEccUxyhHKAcjZzJXM0cylzOnQqdDN0InQldDV0NnQ0dC90G3QmdCh0JXUmdWt1anXiddt143XZddh13nXgdXt2fHaWdpN2tHbcdk937XddeGx4b3gNegh6C3oFegB6mHqXepZ65Xrjekl7VntGe1B7UntUe017S3tPe1F7n3ylfF59UH1ofVV9K31ufXJ9YX1mfWJ9cH1zfYRV1H/VfwuAUoCFgFWBVIFLgVGBToE5gUaBPoFMgVOBdIESghyC6YMDhPiDDYTgg8WDC4TBg++D8YP0g1eECoTwgwyEzIP9g/KDyoM4hA6EBITcgweE1IPfg1uG34bZhu2G1IbbhuSG0IbehleIwYjCiLGIg4mWiTuKYIpVil6KPIpBilSKW4pQikaKNIo6ijaKVophjIKMr4y8jLOMvYzBjLuMwIy0jLeMtoy/jLiMio2FjYGNzo3djcuN2o3RjcyN243GjfuO+I78jpyPLpA1kDGQOJAykDaQApH1kAmR/pBjkWWRz5EUkhWSI5IJkh6SDZIQkgeSEZKUlY+Vi5WRlZOVkpWOlYqWjpaLln2WhZaGlo2WcpaElsGWxZbElsaWx5bvlvKWzJcFmAaYCJjnmOqY75jpmPKY7Ziuma2Zw57NntGegk6tULVQslCzUMVQvlCsULdQu1CvUMdQf1J3Un1S31LmUuRS4lLjUi9T31XoVdNV5lXOVdxVx1XRVeNV5FXvVdpV4VXFVcZV5VXJVRJXE1deWFFYWFhXWFpYVFhrWExYbVhKWGJYUlhLWGdZwVrJWsxavlq9Wrxas1rCWrJaaV1vXUxeeV7JXsheEl9ZX6xfrl8aYQ9hSGEfYfNgG2H5YAFhCGFOYUxhRGFNYT5hNGEnYQ1hBmE3YSFiImITZD5kHmQqZC1kPWQsZA9kHGQUZA1kNmQWZBdkBmRsZZ9lsGWXZolmh2aIZpZmhGaYZo1mA2eUaW1pWml3aWBpVGl1aTBpgmlKaWhpa2leaVNpeWmGaV1pY2lbaUdrcmvAa79r02v9a6Jur27TbrZuwm6Qbp1ux27FbqVumG68brpuq27RbpZunG7EbtRuqm6nbrRuTnFZcWlxZHFJcWdxXHFscWZxTHFlcV5xRnFocVZxOnJScjdzRXM/cz5zb3RadFV0X3RedEF0P3RZdFt0XHR2dXh1AHbwdQF28nXxdfp1/3X0dfN13nbfdlt3a3dmd153Y3d5d2p3bHdcd2V3aHdid+53jniweJd4mHiMeIl4fHiReJN4f3h6eX95gXkshL15HHoaeiB6FHofeh56n3qgend7wHtge257Z3uxfLN8tXyTfXl9kX2BfY99W31uf2l/an9yf6l/qH+kf1aAWICGgISAcYFwgXiBZYFugXOBa4F5gXqBZoEFgkeCgoR3hD2EMYR1hGaEa4RJhGyEW4Q8hDWEYYRjhGmEbYRGhF6GXIZfhvmGE4cIhweHAIf+hvuGAocDhwaHCodZiN+I1IjZiNyI2IjdiOGIyojViNKInInjiWuKcopzimaKaYpwioeKfIpjiqCKcYqFim2KYopuimyKeYp7ij6KaIpijIqMiYzKjMeMyIzEjLKMw4zCjMWM4Y3fjeiN743zjfqN6o3kjeaNso4DjwmP/o4Kj5+Pso9LkEqQU5BCkFSQPJBVkFCQR5BPkE6QTZBRkD6QQZASkReRbJFqkWmRyZE3kleSOJI9kkCSPpJbkkuSZJJRkjSSSZJNkkWSOZI/klqSmJWYlpSWlZbNlsuWyZbKlveW+5b5lvaWVpd0l3aXEJgRmBOYCpgSmAyY/Jj0mP2Y/pizmbGZtJnhmumcgp4OnxOfIJ/nUO5Q5VDWUO1Q2lDVUM9Q0VDxUM5Q6VBiUfNRg1KCUjFTrVP+VQBWG1YXVv1VFFYGVglWDVYOVvdVFlYfVghWEFb2VRhXFld1WH5Yg1iTWIpYeViFWH1Y/VglWSJZJFlqWWlZ4VrmWula11rWWtha41p1W95b51vhW+Vb5lvoW+Jb5FvfWw1cYlyEXYddW15jXlVeV15UXtNe1l4KX0ZfcF+5X0dhP2FLYXdhYmFjYV9hWmFYYXVhKmKHZFhkVGSkZHhkX2R6ZFFkZ2Q0ZG1ke2RyZaFl12XWZaJmqGadZpxpqGmVacFprmnTactpm2m3abtpq2m0adBpzWmtacxppmnDaaNpSWtMazNsM28Ub/5uE2/0bilvPm8gbyxvD28CbyJv/27vbgZvMW84bzJvI28VbytvL2+Ibypv7G4Bb/JuzG73bpRxmXF9cYpxhHGScT5yknKWckRzUHNkdGN0anRwdG10BHWRdSd2DXYLdgl2E3bhduN2hHd9d393YXfBeJ94p3izeKl4o3iOeY95jXkuejF6qnqpeu1673qhe5V7i3t1e5d7nXuUe497uHuHe4R7uXy9fL58u32wfZx9vX2+faB9yn20fbJ9sX26faJ9v321fbh9rX3Sfcd9rH1wf+B/4X/ff16AWoCHgFCBgIGPgYiBioF/gYKB54H6gQeCFIIegkuCyYS/hMaExISZhJ6EsoSchMuEuITAhNOEkIS8hNGEyoQ/hxyHO4cihyWHNIcYh1WHN4cph/OIAon0iPmI+Ij9iOiIGonviKaKjIqeiqOKjYqhipOKpIqqiqWKqIqYipGKmoqnimqMjYyMjNOM0YzSjGuNmY2VjfyNFI8SjxWPE4+jj2CQWJBckGOQWZBekGKQXZBbkBmRGJEekXWReJF3kXSReJKAkoWSmJKWknuSk5KckqiSfJKRkqGVqJWplaOVpZWklZmWnJablsyW0pYAl3yXhZf2lxeYGJivmLGYA5kFmQyZCZnBma+asJrmmkGbQpv0nPac85y8njufSp8EUQBR+1D1UPlQAlEIUQlRBVHcUYdSiFKJUo1SilLwUrJTLlY7VjlWMlY/VjRWKVZTVk5WV1Z0VjZWL1YwVoBYn1ieWLNYnFiuWKlYplhtWQlb+1oLW/VaDFsIW+5b7FvpW+tbZFxlXJ1dlF1iXl9eYV7iXtpe317dXuNe4F5IX3Fft1+1X3ZhZ2FuYV1hVWGCYXxhcGFrYX5hp2GQYathjmGsYZphpGGUYa5hLmJpZG9keWSeZLJkiGSQZLBkpWSTZJVkqWSSZK5krWSrZJpkrGSZZKJks2R1ZXdleGWuZqtmtGaxZiNqH2roaQFqHmoZav1pIWoTagpq82kCagVq7WkRalBrTmuka8Vrxms/b3xvhG9Rb2ZvVG+Gb21vW294b25vjm96b3BvZG+Xb1hv1W5vb2BvX2+fcaxxsXGocVZym3JOc1dzaXSLdIN0fnSAdH91IHYpdh92JHYmdiF2Inaadrp25HaOd4d3jHeRd4t3y3jFeLp4yni+eNV4vHjQeD96PHpAej16N3o7eq96rnqte7F7xHu0e8Z7x3vBe6B7zHvKfOB99H3vfft92H3sfd196H3jfdp93n3pfZ592X3yffl9dX93f69/6X8mgJuBnIGdgaCBmoGYgReFPYUahe6ELIUthROFEYUjhSGFFIXshCWF/4QGhYKHdId2h2CHZod4h2iHWYdXh0yHU4dbiF2IEIkHiRKJE4kViQqJvIrSiseKxIqVisuK+IqyismKwoq/irCK1orNiraKuYrbikyMToxsjOCM3ozmjOSM7IztjOKM44zcjOqM4YxtjZ+No40rjhCOHY4ijg+OKY4fjiGOHo66jh2PG48fjymPJo8qjxyPHo8lj2mQbpBokG2Qd5AwkS2RJ5ExkYeRiZGLkYORxZK7kreS6pKskuSSwZKzkryS0pLHkvCSspKtlbGVBJcGlweXCZdgl42Xi5ePlyGYK5gcmLOYCpkTmRKZGJndmdCZ35nbmdGZ1ZnSmdmZt5rumu+aJ5tFm0Sbd5tvmwadCZ0Dnamevp7OnqhYUp8SURhRFFEQURVRgFGqUd1RkVKTUvNSWVZrVnlWaVZkVnhWalZoVmVWcVZvVmxWYlZ2VsFYvljHWMVYblkdWzRbeFvwWw5cSl+yYZFhqWGKYc1htmG+YcphyGEwYsVkwWTLZLtkvGTaZMRkx2TCZM1kv2TSZNRkvmR0ZcZmyWa5ZsRmx2a4Zj1qOGo6allqa2pYajlqRGpiamFqS2pHajVqX2pIallrd2sFbMJvsW+hb8NvpG/Bb6dvs2/Ab7lvtm+mb6BvtG++cclx0HHScchx1XG5cc5x2XHcccNxxHFoc5x0o3SYdJ90nnTidAx1DXU0djh2OnbnduV2oHeed593pXfoeNp47HjneKZ5TXpOekZ6THpLerp62XsRfMl75Hvbe+F76Xvme9V81nwKfhF+CH4bfiN+Hn4dfgl+EH55f7J/8H/xf+5/KICzgamBqIH7gQiCWIJZgkqFWYVIhWiFaYVDhUmFbYVqhV6Fg4efh56HooeNh2GIKokyiSWJK4khiaqJponmivqK64rxigCL3Irniu6K/ooBiwKL94rtivOK9or8imuMbYyTjPSMRI4xjjSOQo45jjWOO48vjziPM4+oj6aPdZB0kHiQcpB8kHqQNJGSkSCTNpP4kjOTL5Mik/ySK5MEkxqTEJMmkyGTFZMukxmTu5WnlqiWqpbVlg6XEZcWlw2XE5cPl1uXXJdml5iXMJg4mDuYN5gtmDmYJJgQmSiZHpkbmSGZGpntmeKZ8Zm4mrya+5rtmiibkZsVnSOdJp0onRKdG53YntSejZ+cnypRH1EhUTJR9VKOVoBWkFaFVodWj1bVWNNY0VjOWDBbKlskW3pbN1xoXLxdul29Xbhda15MX71fyWHCYcdh5mHLYTJiNGLOZMpk2GTgZPBk5mTsZPFk4mTtZIJlg2XZZtZmgGqUaoRqomqcattqo2p+apdqkGqgalxrrmvaawhs2G/xb99v4G/bb+Rv62/vb4Bv7G/hb+lv1W/ub/Bv53Hfce5x5nHlce1x7HH0ceBxNXJGcnBzcnOpdLB0pnSodEZ2QnZMdup2s3eqd7B3rHend61373f3ePp49HjveAF5p3mqeVd6v3oHfA18/nv3ewx84HvgfNx83nzifN982XzdfC5+Pn5Gfjd+Mn5Dfit+PX4xfkV+QX40fjl+SH41fj9+L35Ef/N//H9xgHKAcIBvgHOAxoHDgbqBwoHAgb+BvYHJgb6B6IEJgnGCqoWEhX6FnIWRhZSFr4WbhYeFqIWKhWeGwIfRh7OH0ofGh6uHu4e6h8iHy4c7iTaJRIk4iT2JrIkOixeLGYsbiwqLIIsdiwSLEItBjD+Mc4z6jP2M/Iz4jPuMqI1JjkuOSI5KjkSPPo9Cj0WPP49/kH2QhJCBkIKQgJA5kaORnpGckU2TgpMok3WTSpNlk0uTGJN+k2yTW5Nwk1qTVJPKlcuVzJXIlcaVsZa4ltaWHJcel6CX05dGmLaYNZkBmv+Zrpurm6qbrZs7nT+di57Pnt6e3J7dntuePp9Ln+JTlVauVtlY2Fg4W11f42EzYvRk8mT+ZAZl+mT7ZPdkt2XcZiZns2qsasNqu2q4asJqrmqval9reGuvawlwC3D+bwZw+m8RcA9w+3H8cf5x+HF3c3Vzp3S/dBV1VnZYdlJ2vXe/d7t3vHcOea55YXpiemB6xHrFeit8J3wqfB58I3whfOd8VH5Vfl5+Wn5hflJ+WX5If/l/+393gHaAzYHPgQqCz4Wphc2F0IXJhbCFuoW5haaF74fsh/KH4IeGibKJ9IkoizmLLIsri1CMBY1ZjmOOZo5kjl+OVY7AjkmPTY+HkIOQiJCrkayR0JGUk4qTlpOik7OTrpOsk7CTmJOak5eT1JXWldCV1ZXiltyW2Zbblt6WJJejl6aXrZf5l02YT5hMmE6YU5i6mD6ZP5k9mS6ZpZkOmsGaA5sGm0+bTptNm8qbyZv9m8ibwJtRnV2dYJ3gnhWfLJ8zUaVW3ljfWOJY9VuQn+xe8mH3YfZh9WEAZQ9l4GbdZuVq3WraatNqG3AfcChwGnAdcBVwGHAGcg1yWHKicnhzenO9dMp043SHdYZ1X3Zhdsd3GXmxeWt6aXo+fD98OHw9fDd8QHxrfm1+eX5pfmp+hX9zfrZ/uX+4f9iB6YXdheqF1YXkheWF94X7hwWIDYj5h/6HYIlfiVaJXolBi1yLWItJi1qLTotPi0aLWYsIjQqNfI5yjoeOdo5sjnqOdI5Uj06PrY+KkIuQsZGukeGT0ZPfk8OTyJPck92T1pPik82T2JPkk9eT6JPclbSW45YqlyeXYZfcl/uXXphYmFuYvJhFmUmZFpoZmg2b6Jvnm9ab25uJnWGdcp1qnWydkp6XnpOetJ74UqhWt1a2VrRWvFbkWEBbQ1t9W/ZbyV34YfphGGUUZRll5mYnZ+xqPnAwcDJwEHJ7c890YnZldiZ5KnkseSt5x3r2ekx8Q3xNfO988Hyuj31+fH6Cfkx/AIDagWaC+4X5hRGG+oUGhguGB4YKhhSIFYhkibqJ+Ilwi2yLZotvi1+La4sPjQ2NiY6BjoWOgo60kcuRGJQDlP2T4ZUwl8SYUplRmaiZK5owmjeaNZoTnA2ceZ61nuieL59fn2OfYZ83UThRwVbAVsJWFFlsXM1d/GH+YR1lHGWVZelm+2oEa/pqsmtMcBtyp3LWdNR0aXbTd1B8j36Mfrx/F4YthhqGI4giiCGIH4hqiWyJvYl0i3eLfYsTjYqOjY6Ljl+Pr4+6kS6UM5Q1lDqUOJQylCuU4pU4lzmXMpf/l2eYZZhXmUWaQ5pAmj6az5pUm1GbLZwlnK+dtJ3CnbidnZ7vnhmfXJ9mn2efPFE7UchWylbJVn9b1F3SXU5f/2EkZQprYWtRcFhwgHPkdIp1bnZsdrN5YHxffH6AfYDfgXKJb4n8iYCLFo0XjZGOk45hj0iRRJRRlFKUPZc+l8OXwZdrmFWZVZpNmtKaGptJnDGcPpw7nNOd1500n2yfap+Un8xW1l0AYiNlK2UqZexmEGvadMp6ZHxjfGV8k36WfpR+4oE4hj+GMYiKi5CQj5BjlGCUZJRol2+YXJlamluaV5rTmtSa0ZpUnFecVpzlnZ+e9J7RVulYLGVecHF2cnbXd1B/iH82iDmIYoiTi5KLlot3ghuNwJFqlEKXSJdEl8aXcJhfmiKbWJtfnPmd+p18nn2eB593n3Kf814Wa2NwbHxufDuIwImhjsGRcpRwlHGYXpnWmiObzJ5kcNp3mot3lMmXYpplmpx+nIuqjsWRfZR+lHyUd5x4nPeeVIx/lBqeKHJqmjGbG54ennJ8YCRhJGIkYyRkJGUkZiRnJGgkaSR0JHUkdiR3JHgkeSR6JHskfCR9JHAhcSFyIXMhdCF1IXYhdyF4IXkhNk4/ToVOoE6CUZZRq1H5UjhTaVO2UwpZgFvbXXpef170XlBfYV80ZeBlknV2drWPtpaoAMYC/TD+MJ0wnjAAAAAABTAGMAcw/DA7/z3/PSdBMEIwQzBEMEUwRjBHMEgwSTBKMEswTDBNME4wTzBQMFEwUjBTMFQwVTBWMFcwWDBZMFowWzBcMF0wXjBfMGAwYTBiMGMwZDBlMGYwZzBoMGkwajBrMGwwbTBuMG8wcDBxMHIwczB0MHUwdjB3MHgweTB6MHswfDB9MH4wfzCAMIEwgjCDMIQwhTCGMIcwiDCJMIowizCMMI0wjjCPMJAwkTCSMJMwoTCiMKMwpDClMKYwpzCoMKkwqjCrMKwwrTCuMK8wsDCxMLIwszC0MLUwtjC3MLgwuTC6MLswvDC9ML4wvzDAMMEwwjDDMMQwxTDGMMcwyDDJMMowyzDMMM0wzjDPMNAw0TDSMNMw1DDVMNYw1zDYMNkw2jDbMNww3TDeMN8w4DDhMOIw4zDkMOUw5jDnMOgw6TDqMOsw7DDtMO4w7zDwMPEw8jDzMPQw9TD2MBAEEQQSBBMEFAQVBAEEFgQXBBgEGQQaBBsEHAQdBB4EHwQgBCEEIgQjBCQEJQQmBCcEKAQpBCoEKwQsBC0ELgQvBDAEMQQyBDMENAQ1BFEENgQ3BDgEOQQ6BDsEPAQ9BD4EPwRABEEEQgRDBEQERQRGBEcESARJBEoESwRMBE0ETgRPBOchuCG5Ic8xzABaTooAAlKRRLCfiFGxnwd2AEGslAgLzXvi/+T/B/8C/zEyFiEhIZswnDCALoQuhi6HLoguii6MLo0ulS6cLp0upS6nLqourC6uLrYuvC6+LsYuyi7MLs0uzy7WLtcu3i7jLgAAAAAAAIMCUAJbAlQCdQJTAfgASwGKAmoCQk5cTvVRGlOCUwdODE5HTo1O11YM+m5cc18PTodRDk4uTpNOwk7JTshOmFH8UmxTuVMgVwNZLFkQXP9d4WWza8xrFGw/cjFOPE7oTtxO6U7hTt1O2k4MUhxTTFMiVyNXF1kvWYFbhFsSXDtcdFxzXARegF6CXslfCWJQYhVsNmxDbD9sO2yucrByinO4eYqAHpYOTxhPLE/1ThRP8U4AT/dOCE8dTwJPBU8iTxNPBE/0ThJPsVETUglSEFKmUiJTH1NNU4pTB1ThVt9WLlcqVzRXPFmAWXxZhVl7WX5Zd1l/WVZbFVwlXHxcelx7XH5c3111XoReAl8aX3Rf1V/UX89fXGJeYmRiYWJmYmJiWWJgYlpiZWLvZe5lPmc5ZzhnO2c6Zz9nPGczZxhsRmxSbFxsT2xKbFRsS2xMbHFwXnK0crVyjnMqdX92dXpRf3iCfIKAgn2Cf4JNhn6JmZCXkJiQm5CUkCKWJJYgliOWVk87T2JPSU9TT2RPPk9nT1JPX09BT1hPLU8zTz9PYU+PUblRHFIeUiFSrVKuUglTY1NyU45Tj1MwVDdUKlRUVEVUGVQcVCVUGFQ9VE9UQVQoVCRUR1TuVudW5VZBV0VXTFdJV0tXUlcGWUBZplmYWaBZl1mOWaJZkFmPWadZoVmOW5JbKFwqXI1cj1yIXItciVySXIpchlyTXJVc4F0KXg5ei16JXoxeiF6NXgVfHV94X3Zf0l/RX9Bf7V/oX+5f81/hX+Rf41/6X+9f91/7XwBg9F86YoNijGKOYo9ilGKHYnFie2J6YnBigWKIYndifWJyYnRiN2XwZfRl82XyZfVlRWdHZ1lnVWdMZ0hnXWdNZ1pnS2fQaxlsGmx4bGdsa2yEbItsj2xxbG9saWyabG1sh2yVbJxsZmxzbGVse2yObHRwenBjcr9yvXLDcsZywXK6csVylXOXc5NzlHOSczp1OXWUdZV1gXY9eTSAlYCZgJCAkoCcgJCCj4KFgo6CkYKTgoqCg4KEgniMyY+/j5+QoZClkJ6Qp5CgkDCWKJYvli2WM06YT3xPhU99T4BPh092T3RPiU+ET3dPTE+XT2pPmk95T4FPeE+QT5xPlE+eT5JPgk+VT2tPbk+eUbxRvlE1UjJSM1JGUjFSvFIKUwtTPFOSU5RTh1R/VIFUkVSCVIhUa1R6VH5UZVRsVHRUZlSNVG9UYVRgVJhUY1RnVGRU91b5Vm9XcldtV2tXcVdwV3ZXgFd1V3tXc1d0V2JXaFd9VwxZRVm1WbpZz1nOWbJZzFnBWbZZvFnDWdZZsVm9WcBZyFm0WcdZYltlW5NblVtEXEdcrlykXKBctVyvXKhcrFyfXKNcrVyiXKpcp1ydXKVctlywXKZcF14UXhleKF8iXyNfJF9UX4Jffl99X95f5V8tYCZgGWAyYAtgNGAKYBdgM2AaYB5gLGAiYA1gEGAuYBNgEWAMYAlgHGAUYj1irWK0YtFivmKqYrZiymKuYrNir2K7YqlisGK4Yj1lqGW7ZQlm/GUEZhJmCGb7ZQNmC2YNZgVm/WURZhBm9mYKZ4VnbGeOZ5Jndmd7Z5hnhmeEZ3RnjWeMZ3pnn2eRZ5lng2d9Z4FneGd5Z5RnJWuAa35r3msdbJNs7GzrbO5s2Wy2bNRsrWznbLds0GzCbLpsw2zGbO1s8mzSbN1stGyKbJ1sgGzebMBsMG3NbMdssGz5bM9s6WzRbJRwmHCFcJNwhnCEcJFwlnCCcJpwg3BqctZyy3LYcsly3HLSctRy2nLMctFypHOhc61zpnOic6BzrHOdc9106HQ/dUB1PnWMdZh1r3bzdvF28Hb1dvh3/Hf5d/t3+nf3d0J5P3nFeXh6e3r7enV8/Xw1gI+AroCjgLiAtYCtgCCCoILAgquCmoKYgpuCtYKngq6CvIKegrqCtIKogqGCqYLCgqSCw4K2gqKCcIZvhm2GboZWjNKPy4/Tj82P1o/Vj9ePspC0kK+Qs5CwkDmWPZY8ljqWQ5bNT8VP00+yT8lPy0/BT9RP3E/ZT7tPs0/bT8dP1k+6T8BPuU/sT0RSSVLAUsJSPVN8U5dTllOZU5hTulShVK1UpVTPVMNUDYO3VK5U1lS2VMVUxlSgVHBUvFSiVL5UclTeVLBUtVeeV59XpFeMV5dXnVebV5RXmFePV5lXpVeaV5VX9FgNWVNZ4VneWe5ZAFrxWd1Z+ln9WfxZ9lnkWfJZ91nbWelZ81n1WeBZ/ln0We1ZqFtMXNBc2FzMXNdcy1zbXN5c2lzJXMdcylzWXNNc1FzPXMhcxlzOXN9c+Fz5XSFeIl4jXiBeJF6wXqReol6bXqNepV4HXy5fVl+GXzdgOWBUYHJgXmBFYFNgR2BJYFtgTGBAYEJgX2AkYERgWGBmYG5gQmJDYs9iDWMLY/ViDmMDY+ti+WIPYwxj+GL2YgBjE2MUY/piFWP7YvBiQWVDZaplv2U2ZiFmMmY1ZhxmJmYiZjNmK2Y6Zh1mNGY5Zi5mD2cQZ8Fn8mfIZ7pn3Ge7Z/hn2GfAZ7dnxWfrZ+Rn32e1Z81ns2f3Z/Zn7mfjZ8JnuWfOZ+dn8GeyZ/xnxmftZ8xnrmfmZ9tn+mfJZ8pnw2fqZ8tnKGuCa4RrtmvWa9hr4GsgbCFsKG00bS1tH208bT9tEm0KbdpsM20EbRltOm0abRFtAG0dbUJtAW0YbTdtA20PbUBtB20gbSxtCG0ibQltEG23cJ9wvnCxcLBwoXC0cLVwqXBBcklySnJscnByc3Jucspy5HLocuty33LqcuZy43KFc8xzwnPIc8VzuXO2c7VztHPrc79zx3O+c8NzxnO4c8tz7HTudC51R3VIdad1qnV5dsR2CHcDdwR3BXcKd/d2+3b6dud36HcGeBF4EngFeBB4D3gOeAl4A3gTeEp5THlLeUV5RHnVec15z3nWec55gHp+etF6AHsBe3p8eHx5fH98gHyBfAN9CH0BfVh/kX+Nf75/B4AOgA+AFIA3gNiAx4DggNGAyIDCgNCAxYDjgNmA3IDKgNWAyYDPgNeA5oDNgP+BIYKUgtmC/oL5ggeD6IIAg9WCOoPrgtaC9ILsguGC8oL1ggyD+4L2gvCC6oLkguCC+oLzgu2Cd4Z0hnyGc4ZBiE6IZ4hqiGmI04kEigeKco3jj+GP7o/gj/GQvZC/kNWQxZC+kMeQy5DIkNSR05FUlk+WUZZTlkqWTpYeUAVQB1ATUCJQMFAbUPVP9E8zUDdQLFD2T/dPF1AcUCBQJ1A1UC9QMVAOUFpRlFGTUcpRxFHFUchRzlFhUlpSUlJeUl9SVVJiUs1SDlOeUyZV4lQXVRJV51TzVORUGlX/VARVCFXrVBFVBVXxVApV+1T3VPhU4FQOVQNVC1UBVwJXzFcyWNVX0le6V8ZXvVe8V7hXtle/V8dX0Fe5V8FXDllKWRlaFlotWi5aFVoPWhdaCloeWjNabFunW61brFsDXFZcVFzsXP9c7lzxXPdcAF35XCleKF6oXq5eql6sXjNfMF9nX11gWmBnYEFgomCIYIBgkmCBYJ1gg2CVYJtgl2CHYJxgjmAZYkZi8mIQY1ZjLGNEY0VjNmNDY+RjOWNLY0pjPGMpY0FjNGNYY1RjWWMtY0djM2NaY1FjOGNXY0BjSGNKZUZlxmXDZcRlwmVKZl9mR2ZRZhJnE2cfaBpoSWgyaDNoO2hLaE9oFmgxaBxoNWgraC1oL2hOaERoNGgdaBJoFGgmaChoLmhNaDpoJWggaCxrL2stazFrNGtta4KAiGvma+Rr6Gvja+Jr52slbHptY21kbXZtDW1hbZJtWG1ibW1tb22RbY1t721/bYZtXm1nbWBtl21wbXxtX22CbZhtL21obYttfm2AbYRtFm2DbXttfW11bZBt3HDTcNFw3XDLcDl/4nDXcNJw3nDgcNRwzXDFcMZwx3DacM5w4XBCcnhyd3J2cgBz+nL0cv5y9nLzcvtyAXPTc9lz5XPWc7xz53Pjc+lz3HPSc9tz1HPdc9pz13PYc+hz3nTfdPR09XQhdVt1X3WwdcF1u3XEdcB1v3W2dbp1inbJdh13G3cQdxN3EncjdxF3FXcZdxp3IncndyN4LHgieDV4L3goeC54K3gheCl4M3gqeDF4VHlbeU95XHlTeVJ5UXnreex54Hnuee156nnced553XmGeol6hXqLeox6inqHeth6EHsEexN7BXsPewh7CnsOewl7EnuEfJF8inyMfIh8jXyFfB59HX0RfQ59GH0WfRN9H30SfQ99DH1cf2F/Xn9gf11/W3+Wf5J/w3/Cf8B/FoA+gDmA+oDygPmA9YABgfuAAIEBgi+CJYIzgy2DRIMZg1GDJYNWgz+DQYMmgxyDIoNCg06DG4MqgwiDPINNgxaDJIMggzeDL4Mpg0eDRYNMg1ODHoMsg0uDJ4NIg1OGUoaihqiGloaNhpGGnoaHhpeGhoaLhpqGhYalhpmGoYanhpWGmIaOhp2GkIaUhkOIRIhtiHWIdohyiICIcYh/iG+Ig4h+iHSIfIgSikeMV4x7jKSMo4x2jXiNtY23jbaN0Y7Tjv6P9Y8CkP+P+48EkPyP9o/WkOCQ2ZDakOOQ35DlkNiQ25DXkNyQ5JBQkU6RT5HVkeKR2pFcll+WvJbjmN+aL5t/TnBQalBhUF5QYFBTUEtQXVByUEhQTVBBUFtQSlBiUBVQRVBfUGlQa1BjUGRQRlBAUG5Qc1BXUFFQ0FFrUm1SbFJuUtZS01ItU5xTdVV2VTxVTVVQVTRVKlVRVWJVNlU1VTBVUlVFVQxVMlVlVU5VOVVIVS1VO1VAVUtVClcHV/tXFFjiV/ZX3Ff0VwBY7Vf9VwhY+FcLWPNXz1cHWO5X41fyV+VX7FfhVw5Y/FcQWOdXAVgMWPFX6VfwVw1YBFhcWWBaWFpVWmdaXlo4WjVabVpQWl9aZVpsWlNaZFpXWkNaXVpSWkRaW1pIWo5aPlpNWjlaTFpwWmlaR1pRWlZaQlpcWnJbblvBW8BbWVweXQtdHV0aXSBdDF0oXQ1dJl0lXQ9dMF0SXSNdH10uXT5eNF6xXrReuV6yXrNeNl84X5tfll+fX4pgkGCGYL5gsGC6YNNg1GDPYORg2WDdYMhgsWDbYLdgymC/YMNgzWDAYDJjZWOKY4JjfWO9Y55jrWOdY5djq2OOY29jh2OQY25jr2N1Y5xjbWOuY3xjpGM7Y59jeGOFY4FjkWONY3BjU2XNZWVmYWZbZllmXGZiZhhneWiHaJBonGhtaG5ormiraFZpb2ijaKxoqWh1aHRosmiPaHdokmh8aGtocmiqaIBocWh+aJtolmiLaKBoiWikaHhoe2iRaIxoimh9aDZrM2s3azhrkWuPa41rjmuMaypswG2rbbRts210bqxt6W3ibbdt9m3UbQBuyG3gbd9t1m2+beVt3G3dbdtt9G3Kbb1t7W3wbbpt1W3Cbc9tyW3QbfJt0239bddtzW3jbbtt+nANcfdwF3H0cAxx8HAEcfNwEHH8cP9wBnETcQBx+HD2cAtxAnEOcX5ye3J8cn9yHXMXcwdzEXMYcwpzCHP/cg9zHnOIc/Zz+HP1cwR0AXT9cwd0AHT6c/xz/3MMdAt09HMIdGR1Y3XOddJ1z3XLdcx10XXQdY92iXbTdjl3L3ctdzF3Mnc0dzN3PXcldzt3NXdIeFJ4SXhNeEp4THgmeEV4UHhkeWd5aXlqeWN5a3lhebt5+nn4efZ593mPepR6kHo1e0d7NHslezB7InskezN7GHsqex17MXsrey17L3syezh7Gnsje5R8mHyWfKN8NX09fTh9Nn06fUV9LH0pfUF9R30+fT99Sn07fSh9Y3+Vf5x/nX+bf8p/y3/Nf9B/0X/Hf89/yX8fgB6AG4BHgEOASIAYgSWBGYEbgS2BH4EsgR6BIYEVgSeBHYEigRGCOIIzgjqCNIIygnSCkIOjg6iDjYN6g3ODpIN0g4+DgYOVg5mDdYOUg6mDfYODg4yDnYObg6qDi4N+g6WDr4OIg5eDsIN/g6aDh4Oug3aDmoNZhlaGv4a3hsKGwYbFhrqGsIbIhrmGs4a4hsyGtIa7hryGw4a9hr6GUoiJiJWIqIiiiKqImoiRiKGIn4iYiKeImYibiJeIpIisiIyIk4iOiIKJ1onZidWJMIoniiyKHoo5jDuMXIxdjH2MpYx9jXuNeY28jcKNuY2/jcGN2I7ejt2O3I7XjuCO4Y4kkAuQEZAckAyQIZDvkOqQ8JD0kPKQ85DUkOuQ7JDpkFaRWJFakVORVZHskfSR8ZHzkfiR5JH5keqR65H3keiR7pF6lYaViJV8lm2Wa5Zxlm+Wv5ZqlwSY5ZiXmZtQlVCUUJ5Qi1CjUINQjFCOUJ1QaFCcUJJQglCHUF9R1FESUxFTpFOnU5FVqFWlVa1Vd1VFVqJVk1WIVY9VtVWBVaNVklWkVX1VjFWmVX9VlVWhVY5VDFcpWDdYGVgeWCdYI1goWPVXSFglWBxYG1gzWD9YNlguWDlYOFgtWCxYO1hhWa9alFqfWnpaolqeWnhaplp8WqVarFqVWq5aN1qEWopal1qDWotaqVp7Wn1ajFqcWo9ak1qdWupbzVvLW9Rb0VvKW85bDFwwXDddQ11rXUFdS10/XTVdUV1OXVVdM106XVJdPV0xXVldQl05XUldOF08XTJdNl1AXUVdRF5BXlhfpl+lX6tfyWC5YMxg4mDOYMRgFGHyYAphFmEFYfVgE2H4YPxg/mDBYANhGGEdYRBh/2AEYQthSmKUY7FjsGPOY+Vj6GPvY8NjnWTzY8pj4GP2Y9Vj8mP1Y2Fk32O+Y91j3GPEY9hj02PCY8djzGPLY8hj8GPXY9ljMmVnZWplZGVcZWhlZWWMZZ1lnmWuZdBl0mV8Zmxme2aAZnFmeWZqZnJmAWcMadNoBGncaCpp7GjqaPFoD2nWaPdo62jkaPZoE2kQafNo4WgHacxoCGlwabRoEWnvaMZoFGn4aNBo/Wj8aOhoC2kKaRdpzmjIaN1o3mjmaPRo0WgGadRo6WgVaSVpx2g5aztrP2s8a5Rrl2uZa5VrvWvwa/Jr82swbPxtRm5Hbh9uSW6IbjxuPW5FbmJuK24/bkFuXW5zbhxuM25LbkBuUW47bgNuLm5ebmhuXG5hbjFuKG5gbnFua245biJuMG5TbmVuJ254bmRud25VbnluUm5mbjVuNm5abiBxHnEvcftwLnExcSNxJXEicTJxH3EocTpxG3FLclpyiHKJcoZyhXKLchJzC3MwcyJzMXMzcydzMnMtcyZzI3M1cwxzLnQsdDB0K3QWdBp0IXQtdDF0JHQjdB10KXQgdDJ0+3QvdW91bHXnddp14XXmdd1133Xkddd1lXaSdtp2RndHd0R3TXdFd0p3TndLd0x33nfsd2B4ZHhleFx4bXhxeGp4bnhweGl4aHheeGJ4dHlzeXJ5cHkCegp6A3oMegR6mXrmeuR6Sns7e0R7SHtMe057QHtYe0V7onyefKh8oXxYfW99Y31TfVZ9Z31qfU99bX1cfWt9Un1UfWl9UX1ffU59Pn8/f2V/Zn+if6B/oX/Xf1GAT4BQgP6A1IBDgUqBUoFPgUeBPYFNgTqB5oHugfeB+IH5gQSCPII9gj+CdYI7g8+D+YMjhMCD6IMShOeD5IP8g/aDEITGg8iD64Pjg7+DAYTdg+WD2IP/g+GDy4POg9aD9YPJgwmED4TegxGEBoTCg/OD1YP6g8eD0YPqgxOEw4Psg+6DxIP7g9eD4oMbhNuD/oPYhuKG5obThuOG2obqht2G64bchuyG6YbXhuiG0YZIiFaIVYi6iNeIuYi4iMCIvoi2iLyIt4i9iLKIAYnJiJWJmImXid2J2onbiU6KTYo5ilmKQIpXiliKRIpFilKKSIpRikqKTIpPil+MgYyAjLqMvoywjLmMtYyEjYCNiY3YjdONzY3HjdaN3I3PjdWN2Y3IjdeNxY3vjveO+o75juaO7o7ljvWO547ojvaO647xjuyO9I7pji2QNJAvkAaRLJEEkf+Q/JAIkfmQ+5ABkQCRB5EFkQORYZFkkV+RYpFgkQGSCpIlkgOSGpImkg+SDJIAkhKS/5H9kQaSBJInkgKSHJIkkhmSF5IFkhaSe5WNlYyVkJWHln6WiJaJloOWgJbClsiWw5bxlvCWbJdwl26XB5ipmOuY5pz5noNOhE62Tr1Qv1DGUK5QxFDKULRQyFDCULBQwVC6ULFQy1DJULZQuFDXUXpSeFJ7UnxSw1XbVcxV0FXLVcpV3VXAVdRVxFXpVb9V0lWNVc9V1VXiVdZVyFXyVc1V2VXCVRRXU1hoWGRYT1hNWElYb1hVWE5YXVhZWGVYW1g9WGNYcVj8WMdaxFrLWrpauFqxWrVasFq/Wshau1rGWrdawFrKWrRatlrNWrlakFrWW9hb2VsfXDNccV1jXUpdZV1yXWxdXl1oXWddYl3wXU9eTl5KXk1eS17FXsxexl7LXsdeQF+vX61f92BJYUphK2FFYTZhMmEuYUZhL2FPYSlhQGEgYmiRI2IlYiRixWPxY+tjEGQSZAlkIGQkZDNkQ2QfZBVkGGQ5ZDdkImQjZAxkJmQwZChkQWQ1ZC9kCmQaZEBkJWQnZAtk52MbZC5kIWQOZG9lkmXTZYZmjGaVZpBmi2aKZplmlGZ4ZiBnZmlfaThpTmliaXFpP2lFaWppOWlCaVdpWWl6aUhpSWk1aWxpM2k9aWVp8Gh4aTRpaWlAaW9pRGl2aVhpQWl0aUxpO2lLaTdpXGlPaVFpMmlSaS9pe2k8aUZrRWtDa0JrSGtBa5trDfr7a/xr+Wv3a/hrm27Wbshuj27Abp9uk26UbqBusW65bsZu0m69bsFunm7JbrdusG7NbqZuz26ybr5uw27cbthumW6Sbo5ujW6kbqFuv26zbtBuym6Xbq5uo25HcVRxUnFjcWBxQXFdcWJxcnF4cWpxYXFCcVhxQ3FLcXBxX3FQcVNxRHFNcVpxT3KNcoxykXKQco5yPHNCcztzOnNAc0pzSXNEdEp0S3RSdFF0V3RAdE90UHROdEJ0RnRNdFR04XT/dP50/XQddXl1d3WDae91D3YDdvd1/nX8dfl1+HUQdvt19nXtdfV1/XWZdrV23XZVd193YHdSd1Z3Wndpd2d3VHdZd2134HeHeJp4lHiPeIR4lXiFeIZ4oXiDeHl4mXiAeJZ4e3h8eYJ5fXl5eRF6GHoZehJ6F3oVeiJ6E3obehB6o3qiep5663pme2R7bXt0e2l7cntle3N7cXtwe2F7eHt2e2N7sny0fK98iH2GfYB9jX1/fYV9en2OfXt9g318fYx9lH2EfX19kn1tf2t/Z39of2x/pn+lf6d/23/cfyGAZIFggXeBXIFpgVuBYoFygSFnXoF2gWeBb4FEgWGBHYJJgkSCQIJCgkWC8YQ/hFaEdoR5hI+EjYRlhFGEQISGhGeEMIRNhH2EWoRZhHSEc4RdhAeFXoQ3hDqENIR6hEOEeIQyhEWEKYTZg0uEL4RChC2EX4RwhDmEToRMhFKEb4TFhI6EO4RHhDaEM4RohH6ERIQrhGCEVIRuhFCEC4cEh/eGDIf6htaG9YZNh/iGDocJhwGH9oYNhwWH1ojLiM2IzojeiNuI2ojMiNCIhYmbid+J5YnkieGJ4IniidyJ5ol2ioaKf4phij+Kd4qCioSKdYqDioGKdIp6ijyMS4xKjGWMZIxmjIaMhIyFjMyMaI1pjZGNjI2OjY+NjY2TjZSNkI2SjfCN4I3sjfGN7o3QjemN443ijeeN8o3rjfSNBo//jgGPAI8FjwePCI8CjwuPUpA/kESQSZA9kBCRDZEPkRGRFpEUkQuRDpFukW+RSJJSkjCSOpJmkjOSZZJekoOSLpJKkkaSbZJskk+SYJJnkm+SNpJhknCSMZJUkmOSUJJykk6SU5JMklaSMpKflZyVnpWblZKWk5aRlpeWzpb6lv2W+Jb1lnOXd5d4l3KXD5gNmA6YrJj2mPmYr5mymbCZtZmtmquaW5vqnO2c55yAnv2e5lDUUNdQ6FDzUNtQ6lDdUORQ01DsUPBQ71DjUOBQ2FGAUoFS6VLrUjBTrFMnVhVWDFYSVvxVD1YcVgFWE1YCVvpVHVYEVv9V+VWJWHxYkFiYWIZYgVh/WHRYi1h6WIdYkViOWHZYgliIWHtYlFiPWP5Ya1ncWu5a5VrVWupa2lrtWuta81riWuBa21rsWt5a3VrZWuha31p3W+Bb41tjXIJdgF19XYZdel2BXXddil2JXYhdfl18XY1deV1/XVheWV5TXthe0V7XXs5e3F7VXtle0l7UXkRfQ19vX7ZfLGEoYUFhXmFxYXNhUmFTYXJhbGGAYXRhVGF6YVthZWE7YWphYWFWYSliJ2IrYitkTWRbZF1kdGR2ZHJkc2R9ZHVkZmSmZE5kgmReZFxkS2RTZGBkUGR/ZD9kbGRrZFlkZWR3ZHNloGWhZqBmn2YFZwRnImexabZpyWmgac5plmmwaaxpvGmRaZlpjmmnaY1pqWm+aa9pv2nEab1ppGnUablpymmaac9ps2mTaappoWmeadlpl2mQacJptWmlacZpSmtNa0trnmufa6Brw2vEa/5rzm71bvFuA28lb/huN2/7bi5vCW9ObxlvGm8nbxhvO28Sb+1uCm82b3Nv+W7ubi1vQG8wbzxvNW/rbgdvDm9DbwVv/W72bjlvHG/8bjpvH28Nbx5vCG8hb4dxkHGJcYBxhXGCcY9xe3GGcYFxl3FEclNyl3KVcpNyQ3NNc1FzTHNidHN0cXR1dHJ0Z3RudAB1AnUDdX11kHUWdgh2DHYVdhF2CnYUdrh2gXd8d4V3gndud4B3b3d+d4N3sniqeLR4rXioeH54q3ieeKV4oHiseKJ4pHiYeYp5i3mWeZV5lHmTeZd5iHmSeZB5K3pKejB6L3ooeiZ6qHqreqx67nqIe5x7inuRe5B7lnuNe4x7m3uOe4V7mHuEUpl7pHuCe7t8v3y8fLp8p323fcJ9o32qfcF9wH3FfZ19zn3EfcZ9y33Mfa99uX2Wfbx9n32mfa59qX2hfcl9c3/if+N/5X/efySAXYBcgImBhoGDgYeBjYGMgYuBFYKXhKSEoYSfhLqEzoTChKyEroSrhLmEtITBhM2EqoSahLGE0ISdhKeEu4SihJSEx4TMhJuEqYSvhKiE1oSYhLaEz4SghNeE1ITShNuEsISRhGGGM4cjhyiHa4dAhy6HHochhxmHG4dDhyyHQYc+h0aHIIcyhyqHLYc8hxKHOocxhzWHQocmhyeHOIckhxqHMIcRh/eI54jxiPKI+oj+iO6I/Ij2iPuI8IjsiOuInYmhiZ+JnonpieuJ6ImripmKi4qSio+Kloo9jGiMaYzVjM+M14yWjQmOAo7/jQ2O/Y0KjgOOB44GjgWO/o0AjgSOEI8Rjw6PDY8jkRyRIJEikR+RHZEakSSRIZEbkXqRcpF5kXORpZKkknaSm5J6kqCSlJKqko2SppKakquSeZKXkn+So5Luko6SgpKVkqKSfZKIkqGSipKGkoySmZKnkn6Sh5Kpkp2Si5Itkp6WoZb/lliXfZd6l36Xg5eAl4KXe5eEl4GXf5fOl82XFpitmK6YApkAmQeZnZmcmcOZuZm7mbqZwpm9mceZsZrjmueaPps/m2CbYZtfm/Gc8pz1nKee/1ADUTBR+FAGUQdR9lD+UAtRDFH9UApRi1KMUvFS71JIVkJWTFY1VkFWSlZJVkZWWFZaVkBWM1Y9VixWPlY4VipWOlYaV6tYnVixWKBYo1ivWKxYpVihWP9Y/1r0Wv1a91r2WgNb+FoCW/laAVsHWwVbD1tnXJldl12fXZJdol2TXZVdoF2cXaFdml2eXWleXV5gXlxe833bXt5e4V5JX7Jfi2GDYXlhsWGwYaJhiWGbYZNhr2GtYZ9hkmGqYaFhjWFmYbNhLWJuZHBklmSgZIVkl2ScZI9ki2SKZIxko2SfZGhksWSYZHZlemV5ZXtlsmWzZbVmsGapZrJmt2aqZq9mAGoGahdq5Wn4aRVq8WnkaSBq/2nsaeJpG2odav5pJ2ryae5pFGr3aedpQGoIauZp+2kNavxp62kJagRqGGolag9q9mkmagdq9GkWalFrpWuja6JrpmsBbABs/2sCbEFvJm9+b4dvxm+Sb41viW+Mb2JvT2+Fb1pvlm92b2xvgm9Vb3JvUm9Qb1dvlG+Tb11vAG9hb2tvfW9nb5BvU2+Lb2lvf2+Vb2Nvd29qb3tvsnGvcZtxsHGgcZpxqXG1cZ1xpXGecaRxoXGqcZxxp3GzcZhymnJYc1JzXnNfc2BzXXNbc2FzWnNZc2Jzh3SJdIp0hnSBdH10hXSIdHx0eXQIdQd1fnUldh52GXYddhx2I3Yadih2G3acdp12nnabdo13j3eJd4h3zXi7eM94zHjReM541HjIeMN4xHjJeJp5oXmgeZx5onmbeXZrOXqyerR6s3q3e8t7vnuse857r3u5e8p7tXvFfMh8zHzLfPd9233qfed9133hfQN++n3mffZ98X3wfe593312f6x/sH+tf+1/63/qf+x/5n/of2SAZ4CjgZ+BnoGVgaKBmYGXgRaCT4JTglKCUIJOglGCJIU7hQ+FAIUphQ6FCYUNhR+FCoUnhRyF+4QrhfqECIUMhfSEKoXyhBWF94TrhPOE/IQSheqE6YQWhf6EKIUdhS6FAoX9hB6F9oQxhSaF54TohPCE74T5hBiFIIUwhQuFGYUvhWKGVodjh2SHd4fhh3OHWIdUh1uHUodhh1qHUYdeh22HaodQh06HX4ddh2+HbId6h26HXIdlh0+He4d1h2KHZ4dph1qIBYkMiRSJC4kXiRiJGYkGiRaJEYkOiQmJoomkiaOJ7YnwieyJz4rGiriK04rRitSK1Yq7iteKvorAisWK2IrDirqKvYrZij6MTYyPjOWM34zZjOiM2ozdjOeMoI2cjaGNm40gjiOOJY4kji6OFY4bjhaOEY4ZjiaOJ44UjhKOGI4TjhyOF44ajiyPJI8YjxqPII8jjxaPF49zkHCQb5BnkGuQL5ErkSmRKpEykSaRLpGFkYaRipGBkYKRhJGAkdCSw5LEksCS2ZK2ks+S8ZLfktiS6ZLXkt2SzJLvksKS6JLKksiSzpLmks2S1ZLJkuCS3pLnktGS05K1kuGSxpK0knyVrJWrla6VsJWklqKW05YFlwiXApdal4qXjpeIl9CXz5cemB2YJpgpmCiYIJgbmCeYspgImfqYEZkUmRaZF5kVmdyZzZnPmdOZ1JnOmcmZ1pnYmcuZ15nMmbOa7JrrmvOa8prxmkabQ5tnm3SbcZtmm3abdZtwm2ibZJtsm/yc+pz9nP+c95wHnQCd+Zz7nAidBZ0EnYOe054PnxCfHFETURdRGlERUd5RNFPhU3BWYFZuVnNWZlZjVm1WclZeVndWHFcbV8hYvVjJWL9YuljCWLxYxlgXWxlbG1shWxRbE1sQWxZbKFsaWyBbHlvvW6xdsV2pXaddtV2wXa5dql2oXbJdrV2vXbRdZ15oXmZeb17pXude5l7oXuVeS1+8X51hqGGWYcVhtGHGYcFhzGG6Yb9huGGMYddk1mTQZM9kyWS9ZIlkw2TbZPNk2WQzZX9lfGWiZchmvmbAZspmy2bPZr1mu2a6ZsxmI2c0amZqSWpnajJqaGo+al1qbWp2altqUWooalpqO2o/akFqampkalBqT2pUam9qaWpgajxqXmpWalVqTWpOakZqVWtUa1Zrp2uqa6tryGvHawRsA2wGbK1vy2+jb8dvvG/Ob8hvXm/Eb71vnm/Kb6hvBHClb65vum+sb6pvz2+/b7hvom/Jb6tvzW+vb7JvsG/FccJxv3G4cdZxwHHBcctx1HHKccdxz3G9cdhxvHHGcdpx23Gdcp5yaXNmc2dzbHNlc2tzanN/dJp0oHSUdJJ0lXShdAt1gHUvdi12MXY9djN2PHY1djJ2MHa7duZ2mnedd6F3nHebd6J3o3eVd5l3l3fdeOl45XjqeN5443jbeOF44njteN944HikeUR6SHpHerZ6uHq1erF6t3ree+N753vde9V75Xvae+h7+XvUe+p74nvce+t72Hvfe9J81HzXfNB80XwSfiF+F34Mfh9+IH4Tfg5+HH4Vfhp+In4Lfg9+Fn4NfhR+JX4kfkN/e398f3p/sX/vfyqAKYBsgLGBpoGugbmBtYGrgbCBrIG0gbKBt4GngfKBVYJWgleCVoVFhWuFTYVThWGFWIVAhUaFZIVBhWKFRIVRhUeFY4U+hVuFcYVOhW6FdYVVhWeFYIWMhWaFXYVUhWWFbIVjhmWGZIabh4+Hl4eTh5KHiIeBh5aHmId5h4eHo4eFh5CHkYedh4SHlIech5qHiYceiSaJMIktiS6JJ4kxiSKJKYkjiS+JLIkfifGJ4IriivKK9Ir1it2KFIvkit+K8IrIit6K4Yroiv+K74r7ipGMkoyQjPWM7ozxjPCM84xsjW6NpY2njTOOPo44jkCORY42jjyOPY5BjjCOP469jjaPLo81jzKPOY83jzSPdpB5kHuQhpD6kDORNZE2kZORkJGRkY2Rj5Enkx6TCJMfkwaTD5N6kziTPJMbkyOTEpMBk0aTLZMOkw2Ty5Idk/qSJZMTk/mS95I0kwKTJJP/kimTOZM1kyqTFJMMkwuT/pIJkwCT+5IWk7yVzZW+lbmVupW2lb+VtZW9lamW1JYLlxKXEJeZl5eXlJfwl/iXNZgvmDKYJJkfmSeZKZmeme6Z7JnlmeSZ8JnjmeqZ6Znnmbmav5q0mrua9pr6mvma95ozm4CbhZuHm3ybfpt7m4Kbk5uSm5CbepuVm32biJslnRedIJ0enRSdKZ0dnRidIp0QnRmdH52Inoaeh56unq2e1Z7WnvqeEp89nyZRJVEiUSRRIFEpUfRSk1aMVo1WhlaEVoNWflaCVn9WgVbWWNRYz1jSWC1bJVsyWyNbLFsnWyZbL1suW3tb8VvyW7ddbF5qXr5fu1/DYbVhvGHnYeBh5WHkYehh3mHvZOlk42TrZORk6GSBZYBltmXaZdJmjWqWaoFqpWqJap9qm2qhap5qh2qTao5qlWqDaqhqpGqRan9qpmqaaoVqjGqSaltrrWsJbMxvqW/0b9Rv42/cb+1v52/mb95v8m/db+Jv6G/hcfFx6HHyceRx8HHicXNzbnNvc5d0snSrdJB0qnStdLF0pXSvdBB1EXUSdQ91hHVDdkh2SXZHdqR26Xa1d6t3sne3d7Z3tHexd6h38HfzeP14Ann7ePx48ngFefl4/ngEeat5qHlcelt6VnpYelR6Wnq+esB6wXoFfA988nsAfP97+3sOfPR7C3zzewJ8CXwDfAF8+Hv9ewZ88HvxexB8CnzofC1+PH5CfjN+SJg4fip+SX5Afkd+KX5MfjB+O342fkR+On5Ff39/fn99f/R/8n8sgLuBxIHMgcqBxYHHgbyB6YFbglqCXIKDhYCFj4WnhZWFoIWLhaOFe4WkhZqFnoV3hXyFiYWhhXqFeIVXhY6FloWGhY2FmYWdhYGFooWChYiFhYV5hXaFmIWQhZ+FaIa+h6qHrYfFh7CHrIe5h7WHvIeuh8mHw4fCh8yHt4evh8SHyoe0h7aHv4e4h72H3oeyhzWJM4k8iT6JQYlSiTeJQomtia+JronyifOJHosYixaLEYsFiwuLIosPixKLFYsHiw2LCIsGixyLE4sai0+McIxyjHGMb4yVjJSM+YxvjU6OTY5TjlCOTI5HjkOPQI+FkH6QOJGakaKRm5GZkZ+RoZGdkaCRoZODk6+TZJNWk0eTfJNYk1yTdpNJk1CTUZNgk22Tj5NMk2qTeZNXk1WTUpNPk3GTd5N7k2GTXpNjk2eTgJNOk1mTx5XAlcmVw5XFlbeVrpawlqyWIJcflxiXHZcZl5qXoZecl56XnZfVl9SX8ZdBmESYSphJmEWYQ5glmSuZLJkqmTOZMpkvmS2ZMZkwmZiZo5mhmQKa+pn0mfeZ+Zn4mfaZ+5n9mf6Z/JkDmr6a/pr9mgGb/JpIm5qbqJuem5ubppuhm6WbpJuGm6KboJuvmzOdQZ1nnTadLp0vnTGdOJ0wnUWdQp1DnT6dN51AnT2d9X8tnYqeiZ6NnrCeyJ7anvue/54knyOfIp9Un6CfMVEtUS5RmFacVpdWmladVplWcFk8W2lcalzAXW1ebl7YYd9h7WHuYfFh6mHwYeth1mHpYf9kBGX9ZPhkAWUDZfxklGXbZdpm22bYZsVquWq9auFqxmq6arZqt2rHarRqrWpea8lrC2wHcAxwDXABcAVwFHAOcP9vAHD7byZw/G/3bwpwAXL/cflxA3L9cXZzuHTAdLV0wXS+dLZ0u3TCdBR1E3VcdmR2WXZQdlN2V3ZadqZ2vXbsdsJ3unf/eAx5E3kUeQl5EHkSeRF5rXmseV96HHwpfBl8IHwffC18HXwmfCh8InwlfDB8XH5QflZ+Y35YfmJ+X35RfmB+V35TfrV/s3/3f/h/dYDRgdKB0IFfgl6CtIXGhcCFw4XChbOFtYW9hceFxIW/hcuFzoXIhcWFsYW2hdKFJIa4hbeFvoVphueH5ofih9uH64fqh+WH34fzh+SH1Ifch9OH7YfYh+OHpIfXh9mHAYj0h+iH3YdTiUuJT4lMiUaJUIlRiUmJKosniyOLM4swizWLR4svizyLPosxiyWLN4smizaLLoskizuLPYs6i0KMdYyZjJiMl4z+jASNAo0AjVyOYo5gjleOVo5ejmWOZ45bjlqOYY5djmmOVI5Gj0ePSI9LjyiROpE7kT6RqJGlkaeRr5GqkbWTjJOSk7eTm5Odk4mTp5OOk6qTnpOmk5WTiJOZk5+TjZOxk5GTspOkk6iTtJOjk6WT0pXTldGVs5bXltqWwl3fltiW3ZYjlyKXJZesl66XqJerl6SXqpeil6WX15fZl9aX2Jf6l1CYUZhSmLiYQZk8mTqZD5oLmgmaDZoEmhGaCpoFmgeaBprAmtyaCJsEmwWbKZs1m0qbTJtLm8ebxpvDm7+bwZu1m7ib05u2m8SbuZu9m1ydU51PnUqdW51LnVmdVp1MnVedUp1UnV+dWJ1anY6ejJ7fngGfAJ8WnyWfK58qnymfKJ9Mn1WfNFE1UZZS91K0U6tWrVamVqdWqlasVtpY3VjbWBJZPVs+Wz9bw11wXr9f+2EHZRBlDWUJZQxlDmWEZd5l3WXeZudq4GrMatFq2WrLat9q3GrQautqz2rNat5qYGuwawxsGXAncCBwFnArcCFwInAjcClwF3AkcBxwKnAMcgpyB3ICcgVypXKmcqRyo3Khcst0xXS3dMN0FnVgdsl3ynfEd/F3HXkbeSF5HHkXeR55sHlnemh6M3w8fDl8LHw7fOx86nx2fnV+eH5wfnd+b356fnJ+dH5ofkt/Sn+Df4Z/t3/9f/5/eIDXgdWBZIJhgmOC64Xxhe2F2YXhheiF2oXXheyF8oX4hdiF34XjhdyF0YXwheaF74XeheKFAIj6hwOI9of3hwmIDIgLiAaI/IcIiP+HCogCiGKJWolbiVeJYYlciViJXYlZiYiJt4m2ifaJUItIi0qLQItTi1aLVItLi1WLUYtCi1KLV4tDjHeMdoyajAaNB40JjayNqo2tjauNbY54jnOOao5vjnuOwo5Sj1GPT49Qj1OPtI9AkT+RsJGtkd6Tx5PPk8KT2pPQk/mT7JPMk9mTqZPmk8qT1JPuk+OT1ZPEk86TwJPSk+eTfZXalduV4ZYplyuXLJcolyaXs5e3l7aX3Zfel9+XXJhZmF2YV5i/mL2Yu5i+mEiZR5lDmaaZp5kamhWaJZodmiSaG5oimiCaJ5ojmh6aHJoUmsKaC5sKmw6bDJs3m+qb65vgm96b5Jvmm+Kb8JvUm9eb7Jvcm9mb5ZvVm+Gb2pt3nYGdip2EnYidcZ2AnXidhp2LnYydfZ1rnXSddZ1wnWmdhZ1znXudgp1vnXmdf52HnWidlJ6RnsCe/J4tn0CfQZ9Nn1afV59YnzdTsla1VrNW41hFW8Zdx13uXu9ewF/BX/lhF2UWZRVlE2XfZehm42bkZvNq8Grqauhq+Wrxau5q72o8cDVwL3A3cDRwMXBCcDhwP3A6cDlwQHA7cDNwQXATchRyqHJ9c3xzunSrdqp2vnbtdsx3znfPd8138ncleSN5J3koeSR5KXmyeW56bHptevd6SXxIfEp8R3xFfO58e35+foF+gH66f/9/eYDbgdmBC4JogmmCIob/hQGG/oUbhgCG9oUEhgmGBYYMhv2FGYgQiBGIF4gTiBaIY4lmibmJ94lgi2qLXYtoi2OLZYtni22Lro2GjoiOhI5Zj1aPV49Vj1iPWo+NkEORQZG3kbWRspGzkQuUE5T7kyCUD5QUlP6TFZQQlCiUGZQNlPWTAJT3kweUDpQWlBKU+pMJlPiTCpT/k/yTDJT2kxGUBpTeleCV35Uuly+XuZe7l/2X/pdgmGKYY5hfmMGYwphQmU6ZWZlMmUuZU5kymjSaMZosmiqaNpopmi6aOJotmseayprGmhCbEpsRmwucCJz3mwWcEpz4m0CcB5wOnAacF5wUnAmcn52ZnaSdnZ2SnZidkJ2bnaCdlJ2cnaqdl52hnZqdop2onZ6do52/namdlp2mnaedmZ6bnpqe5Z7knuee5p4wny6fW59gn16fXZ9Zn5GfOlE5UZhSl1LDVr1WvlZIW0dby13PXfFe/WEbZQJr/GoDa/hqAGtDcERwSnBIcElwRXBGcB1yGnIZcn5zF3VqdtB3LXkxeS95VHxTfPJ8in6Hfoh+i36Gfo1+TX+7fzCA3YEYhiqGJoYfhiOGHIYZhieGLoYhhiCGKYYehiWGKYgdiBuIIIgkiByIK4hKiG2JaYluiWuJ+ol5i3iLRYt6i3uLEI0Uja+Njo6Mjl6PW49dj0aRRJFFkbmRP5Q7lDaUKZQ9lDyUMJQ5lCqUN5QslECUMZTlleSV45U1lzqXv5fhl2SYyZjGmMCYWJlWmTmaPZpGmkSaQppBmjqaP5rNmhWbF5sYmxabOptSmyucHZwcnCycI5wonCmcJJwhnLedtp28ncGdx53Knc+dvp3FncOdu521nc6duZ26naydyJ2xna2dzJ2znc2dsp16npye657unu2eG58YnxqfMZ9On2WfZJ+Sn7lOxlbFVstWcVlLW0xb1V3RXfJeIWUgZSZlImULawhrCWsNbFVwVnBXcFJwHnIfcqlyf3PYdNV02XTXdG12rXY1ebR5cHpxeld8XHxZfFt8Wnz0fPF8kX5Pf4d/3oFrgjSGNYYzhiyGMoY2hiyIKIgmiCqIJYhxib+Jvon7iX6LhIuCi4aLhYt/ixWNlY6UjpqOko6QjpaOl45gj2KPR5FMlFCUSpRLlE+UR5RFlEiUSZRGlD+X45dqmGmYy5hUmVuZTppTmlSaTJpPmkiaSppJmlKaUJrQmhmbK5s7m1abVZtGnEicP5xEnDmcM5xBnDycN5w0nDKcPZw2nNud0p3endqdy53Qndyd0Z3fnemd2Z3Yndad9Z3Vnd2dtp7wnjWfM58yn0Kfa5+Vn6KfPVGZUuhY51hyWU1b2F0viE9fAWIDYgRiKWUlZZZl62YRaxJrD2vKa1twWnAicoJzgXODc3B21HdnfGZ8lX5sgjqGQIY5hjyGMYY7hj6GMIgyiC6IM4h2iXSJc4n+iYyLjouLi4iLRYwZjZiOZI9jj7yRYpRVlF2UV5RelMSXxZcA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rCCsJKwsrC2sL6wwrDGsOKw5rDysQKxLrE2sVKxYrFyscKxxrHSsd6x4rHqsgKyBrIOshKyFrIasiayKrIusjKyQrJSsnKydrJ+soKyhrKisqayqrKysr6ywrLisuay7rLysvazBrMSsyKzMrNWs16zgrOGs5KznrOis6qzsrO+s8KzxrPOs9az2rPys/awArQStBq0MrQ2tD60RrRitHK0grSmtLK0trTStNa04rTytRK1FrUetSa1QrVStWK1hrWOtbK1trXCtc610rXWtdq17rXytfa1/rYGtgq2IrYmtjK2QrZytna2krbetwK3BrcStyK3QrdGt063creCt5K34rfmt/K3/rQCuAa4IrgmuC64NrhSuMK4xrjSuN644rjquQK5BrkOuRa5GrkquTK5Nrk6uUK5UrlauXK5drl+uYK5hrmWuaK5prmyucK54rnmue658rn2uhK6FroyuvK69rr6uwK7Ersyuza7PrtCu0a7Yrtmu3K7oruuu7a70rviu/K4HrwivDa8QryyvLa8wrzKvNK88rz2vP69Br0KvQ69Ir0mvUK9cr12vZK9lr3mvgK+Er4ivkK+Rr5WvnK+4r7mvvK/Ar8evyK/Jr8uvza/Or9Sv3K/or+mv8K/xr/Sv+K8AsAGwBLAMsBCwFLAcsB2wKLBEsEWwSLBKsEywTrBTsFSwVbBXsFmwXbB8sH2wgLCEsIywjbCPsJGwmLCZsJqwnLCfsKCwobCisKiwqbCrsKywrbCusK+wsbCzsLSwtbC4sLywxLDFsMewyLDJsNCw0bDUsNiw4LDlsAixCbELsQyxELESsROxGLEZsRuxHLEdsSOxJLElsSixLLE0sTWxN7E4sTmxQLFBsUSxSLFQsVGxVLFVsVixXLFgsXixebF8sYCxgrGIsYmxi7GNsZKxk7GUsZixnLGoscyx0LHUsdyx3bHfseix6bHssfCx+bH7sf2xBLIFsgiyC7IMshSyFbIXshmyILI0sjyyWLJcsmCyaLJpsnSydbJ8soSyhbKJspCykbKUspiymbKasqCyobKjsqWyprKqsqyysLK0ssiyybLMstCy0rLYstmy27LdsuKy5LLlsuay6LLrsuyy7bLusu+y87L0svWy97L4svmy+rL7sv+yALMBswSzCLMQsxGzE7MUsxWzHLNUs1WzVrNYs1uzXLNes1+zZLNls2ezabNrs26zcLNxs3SzeLOAs4Gzg7OEs4WzjLOQs5SzoLOhs6izrLPEs8WzyLPLs8yzzrPQs9Sz1bPXs9mz27Pds+Cz5LPos/yzELQYtBy0ILQotCm0K7Q0tFC0UbRUtFi0YLRhtGO0ZbRstIC0iLSdtKS0qLSstLW0t7S5tMC0xLTItNC01bTctN204LTjtOS05rTstO2077TxtPi0FLUVtRi1G7UctSS1JbUntSi1KbUqtTC1MbU0tTi1QLVBtUO1RLVFtUu1TLVNtVC1VLVctV21X7VgtWG1oLWhtaS1qLWqtau1sLWxtbO1tLW1tbu1vLW9tcC1xLXMtc21z7XQtdG12LXstRC2EbYUthi2JbYstjS2SLZktmi2nLadtqC2pLartqy2sbbUtvC29Lb4tgC3AbcFtyi3Kbcsty+3MLc4tzm3O7dEt0i3TLdUt1W3YLdkt2i3cLdxt3O3dbd8t323gLeEt4y3jbePt5C3kbeSt5a3l7eYt5m3nLegt6i3qbert6y3rbe0t7W3uLfHt8m37Lftt/C39Lf8t/23/7cAuAG4B7gIuAm4DLgQuBi4GbgbuB24JLgluCi4LLg0uDW4N7g4uDm4QLhEuFG4U7hcuF24YLhkuGy4bbhvuHG4eLh8uI24qLiwuLS4uLjAuMG4w7jFuMy40LjUuN2437jhuOi46bjsuPC4+Lj5uPu4/bgEuRi5ILk8uT25QLlEuUy5T7lRuVi5WblcuWC5aLlpuWu5bbl0uXW5eLl8uYS5hbmHuYm5irmNuY65rLmtubC5tLm8ub25v7nBuci5ybnMuc65z7nQudG50rnYudm527ndud654bnjueS55bnouey59Ln1ufe5+Ln5ufq5ALoBugi6Fbo4ujm6PLpAukK6SLpJuku6TbpOulO6VLpVuli6XLpkumW6Z7poumm6cLpxunS6eLqDuoS6hbqHuoy6qLqpuqu6rLqwurK6uLq5uru6vbrEusi62LrZuvy6ALsEuw27D7sRuxi7HLsguym7K7s0uzW7Nrs4uzu7PLs9uz67RLtFu0e7SbtNu0+7ULtUu1i7Ybtju2y7iLuMu5C7pLuou6y7tLu3u8C7xLvIu9C707v4u/m7/Lv/uwC8ArwIvAm8C7wMvA28D7wRvBS8FbwWvBe8GLwbvBy8HbwevB+8JLwlvCe8KbwtvDC8Mbw0vDi8QLxBvEO8RLxFvEm8TLxNvFC8XbyEvIW8iLyLvIy8jryUvJW8l7yZvJq8oLyhvKS8p7yovLC8sbyzvLS8tby8vL28wLzEvM28z7zQvNG81bzYvNy89Lz1vPa8+Lz8vAS9Bb0HvQm9EL0UvSS9LL1AvUi9Sb1MvVC9WL1ZvWS9aL2AvYG9hL2HvYi9ib2KvZC9kb2TvZW9mb2avZy9pL2wvbi91L3Vvdi93L3pvfC99L34vQC+A74Fvgy+Db4QvhS+HL4dvh++RL5Fvki+TL5OvlS+Vb5Xvlm+Wr5bvmC+Yb5kvmi+ar5wvnG+c750vnW+e758vn2+gL6Evoy+jb6PvpC+kb6Yvpm+qL7QvtG+1L7Xvti+4L7jvuS+5b7svgG/CL8Jvxi/Gb8bvxy/Hb9Av0G/RL9Iv1C/Ub9Vv5S/sL/Fv8y/zb/Qv9S/3L/fv+G/PMBRwFjAXMBgwGjAacCQwJHAlMCYwKDAocCjwKXArMCtwK/AsMCzwLTAtcC2wLzAvcC/wMDAwcDFwMjAycDMwNDA2MDZwNvA3MDdwOTA5cDowOzA9MD1wPfA+cAAwQTBCMEQwRXBHMEdwR7BH8EgwSPBJMEmwSfBLMEtwS/BMMExwTbBOME5wTzBQMFIwUnBS8FMwU3BVMFVwVjBXMFkwWXBZ8FowWnBcMF0wXjBhcGMwY3BjsGQwZTBlsGcwZ3Bn8GhwaXBqMGpwazBsMG9wcTByMHMwdTB18HYweDB5MHowfDB8cHzwfzB/cEAwgTCDMINwg/CEcIYwhnCHMIfwiDCKMIpwivCLcIvwjHCMsI0wkjCUMJRwlTCWMJgwmXCbMJtwnDCdMJ8wn3Cf8KBwojCicKQwpjCm8KdwqTCpcKowqzCrcK0wrXCt8K5wtzC3cLgwuPC5MLrwuzC7cLvwvHC9sL4wvnC+8L8wgDDCMMJwwzDDcMTwxTDFcMYwxzDJMMlwyjDKcNFw2jDacNsw3DDcsN4w3nDfMN9w4TDiMOMw8DD2MPZw9zD38Pgw+LD6MPpw+3D9MP1w/jDCMQQxCTELMQwxDTEPMQ9xEjEZMRlxGjEbMR0xHXEecSAxJTEnMS4xLzE6cTwxPHE9MT4xPrE/8QAxQHFDMUQxRTFHMUoxSnFLMUwxTjFOcU7xT3FRMVFxUjFScVKxUzFTcVOxVPFVMVVxVfFWMVZxV3FXsVgxWHFZMVoxXDFccVzxXTFdcV8xX3FgMWExYfFjMWNxY/FkcWVxZfFmMWcxaDFqcW0xbXFuMW5xbvFvMW9xb7FxMXFxcbFx8XIxcnFysXMxc7F0MXRxdTF2MXgxeHF48XlxezF7cXuxfDF9MX2xffF/MX9xf7F/8UAxgHGBcYGxgfGCMYMxhDGGMYZxhvGHMYkxiXGKMYsxi3GLsYwxjPGNMY1xjfGOcY7xkDGQcZExkjGUMZRxlPGVMZVxlzGXcZgxmzGb8ZxxnjGecZ8xoDGiMaJxovGjcaUxpXGmMacxqTGpcanxqnGsMaxxrTGuMa5xrrGwMbBxsPGxcbMxs3G0MbUxtzG3cbgxuHG6MbpxuzG8Mb4xvnG/cYExwXHCMcMxxTHFccXxxnHIMchxyTHKMcwxzHHM8c1xzfHPMc9x0DHRMdKx0zHTcdPx1HHUsdTx1THVcdWx1fHWMdcx2DHaMdrx3THdcd4x3zHfcd+x4PHhMeFx4fHiMeJx4rHjseQx5HHlMeWx5fHmMeax6DHocejx6THpcemx6zHrcewx7THvMe9x7/HwMfBx8jHycfMx87H0MfYx93H5Mfox+zHAMgByATICMgKyBDIEcgTyBXIFsgcyB3IIMgkyCzILcgvyDHIOMg8yEDISMhJyEzITchUyHDIcch0yHjIesiAyIHIg8iFyIbIh8iLyIzIjciUyJ3In8ihyKjIvMi9yMTIyMjMyNTI1cjXyNnI4MjhyOTI9cj8yP3IAMkEyQXJBskMyQ3JD8kRyRjJLMk0yVDJUclUyVjJYMlhyWPJbMlwyXTJfMmIyYnJjMmQyZjJmcmbyZ3JwMnBycTJx8nIycrJ0MnRydPJ1cnWydnJ2sncyd3J4MniyeTJ58nsye3J78nwyfHJ+Mn5yfzJAMoIygnKC8oMyg3KFMoYyinKTMpNylDKVMpcyl3KX8pgymHKaMp9yoTKmMq8yr3KwMrEyszKzcrPytHK08rYytnK4MrsyvTKCMsQyxTLGMsgyyHLQctIy0nLTMtQy1jLWctdy2TLeMt5y5zLuMvUy+TL58vpywzMDcwQzBTMHMwdzCHMIswnzCjMKcwszC7MMMw4zDnMO8w8zD3MPsxEzEXMSMxMzFTMVcxXzFjMWcxgzGTMZsxozHDMdcyYzJnMnMygzKjMqcyrzKzMrcy0zLXMuMy8zMTMxczHzMnM0MzUzOTM7MzwzAHNCM0JzQzNEM0YzRnNG80dzSTNKM0szTnNXM1gzWTNbM1tzW/Ncc14zYjNlM2VzZjNnM2kzaXNp82pzbDNxM3MzdDN6M3szfDN+M35zfvN/c0EzgjODM4UzhnOIM4hziTOKM4wzjHOM841zljOWc5czl/OYM5hzmjOac5rzm3OdM51znjOfM6EzoXOh86JzpDOkc6UzpjOoM6hzqPOpM6lzqzOrc7BzuTO5c7ozuvO7M70zvXO9874zvnOAM8BzwTPCM8QzxHPE88VzxzPIM8kzyzPLc8vzzDPMc84z1TPVc9Yz1zPZM9lz2fPac9wz3HPdM94z4DPhc+Mz6HPqM+wz8TP4M/hz+TP6M/wz/HP88/1z/zPANAE0BHQGNAt0DTQNdA40DzQRNBF0EfQSdBQ0FTQWNBg0GzQbdBw0HTQfNB90IHQpNCl0KjQrNC00LXQt9C50MDQwdDE0MjQydDQ0NHQ09DU0NXQ3NDd0ODQ5NDs0O3Q79Dw0PHQ+NAN0TDRMdE00TjROtFA0UHRQ9FE0UXRTNFN0VDRVNFc0V3RX9Fh0WjRbNF80YTRiNGg0aHRpNGo0bDRsdGz0bXRutG80cDR2NH00fjRB9IJ0hDSLNIt0jDSNNI80j3SP9JB0kjSXNJk0oDSgdKE0ojSkNKR0pXSnNKg0qTSrNKx0rjSudK80r/SwNLC0sjSydLL0tTS2NLc0uTS5dLw0vHS9NL40gDTAdMD0wXTDNMN0w7TENMU0xbTHNMd0x/TINMh0yXTKNMp0yzTMNM40znTO9M80z3TRNNF03zTfdOA04TTjNON04/TkNOR05jTmdOc06DTqNOp06vTrdO007jTvNPE08XTyNPJ09DT2NPh0+PT7NPt0/DT9NP80/3T/9MB1AjUHdRA1ETUXNRg1GTUbdRv1HjUedR81H/UgNSC1IjUidSL1I3UlNSp1MzU0NTU1NzU39To1OzU8NT41PvU/dQE1QjVDNUU1RXVF9U81T3VQNVE1UzVTdVP1VHVWNVZ1VzVYNVl1WjVadVr1W3VdNV11XjVfNWE1YXVh9WI1YnVkNWl1cjVydXM1dDV0tXY1dnV29Xd1eTV5dXo1ezV9NX11ffV+dUA1gHWBNYI1hDWEdYT1hTWFdYc1iDWJNYt1jjWOdY81kDWRdZI1knWS9ZN1lHWVNZV1ljWXNZn1mnWcNZx1nTWg9aF1ozWjdaQ1pTWndaf1qHWqNas1rDWuda71sTWxdbI1szW0dbU1tfW2dbg1uTW6Nbw1vXW/Nb91gDXBNcR1xjXGdcc1yDXKNcp1yvXLdc01zXXONc810TXR9dJ11DXUddU11bXV9dY11nXYNdh12PXZddp12zXcNd013zXfdeB14jXideM15DXmNeZ15vXndcAQczJCQvDwQE9T3NPR1D5UKBS71N1VOVUCVbBWrZbh2a2Z7dn72dMa8JzwnU8etuCBINXiIiINorIjM+N+47mj9WZO1J0UwRUamBkYbxrz3MagbqJ0omjlYNPClK+WHhZ5llyXnlex2HAY0Zn7Gd/aJdvTnYLd/V4CHr/eiF8nYBugnGC64qTlWtOnVX3ZjRuo3jteluEEIlOh6iX2FJOVypYTF0fYb5hIWJiZdFnRGobbhh1s3XjdrB3On2vkFGUUpSVnyNTrFwydduAQJKYlVtSCFjcWaFcF123XjpfSl93YV9senWGdeB8c32xfYx/VIEhgpGFQYkbi/ySTZZHnMtO904LUPFRT1g3YT5haGE5ZeppEW+ldYZ21naHe6WCy4QA+aeTi5WAVaJbUVcB+bN8uX+1kShQu1NFXOhd0mJuY9pk52QgbqxwW3ndjR6OAvl9kEWS+JJ+TvZOZVD+XfpeBmFXaXGBVIZHjnWTK5peTpFQcGdAaAlRjVKSUqJqvHcQktSeq1IvYPKPSFCpYe1jymQ8aIRqwG+IgaGJlJYFWH1yrHIEdXl9bX6pgIuJdItjkFGdiWJ6bFRvUH06fyOKfFFKYZ17GYtXkoyTrE7TTx5QvlAGUcFSzVJ/U3BXg1iaXpFfdmGsYc5kbGVvZrtm9GaXaIdthXDxcJ90pXTKdNl1bHjseN969npFfZN9FYA/gBuBloNmixWPFZDhkwOYOJhamuibwk9TVTpYUVljW0ZcuGASYkJosGjoaKpuTHV4ds54PXr7fGt+fH4IiqGKP4yOlsSd5FPpU0pUcVT6VtFZZFs7XKte92I3ZUVlcmWgZq9nwWm9bPx1kHZ+dz96lH8DgKGAj4Hmgv2C8IPBhTGItIiligP5nI8uk8eWZ5jYmhOf7VSbZfJmj2hAejeMYJ3wVmRXEV0GZrFozWj+bih0nojkm2hsBPmomptPbFFxUZ9SVFvlXVBgbWDxYqdjO2XZc3p6o4aijI+XMk7hWwhinGfcdNF504OHirKK6I1OkEuTRpjTXuhp/4XtkAX5oFGYW+xbY2H6aD5rTHAvdNh0oXtQf8WDwImrjNyVKJkuUl1g7GICkIpPSVEhU9lY417gZjhtmnDCctZzUHvxgFuUZlObY2t/Vk6AUEpY3lgqYCdh0GLQaUGbj1sYfbGAX4+kTtFQrFSsVQxboF3nXSplTmUhaEtq4XKOdu93Xn35f6CBToXfhgOPTo/KkAOZVZqrmxhORU5dTsdO8U93Uf5SQFPjU+VTjlQUVnVXolfHW4dd0F78YdhiUWW4Z+lny2lQa8Zr7GtCbJ1ueHDXcpZzA3S/d+l3dnp/fQmA/IEFggqC34JiiDOL/IzAjhGQsZBkkraS0plFmumc152cnwtXQFzKg6CXq5e0nhtUmHqkf9mIzY7hkABYSFyYY596rlsTX3l6rnqOgqyOJlA4UvhSd1MIV/NicmMKa8NtN3elU1dzaIV2jtWVOmfDanBvbYrMjkuZBvl3ZnhrtIw8mwf561MtV05ZxmP7aepzRXi6esV6/nx1hI+Jc401kKiV+1JHV0d1YHvMgx6SCPlYaktRS1KHUh9i2Gh1aZmWxVCkUuRSw2GkZTlo/2l+dEt7uYLrg7KJOYvRj0mZCfnKTpdZ0mQRZo5qNHSBeb15qYJ+iH+IX4kK+SaTC0/KUyVgcWJybBp9Zn2YTmJR3HevgAFPDk92UYBR3FVoVjtX+lf8VxRZR1mTWcRbkFwOXfFdfl7MX4Bi12XjZR5nH2deZ8toxGhfajprI2x9bIJsx22YcyZ0KnSCdKN0eHV/dYF473hBeUd5SHl6eZV7AH26fYh/BoAtgIyAGIpPi0iMd40hkyST4phRmQ6aD5plmpKeyn12TwlU7mJUaNGRq1U6UQv5DPkcWuZhDfnPYv9iDvkP+RD5EfkS+RP5o5AU+RX5FvkX+Rj5/ooZ+Rr5G/kc+ZZmHflWcR75H/njliD5T2N6Y1dTIfmPZ2Bpc24i+Td1I/kk+SX5DX0m+Sf5cojKVhhaKPkp+Sr5K/ks+UNOLflnUUhZ8GcQgC75c1l0Xppkynn1X2xgyGJ7Y+db11uqUi/5dFkpXxJgMPkx+TL5WXQz+TT5Nfk2+Tf5OPnRmTn5Ovk7+Tz5Pfk++T/5QPlB+UL5Q/nDb0T5Rfm/gbKP8WBG+Uf5ZoFI+Un5P1xK+Uv5TPlN+U75T/lQ+VH56VolintnEH1S+VP5VPlV+Vb5V/n9gFj5Wfk8XOVsP1O6bhpZNoM5TrZORk+uVRhXx1hWX7dl5mWAarVrTW7td+96HnzefcuGkogykVuTu2S+b3pzuHVUkFZVTVe6YdRkx2bhbVtubW+5b/B1Q4C9gUGFg4nHilqLH5OTbFN1VHsPjl2QEFUCWFhYYl4HYp5k4Gh2ddZ8s4fonuNOiFduVydZDVyxXDZehV80YuFks3P6gYuIuIyKltuehVu3X7NgElAAUjBSFlc1WFdYDlxgXPZci12mXpJfvGARY4ljF2RDaPlowmrYbSFu1G7kb/5x3HZ5d7F5O3oEhKmJ7YzzjUiOA5AUkFOQ/ZBNk3aW3JfSawZwWHKicmhzY3e/eeR7m36Ai6lYx2BmZf1lvmaMbB5xyXFajBOYbU6Bet1OrFHNUdVSDFSnYXFnUGjfaB5tfG+8dbN35Xr0gGOEhZJcUZdlXGeTZ9h1x3pzg1r5RowXkC2Yb1zAgZqCQZBvkA2Sl1+dXVlqyHF7dkl75IUEiyeRMJqHVfZhW/lpdoV/P4a6h/iIj5Bc+Rtt2XDec2F9PYRd+WqR8Zle+YJOdVMEaxJrPnAbci2GHp5MUqOPUF3lZCxlFmvrb0N8nH7NhWSJvYnJYtiBH4jKXhdnam38cgV0b3SCh96Qhk8NXaBfCoS3UaBjZXWuTgZQaVHJUYFoEWqufLF853xvgtKKG4/PkbZPN1H1UkJU7F5uYT5ixWXaav5vKnnchSOIrZVimmqal57OnptSxmZ3ax1wK3lij0KXkGEAYiNlI29JcYl09H1vgO6EJo8jkEqTvVEXUqNSDG3IcMKIyV6CZa5rwm8+fHVz5E42T/lWX/m6XLpdHGCycy17mn/Of0aAHpA0kvaWSJcYmGGfi0+nb655tJG3lt5SYPmIZMRk02pebxhwEHLndgGABoZchu+NBY8yl2+b+p11nox4f3mgfcmDBJN/npOe1orfWARfJ2cncM90YHx+gCFRKHBicsp4wozajPSM95aGTtpQ7lvWXpllznFCdq13SoD8hHyQJ5uNn9hYQVpiXBNq2m0Pbzt2L303fh6FOInkk0uWiVLSZfNntGlBbZxuD3AJdGB0WXUkdmt4LItemG1RLmJ4lpZPK1AZXeptuH0qj4tfRGEXaGH5hpbSUouA3FHMUV5pHHq+ffGDdZbaTylSmFMPVA5VZVynYE5nqGhsbYFy+HIGdIN0YvnidWx8eX+4f4mDz4jhiMyR0JHilsmbHVR+b9BxmHT6haqOo5ZXnJ+el2fLbTN06IEWlyx4y3oge5J8aWRqdPJ1vHjoeKyZVJu7nt5bVV4gb5yBq4OIkAdOTVMpWtJdTl9iYT1jaWb8Zv9uK29jcJ53LIQThTuIE49FmTucHFW5Yitnq2wJg2qJepehToRZ2F/ZXxtnsn1Uf5KCK4O9gx6PmZDLV7lZklrQWydmmmeFaM9rZHF1f7eM44yBkEWbCIGKjEyWQJqlnl9bE2wbc/J233YMhKpRk4lNUZVRyVLJaJRsBHcgd7997H1il7WexW4RhaVRDVR9VA5mnWYnaZ9uv3aRdxeDwoSfh2mRmJL0nIKIrk+SUd9Sxlk9XlVheGR5ZK5m0Gchas1r22tfcmFyQXQ4d9t3F4C8ggWDAIsoi4yMKGeQbGdy7nZmd0Z6qZ1/a5JsIlkmZ5mEb1OTWJlZ317PYzRmc2c6bitz13rXgiiT2VLrXa5hy2EKYsdiq2TgZVlpZmvLayFx93NddUZ+HoICg2qFo4q/jCeXYZ2oWNieEVAOUjtUT1WHZXZsCn0LfV6AioaAle+W/1KVbGlyc1SaWj5cS11MX65fKme2aGNpPG5Ebgl3c3yOf4eFDov3j2GX9J63XLZgDWGrYU9l+2X8ZRFs72yfc8lz4X2UlcZbHIcQi11SWlPNYg9ksmQ0ZzhqymzAc550lHuVfBt+ioE2goSF64/5lsGZNE9KU81T21PMYixkAGWRZcNp7mxYb+1zVHUiduR2/HbQePt4LHlGfSyC4IfUjxKY75jDUtRipWQkblFvfHbLjbGRYpLumkObI1CNUEpXqFkoXEded18/Yj5luWXBZQlmi2ecacJuxXghfaqAgIErgrOCoYSMhiqKF4umkDKWkJ8NUPNPY/n5V5hf3GKSY29nQ24ZccN2zIDagPSI9YgZieCMKY9NkWqWL09wTxtez2ciaH12fnZEm2FeCmppcdRxanVk+UF+Q4XphdyYEE9Pe3B/pZXhUQZetWg+bE5s22yvcsR7A4PVbDp0+1CIUsFY2GSXaqd0VnaneBeG4pU5l2X5XlMBX4qLqI+vj4qQJVKld0mcCJ8ZTgJQdVFbXHdeHmY6ZsRnxWizcAF1xXXJed16J48gmQia3U8hWDFY9ltuZmVrEW16bn1v5HMrdemD3IgTiVyLFI8PT9VQEFNcU5NbqV8NZ495eYEvgxSFB4mGiTmPO4+lmRKcLGd2TvhPSVkBXO9c8FxnY9Jo/XCicSt0K37shAKHIpDSkvOcDU7YTu9PhVBWUm9SJlSQVOBXK1lmWlpbdVvMW5xeZvl2Yndlp2VubaVuNnImez98Nn9QgVGBmoFAgpmCqYMDiqCM5oz7jHSNuo3okNyRHJZEltmZ55wXUwZSKVR0VrNYVFluWf9fpGFuYhBmfmwaccZ2iXzefBt9rILBjPCWZ/lbTxdff1/CYildC2faaHx4Q35snRVOmVAVUypTUVODWWJah16yYIphSWJ5YpBlh2enadRr1mvXa9hruGxo+TV0+nUSeJF41XnYeYN8y33hf6WAPoHCgfKDGofoiLmKbIu7jBmRXpfbmDufrFYqW2xfjGWzaq9rXG3xbxVwXXKtc6eM04w7mJFhN2xYgAGaTU6LTptO1U46TzxPf0/fT/9Q8lP4UwZV41XbVutYYlkRWutb+lsEXPNdK16ZXx1gaGOcZa9l9mf7Z61oe2uZbNdsI24JcEVzAng+eUB5YHnBeel7F31yfYaADYKOg9GEx4bfiFCKXoodi9yMZo2tj6qQ/JjfmZ2eSlJp+RRnavmYUCpScVxjZVVsynMjdZ11l3uchHiRMJd3TpJkumtecamFCU5r+Uln7mgXbp+CGIVriPdjgW8Skq+YCk63UM9QH1FGVapVF1ZAWxlc4Fw4XopeoF7CXvNgUWhhalhuPXJAcsBy+HZlebF71H/ziPSJc4phjN6MHJdeWL10/YzHVWz5YXoifXKCcnIfdSV1bfkZe4VY+1i8XY9etl6QX1VgkmJ/Y01lkWbZZvhmFmjyaIByXnRue2591n1yf+WAEoKvhX+Jk4odkOSSzZ4gnxVZbVktXtxgFGZzZpBnUGzFbV9v83epeMaEy5Erk9lOylBIUYRVC1ujW0difmXLZTJufXEBdER0h3S/dGx2qnnafVV+qH96gbOBOYIahuyHdYrjjXiQkZIllE2ZrptoU1FcVGnEbCltK24MgpuFO4ktiqqK6pZnn2FSuWaya5Z+/ocNjYOVXZYdZYlt7nFu+c5X01msWydg+mAQYh9mX2Ypc/lz23YBd2x7VoBygGWBoIqSkRZO4lJyaxdtBXo5ezB9b/mwjOxTL1ZRWLVbD1wRXOJdQGKDYxRkLWazaLxsiG2vbh9wpHDScSZ1j3WOdRl2EXvgeyt8IH05fSyFbYUHhjSKDZBhkLWQt5L2lzea109sXF9nkW2ffIx+FosWjR+Qa1v9XQ1kwIRckOGYh3OLW5pgfmfebR+KpooBkAyYN1Jw+VFwjniWk3CI15HuT9dT/VXaVoJX/VjCWohbq1zAXCVeAWENYktiiGMcZDZleGU5aoprNGwZbTFv53HpcnhzB3SydCZ2YXfAeVd66nq5fI99rH1hfp5/KYExg5CE2oTqhZaIsIqQiziPQpCDkGyRlpK5kouWp5aoltaWAJcImJaZ05oam9RTflgZWXBbv1vRbVpvn3EhdLl0hYD9g+Fdh1+qX0Jg7GUSaG9pU2qJazVt823jc/52rHdNexR9I4EcgkCD9IRjhWKKxIqHkR6TBpi0mQxiU4jwj2WSB10nXWldX3SdgWiH1W/+YtJ/NolyiR5OWE7nUN1SR1N/YgdmaX4FiF6WjU8ZUzZWy1mkWjhcTlxNXAJeEV9DYL1lL2ZCZr5n9Gccc+J3OnnFf5SEzYSWiWaKaYrhilWMeoz0V9RbD19vYO1iDWmWa1xuhHHSe1WHWIv+jt+Y/pg4T4FP4U97VCBauFs8YbBlaGb8cTN1XnkzfU6B44GYg6qFzoUDhwqKq46bj3H5xY8xWaRb5luJYOlbC1zDX4FscvnxbQtwGnWvgvaKwE5BU3P52ZYPbJ5OxE9SUV5VJVroXBFiWXK9gqqD/oZZiB2KP5bFlhOZCZ1dnQpYs1y9XURe4WAVYeFjAmolbgKRVJNOmBCcd5+JW7hcCWNPZkhoPHfBlo2XVJifm6FlAYvLjryVNVWpXNZdtV6XZkx29IPHldNYvGLOciid8E4uWQ9gO2aDa+d5Jp2TU8BUw1cWXRth1mavbY14foKYlkSXhFN8YpZjsm0KfkuBTZj7akx/r50anl9OO1C2URxZ+WD2YzBpOnI2gHT5zpExX3X5dvkEfeWCb4S7hOWFjY53+W9PePl5+eRYQ1tZYNpjGGVtZZhmevlKaSNqC20BcGxx0nUNdrN5cHp7+Yp/fPlEiX35k4vAkX2WfvkKmQRXoV+8ZQFvAHameZ6KrZlam2yfBFG2YZFijWrGgUNQMFhmXwlxAIr6inxb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jpvenqVjemR2hwFOlU6tTlxQdVBIVMNZmltAXq1e916BX8VgOmM/ZXRlzGV2Znhm/mdoaYlqY2tAbMBt6G0fbl5uHnChcI5z/XM6dVt3h3iOeQt6fXq+fI59R4ICiuqKnowtkUqR2JFmksySIJMGl1aXXJcCmA6fNlKRUnxVJFgdXh9fjGDQY69o329teSx7zYG6hf2I+IpEjo2RZJablj2XTJhKn85PRlHLUalSMlYUX2tfqmPNZOllQWb6ZvlmHWedaNdo/WkVb25vZ3HlcSpyqnQ6d1Z5WnnfeSB6lXqXfN98RH1wfoeA+4WkhlSKv4qZjYGOIJBtkOORO5bVluWcz2UHfLONw5NYWwpcUlPZYh1zJ1CXW55fsGBrYdVo2W0udC56Qn2cfTF+a4EqjjWOfpMYlFBPUFfmXadeK2NqfztOT0+PT1pQ3VnEgGpUaFT+VU9ZmVveXdpeXWYxZ/FnKmjobDJtSm6Nb7dw4HOHdUx8An0sfaJ9H4LbhjuKhYpwjYqOM48xkE6RUpFElNCZ+XqlfMpPAVHGUchX71v7XFlmPWpabZZu7G8McW9143oiiCGQdZDLlv+ZAYMtTvJORojNkX1T22praUFseoSeWI5h/mbvYt1wEXXHdVJ+uIRJiwiNS07qU6tUMFdAV9dfAWMHY29kL2XoZXpmnWezZ2JrYGyabCxv5XcleEl5V3kZfaKAAoHzgZ2Ct4IYh4yK/PkEjb6NcpD0dhl6N3pUfneAB1XUVXVYL2MiZElmS2ZtaJtphGslbbFuzXNodKF0W3W5deF2HneLd+Z5CX4dfvuBL4WXiDqK0YzrjrCPMpCtk2OWc5YHl4RP8VPqWclaGV5OaMZ0vnXpeZJ6o4HthuqMzI3tj59lFWf9+fdXV2/dfS+P9pPGlrVf8mGEbxROmE8fUMlT31VvXe5dIWtka8t4mnv++UmOyo5ukEljPmRAd4R6L5N/lGqfsGSvb+ZxqHTadMR6EnyCfrJ8mH6aiwqNfZQQmUyZOVLfW+ZkLWcufe1Qw1N5WFhhWWH6Yaxl2XqSi5aLCVAhUHVSMVU8WuBecF80YV5lDGY2ZqJmzWnEbjJvFnMhdpN6OYFZgtaDvIS1UPBXwFvoW2lfoWMmeLV93IMhhceR9ZGKUfVnVnusjMRRu1m9YFWGHFD/+VRSOlx9YRpi02LyZKVlzG4gdgqBYI5flruW305DU5hVKVndXcVkyWz6bZRzf3obgqaF5IwQjneQ55HhlSGWxpf4UfJUhlW5X6RkiG+0fR+PTY81lMlQFly+bPttG3W7dz18ZHx5isKKHli+WRZed2NScop1a3fciryMEo/zXnRm+G19gMGDy4pRl9abAPpDUv9mlW3vbuB95ooukF6Q1JodUn9S6FSUYYRi22KiaBJpWmk1apJwJnFdeAF5DnnSeQ16loB4gtWCSYNJhYKMhY1ikYuRrpHDT9FW7XHXdwCH+In4W9ZfUWeokOJTWlj1W6RggWFgZD1+cIAlhYOSrmSsUBRdAGecWL1iqGMOaXhpHmprbrp2y3m7gimEz4qojf2PEpFLkZyREJMYk5qT25Y2mg2cEU5cdV15+npRe8l7Ln7EhFmOdI74jhCQJWY/aUN0+lEuZ9yeRVHgX5Zs8oddiHeItGC1gQOEBY3WUzlUNFY2WjFcinDgf1qABoHtgaONiZFfmvKddFDETqBT+2AsbmRciE8kUORV2VxfXmVglGi7bMRtvnHUdfR1YXYaekl6x337fW5/9IGphhyPyZazmVKfR1LFUu2YqokDTtJnBm+1T+JblWeIbHhtG3QneN2RfJPEh+R5MXrrX9ZOpFQ+Va5YpVnwYFNi1mI2Z1VpNYJAlrGZ3ZksUFNTRFV8VwH6WGIC+uJka2bdZ8Fv728idDh0F4o4lFFUBlZmV0hfmmFOa1hwrXC7fZWKalkrgaJjCHc9gKqMVFgtZLtplVsRXm9uA/pphUxR8FMqWSBgS2GGa3Bs8Gwee86A1ILGjbCQsZgE+sdkpG+RZARlTlEQVB9XDopfYXZoBfrbdVJ7cX0akAZYzGl/gSqJAJA5mHhQV1msWZViD5Aqm11heXLWlWFXRlr0XYpirWT6ZHdn4mw+bSxyNnQ0eHd/rYLbjReYJFJCV39nSHLjdKmMpo8RkiqWa1HtU0xjaU8EVZZgV2WbbH9tTHL9chd6h4mdjG1fjm/5cKiBDmG/T09QQWJHcsd76H3pf02QrZcZmraMaldzXrBnDYRViiBUFltjXuJeCl+DZbqAPYWJlVuWSE8FUw1TD1OGVPpUA1cDXhZgm2KxYlVjBvrhbGZtsXUyeN6AL4HegmGEsoSNiBKJC5Dqkv2YkZtFXrRm3WYRcAZyB/r1T31Sal9TYVNnGWoCb+J0aHloiHmMx5jEmEOawVQfelNp94pKjKiYrpl8X6tisnWudquIf5BCljlTPF/FX8xszHNidYt1Rnv+gp2ZT048kAtOVU+mUw9ZyF4wZrNsVXR3g2aHwIxQkB6XFZzRWHhbUIYUi7Sd0ltoYI1g8WVXbCJvo28acFV/8H+RlZKVUJbTl3JSRI/9UStUuFRjVYpVu2q1bdh9ZoKckneWeZ4IVMhU0nbkhqSV1JVclqJOCU/uWeZa911SYJdibWdBaIZsL244f5uAKoII+gn6BZilTlVQs1STV1pZaVuzW8hhd2l3bSNw+YfjiXKK54qCkO2ZuJq+UjhoFlB4Xk9nR4NMiKtOEVSuVuZzFZH/lwmZV5mZmVNWn1hbhjGKsmH2antz0o5Ha6qWV5pVWQBya41pl9RP9FwmX/hhW2brbKtwhHO5c/5zKXdNd0N9Yn0jfjeCUogK+uKMSZJvmFFbdHpAiAGYzFrgT1RTPln9XD5jeW35cgWBB4Gig8+SMJioTkRREVKLV2JfwmzObgVwUHCvcJJx6XNpdEqDoodhiAiQopCjk6iZblFXX+BgZ2GzZlmFSo6vkYuXTk6STnxU1Vj6WH1ZtVwnXzZiSGIKZmdm62tpbc9tVm74bpRv4G/pb11w0HIldFp04HSTdlx5ynwefuGApoJrhL+EToZfhnSHd4tqjKyTAJhlmNFgFmJ3kVpaD2b3bT5uP3RCm/1f2mAPe8RUGF9ebNNsKm3YcAV9eYYMijudFlOMVAVbOmprcHV1jXm+ebGC74NxikGLqIx0lwv69GQrZbp4u3hrejhOmlVQWaZbe16jYNtjYWtlZlNoGW5lcbB0CH2EkGmaJZw7bdFuPnNBjMqV8FFMXqhfTWD2YDBhTGFDZkRmpWnBbF9uyW5ib0xxnHSHdsF7J3xSg1eHUZCNlsOeL1PeVvteil9iYJRg92FmZgNnnGruba5vcHBqc2p+voE0g9SGqIrEjINScnOWW2tqBJTuVIZWXVtIZYVlyWafaI1txm07crSAdZFNmq9PGVCaUw5UPFSJVcVVP16MXz1nZnHdcwWQ21LzUmRYzlgEcY9x+3GwhROKiGaohadVhGZKcTGESVOZVcFrWV+9X+5jiWZHcfGKHY++nhFPOmTLcGZ1Z4ZkYE6L+J1HUfZRCFM2bfiA0Z4VZiNrmHDVdQNUeVwHfRaKIGs9a0ZrOFRwYD1t1X8IgtZQ3lGcVWtWzVbsWQlbDF6ZYZhhMWJeZuZmmXG5cbpxp3KneQB6sn9wigAAAAAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFgEXARgBGQEaARsBHAEdAR4BHwEgASEBIgEjASQBJQEmAScBKAEpASoBKwEuAS8BMAExATQBNQE2ATcBOAE5AToBOwE8AT0BPgFBAUIBQwFEAUUBRgFHAUgBSgFLAUwBTQFQAVEBUgFTAVQBVQFWAVcBWAFZAVoBWwFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkBagFrAWwBbQFuAW8BcAFxAXIBcwF0AXUBdgF3AXgBeQF6AXsBfAF9AX4BkgGgAaEBrwGwARgCGQIaAhsCxgLHAtgC2QLbAtwC3QIAAwEDAwMJAyMDegOEA4UDhgOIA4kDigOMA44DjwOQA5EDkgOTA5QDlQOWA5cDmAOZA5oDmwOcA50DngOfA6ADoQOjA6QDpQOmA6cDqAOpA6oDqwOsA60DrgOvA7ADsQOyA7MDtAO1A7YDtwO4A7kDugO7A7wDvQO+A78DwAPBA8IDwwPEA8UDxgPHA8gDyQPKA8sDzAPNA84DAQQCBAMEBAQFBAYEBwQIBAkECgQLBAwEDgQPBBAEEQQSBBMEFAQVBBYEFwQYBBkEGgQbBBwEHQQeBB8EIAQhBCIEIwQkBCUEJgQnBCgEKQQqBCsELAQtBC4ELwQwBDEEMgQzBDQENQQ2BDcEOAQ5BDoEOwQ8BD0EPgQ/BEAEQQRCBEMERARFBEYERwRIBEkESgRLBEwETQROBE8EUQRSBFMEVARVBFYEVwRYBFkEWgRbBFwEXgRfBJAEkQSwBbEFsgWzBbQFtQW2BbcFuAW5BbsFvAW9Bb4FvwXABcEFwgXDBdAF0QXSBdMF1AXVBdYF1wXYBdkF2gXbBdwF3QXeBd8F4AXhBeIF4wXkBeUF5gXnBegF6QXqBfAF8QXyBfMF9AUMBhsGHwYhBiIGIwYkBiUGJgYnBigGKQYqBisGLAYtBi4GLwYwBjEGMgYzBjQGNQY2BjcGOAY5BjoGQAZBBkIGQwZEBkUGRgZHBkgGSQZKBksGTAZNBk4GTwZQBlEGUgZ5Bn4GhgaIBpEGmAapBq8Guga+BsEG0gYBDgIOAw4EDgUOBg4HDggOCQ4KDgsO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", module.meta.url).href) {
        if (wasmBinary) {
          return;
        }
        if (typeof source === "string") {
          const response = await fetch(source);
          if (response.ok) {
            wasmBinary = await response.arrayBuffer();
          }
        } else {
          wasmBinary = source;
        }
      }
      const isInWorker = typeof importScripts !== "undefined";
      async function metaflac(args, options) {
        const { inputFiles, outputFileNames } = options;
        let stdout = "";
        let stderr = "";
        const { FS, callMain } = await Module({
          preRun: ({ FS: FS2 }) => {
            if (isInWorker) {
              FS2.init(null, (c) => self.postMessage({ kind: "stdout", payload: c }), (c) => self.postMessage({ kind: "stderr", payload: c }));
            }
          },
          print(text2) {
            stdout += text2 + "\n";
          },
          printErr(text2) {
            stderr += text2 + "\n";
          },
          wasmBinary
        });
        if (inputFiles) {
          [...inputFiles.entries()].forEach(([name2, data]) => {
            FS.writeFile(name2, data);
          });
        }
        const exitCode = callMain(args);
        if (!outputFileNames) {
          return {
            exitCode,
            stdout,
            stderr,
            files: new Map()
          };
        }
        return {
          exitCode,
          stdout,
          stderr,
          files: new Map(outputFileNames.map((outputFileName) => {
            const { exists } = FS.analyzePath(outputFileName);
            return [
              outputFileName,
              exists ? FS.readFile(outputFileName) : null
            ];
          }).filter((pair) => pair[1] != null))
        };
      }
      if (isInWorker) {
        self.addEventListener("message", async ({ data }) => {
          switch (data.kind) {
            case "execute":
              self.postMessage({
                kind: "complete",
                payload: await metaflac(data.payload.args, data.payload.options)
              });
              break;
            case "preload-wasm":
              preloadWASM(data.payload.wasm);
              break;
          }
        });
      }
      const audio = new Audio();
      const usePlayMusic = () => {
        const [currentMid, setCurrentMid] = useState("");
        const [isPlaying, setIsPlaying] = useState();
        const [currentTime, setCurrentTime] = useState(0);
        const [duration2, setDuration] = useState(0);
        const urlMap = useRef({});
        const getUrl = async (id, level = QUALITY_LEVELS.无损) => {
          const key = `${id}-${level}`;
          console.log("获取歌曲url的key", key);
          if (urlMap.current[key]) {
            return urlMap.current[key];
          }
          const res = await getSongUrl([id], { level });
          if (res.code !== 200) {
            msgError(res.message || res.msg || "获取歌曲链接失败");
            throw new Error(res.message || res.msg || "获取歌曲链接失败");
          }
          console.log("res", res);
          urlMap.current[key] = res.data[0].url;
          return res.data[0].url;
        };
        const play = async (id, level) => {
          try {
            if (currentMid === id) {
              audio.play();
              return;
            }
            const url = await getUrl(id, level);
            setIsPlaying(id);
            audio.src = url;
            audio.play();
            setCurrentMid(id);
            return new Promise((resolve) => {
              audio.onended = () => {
                resolve(true);
                setIsPlaying(void 0);
              };
            });
          } catch (error) {
            console.log("error", error);
          }
        };
        const playPlayList = async (ids, level) => {
          for (const id of ids) {
            await play(id, level);
          }
        };
        const download = async (id, name2, level = QUALITY_LEVELS.无损, albumMid) => {
          const url = await getUrl(id, level);
          console.log(`当前下载歌曲${name2},音质为${level},链接为${url}`);
          const finalExt = url.split("?")[0].split(".").pop();
          const { blob, response } = await getFileBlob(
            url.replace("http://", "https://")
          );
          console.log("blob", blob);
          const fileName = `${name2}.${finalExt}`;
          let outputFile = blob;
          downloadFileWithBlob(outputFile, fileName);
        };
        const pause = () => {
          audio.pause();
          setIsPlaying(false);
        };
        return {
          currentMid,
          isPlaying,
          currentTime,
          duration: duration2,
          getUrl,
          play,
          pause,
          playPlayList,
          download
        };
      };
      var duration$2 = { exports: {} };
      var duration$1 = duration$2.exports;
      var hasRequiredDuration;
      function requireDuration() {
        if (hasRequiredDuration) return duration$2.exports;
        hasRequiredDuration = 1;
        (function(module, exports) {
          !(function(t, s) {
            module.exports = s();
          })(duration$1, (function() {
            var t, s, n = 1e3, i = 6e4, e = 36e5, r = 864e5, o = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, u = 31536e6, d = 2628e6, a = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, h = { years: u, months: d, days: r, hours: e, minutes: i, seconds: n, milliseconds: 1, weeks: 6048e5 }, c = function(t2) {
              return t2 instanceof g;
            }, f = function(t2, s2, n2) {
              return new g(t2, n2, s2.$l);
            }, m = function(t2) {
              return s.p(t2) + "s";
            }, l = function(t2) {
              return t2 < 0;
            }, $ = function(t2) {
              return l(t2) ? Math.ceil(t2) : Math.floor(t2);
            }, y = function(t2) {
              return Math.abs(t2);
            }, v = function(t2, s2) {
              return t2 ? l(t2) ? { negative: true, format: "" + y(t2) + s2 } : { negative: false, format: "" + t2 + s2 } : { negative: false, format: "" };
            }, g = (function() {
              function l2(t2, s2, n2) {
                var i2 = this;
                if (this.$d = {}, this.$l = n2, void 0 === t2 && (this.$ms = 0, this.parseFromMilliseconds()), s2) return f(t2 * h[m(s2)], this);
                if ("number" == typeof t2) return this.$ms = t2, this.parseFromMilliseconds(), this;
                if ("object" == typeof t2) return Object.keys(t2).forEach((function(s3) {
                  i2.$d[m(s3)] = t2[s3];
                })), this.calMilliseconds(), this;
                if ("string" == typeof t2) {
                  var e2 = t2.match(a);
                  if (e2) {
                    var r2 = e2.slice(2).map((function(t3) {
                      return null != t3 ? Number(t3) : 0;
                    }));
                    return this.$d.years = r2[0], this.$d.months = r2[1], this.$d.weeks = r2[2], this.$d.days = r2[3], this.$d.hours = r2[4], this.$d.minutes = r2[5], this.$d.seconds = r2[6], this.calMilliseconds(), this;
                  }
                }
                return this;
              }
              var y2 = l2.prototype;
              return y2.calMilliseconds = function() {
                var t2 = this;
                this.$ms = Object.keys(this.$d).reduce((function(s2, n2) {
                  return s2 + (t2.$d[n2] || 0) * h[n2];
                }), 0);
              }, y2.parseFromMilliseconds = function() {
                var t2 = this.$ms;
                this.$d.years = $(t2 / u), t2 %= u, this.$d.months = $(t2 / d), t2 %= d, this.$d.days = $(t2 / r), t2 %= r, this.$d.hours = $(t2 / e), t2 %= e, this.$d.minutes = $(t2 / i), t2 %= i, this.$d.seconds = $(t2 / n), t2 %= n, this.$d.milliseconds = t2;
              }, y2.toISOString = function() {
                var t2 = v(this.$d.years, "Y"), s2 = v(this.$d.months, "M"), n2 = +this.$d.days || 0;
                this.$d.weeks && (n2 += 7 * this.$d.weeks);
                var i2 = v(n2, "D"), e2 = v(this.$d.hours, "H"), r2 = v(this.$d.minutes, "M"), o2 = this.$d.seconds || 0;
                this.$d.milliseconds && (o2 += this.$d.milliseconds / 1e3, o2 = Math.round(1e3 * o2) / 1e3);
                var u2 = v(o2, "S"), d2 = t2.negative || s2.negative || i2.negative || e2.negative || r2.negative || u2.negative, a2 = e2.format || r2.format || u2.format ? "T" : "", h2 = (d2 ? "-" : "") + "P" + t2.format + s2.format + i2.format + a2 + e2.format + r2.format + u2.format;
                return "P" === h2 || "-P" === h2 ? "P0D" : h2;
              }, y2.toJSON = function() {
                return this.toISOString();
              }, y2.format = function(t2) {
                var n2 = t2 || "YYYY-MM-DDTHH:mm:ss", i2 = { Y: this.$d.years, YY: s.s(this.$d.years, 2, "0"), YYYY: s.s(this.$d.years, 4, "0"), M: this.$d.months, MM: s.s(this.$d.months, 2, "0"), D: this.$d.days, DD: s.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: s.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: s.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: s.s(this.$d.seconds, 2, "0"), SSS: s.s(this.$d.milliseconds, 3, "0") };
                return n2.replace(o, (function(t3, s2) {
                  return s2 || String(i2[t3]);
                }));
              }, y2.as = function(t2) {
                return this.$ms / h[m(t2)];
              }, y2.get = function(t2) {
                var s2 = this.$ms, n2 = m(t2);
                return "milliseconds" === n2 ? s2 %= 1e3 : s2 = "weeks" === n2 ? $(s2 / h[n2]) : this.$d[n2], s2 || 0;
              }, y2.add = function(t2, s2, n2) {
                var i2;
                return i2 = s2 ? t2 * h[m(s2)] : c(t2) ? t2.$ms : f(t2, this).$ms, f(this.$ms + i2 * (n2 ? -1 : 1), this);
              }, y2.subtract = function(t2, s2) {
                return this.add(t2, s2, true);
              }, y2.locale = function(t2) {
                var s2 = this.clone();
                return s2.$l = t2, s2;
              }, y2.clone = function() {
                return f(this.$ms, this);
              }, y2.humanize = function(s2) {
                return t().add(this.$ms, "ms").locale(this.$l).fromNow(!s2);
              }, y2.valueOf = function() {
                return this.asMilliseconds();
              }, y2.milliseconds = function() {
                return this.get("milliseconds");
              }, y2.asMilliseconds = function() {
                return this.as("milliseconds");
              }, y2.seconds = function() {
                return this.get("seconds");
              }, y2.asSeconds = function() {
                return this.as("seconds");
              }, y2.minutes = function() {
                return this.get("minutes");
              }, y2.asMinutes = function() {
                return this.as("minutes");
              }, y2.hours = function() {
                return this.get("hours");
              }, y2.asHours = function() {
                return this.as("hours");
              }, y2.days = function() {
                return this.get("days");
              }, y2.asDays = function() {
                return this.as("days");
              }, y2.weeks = function() {
                return this.get("weeks");
              }, y2.asWeeks = function() {
                return this.as("weeks");
              }, y2.months = function() {
                return this.get("months");
              }, y2.asMonths = function() {
                return this.as("months");
              }, y2.years = function() {
                return this.get("years");
              }, y2.asYears = function() {
                return this.as("years");
              }, l2;
            })(), p = function(t2, s2, n2) {
              return t2.add(s2.years() * n2, "y").add(s2.months() * n2, "M").add(s2.days() * n2, "d").add(s2.hours() * n2, "h").add(s2.minutes() * n2, "m").add(s2.seconds() * n2, "s").add(s2.milliseconds() * n2, "ms");
            };
            return function(n2, i2, e2) {
              t = e2, s = e2().$utils(), e2.duration = function(t2, s2) {
                var n3 = e2.locale();
                return f(t2, { $l: n3 }, s2);
              }, e2.isDuration = c;
              var r2 = i2.prototype.add, o2 = i2.prototype.subtract;
              i2.prototype.add = function(t2, s2) {
                return c(t2) ? p(this, t2, 1) : r2.bind(this)(t2, s2);
              }, i2.prototype.subtract = function(t2, s2) {
                return c(t2) ? p(this, t2, -1) : o2.bind(this)(t2, s2);
              };
            };
          }));
        })(duration$2);
        return duration$2.exports;
      }
      var durationExports = requireDuration();
      const duration = getDefaultExportFromCjs(durationExports);
      const styles$3 = {
        "playlist-id-input": "_playlist-id-input_1r0t2_5"
      };
      dayjs.extend(duration);
      function SongList(props, ref) {
        const { visible, close } = useVisible(
          {
            onOpen(id) {
              setPlaylistId(id);
            },
            onReset() {
              setSongList([]);
              setPlaylistId(null);
            }
          },
          ref
        );
        const { play, pause, isPlaying, download, playPlayList } = usePlayMusic();
        const [loading, setLoading] = useState(false);
        const [songList2, setSongList] = useState([]);
        const [playlistId, setPlaylistId] = useState(null);
        const [selectedRows, setSelectedRows] = useState([]);
        const getSongListData = async (playlistId2) => {
          if (!playlistId2) return;
          try {
            setLoading(true);
            const res = await getPlaylistAllData(playlistId2);
            console.log("res", res);
            setSongList(res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        useEffect(() => {
          if (playlistId && visible) {
            getSongListData(playlistId);
          }
        }, [playlistId, visible]);
        const filterConfig = {
          fields: {
            name: {
              getValue: (song) => song.name
            },
            artists: {
              getValue: (song) => song.ar?.map((artist2) => artist2.name).join(", ")
            },
            album: {
              getValue: (song) => song.al?.name
            }
          }
        };
        const {
          filteredList: filteredSongList,
          setFilteredList: setFilteredSongList,
          handleFilter: handleSearch
        } = useFilter(songList2, filterConfig);
        const handleSelectQuality = (record, value2) => {
          console.log("record", record);
          console.log("value", value2);
          setFilteredSongList((prev) => {
            return prev.map((song) => {
              if (song.id === record.id) {
                return { ...song, level: value2 };
              }
              return song;
            });
          });
        };
        const handlePlay = (record) => {
          console.log("record", record);
          if (isPlaying === record.id) {
            pause();
          } else {
            play(record.id, record.level);
          }
        };
        const handleDownload = (record) => {
          console.log("record", record);
          download(
            record.id,
            record.name,
            record.level || QUALITY_LEVELS.无损,
            record.al?.id
          );
        };
        const columns = [
          {
            title: "歌曲信息",
            key: "songInfo",
            width: 350,
            fixed: "left",
            sorter: (a, b) => a.name?.localeCompare(b.name),
            sortDirections: ["ascend", "descend"],
            render: (_, record) => {
              const alias = record.alia?.[0] || "";
              return jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    display: "flex",
                    alignItems: "center",
                    gap: "12px",
                    minWidth: 0
                  },
                  children: [
jsxRuntimeExports.jsx(
                      "div",
                      {
                        style: {
                          width: "60px",
                          height: "60px",
                          borderRadius: "6px",
                          flexShrink: 0,
                          overflow: "hidden",
                          cursor: "pointer"
                        },
                        onClick: (e) => e.stopPropagation(),
                        children: record.al?.picUrl ? jsxRuntimeExports.jsx(
                          Image,
                          {
                            src: record.al.picUrl,
                            width: 60,
                            height: 60,
                            preview: false,
                            placeholder: true
                          }
                        ) : jsxRuntimeExports.jsx(
                          "div",
                          {
                            style: {
                              width: "60px",
                              height: "60px",
                              backgroundColor: "#f0f0f0",
                              borderRadius: "6px",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                              color: "#999",
                              fontSize: "12px"
                            },
                            children: "无封面"
                          }
                        )
                      }
                    ),
jsxRuntimeExports.jsxs(
                      "div",
                      {
                        style: {
                          flex: 1,
                          minWidth: 0,
                          display: "flex",
                          flexDirection: "column",
                          gap: "4px"
                        },
                        children: [
jsxRuntimeExports.jsx(Tooltip, { title: record.name, placement: "top", children: jsxRuntimeExports.jsx(
                            "div",
                            {
                              style: {
                                fontWeight: 500,
                                fontSize: "14px",
                                overflow: "hidden",
                                textOverflow: "ellipsis",
                                whiteSpace: "nowrap",
                                color: "#262626"
                              },
                              children: record.name
                            }
                          ) }),
                          alias && jsxRuntimeExports.jsx(Tooltip, { title: alias, placement: "top", children: jsxRuntimeExports.jsx(
                            "div",
                            {
                              style: {
                                fontSize: "12px",
                                color: "#8c8c8c",
                                fontStyle: "italic",
                                overflow: "hidden",
                                textOverflow: "ellipsis",
                                whiteSpace: "nowrap"
                              },
                              children: alias
                            }
                          ) }),
jsxRuntimeExports.jsx(Tooltip, { title: record.id, placement: "top", children: jsxRuntimeExports.jsxs(
                            "div",
                            {
                              style: {
                                fontSize: "12px",
                                color: "#8c8c8c",
                                overflow: "hidden",
                                textOverflow: "ellipsis",
                                whiteSpace: "nowrap"
                              },
                              children: [
                                "ID:",
                                " ",
jsxRuntimeExports.jsx(Typography.Text, { copyable: true, style: { fontSize: "12px" }, children: record.id })
                              ]
                            }
                          ) })
                        ]
                      }
                    )
                  ]
                }
              );
            }
          },
          {
            title: "歌手",
            dataIndex: "ar",
            key: "ar",
            width: 150,
            sorter: (a, b) => {
              const aName = a.ar?.map((a2) => a2.name).join(", ") || "";
              const bName = b.ar?.map((b2) => b2.name).join(", ") || "";
              return aName.localeCompare(bName);
            },
            sortDirections: ["ascend", "descend"],
            render: (ar) => ar?.map((a) => a.name).join(", ")
          },
          {
            title: "专辑",
            dataIndex: "al",
            key: "al",
            width: 200,
            sorter: (a, b) => (a.al?.name || "").localeCompare(b.al?.name || ""),
            sortDirections: ["ascend", "descend"],
            render: (al) => al?.name
          },
          {
            title: "专辑ID",
            dataIndex: ["al", "id"],
            key: "albumId",
            width: 120,
            render: (id) => id || "-"
          },
          {
            title: "时长",
            dataIndex: "dt",
            key: "dt",
            width: 80,
            sorter: (a, b) => a.dt - b.dt,
            sortDirections: ["ascend", "descend"],
            render: (dt) => formatDuration(dt)
          },
          {
            title: "光盘号",
            dataIndex: "cd",
            key: "cd",
            width: 80,
            render: (cd) => cd || "-"
          },
          {
            title: "序号",
            dataIndex: "no",
            key: "no",
            width: 60,
            sorter: (a, b) => a.no - b.no,
            sortDirections: ["ascend", "descend"],
            render: (no) => no || "-"
          },
          {
            title: "版权",
            dataIndex: "fee",
            key: "fee",
            width: 100,
            filters: [
              { text: "免费", value: 0 },
              { text: "VIP", value: 1 },
              { text: "专辑购买", value: 4 },
              { text: "付费/试听", value: 8 }
            ],
            onFilter: (value2, record) => record.fee === value2,
            render: (fee) => {
              const tag2 = getFeeTag(fee);
              return jsxRuntimeExports.jsx(Tag, { color: tag2.color, children: tag2.text });
            }
          },
          {
            title: "版权信息",
            dataIndex: "copyright",
            key: "copyright",
            width: 100,
            render: (copyright) => {
              if (copyright === void 0 || copyright === null) return "-";
              return copyright === 1 ? jsxRuntimeExports.jsx(Tag, { color: "#87d068", children: "有版权" }) : jsxRuntimeExports.jsx(Tag, { color: "#ff4d4f", children: "无版权" });
            }
          },
          {
            title: "音源",
            dataIndex: "noCopyrightRcmd",
            key: "noCopyrightRcmd",
            width: 100,
            filters: [
              { text: "有音源", value: false },
              { text: "无音源", value: true }
            ],
            onFilter: (value2, record) => !!record.noCopyrightRcmd === value2,
            render: (noCopyrightRcmd) => {
              return jsxRuntimeExports.jsx(Tag, { color: noCopyrightRcmd ? "#ff4d4f" : "#87d068", children: noCopyrightRcmd ? "无音源" : "有音源" });
            }
          },
          {
            title: "原创类型",
            dataIndex: "originCoverType",
            key: "originCoverType",
            width: 100,
            filters: [
              { text: "未知", value: 0 },
              { text: "原曲", value: 1 },
              { text: "翻唱", value: 2 }
            ],
            onFilter: (value2, record) => record.originCoverType === value2,
            render: (type) => {
              const tag2 = getOriginTag(type);
              return jsxRuntimeExports.jsx(Tag, { color: tag2.color, children: tag2.text });
            }
          },
          {
            title: "热度",
            dataIndex: "pop",
            key: "pop",
            width: 80,
            sorter: (a, b) => a.pop - b.pop,
            sortDirections: ["ascend", "descend"],
            render: (pop) => formatPopularity(pop)
          },
          {
            title: "MV ID",
            dataIndex: "mv",
            key: "mv",
            width: 100,
            render: (mv) => mv ? jsxRuntimeExports.jsx(Typography.Text, { copyable: true, children: mv }) : "-"
          },
          {
            title: "发布时间",
            dataIndex: "publishTime",
            key: "publishTime",
            width: 120,
            sorter: (a, b) => a.publishTime - b.publishTime,
            sortDirections: ["ascend", "descend"],
            render: (time) => time ? dayjs(time).format("YYYY-MM-DD") : "-"
          },
          {
            title: "歌曲类型",
            dataIndex: "t",
            key: "t",
            width: 100,
            render: (t) => {
              const tag2 = getTypeTag(t);
              return jsxRuntimeExports.jsx(Tag, { color: tag2.color, children: tag2.text });
            }
          },
          {
            title: "音质",
            key: "quality",
            width: 150,
            render: (_, record) => {
              const tags = getQualityTags(record);
              if (tags.length === 0) return "-";
              return jsxRuntimeExports.jsx("div", { children: tags.map((tag2, index) => jsxRuntimeExports.jsx(
                Tag,
                {
                  color: tag2.color,
                  style: { marginBottom: "4px" },
                  children: tag2.label
                },
                index
              )) });
            }
          },
{
            title: "选择音质",
            key: "selectQuality",
            width: 150,
            render: (_, record) => {
              const options = getQualityTags(record);
              const defaultLevel = options.find((option) => option.value === QUALITY_LEVELS.无损)?.value || options[0].value;
              return jsxRuntimeExports.jsx(
                Select,
                {
                  options,
                  value: record.level || defaultLevel,
                  onChange: (value2) => handleSelectQuality(record, value2)
                }
              );
            }
          },
          {
            title: "标记",
            dataIndex: "mark",
            key: "mark",
            width: 150,
            render: (mark) => {
              if (!mark) return "-";
              const tags = getMarkTags(mark);
              if (tags.length === 0) return "-";
              return jsxRuntimeExports.jsx("div", { children: tags.map((tag2, index) => jsxRuntimeExports.jsx(
                Tag,
                {
                  color: tag2.color,
                  style: { marginBottom: "4px" },
                  children: tag2.text
                },
                index
              )) });
            }
          },
          {
            title: "版本",
            dataIndex: "version",
            key: "version",
            width: 80,
            render: (version2) => version2 || "-"
          },
          {
            title: "CP",
            dataIndex: "cp",
            key: "cp",
            width: 80,
            render: (cp) => cp || "-"
          },
          {
            title: "资源状态",
            dataIndex: "resourceState",
            key: "resourceState",
            width: 100,
            render: (state) => {
              if (state === void 0 || state === null) return "-";
              return state ? jsxRuntimeExports.jsx(Tag, { color: "#87d068", children: "可用" }) : jsxRuntimeExports.jsx(Tag, { color: "#ff4d4f", children: "不可用" });
            }
          },
{
            title: "操作",
            key: "action",
            width: 200,
            align: "center",
            fixed: "right",
            render: (_, record) => {
              return jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    icon: isPlaying === record.id ? jsxRuntimeExports.jsx(PauseCircleOutlined, {}) : jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                    onClick: () => handlePlay(record),
                    children: "播放"
                  }
                ),
jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    icon: jsxRuntimeExports.jsx(DownloadOutlined, {}),
                    onClick: () => handleDownload(record),
                    children: "下载"
                  }
                )
              ] });
            }
          }
        ];
        const handlePlayAll = async () => {
          if (!filteredSongList.length) return;
          try {
            await playPlayList(filteredSongList.map((song) => song.id));
          } catch (error) {
            console.error("播放歌单失败:", error);
          }
        };
        const handleDownloadAll = async () => {
          if (!currentDissid) return;
          try {
            await downloadPlaylistSong(currentDissid);
          } catch (error) {
            console.error("下载歌单失败:", error);
          }
        };
        const handleDownloadAllJson = async () => {
          if (!currentDissid) return;
          try {
            await getPlaylistDownloadJson(currentDissid);
          } catch (error) {
            console.error("下载歌单JSON失败:", error);
          }
        };
        const renderFooter = () => {
          return jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(
              Button,
              {
                type: "primary",
                icon: jsxRuntimeExports.jsx(PlayCircleOutlined, {}),
                onClick: handlePlayAll,
                children: "播放全部"
              }
            ),
jsxRuntimeExports.jsx(Button, { icon: jsxRuntimeExports.jsx(DownloadOutlined, {}), onClick: handleDownloadAll, children: "下载全部" }),
jsxRuntimeExports.jsx(Button, { icon: jsxRuntimeExports.jsx(FileOutlined, {}), onClick: handleDownloadAllJson, children: "下载JSON" })
          ] });
        };
        return jsxRuntimeExports.jsxs(
          Modal,
          {
            title: "歌曲列表",
            width: "90%",
            centered: true,
            open: visible,
            destroyOnHidden: true,
            footer: renderFooter(),
            onCancel: close,
            children: [
jsxRuntimeExports.jsx(
                SearchForm,
                {
                  onSearch: handleSearch,
                  data: songList2.map((song) => ({
                    ...song,
                    artists: song.ar?.map((artist2) => artist2.name).join(", "),
                    album: song.al?.name
                  })),
                  options: [
                    { label: "歌曲", value: "name" },
                    { label: "歌手", value: "artists" },
                    { label: "专辑", value: "album" }
                  ]
                }
              ),
jsxRuntimeExports.jsx(Form.Item, { label: "歌单ID", children: jsxRuntimeExports.jsx(
                Input,
                {
                  className: styles$3["playlist-id-input"],
                  defaultValue: playlistId,
                  onKeyDown: (e) => {
                    if (e.key === "Enter") {
                      setPlaylistId(e.target.value);
                    }
                  }
                }
              ) }),
jsxRuntimeExports.jsx(
                Table,
                {
                  columns,
                  dataSource: filteredSongList,
                  rowKey: "id",
                  loading,
                  scroll: { y: 400, x: 2e3 },
                  rowSelection: {
                    type: "checkbox",
                    fixed: true,
                    onChange: (selectedRowKeys, selectedRows2) => {
                      setSelectedRows(selectedRows2);
                    }
                  }
                }
              )
            ]
          }
        );
      }
      const SongList$1 = forwardRef(SongList);
      const formatDuration = (ms2) => {
        const time = dayjs.duration(ms2);
        const minutes = time.minutes();
        const seconds = time.seconds();
        return `${minutes}:${seconds.toString().padStart(2, "0")}`;
      };
      const getQualityTags = (song) => {
        const tags = [];
        if (song.hr)
          tags.push({
            label: "Hi-Res",
            color: "#f50",
            value: QUALITY_LEVELS["Hi-Res"]
          });
        if (song.sq)
          tags.push({ label: "SQ", color: "#87d068", value: QUALITY_LEVELS.无损 });
        if (song.h)
          tags.push({ label: "HQ", color: "#2db7f5", value: QUALITY_LEVELS.较高 });
        return tags;
      };
      const getMarkTags = (mark) => {
        const tags = [];
        if (mark & 131072) tags.push({ text: "纯音乐", color: "#2db7f5" });
        if (mark & 262144) tags.push({ text: "杜比全景声", color: "#722ed1" });
        if (mark & 1048576) tags.push({ text: "🅴", color: "#f50" });
        if (mark & 17179869184) tags.push({ text: "Hi-Res", color: "#f50" });
        return tags;
      };
      const getOriginTag = (originCoverType) => {
        const types = {
          0: { text: "未知", color: "#d9d9d9" },
          1: { text: "原曲", color: "#87d068" },
          2: { text: "翻唱", color: "#2db7f5" }
        };
        return types[originCoverType] || types[0];
      };
      const formatPopularity = (pop) => {
        if (!pop) return "0";
        return pop.toFixed(1);
      };
      const getTypeTag = (t) => {
        const types = {
          0: { text: "普通歌曲", color: "#108ee9" },
          1: { text: "独立云盘", color: "#f50" },
          2: { text: "云盘歌曲", color: "#87d068" }
        };
        return types[t] || types[0];
      };
      const getFeeTag = (fee) => {
        const fees = {
          0: { text: "免费", color: "#87d068" },
          1: { text: "VIP", color: "#f50" },
          4: { text: "专辑购买", color: "#722ed1" },
          8: { text: "付费/试听", color: "#faad14" }
        };
        return fees[fee] || fees[0];
      };
      const cover = "_cover_15nrq_8";
      const info = "_info_15nrq_40";
      const name = "_name_15nrq_47";
      const creator = "_creator_15nrq_58";
      const styles$2 = {
        "playlist-info": "_playlist-info_15nrq_1",
        cover,
        info,
        name,
        creator,
        "playlist-item": "_playlist-item_15nrq_69"
      };
      function PlayList(props, ref) {
        const { visible, close } = useVisible(
          {
            onOpen() {
              getPlayListData();
            },
            onReset() {
              setPlayList([]);
            }
          },
          ref
        );
        const [loading, setLoading] = useState(false);
        const [playList, setPlayList] = useState([]);
        const songListRef = useRef();
        const getPlayListData = async () => {
          try {
            setLoading(true);
            const res = await getPlaylistList();
            if (res.code === 200) {
              setPlayList(res.playlist || []);
            }
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        const formatPlayCount = (count2) => {
          if (count2 < 1e4) return count2;
          return `${(count2 / 1e4).toFixed(1)}万`;
        };
        const handleRowClick = (record) => {
          songListRef.current?.open(record.id);
        };
        const { filteredList, handleFilter } = useFilter(playList, {
          fields: {
            name: {
              getValue: (item) => item.name
            },
            creator: {
              getValue: (item) => item.creator.nickname
            }
          }
        });
        const columns = [
          {
            title: "歌单信息",
            key: "playlistInfo",
            width: 250,
            render: (_, record) => jsxRuntimeExports.jsxs("div", { className: styles$2["playlist-info"], children: [
jsxRuntimeExports.jsx("div", { className: styles$2["cover"], children: jsxRuntimeExports.jsx(
                Image,
                {
                  src: record.coverImgUrl,
                  width: 60,
                  height: 60,
                  onClick: (e) => e.stopPropagation(),
                  preview: false
                }
              ) }),
jsxRuntimeExports.jsxs("div", { className: styles$2["info"], children: [
jsxRuntimeExports.jsx(Tooltip, { title: record.name, placement: "top", children: jsxRuntimeExports.jsx("div", { className: styles$2["name"], children: record.name }) }),
jsxRuntimeExports.jsx(Tooltip, { title: record.creator.nickname, placement: "top", children: jsxRuntimeExports.jsx("div", { className: styles$2["creator"], children: record.creator.nickname }) })
              ] })
            ] })
          },
          {
            title: "歌曲数量",
            dataIndex: "trackCount",
            key: "trackCount",
            width: 100
          },
{
            title: "歌单id",
            dataIndex: "id",
            key: "id",
            width: 100,
            render: (id) => jsxRuntimeExports.jsx(Typography.Text, { copyable: true, children: id })
          },
          {
            title: "播放次数",
            dataIndex: "playCount",
            key: "playCount",
            width: 100,
            render: (count2) => formatPlayCount(count2)
          },
          {
            title: "创建时间",
            dataIndex: "createTime",
            key: "createTime",
            width: 120,
            render: (time) => dayjs(time).format("YYYY-MM-DD")
          },
          {
            title: "更新时间",
            dataIndex: "updateTime",
            key: "updateTime",
            width: 120,
            render: (time) => dayjs(time).format("YYYY-MM-DD")
          }
        ];
        return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
jsxRuntimeExports.jsxs(
            Modal,
            {
              title: "歌单列表",
              width: 1300,
              centered: true,
              open: visible,
              footer: null,
              onCancel: close,
              children: [
jsxRuntimeExports.jsx(
                  SearchForm,
                  {
                    data: playList.map((item) => ({
                      ...item,
                      creator: item.creator.nickname
                    })),
                    options: [
                      {
                        label: "歌单名字",
                        value: "name"
                      },
                      {
                        label: "创建者",
                        value: "creator"
                      }
                    ],
                    onSearch: handleFilter
                  }
                ),
jsxRuntimeExports.jsx(
                  Table,
                  {
                    columns,
                    dataSource: filteredList,
                    rowKey: "id",
                    loading,
                    scroll: { x: 1e3, y: 400 },
                    onRow: (record) => ({
                      onClick: () => handleRowClick(record),
                      className: styles$2["playlist-item"]
                    }),
                    pagination: {
                      showQuickJumper: true,
                      showSizeChanger: true
                    }
                  }
                )
              ]
            }
          ),
jsxRuntimeExports.jsx(SongList$1, { ref: songListRef })
        ] });
      }
      const PlayList$1 = forwardRef(PlayList);
      const select = "_select_1rogj_22";
      const tag = "_tag_1rogj_46";
      const divider = "_divider_1rogj_70";
      const label = "_label_1rogj_87";
      const value = "_value_1rogj_92";
      const size = "_size_1rogj_67";
      const percentage = "_percentage_1rogj_113";
      const progressInfo = "_progressInfo_1rogj_157";
      const statsContainer = "_statsContainer_1rogj_172";
      const statsItem = "_statsItem_1rogj_180";
      const songName = "_songName_1rogj_208";
      const uploadModal = "_uploadModal_1rogj_218";
      const progressSection = "_progressSection_1rogj_222";
      const count = "_count_1rogj_241";
      const statsTag = "_statsTag_1rogj_256";
      const songList = "_songList_1rogj_261";
      const songItem = "_songItem_1rogj_277";
      const songInfo = "_songInfo_1rogj_292";
      const artistName = "_artistName_1rogj_306";
      const styles$1 = {
        "quick-upload-tabs": "_quick-upload-tabs_1rogj_22",
        select,
        "singer-choose": "_singer-choose_1rogj_26",
        "singer-choose-form": "_singer-choose-form_1rogj_26",
        "btn-group": "_btn-group_1rogj_32",
        "option-label": "_option-label_1rogj_36",
        "singer-name": "_singer-name_1rogj_43",
        "tag-group": "_tag-group_1rogj_46",
        tag,
        "upload-list": "_upload-list_1rogj_50",
        "upload-footer": "_upload-footer_1rogj_54",
        "upload-stats": "_upload-stats_1rogj_62",
        "size-text": "_size-text_1rogj_67",
        divider,
        "upload-confirm": "_upload-confirm_1rogj_75",
        "confirm-item": "_confirm-item_1rogj_79",
        label,
        value,
        size,
        percentage,
        progressInfo,
        statsContainer,
        statsItem,
        songName,
        uploadModal,
        progressSection,
        count,
        statsTag,
        songList,
        songItem,
        songInfo,
        artistName
      };
      function SingerChoose({ singerList, onChoose, loading }) {
        const renderSingerList = useMemo(() => {
          return singerList.map((item) => {
            const { id, name: name2, count: count2, size: size2, sizeDesc } = item;
            return {
              ...item,
              label: jsxRuntimeExports.jsxs("div", { className: styles$1["option-label"], children: [
jsxRuntimeExports.jsx("span", { className: styles$1["singer-name"], children: name2 }),
jsxRuntimeExports.jsxs("div", { className: styles$1["tag-group"], children: [
jsxRuntimeExports.jsxs(Tag, { color: "blue", className: styles$1["tag"], children: [
                    count2,
                    "首"
                  ] }),
jsxRuntimeExports.jsx(Tag, { color: "green", className: styles$1["tag"], children: sizeDesc })
                ] })
              ] }),
              value: id
            };
          });
        }, [singerList]);
        const [formRef] = Form.useForm();
        const handleChoose = (values) => {
          const { singer } = values;
          onChoose([...singer]);
        };
        return jsxRuntimeExports.jsx("div", { className: styles$1["singer-choose"], children: loading ? jsxRuntimeExports.jsx(Spin, { tip: "正在加载中" }) : jsxRuntimeExports.jsxs(
          Form,
          {
            form: formRef,
            onFinish: handleChoose,
            className: styles$1["singer-choose-form"],
            children: [
jsxRuntimeExports.jsx(Form.Item, { name: "singer", label: "歌手", children: jsxRuntimeExports.jsx(
                Select,
                {
                  mode: "multiple",
                  placeholder: "请选择歌手",
                  allowClear: true,
                  className: styles$1["select"],
                  filterOption: (input, option) => option.name?.toLowerCase().indexOf(input.toLowerCase()) >= 0,
                  options: renderSingerList,
                  getPopupContainer: (trigger) => trigger.parentNode
                }
              ) }),
jsxRuntimeExports.jsx(Form.Item, { style: { marginBottom: 0 }, children: jsxRuntimeExports.jsx("div", { className: styles$1["btn-group"], children: jsxRuntimeExports.jsx(Button, { type: "primary", htmlType: "submit", children: "选择" }) }) })
            ]
          }
        ) });
      }
      const UploadProgress = forwardRef(
        ({ uploadedList, total, uploadFailedSongList, onClose }, ref) => {
          const [visible, setVisible] = useState(false);
          const open = () => setVisible(true);
          const close = () => {
            setVisible(false);
            onClose?.();
          };
          const reset = () => {
          };
          useImperativeHandle(ref, () => ({
            open,
            close,
            reset
          }));
          const uploadedCount = uploadedList.length;
          const failedCount = uploadFailedSongList.length;
          const percent = Math.floor((uploadedCount + failedCount) / total * 100);
          const isCompleted = uploadedCount + failedCount === total;
          const songListRef = useRef(null);
          useEffect(() => {
            let timeId;
            if (visible) {
              timeId = setInterval(() => {
                songListRef.current?.scrollTo({
                  top: songListRef.current.scrollHeight,
                  behavior: "smooth"
                });
              }, 500);
            }
            return () => {
              clearInterval(timeId);
            };
          }, [visible]);
          return jsxRuntimeExports.jsxs(
            Modal,
            {
              title: "上传进度",
              open: visible,
              onCancel: close,
              width: 520,
              maskClosable: false,
              footer: null,
              centered: true,
              className: styles$1.uploadModal,
              children: [
jsxRuntimeExports.jsxs("div", { className: styles$1.progressSection, children: [
jsxRuntimeExports.jsx(
                    Progress,
                    {
                      type: "circle",
                      percent,
                      status: isCompleted ? failedCount > 0 ? "exception" : "success" : "active",
                      format: () => jsxRuntimeExports.jsxs("div", { className: styles$1.progressInfo, children: [
jsxRuntimeExports.jsxs("span", { className: styles$1.percentage, children: [
                          percent,
                          "%"
                        ] }),
jsxRuntimeExports.jsxs("span", { className: styles$1.count, children: [
                          uploadedCount + failedCount,
                          "/",
                          total
                        ] })
                      ] })
                    }
                  ),
jsxRuntimeExports.jsxs("div", { className: styles$1.statsContainer, children: [
jsxRuntimeExports.jsx("div", { className: styles$1.statsItem, children: jsxRuntimeExports.jsxs(Tag, { color: "success", className: styles$1.statsTag, children: [
                      "成功：",
                      uploadedCount
                    ] }) }),
                    failedCount > 0 && jsxRuntimeExports.jsx("div", { className: styles$1.statsItem, children: jsxRuntimeExports.jsxs(Tag, { color: "error", className: styles$1.statsTag, children: [
                      "失败：",
                      failedCount
                    ] }) })
                  ] })
                ] }),
                (uploadedList.length > 0 || uploadFailedSongList.length > 0) && jsxRuntimeExports.jsxs("div", { className: styles$1.songList, ref: songListRef, children: [
                  uploadFailedSongList.map((song) => jsxRuntimeExports.jsxs("div", { className: styles$1.songItem, children: [
jsxRuntimeExports.jsxs("div", { className: styles$1.songInfo, children: [
jsxRuntimeExports.jsx("span", { className: styles$1.songName, children: song.name }),
jsxRuntimeExports.jsxs("span", { className: styles$1.artistName, children: [
                        "- ",
                        song.artists
                      ] })
                    ] }),
jsxRuntimeExports.jsx(Tag, { color: "error", children: "上传失败" })
                  ] }, song.id)),
                  uploadedList.map((song) => jsxRuntimeExports.jsxs("div", { className: styles$1.songItem, children: [
jsxRuntimeExports.jsxs("div", { className: styles$1.songInfo, children: [
jsxRuntimeExports.jsx("span", { className: styles$1.songName, children: song.name }),
jsxRuntimeExports.jsxs("span", { className: styles$1.artistName, children: [
                        "- ",
                        song.artists
                      ] })
                    ] }),
jsxRuntimeExports.jsx(Tag, { color: "success", children: "已上传" })
                  ] }, song.id))
                ] })
              ]
            }
          );
        }
      );
      const UploadStats = memo(({ selectedRows, filteredSongList }) => {
        const selectedSize = selectedRows.reduce((acc, cur) => acc + cur.size, 0);
        const totalSize = filteredSongList.reduce((acc, cur) => acc + cur.size, 0);
        return jsxRuntimeExports.jsxs("div", { className: styles$1["upload-stats"], children: [
          "已选择",
          " ",
jsxRuntimeExports.jsxs(Tag, { color: "blue", style: { margin: 0 }, children: [
            selectedRows.length,
            " 首"
          ] }),
          " ",
jsxRuntimeExports.jsx("span", { className: styles$1["size-text"], children: +selectedSize && formatFileSize(selectedSize) }),
jsxRuntimeExports.jsx("span", { className: styles$1.divider, children: "/" }),
          "共",
          " ",
jsxRuntimeExports.jsxs(Tag, { color: "green", style: { margin: 0 }, children: [
            filteredSongList.length,
            " 首"
          ] }),
          " ",
jsxRuntimeExports.jsx("span", { className: styles$1["size-text"], children: formatFileSize(totalSize) })
        ] });
      });
      UploadStats.displayName = "UploadStats";
      function UploadList({ singerList }) {
        const [songList2, setSongList] = useState([]);
        const [loading, setLoading] = useState(false);
        const getSongList = async (ids) => {
          try {
            setLoading(true);
            if (!ids?.length) {
              msgError("请先选择歌手");
              return;
            }
            const proArr = ids.map(async (id) => {
              const res = await getCDNConfig(id);
              return res.data;
            });
            let allConfig = await Promise.all(proArr);
            allConfig = allConfig.flat();
            const allConfigMap = Object.fromEntries(
              allConfig.map((item) => [item.id, item])
            );
            const allInfo = await getSongInfoList(allConfig.map((item) => item.id));
            const songList22 = [];
            allInfo.map(({ privileges, songs: songs2 }) => {
              privileges.forEach((p) => {
                const otherInfo = allConfigMap[p.id] || {};
                const defaultItem = mergeObjects(
                  { ...otherInfo, artists: void 0 },
                  {
                    id: p.id,
                    name: "",
                    album: "",
                    albumid: 0,
                    artists: "",
                    bitrate: 9e4,
                    tns: "",
dt: formatDuration$1(0),
                    filename: "",
                    picUrl: "http://p4.music.126.net/UeTuwE7pvjBpypWLudqukA==/3132508627578625.jpg",
                    isNoCopyright: p.st < 0,
                    isVIP: false,
                    isPay: false,
                    uploaded: p.cs,
                    needMatch: otherInfo.name == void 0
                  }
                );
                const songsMap = Object.fromEntries(songs2.map((s) => [s.id, s]));
                const song = songsMap[p.id];
                if (song) {
                  const artists = getArtistTextInSongDetail(song);
                  mergeObjects(defaultItem, song, {
                    album: getAlbumTextInSongDetail(song),
                    artists,
                    dt: formatDuration$1(song.dt),
                    filename: song.name ? `${song.name}` : void 0,
                    picUrl: song.al?.picUrl || "http://p4.music.126.net/UeTuwE7pvjBpypWLudqukA==/3132508627578625.jpg",
                    isVIP: song.fee === 1,
                    isPay: song.fee === 4
                  });
                }
                if (otherInfo.name) {
                  defaultItem.name = otherInfo.name;
                  defaultItem.album ||= otherInfo.al?.name || otherInfo.album || "";
                  defaultItem.artists ||= otherInfo.ar || otherInfo.artists?.join?.();
                  defaultItem.filename ||= `${defaultItem.name}.${otherInfo.ext}` || "未知.flac";
                }
                songList22.push(defaultItem);
              });
            });
            setSongList(songList22);
            setFilteredSongList(songList22);
          } catch (error) {
            console.log("error", error);
            message.error("获取歌曲信息失败", error.message);
          } finally {
            setLoading(false);
          }
        };
        useEffect(() => {
          console.log("singerList", singerList);
          getSongList(singerList);
        }, [singerList]);
        const filterConfig = {
          fields: {
            name: {
              getValue: (song) => song.name
            },
            artists: {
              getValue: (song) => song.artists
            },
            album: {
              getValue: (song) => song.album
            }
          }
        };
        const [searchParams, setSearchParams] = useState({});
        const {
          filteredList: filteredSongList,
          setFilteredList: setFilteredSongList,
          handleFilter: handleSearch
        } = useFilter(songList2, filterConfig);
        useEffect(() => {
          handleSearch(searchParams);
        }, [songList2]);
        const [selectedRows, setSelectedRows] = useState([]);
        const rowSelection = {
          type: "checkbox",
          fixed: true,
          getCheckboxProps: (record) => ({
            disabled: record.uploaded
          }),
          onChange: (selectedRowKeys, selectedRows2) => {
            setSelectedRows(selectedRows2);
          }
        };
        const handleUpload = async (record) => {
          try {
            setFilteredSongList((songList22) => {
              return songList22.map((song) => {
                if (song.id === record.id) song.uploading = true;
                return song;
              });
            });
            const res = await uploadSong(record);
            msgSuccess("上传成功");
            getSongList(singerList);
          } catch (error) {
            console.log("error", error);
          } finally {
            setFilteredSongList((songList22) => {
              return songList22.map((song) => {
                if (song.id === record.id) song.uploading = false;
                return song;
              });
            });
          }
        };
        const columns = [
{
            title: "上传状态",
            dataIndex: "uploaded",
            key: "uploaded",
            width: 140,
            align: "center",
            filters: [
              { text: "已上传", value: true },
              { text: "未上传", value: false }
            ],
            onFilter: (value2, record) => record.uploaded === value2,
            defaultFilterValue: [false],
            render: (_, record) => {
              if (record.uploaded) return jsxRuntimeExports.jsx(Tag, { color: "success", children: "已上传" });
              return jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  size: "small",
                  onClick: () => handleUpload(record),
                  loading: record.uploading,
                  children: "上传"
                }
              );
            }
          },
          {
            title: "歌曲",
            dataIndex: "name",
            key: "name",
            width: 200,
            sorter: (a, b) => a.name?.localeCompare(b.name),
            sortDirections: ["ascend", "descend"],
            render: (text2, record) => jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
jsxRuntimeExports.jsx(
                "img",
                {
                  src: record.picUrl,
                  alt: text2,
                  style: { width: "40px", height: "40px", borderRadius: "4px" }
                }
              ),
jsxRuntimeExports.jsxs("div", { children: [
jsxRuntimeExports.jsx("div", { children: text2 }),
                record.tns && jsxRuntimeExports.jsx("div", { style: { color: "#666", fontSize: "12px" }, children: record.tns })
              ] })
            ] })
          },
          {
            title: "艺术家",
            dataIndex: "artists",
            key: "artists",
            width: 180,
            sorter: (a, b) => a.artists?.localeCompare(b.artists),
            sortDirections: ["ascend", "descend"],
            ellipsis: true
          },
          {
            title: "专辑",
            dataIndex: "album",
            key: "album",
            width: 160,
            sorter: (a, b) => a.album?.localeCompare(b.album),
            sortDirections: ["ascend", "descend"],
            defaultSortOrder: "descend",
            ellipsis: true
          },
          {
            title: "时长",
            dataIndex: "dt",
            key: "dt",
            width: 80,
            sorter: (a, b) => a.dt?.localeCompare(b.dt),
            sortDirections: ["ascend", "descend"]
          },
          {
            title: "音质",
            key: "quality",
            width: 100,
            render: (_, record) => {
              const quality = [];
              if (record.sq) quality.push("无损");
              if (record.h?.br >= 32e4) quality.push("320K");
              return quality.join(" / ") || "标准";
            }
          },
          {
            title: "备注",
            key: "status",
            width: 120,
            render: (_, record) => {
              if (record.isNoCopyright) return jsxRuntimeExports.jsx(Tag, { color: "error", children: "无版权" });
              if (record.isVIP) return jsxRuntimeExports.jsx(Tag, { color: "warning", children: "VIP" });
              if (record.isPay) return jsxRuntimeExports.jsx(Tag, { color: "success", children: "付费" });
              if (record.uploaded) return jsxRuntimeExports.jsx(Tag, { color: "processing", children: "已上传" });
            }
          },
{
            title: "歌曲大小",
            dataIndex: "size",
            key: "size",
            width: 120,
            render: (size2) => formatFileSize(size2)
          },
{
            title: "歌曲后缀",
            dataIndex: "ext",
            key: "ext",
            width: 100,
            render: (ext) => jsxRuntimeExports.jsx(Tag, { color: "blue", children: ext })
          }
        ];
        const handleTableChange = (pagination, filters, sorter) => {
          setFilteredSongList((songList22) => {
            return songList22.sort((a, b) => {
              const order = sorter.order === "ascend" ? 1 : -1;
              return order * a[sorter.columnKey]?.localeCompare(b[sorter.columnKey]);
            });
          });
        };
        const uploadProgressRef = useRef(null);
        const [uploadedSongList, setUploadedSongList] = useState([]);
        const [uploadFailedSongList, setUploadFailedSongList] = useState([]);
        const [toUploadingSongList, setToUploadingSongList] = useState([]);
        const [uploading, setUploading] = useState(false);
        const [concurrency, setConcurrency] = useState(6);
        const resetData = () => {
          setUploadedSongList([]);
          setToUploadingSongList([]);
          setUploadFailedSongList([]);
        };
        const handleBatchUpload = async (songs2, needConfirm = true) => {
          try {
            if (uploading) return;
            resetData();
            setUploading(true);
            console.log("将要批量上传的选中的歌曲", songs2);
            const uploadSongList = songs2.filter((song) => !song.uploaded);
            setToUploadingSongList(uploadSongList);
            if (!uploadSongList.length) return msgError("没有可上传的歌曲");
            if (needConfirm) {
              await UploadConfirm({
                total: songs2.length,
                uploaded: 0,
                toUpload: uploadSongList
              });
            }
            uploadProgressRef.current?.open();
            const tasks = uploadSongList.map((song) => async () => {
              try {
                const res = await uploadSong(song);
                song.uploaded = true;
                setUploadedSongList((list) => [...list, song]);
                return res;
              } catch (error) {
                song.uploaded = true;
                setUploadFailedSongList((list) => [...list, song]);
                return error;
              }
            });
            const results = await promiseLimit(tasks, concurrency || 6);
            getSongList(singerList);
            const successCount = results.filter((r) => !(r instanceof Error)).length;
            const failedCount = results.length - successCount;
            msgSuccess(`上传完成: 成功${successCount}首，失败${failedCount}首`);
          } catch (error) {
            console.log("error", error);
          } finally {
            setUploading(false);
          }
        };
        const handleUploadAll = async () => {
          handleBatchUpload(filteredSongList);
        };
        const handleUploadSelected = async () => {
          handleBatchUpload(selectedRows);
        };
        const [downloading, setDownloading] = useState(false);
        const handleDownloadAll = async () => {
          try {
            setDownloading(true);
            const ids = filteredSongList.map((item) => item.id);
            console.log("ids", ids);
            const res = await getSongUrl(ids);
            console.log("res", res);
            if (res.code === 200) {
              const songs2 = res.data.map((item, index) => ({
                url: item.url,
                name: filteredSongList[index]?.["name"]
              })).filter((item) => item.url);
              console.log("songs", songs2);
              let count2 = 0;
              const proArr = songs2.map(async ({ url, name: name2 }) => {
                const res2 = await downloadFile(url, name2);
                count2++;
                msgSuccess({
                  content: `下载完成: ${count2}/${songs2.length}`,
                  key: "batchDownload"
                });
                return res2;
              });
              await promiseLimit(proArr, concurrency || 6);
            }
          } catch (error) {
            console.log("error", error);
          } finally {
            setDownloading(false);
          }
        };
        const handleUploadByAlbum = async () => {
          try {
            if (uploading) return;
            resetData();
            setUploading(true);
            console.log("将要批量上传的选中的歌曲", selectedRows);
            const albumMap = {};
            filteredSongList.forEach((song) => {
              if (!albumMap[song.album]) albumMap[song.album] = [];
              albumMap[song.album].push(song);
            });
            console.log("albumMap", albumMap);
            const albumList = Object.values(albumMap);
            const uploadAlbumList = albumList.map(
              (album2) => album2.filter((song) => !song.uploaded)
            );
            await UploadConfirm({
              total: filteredSongList?.length,
              uploaded: 0,
              toUpload: uploadAlbumList?.flat()
            });
            let index = 1;
            for (const album2 of albumList) {
              msgSuccess(
                `当前正在上传第${index}/${albumList.length}专辑，开始上传专辑: ${album2[0].album}`
              );
              console.log(
                `当前正在上传第${index}/${albumList.length}专辑，开始上传专辑: ${album2[0].album}`,
                album2
              );
              await handleBatchUpload(album2, false);
              index++;
            }
            console.log("上传完成");
          } catch (error) {
            console.log("error", error);
          } finally {
            setUploading(false);
          }
        };
        return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          singerList?.length ? jsxRuntimeExports.jsxs("div", { className: styles$1["upload-list"], children: [
jsxRuntimeExports.jsx(
              SearchForm,
              {
                onSearch: (values) => {
                  console.log("values", values);
                  setSearchParams(values);
                  handleSearch(values);
                },
                data: songList2,
                options: [
                  { label: "歌曲", value: "name" },
                  { label: "歌手", value: "artists" },
                  { label: "专辑", value: "album" }
                ]
              }
            ),
jsxRuntimeExports.jsx(
              Table,
              {
                rowSelection,
                dataSource: filteredSongList,
                columns,
                scroll: { y: 400, x: 1e3 },
                size: "small",
                loading,
                rowKey: ({ artists, id, name: name2 }) => name2 + artists + id,
                onChange: handleTableChange,
                pagination: {
                  showQuickJumper: true,
                  showSizeChanger: true
                }
              }
            ),
jsxRuntimeExports.jsxs("div", { className: styles$1["upload-footer"], children: [
jsxRuntimeExports.jsx(
                UploadStats,
                {
                  selectedRows,
                  filteredSongList
                }
              ),
jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
jsxRuntimeExports.jsx("span", { children: "并发量：" }),
jsxRuntimeExports.jsx(
                  Input,
                  {
                    type: "number",
                    min: 1,
                    max: 6,
                    value: concurrency,
                    style: { width: 80 },
                    onChange: (e) => setConcurrency(Number(e.target.value)),
                    placeholder: "1-6"
                  }
                )
              ] }),
jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  onClick: () => handleUploadSelected(),
                  disabled: !selectedRows.length,
                  loading: uploading,
                  children: "批量上传"
                }
              ),
jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  onClick: () => handleUploadAll(),
                  loading: uploading,
                  children: "全部上传"
                }
              ),
jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  onClick: () => handleDownloadAll(),
                  loading: downloading,
                  children: "直接下载"
                }
              ),
jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  onClick: handleUploadByAlbum,
                  loading: uploading,
                  children: "按专辑上传"
                }
              )
            ] })
          ] }) : jsxRuntimeExports.jsx(
            Empty,
            {
              description: "请先选择歌手",
              style: {
                height: 400,
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center"
              }
            }
          ),
jsxRuntimeExports.jsx(
            UploadProgress,
            {
              ref: uploadProgressRef,
              total: toUploadingSongList.length,
              uploadedList: uploadedSongList,
              uploadFailedSongList
            }
          )
        ] });
      }
      const UploadConfirm = ({ total, uploaded, toUpload }) => {
        return confirm(
jsxRuntimeExports.jsxs("div", { className: styles$1["upload-confirm"], children: [
jsxRuntimeExports.jsxs("div", { className: styles$1["confirm-item"], children: [
jsxRuntimeExports.jsx("span", { className: styles$1.label, children: "总计歌曲：" }),
jsxRuntimeExports.jsxs("span", { className: styles$1.value, children: [
                total,
                " 首"
              ] })
            ] }),
jsxRuntimeExports.jsxs("div", { className: styles$1["confirm-item"], children: [
jsxRuntimeExports.jsx("span", { className: styles$1.label, children: "已上传：" }),
jsxRuntimeExports.jsxs("span", { className: styles$1.value, children: [
                uploaded,
                " 首"
              ] })
            ] }),
jsxRuntimeExports.jsxs("div", { className: styles$1["confirm-item"], children: [
jsxRuntimeExports.jsx("span", { className: styles$1.label, children: "待上传：" }),
jsxRuntimeExports.jsxs("span", { className: styles$1.value, children: [
                toUpload.length,
                " 首",
jsxRuntimeExports.jsxs("span", { className: styles$1.size, children: [
                  "（",
                  formatFileSize(toUpload.reduce((acc, cur) => acc + cur.size, 0)),
                  "）"
                ] })
              ] })
            ] })
          ] }),
          "上传歌曲"
        );
      };
      const { TabPane } = Tabs;
      function QuickUpload(props, ref) {
        const { visible, close } = useVisible(
          {
            onOpen() {
              getSingerList();
            },
            onReset() {
              setSingerList([]);
              setCurrentTab("1");
            }
          },
          ref
        );
        const [currentTab, setCurrentTab] = useState("1");
        const handleTabChange = (key) => {
          if (key !== "1" && !chooseList.length) {
            return msgError("请选择歌手");
          }
          setCurrentTab(key);
        };
        const [singerList, setSingerList] = useState([]);
        const [loading, setLoading] = useState(false);
        const getSingerList = async () => {
          try {
            setLoading(true);
            const res = await getArtists();
            const res2 = await getArtists2();
            console.log("res2", res2);
            const list = [
              ...new Map([...res2, ...res].map((item) => [item.id, item])).values()
            ];
            console.log("list", list);
            setSingerList(list);
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        const [chooseList, setChooseList] = useState([]);
        const handleChoose = (value2) => {
          console.log(value2);
          setChooseList(value2);
          setCurrentTab("2");
        };
        return jsxRuntimeExports.jsx(
          Modal,
          {
            title: "云盘快速上传",
            width: 900,
            centered: true,
            open: visible,
            footer: null,
            onCancel: close,
            children: jsxRuntimeExports.jsxs(
              Tabs,
              {
                defaultActiveKey: "1",
                activeKey: currentTab,
                className: styles$1["quick-upload-tabs"],
                onChange: handleTabChange,
                children: [
jsxRuntimeExports.jsx(TabPane, { tab: "歌曲选择", children: jsxRuntimeExports.jsx(
                    SingerChoose,
                    {
                      singerList,
                      loading,
                      onChoose: handleChoose
                    }
                  ) }, "1"),
jsxRuntimeExports.jsx(TabPane, { tab: "上传列表", children: jsxRuntimeExports.jsx(UploadList, { singerList: chooseList }, currentTab) }, "2")
                ]
              }
            )
          }
        );
      }
      const QuickUpload$1 = forwardRef(QuickUpload);
      const TestModal = forwardRef((props, ref) => {
        const { visible, close } = useVisible({}, ref);
        const handleGetUserAccount = async () => {
          console.log("获取用户信息");
          try {
            const res = await getUserAccount();
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [pageData, setPageData] = useState({
          limit: 500,
          offset: 0
        });
        const handleGetCloudData = async () => {
          console.log("获取云盘数据");
          try {
            const res = await getCloudData(pageData.limit, pageData.offset);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [songListName, setSongListName] = useState("");
        const handleCreateSongList = async () => {
          console.log("新建歌单");
          try {
            const res = await createPlaylist(songListName);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [addInfo, setAddInfo] = useState({
          songId: "185620",
          playlistId: "12999288729"
        });
        const handleAddSong = async () => {
          console.log("添加歌曲");
          try {
            const res = await addSongToPlaylist(addInfo.playlistId, [addInfo.songId]);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [userId, setUserId] = useState("12999288729");
        const handleGetPlaylistList = async () => {
          console.log("获取歌单列表");
          try {
            const res = await getPlaylistList(userId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [songId, setSongId] = useState("2608471890");
        const handleGetSongUrl = async () => {
          console.log("获取歌曲URL");
          try {
            const res = await getSongUrl([songId]);
            console.log("res", res);
            if (res.code === 200) {
              const url = res.data[0].url;
              await navigator.clipboard.writeText(url);
              msgSuccess("获取成功,已复制到剪切板");
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSongInfo = async () => {
          console.log("获取歌曲信息");
          try {
            const res = await getSongInfoList([songId]);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetSongLyric = async () => {
          console.log("获取歌曲歌词");
          try {
            const res = await getSongLyric(songId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleDeleteCloudSong = async () => {
          console.log("删除云盘歌曲");
          try {
            const res = await deleteCloudSong([songId]);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [albumId, setAlbumId] = useState("242274622");
        const handleGetAlbumSongList = async () => {
          console.log("获取专辑歌曲列表");
          try {
            const res = await getAlbumSongList(albumId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetAlbumDetail = async () => {
          console.log("获取专辑详情");
          try {
            const res = await getAlbumDetail(albumId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [artistId, setArtistId] = useState("3684");
        const handleGetArtistTopSongList = async () => {
          console.log("获取歌手歌曲列表");
          try {
            const res = await getArtistTopSongList(artistId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetArtistAlbum = async () => {
          console.log("获取歌手专辑");
          try {
            const res = await getArtistAlbumList(artistId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetArtistAlbumPic = async () => {
          console.log("下载专辑封面");
          try {
            const res = await getArtistAlbumList(artistId);
            console.log("res", res);
            const downloadTask = res.map(
              (item) => () => downloadFile(item.cover.split("?")[0], item.name + ".jpg")
            );
            await promiseLimit(downloadTask, 1);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetArtistAllSongList = async () => {
          console.log("获取歌手全部歌曲");
          try {
            const res = await getArtistAllSongList(artistId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleQrLogin = async () => {
          console.log("二维码登录");
          try {
            const keyRes = await getQrKey();
            if (keyRes.code !== 200) return msgError("获取二维码key失败");
            const key = keyRes.unikey;
            console.log("key", key);
            const qrcode2 = await getQrCode(key);
            const qrImg = document.createElement("img");
            qrImg.src = qrcode2;
            qrImg.style.width = "200px";
            qrImg.style.height = "200px";
            document.getElementById("qrcode-container").innerHTML = "";
            document.getElementById("qrcode-container").appendChild(qrImg);
            const timeOutTime = Date.now() + 2 * 60 * 1e3;
            while (Date.now() < timeOutTime) {
              const qrStatusRes = await getQrStatus(key);
              console.log("qrStatus", qrStatusRes);
              const { code } = qrStatusRes.response;
              if (code === 801) {
                console.log("等待扫码");
              } else if (code === 802) {
                console.log("授权中");
              } else if (code === 803) {
                console.log("授权成功");
                console.log("qrStatusRes", qrStatusRes);
                break;
              } else if (code === 800) {
                console.log("不存在或失效");
                break;
              }
              await sleep(1e3);
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        const [fileList, setFileList] = useState([]);
        const handleUploadLocalSong = async () => {
          try {
            console.log("fileList", fileList);
            if (!fileList.length) return msgError("请选择文件");
            for (let i = 0; i < fileList.length; i++) {
              const file = fileList[i];
              const res = await uploadLocalSong(file);
              console.log("res", res);
              console.log(JSON.stringify(res, null, 2));
              if (res.artist) {
                setSearchValue(res.artist);
              }
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleLocalMatch = async () => {
          try {
            const res = await matchLocalSong(fileList);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [searchValue, setSearchValue] = useState("");
        const handleSearchArtist = async () => {
          try {
            const res = await searchArtist(searchValue);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [playlistId, setPlaylistId] = useState("13508631377");
        const handleGetPlaylist = async () => {
          try {
            const res = await getPlaylistAllData(playlistId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        return jsxRuntimeExports.jsxs(
          Modal,
          {
            title: "测试Modal",
            open: visible,
            onCancel: close,
            width: 800,
            footer: null,
            centered: true,
            children: [
jsxRuntimeExports.jsxs(Form, { children: [
jsxRuntimeExports.jsx(Form.Item, { label: "获取用户信息", children: jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetUserAccount, children: "获取用户信息" }) }),
jsxRuntimeExports.jsx(Form.Item, { label: "获取云盘数据", children: jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(Input, { placeholder: "limit", style: { width: 100 } }),
jsxRuntimeExports.jsx(Input, { placeholder: "offset", style: { width: 100 } }),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetCloudData, children: "获取云盘数据" })
                ] }) }),
jsxRuntimeExports.jsx(Form.Item, { label: "新建歌单", children: jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入歌单名称",
                      value: songListName,
                      onChange: (e) => setSongListName(e.target.value)
                    }
                  ),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleCreateSongList, children: "新建歌单" })
                ] }) }),
jsxRuntimeExports.jsx(Form.Item, { label: "添加歌曲", children: jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入歌单id",
                      value: addInfo.playlistId,
                      onChange: (e) => setAddInfo({ ...addInfo, playlistId: e.target.value })
                    }
                  ),
jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入歌曲id",
                      value: addInfo.songId,
                      onChange: (e) => setAddInfo({ ...addInfo, songId: e.target.value })
                    }
                  ),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleAddSong, children: "添加歌曲" })
                ] }) }),
jsxRuntimeExports.jsx(Form.Item, { label: "获取歌单列表", children: jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入用户id",
                      value: userId,
                      onChange: (e) => setUserId(e.target.value)
                    }
                  ),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetPlaylistList, children: "获取用户歌单列表" })
                ] }) }),
jsxRuntimeExports.jsx(Form.Item, { label: "测试获取歌单详情", children: jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入歌单id",
                      value: playlistId,
                      onChange: (e) => setPlaylistId(e.target.value)
                    }
                  ),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetPlaylist, children: "获取歌单详情" })
                ] }) }),
jsxRuntimeExports.jsx(Form.Item, { label: "获取歌曲信息", children: jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入歌曲id",
                      value: songId,
                      onChange: (e) => setSongId(e.target.value)
                    }
                  ),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetSongUrl, children: "获取歌曲URL" }),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetSongInfo, children: "获取歌曲信息" }),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetSongLyric, children: "获取歌曲歌词" }),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleDeleteCloudSong, children: "删除云盘歌曲" })
                ] }) }),
jsxRuntimeExports.jsx(Form.Item, { label: "获取专辑歌曲列表", children: jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入专辑id",
                      value: albumId,
                      onChange: (e) => setAlbumId(e.target.value)
                    }
                  ),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetAlbumSongList, children: "获取专辑歌曲列表" }),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetAlbumDetail, children: "获取专辑详情" })
                ] }) }),
jsxRuntimeExports.jsx(Form.Item, { label: "获取歌手歌曲列表", children: jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入歌手id",
                      value: artistId,
                      onChange: (e) => setArtistId(e.target.value)
                    }
                  ),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetArtistTopSongList, children: "获取歌手热门歌曲列表" }),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetArtistAlbum, children: "获取歌手专辑" }),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetArtistAlbumPic, children: "下载专辑封面" }),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleGetArtistAllSongList, children: "获取歌手全部歌曲" })
                ] }) })
              ] }),
jsxRuntimeExports.jsxs(Form.Item, { label: "二维码登录", children: [
jsxRuntimeExports.jsx("div", { id: "qrcode-container" }),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleQrLogin, children: "二维码登录" })
              ] }),
jsxRuntimeExports.jsx(Form.Item, { label: "上传本地歌曲到云盘", children: jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(
                  Upload,
                  {
                    fileList,
                    accept: ".flac,.mp3,.wav,.aac,.m4a,.ogg,.wma",
                    beforeUpload: (file) => {
                      setFileList([...fileList, file]);
                      return false;
                    },
                    onRemove: (file) => {
                      setFileList(fileList.filter((f) => f !== file));
                    },
                    children: jsxRuntimeExports.jsx(Button, { icon: jsxRuntimeExports.jsx(UploadOutlined, {}), children: "Select File" })
                  }
                ),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleUploadLocalSong, children: "上传本地歌曲到云盘" }),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleLocalMatch, children: "测试本地歌曲匹配" })
              ] }) }),
jsxRuntimeExports.jsx(Form.Item, { label: "测试搜索歌手信息", children: jsxRuntimeExports.jsxs(Space, { children: [
jsxRuntimeExports.jsx(
                  Input,
                  {
                    placeholder: "请输入歌手名称",
                    value: searchValue,
                    onChange: (e) => setSearchValue(e.target.value)
                  }
                ),
jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleSearchArtist, children: "搜索歌手信息" })
              ] }) })
            ]
          }
        );
      });
      const styles = {
        "button-group": "_button-group_dcsms_1"
      };
      const ButtonGroup = () => {
        console.log("import.meta.env.MODE", "production");
        const quickUploadRef = useRef(null);
        const handleQuickUpload = () => {
          quickUploadRef.current.open();
        };
        const cloudMusicManagerRef = useRef(null);
        const handleCloudMusicManager = () => {
          cloudMusicManagerRef.current.open();
        };
        const localUploadRef = useRef(null);
        const handleLocalUpload = () => {
          localUploadRef.current.open();
        };
        const playListRef = useRef(null);
        const handlePlayList = () => {
          playListRef.current.open();
        };
        const cloudImportRef = useRef(null);
        const handleImport = () => {
          cloudImportRef.current.open();
        };
        const testModalRef = useRef(null);
        const handleTestModal = () => {
          testModalRef.current.open();
        };
        const githubInfoRef = useRef(null);
        const handleGithubInfo = () => {
          githubInfoRef.current.open();
        };
        return jsxRuntimeExports.jsxs("div", { className: styles["button-group"], children: [
jsxRuntimeExports.jsx(Tooltip, { title: "云盘快速上传", placement: "left", children: jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: jsxRuntimeExports.jsx(CloudUploadOutlined, {}),
              onClick: handleQuickUpload,
              className: styles["button"]
            }
          ) }),
jsxRuntimeExports.jsx(Tooltip, { title: "云盘歌曲管理", placement: "left", children: jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: jsxRuntimeExports.jsx(CustomerServiceOutlined, {}),
              onClick: handleCloudMusicManager,
              className: styles["button"]
            }
          ) }),
jsxRuntimeExports.jsx(Tooltip, { title: "云盘本地上传", placement: "left", children: jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: jsxRuntimeExports.jsx(UploadOutlined, {}),
              onClick: handleLocalUpload,
              className: styles["button"]
            }
          ) }),
jsxRuntimeExports.jsx(Tooltip, { title: "云盘JSON导入", placement: "left", children: jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: jsxRuntimeExports.jsx(CodeOutlined, {}),
              onClick: handleImport,
              className: styles["button"]
            }
          ) }),
jsxRuntimeExports.jsx(Tooltip, { title: "查看歌单", placement: "left", children: jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: jsxRuntimeExports.jsx(OrderedListOutlined, {}),
              onClick: handlePlayList,
              className: styles["button"]
            }
          ) }),
jsxRuntimeExports.jsx(Tooltip, { title: "testModal", placement: "left", children: jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: jsxRuntimeExports.jsx(InfoCircleOutlined, {}),
              onClick: handleTestModal,
              className: styles["button"]
            }
          ) }),
jsxRuntimeExports.jsx(Tooltip, { title: "GitHub信息", placement: "left", children: jsxRuntimeExports.jsx(
            Button,
            {
              type: "primary",
              icon: jsxRuntimeExports.jsx(GithubOutlined, {}),
              onClick: handleGithubInfo,
              className: styles["button"]
            }
          ) }),
jsxRuntimeExports.jsx(QuickUpload$1, { ref: quickUploadRef }),
jsxRuntimeExports.jsx(CloudMusicManager, { ref: cloudMusicManagerRef }),
jsxRuntimeExports.jsx(LocalUpload, { ref: localUploadRef }),
jsxRuntimeExports.jsx(CloudImport, { ref: cloudImportRef }),
jsxRuntimeExports.jsx(TestModal, { ref: testModalRef }),
jsxRuntimeExports.jsx(PlayList$1, { ref: playListRef }),
jsxRuntimeExports.jsx(CloudImport, { ref: cloudImportRef }),
jsxRuntimeExports.jsx(GithubInfo, { ref: githubInfoRef })
        ] });
      };
      function App() {
        const getUserInfo = async () => {
          try {
            const res = await getUserAccount();
            console.log("res", res);
            if (res.code === 200) {
              const globalThis2 = getGlobalThis();
              globalThis2.CustomUser = {
                ...res.account,
                ...res.profile
              };
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        useEffect(() => {
          getUserInfo();
        }, []);
        return jsxRuntimeExports.jsx("div", { className: "App", children: jsxRuntimeExports.jsx(ButtonGroup, {}) });
      }
      const indexCss = "::-webkit-scrollbar{width:6px;height:6px}::-webkit-scrollbar-track{background:transparent;border-radius:6px}::-webkit-scrollbar-thumb{background:#8080804d;border-radius:6px;transition:all .2s ease-in-out}::-webkit-scrollbar-thumb:hover{background:#80808080}*{scrollbar-width:thin;scrollbar-color:rgba(128,128,128,.3) transparent}input[type=text]{box-sizing:border-box;height:32px;padding:4px 12px;border:1px solid #e1e1e1;border-radius:4px;background-color:#fff;color:#333;font-size:14px;transition:border-color .2s,box-shadow .2s;outline:none}input[type=text]::placeholder{color:#999;opacity:1;font-size:14px}input[type=text]:hover{border-color:#c20c0c}input[type=text]:focus{border-color:#c20c0c;box-shadow:0 0 0 2px #c20c0c14}input[type=text]:disabled{background:#f5f5f5;color:#bfbfbf;cursor:not-allowed;border-color:#f0f0f0}";
      importCSS(indexCss);
      const PRIMARY_COLOR = "#C20C0C";
      const theme = {
token: {
colorPrimary: PRIMARY_COLOR,
colorPrimaryHover: "#D81E06",
          colorPrimaryActive: "#A00606",
colorText: "#333333",
          colorTextSecondary: "#666666",
          colorTextTertiary: "#999999",
          colorTextDescription: "#666666",
colorBgContainer: "#FFFFFF",
          colorBgLayout: "#F5F5F5",
          colorBgMask: "rgba(0, 0, 0, 0.45)",
colorBorder: "#E1E1E1",
          colorBorderSecondary: "#F0F0F0",
colorLink: PRIMARY_COLOR,
          colorLinkHover: "#D81E06",
          colorLinkActive: "#A00606",
colorSuccess: "#52C41A",
          colorWarning: "#FAAD14",
          colorError: "#FF4D4F",
fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif',
          fontSize: 14,
borderRadius: 4,
          borderRadiusLG: 8,
          borderRadiusSM: 2,
marginXS: 8,
          marginSM: 12,
          margin: 16,
          marginMD: 20,
          marginLG: 24,
          marginXL: 32,
motionDurationFast: "0.1s",
          motionDurationMid: "0.2s",
          motionDurationSlow: "0.3s",
          motionEaseInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
          motionEaseOut: "cubic-bezier(0.0, 0, 0.2, 1)",
          motionEaseIn: "cubic-bezier(0.4, 0, 1, 1)"
        },
components: {
          Button: {
            colorPrimary: "#C20C0C",
            algorithm: true
},
          Input: {
            colorBorder: "#E1E1E1",
            colorText: "#333333",
            colorTextPlaceholder: "#999999",
            paddingInline: 12,
            paddingBlock: 8,
            borderRadius: 4,
            hoverBorderColor: PRIMARY_COLOR,
            activeBorderColor: PRIMARY_COLOR,
            algorithm: true
          },
          Table: {}
        }
      };
      var zh_CN$6 = {};
      var interopRequireDefault = { exports: {} };
      var hasRequiredInteropRequireDefault;
      function requireInteropRequireDefault() {
        if (hasRequiredInteropRequireDefault) return interopRequireDefault.exports;
        hasRequiredInteropRequireDefault = 1;
        (function(module) {
          function _interopRequireDefault(e) {
            return e && e.__esModule ? e : {
              "default": e
            };
          }
          module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(interopRequireDefault);
        return interopRequireDefault.exports;
      }
      var zh_CN$5 = {};
      var hasRequiredZh_CN$6;
      function requireZh_CN$6() {
        if (hasRequiredZh_CN$6) return zh_CN$5;
        hasRequiredZh_CN$6 = 1;
        Object.defineProperty(zh_CN$5, "__esModule", {
          value: true
        });
        zh_CN$5.default = void 0;
        var locale = {
items_per_page: "条/页",
          jump_to: "跳至",
          jump_to_confirm: "确定",
          page: "页",
prev_page: "上一页",
          next_page: "下一页",
          prev_5: "向前 5 页",
          next_5: "向后 5 页",
          prev_3: "向前 3 页",
          next_3: "向后 3 页",
          page_size: "页码"
        };
        zh_CN$5.default = locale;
        return zh_CN$5;
      }
      var zh_CN$4 = {};
      var zh_CN$3 = {};
      var zh_CN$2 = {};
      var objectSpread2 = { exports: {} };
      var defineProperty = { exports: {} };
      var toPropertyKey = { exports: {} };
      var _typeof = { exports: {} };
      var hasRequired_typeof;
      function require_typeof() {
        if (hasRequired_typeof) return _typeof.exports;
        hasRequired_typeof = 1;
        (function(module) {
          function _typeof2(o) {
            "@babel/helpers - typeof";
            return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
              return typeof o2;
            } : function(o2) {
              return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
            }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
          }
          module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(_typeof);
        return _typeof.exports;
      }
      var toPrimitive = { exports: {} };
      var hasRequiredToPrimitive;
      function requireToPrimitive() {
        if (hasRequiredToPrimitive) return toPrimitive.exports;
        hasRequiredToPrimitive = 1;
        (function(module) {
          var _typeof2 = require_typeof()["default"];
          function toPrimitive2(t, r) {
            if ("object" != _typeof2(t) || !t) return t;
            var e = t[Symbol.toPrimitive];
            if (void 0 !== e) {
              var i = e.call(t, r || "default");
              if ("object" != _typeof2(i)) return i;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === r ? String : Number)(t);
          }
          module.exports = toPrimitive2, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(toPrimitive);
        return toPrimitive.exports;
      }
      var hasRequiredToPropertyKey;
      function requireToPropertyKey() {
        if (hasRequiredToPropertyKey) return toPropertyKey.exports;
        hasRequiredToPropertyKey = 1;
        (function(module) {
          var _typeof2 = require_typeof()["default"];
          var toPrimitive2 = requireToPrimitive();
          function toPropertyKey2(t) {
            var i = toPrimitive2(t, "string");
            return "symbol" == _typeof2(i) ? i : i + "";
          }
          module.exports = toPropertyKey2, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(toPropertyKey);
        return toPropertyKey.exports;
      }
      var hasRequiredDefineProperty;
      function requireDefineProperty() {
        if (hasRequiredDefineProperty) return defineProperty.exports;
        hasRequiredDefineProperty = 1;
        (function(module) {
          var toPropertyKey2 = requireToPropertyKey();
          function _defineProperty(e, r, t) {
            return (r = toPropertyKey2(r)) in e ? Object.defineProperty(e, r, {
              value: t,
              enumerable: true,
              configurable: true,
              writable: true
            }) : e[r] = t, e;
          }
          module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(defineProperty);
        return defineProperty.exports;
      }
      var hasRequiredObjectSpread2;
      function requireObjectSpread2() {
        if (hasRequiredObjectSpread2) return objectSpread2.exports;
        hasRequiredObjectSpread2 = 1;
        (function(module) {
          var defineProperty2 = requireDefineProperty();
          function ownKeys(e, r) {
            var t = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
              var o = Object.getOwnPropertySymbols(e);
              r && (o = o.filter(function(r2) {
                return Object.getOwnPropertyDescriptor(e, r2).enumerable;
              })), t.push.apply(t, o);
            }
            return t;
          }
          function _objectSpread2(e) {
            for (var r = 1; r < arguments.length; r++) {
              var t = null != arguments[r] ? arguments[r] : {};
              r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
                defineProperty2(e, r2, t[r2]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
                Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
              });
            }
            return e;
          }
          module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;
        })(objectSpread2);
        return objectSpread2.exports;
      }
      var common = {};
      var hasRequiredCommon;
      function requireCommon() {
        if (hasRequiredCommon) return common;
        hasRequiredCommon = 1;
        Object.defineProperty(common, "__esModule", {
          value: true
        });
        common.commonLocale = void 0;
        common.commonLocale = {
          yearFormat: "YYYY",
          dayFormat: "D",
          cellMeridiemFormat: "A",
          monthBeforeYear: true
        };
        return common;
      }
      var hasRequiredZh_CN$5;
      function requireZh_CN$5() {
        if (hasRequiredZh_CN$5) return zh_CN$2;
        hasRequiredZh_CN$5 = 1;
        var _interopRequireDefault = requireInteropRequireDefault().default;
        Object.defineProperty(zh_CN$2, "__esModule", {
          value: true
        });
        zh_CN$2.default = void 0;
        var _objectSpread2 = _interopRequireDefault(requireObjectSpread2());
        var _common = requireCommon();
        var locale = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _common.commonLocale), {}, {
          locale: "zh_CN",
          today: "今天",
          now: "此刻",
          backToToday: "返回今天",
          ok: "确定",
          timeSelect: "选择时间",
          dateSelect: "选择日期",
          weekSelect: "选择周",
          clear: "清除",
          week: "周",
          month: "月",
          year: "年",
          previousMonth: "上个月 (翻页上键)",
          nextMonth: "下个月 (翻页下键)",
          monthSelect: "选择月份",
          yearSelect: "选择年份",
          decadeSelect: "选择年代",
          previousYear: "上一年 (Control键加左方向键)",
          nextYear: "下一年 (Control键加右方向键)",
          previousDecade: "上一年代",
          nextDecade: "下一年代",
          previousCentury: "上一世纪",
          nextCentury: "下一世纪",
          yearFormat: "YYYY年",
          cellDateFormat: "D",
          monthBeforeYear: false
        });
        zh_CN$2.default = locale;
        return zh_CN$2;
      }
      var zh_CN$1 = {};
      var hasRequiredZh_CN$4;
      function requireZh_CN$4() {
        if (hasRequiredZh_CN$4) return zh_CN$1;
        hasRequiredZh_CN$4 = 1;
        Object.defineProperty(zh_CN$1, "__esModule", {
          value: true
        });
        zh_CN$1.default = void 0;
        const locale = {
          placeholder: "请选择时间",
          rangePlaceholder: ["开始时间", "结束时间"]
        };
        zh_CN$1.default = locale;
        return zh_CN$1;
      }
      var hasRequiredZh_CN$3;
      function requireZh_CN$3() {
        if (hasRequiredZh_CN$3) return zh_CN$3;
        hasRequiredZh_CN$3 = 1;
        var _interopRequireDefault = requireInteropRequireDefault().default;
        Object.defineProperty(zh_CN$3, "__esModule", {
          value: true
        });
        zh_CN$3.default = void 0;
        var _zh_CN = _interopRequireDefault(requireZh_CN$5());
        var _zh_CN2 = _interopRequireDefault( requireZh_CN$4());
        const locale = {
          lang: Object.assign({
            placeholder: "请选择日期",
            yearPlaceholder: "请选择年份",
            quarterPlaceholder: "请选择季度",
            monthPlaceholder: "请选择月份",
            weekPlaceholder: "请选择周",
            rangePlaceholder: ["开始日期", "结束日期"],
            rangeYearPlaceholder: ["开始年份", "结束年份"],
            rangeMonthPlaceholder: ["开始月份", "结束月份"],
            rangeQuarterPlaceholder: ["开始季度", "结束季度"],
            rangeWeekPlaceholder: ["开始周", "结束周"]
          }, _zh_CN.default),
          timePickerLocale: Object.assign({}, _zh_CN2.default)
        };
        locale.lang.ok = "确定";
        zh_CN$3.default = locale;
        return zh_CN$3;
      }
      var hasRequiredZh_CN$2;
      function requireZh_CN$2() {
        if (hasRequiredZh_CN$2) return zh_CN$4;
        hasRequiredZh_CN$2 = 1;
        var _interopRequireDefault = requireInteropRequireDefault().default;
        Object.defineProperty(zh_CN$4, "__esModule", {
          value: true
        });
        zh_CN$4.default = void 0;
        var _zh_CN = _interopRequireDefault( requireZh_CN$3());
        zh_CN$4.default = _zh_CN.default;
        return zh_CN$4;
      }
      var hasRequiredZh_CN$1;
      function requireZh_CN$1() {
        if (hasRequiredZh_CN$1) return zh_CN$6;
        hasRequiredZh_CN$1 = 1;
        var _interopRequireDefault = requireInteropRequireDefault().default;
        Object.defineProperty(zh_CN$6, "__esModule", {
          value: true
        });
        zh_CN$6.default = void 0;
        var _zh_CN = _interopRequireDefault(requireZh_CN$6());
        var _zh_CN2 = _interopRequireDefault( requireZh_CN$2());
        var _zh_CN3 = _interopRequireDefault( requireZh_CN$3());
        var _zh_CN4 = _interopRequireDefault( requireZh_CN$4());
        const typeTemplate = "${label}不是一个有效的${type}";
        const localeValues = {
          locale: "zh-cn",
          Pagination: _zh_CN.default,
          DatePicker: _zh_CN3.default,
          TimePicker: _zh_CN4.default,
          Calendar: _zh_CN2.default,
global: {
            placeholder: "请选择",
            close: "关闭"
          },
          Table: {
            filterTitle: "筛选",
            filterConfirm: "确定",
            filterReset: "重置",
            filterEmptyText: "无筛选项",
            filterCheckAll: "全选",
            filterSearchPlaceholder: "在筛选项中搜索",
            emptyText: "暂无数据",
            selectAll: "全选当页",
            selectInvert: "反选当页",
            selectNone: "清空所有",
            selectionAll: "全选所有",
            sortTitle: "排序",
            expand: "展开行",
            collapse: "关闭行",
            triggerDesc: "点击降序",
            triggerAsc: "点击升序",
            cancelSort: "取消排序"
          },
          Modal: {
            okText: "确定",
            cancelText: "取消",
            justOkText: "知道了"
          },
          Tour: {
            Next: "下一步",
            Previous: "上一步",
            Finish: "结束导览"
          },
          Popconfirm: {
            cancelText: "取消",
            okText: "确定"
          },
          Transfer: {
            titles: ["", ""],
            searchPlaceholder: "请输入搜索内容",
            itemUnit: "项",
            itemsUnit: "项",
            remove: "删除",
            selectCurrent: "全选当页",
            removeCurrent: "删除当页",
            selectAll: "全选所有",
            deselectAll: "取消全选",
            removeAll: "删除全部",
            selectInvert: "反选当页"
          },
          Upload: {
            uploading: "文件上传中",
            removeFile: "删除文件",
            uploadError: "上传错误",
            previewFile: "预览文件",
            downloadFile: "下载文件"
          },
          Empty: {
            description: "暂无数据"
          },
          Icon: {
            icon: "图标"
          },
          Text: {
            edit: "编辑",
            copy: "复制",
            copied: "复制成功",
            expand: "展开",
            collapse: "收起"
          },
          Form: {
            optional: "（可选）",
            defaultValidateMessages: {
              default: "字段验证错误${label}",
              required: "请输入${label}",
              enum: "${label}必须是其中一个[${enum}]",
              whitespace: "${label}不能为空字符",
              date: {
                format: "${label}日期格式无效",
                parse: "${label}不能转换为日期",
                invalid: "${label}是一个无效日期"
              },
              types: {
                string: typeTemplate,
                method: typeTemplate,
                array: typeTemplate,
                object: typeTemplate,
                number: typeTemplate,
                date: typeTemplate,
                boolean: typeTemplate,
                integer: typeTemplate,
                float: typeTemplate,
                regexp: typeTemplate,
                email: typeTemplate,
                url: typeTemplate,
                hex: typeTemplate
              },
              string: {
                len: "${label}须为${len}个字符",
                min: "${label}最少${min}个字符",
                max: "${label}最多${max}个字符",
                range: "${label}须在${min}-${max}字符之间"
              },
              number: {
                len: "${label}必须等于${len}",
                min: "${label}最小值为${min}",
                max: "${label}最大值为${max}",
                range: "${label}须在${min}-${max}之间"
              },
              array: {
                len: "须为${len}个${label}",
                min: "最少${min}个${label}",
                max: "最多${max}个${label}",
                range: "${label}数量须在${min}-${max}之间"
              },
              pattern: {
                mismatch: "${label}与模式不匹配${pattern}"
              }
            }
          },
          Image: {
            preview: "预览"
          },
          QRCode: {
            expired: "二维码过期",
            refresh: "点击刷新",
            scanned: "已扫描"
          },
          ColorPicker: {
            presetEmpty: "暂无",
            transparent: "无色",
            singleColor: "单色",
            gradientColor: "渐变色"
          }
        };
        zh_CN$6.default = localeValues;
        return zh_CN$6;
      }
      var zh_CN;
      var hasRequiredZh_CN;
      function requireZh_CN() {
        if (hasRequiredZh_CN) return zh_CN;
        hasRequiredZh_CN = 1;
        zh_CN = requireZh_CN$1();
        return zh_CN;
      }
      var zh_CNExports = requireZh_CN();
      const zhCN = getDefaultExportFromCjs(zh_CNExports);
      ReactDOM.createRoot(
        (() => {
          const app = document.createElement("div");
          document.body.append(app);
          return app;
        })()
      ).render(
jsxRuntimeExports.jsx(require$$0.StrictMode, { children: jsxRuntimeExports.jsx(ConfigProvider, { locale: zhCN, theme, children: jsxRuntimeExports.jsx(App, {}) }) })
      );

    })
  };
}));

System.register("./MpegParser-BMBmvP9Z-CHeEGubd.js", ['./__monkey.entry-DKLp9CGx.js', './AbstractID3Parser-Besqtu1X-CrHsEW-u.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge', './ID3v2Parser-Bm2mHbjm-CPeRbws5.js'], (function (exports, module) {
  'use strict';
  var EndOfStreamError, initDebug, getBitAllignedNumber, INT16_BE, Uint8ArrayType, StringType, stripNulls, isBitSet$1, makeUnexpectedFileContentError, UINT32_BE, UINT16_BE, UINT8, AbstractID3Parser;
  return {
    setters: [module => {
      EndOfStreamError = module.E;
      initDebug = module.i;
      getBitAllignedNumber = module.g;
      INT16_BE = module.I;
      Uint8ArrayType = module.U;
      StringType = module.S;
      stripNulls = module.s;
      isBitSet$1 = module.a;
      makeUnexpectedFileContentError = module.m;
      UINT32_BE = module.b;
      UINT16_BE = module.c;
      UINT8 = module.d;
    }, module => {
      AbstractID3Parser = module.A;
    }, null, null, null, null, null, null],
    execute: (function () {

      const ReplayGain = {
        len: 2,
        get: (buf, off) => {
          const gain_type = getBitAllignedNumber(buf, off, 0, 3);
          const sign = getBitAllignedNumber(buf, off, 6, 1);
          const gain_adj = getBitAllignedNumber(buf, off, 7, 9) / 10;
          if (gain_type > 0) {
            return {
              type: getBitAllignedNumber(buf, off, 0, 3),
              origin: getBitAllignedNumber(buf, off, 3, 3),
              adjustment: sign ? -gain_adj : gain_adj
            };
          }
          return void 0;
        }
      };
      const ExtendedLameHeader = {
        len: 27,
        get: (buf, off) => {
          const track_peak = UINT32_BE.get(buf, off + 2);
          return {
            revision: getBitAllignedNumber(buf, off, 0, 4),
            vbr_method: getBitAllignedNumber(buf, off, 4, 4),
            lowpass_filter: 100 * UINT8.get(buf, off + 1),
            track_peak: track_peak === 0 ? null : track_peak / 2 ** 23,
            track_gain: ReplayGain.get(buf, 6),
            album_gain: ReplayGain.get(buf, 8),
            music_length: UINT32_BE.get(buf, off + 20),
            music_crc: UINT8.get(buf, off + 24),
            header_crc: UINT16_BE.get(buf, off + 24)
          };
        }
      };
      const InfoTagHeaderTag = new StringType(4, "ascii");
      const LameEncoderVersion = new StringType(6, "ascii");
      const XingHeaderFlags = {
        len: 4,
        get: (buf, off) => {
          return {
            frames: isBitSet$1(buf, off, 31),
            bytes: isBitSet$1(buf, off, 30),
            toc: isBitSet$1(buf, off, 29),
            vbrScale: isBitSet$1(buf, off, 28)
          };
        }
      };
      async function readXingHeader(tokenizer) {
        const flags = await tokenizer.readToken(XingHeaderFlags);
        const xingInfoTag = { numFrames: null, streamSize: null, vbrScale: null };
        if (flags.frames) {
          xingInfoTag.numFrames = await tokenizer.readToken(UINT32_BE);
        }
        if (flags.bytes) {
          xingInfoTag.streamSize = await tokenizer.readToken(UINT32_BE);
        }
        if (flags.toc) {
          xingInfoTag.toc = new Uint8Array(100);
          await tokenizer.readBuffer(xingInfoTag.toc);
        }
        if (flags.vbrScale) {
          xingInfoTag.vbrScale = await tokenizer.readToken(UINT32_BE);
        }
        const lameTag = await tokenizer.peekToken(new StringType(4, "ascii"));
        if (lameTag === "LAME") {
          await tokenizer.ignore(4);
          xingInfoTag.lame = {
            version: await tokenizer.readToken(new StringType(5, "ascii"))
          };
          const match = xingInfoTag.lame.version.match(/\d+.\d+/g);
          if (match !== null) {
            const majorMinorVersion = match[0];
            const version = majorMinorVersion.split(".").map((n) => Number.parseInt(n, 10));
            if (version[0] >= 3 && version[1] >= 90) {
              xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader);
            }
          }
        }
        return xingInfoTag;
      }
      const debug = initDebug("music-metadata:parser:mpeg");
      class MpegContentError extends makeUnexpectedFileContentError("MPEG") {
      } exports("MpegContentError", MpegContentError);
      const maxPeekLen = 1024;
      const MPEG4 = {
AudioObjectTypes: [
          "AAC Main",
          "AAC LC",
"AAC SSR",
"AAC LTP"
],
SamplingFrequencies: [
          96e3,
          88200,
          64e3,
          48e3,
          44100,
          32e3,
          24e3,
          22050,
          16e3,
          12e3,
          11025,
          8e3,
          7350,
          null,
          null,
          -1
        ]
};
      const MPEG4_ChannelConfigurations = [
        void 0,
        ["front-center"],
        ["front-left", "front-right"],
        ["front-center", "front-left", "front-right"],
        ["front-center", "front-left", "front-right", "back-center"],
        ["front-center", "front-left", "front-right", "back-left", "back-right"],
        ["front-center", "front-left", "front-right", "back-left", "back-right", "LFE-channel"],
        ["front-center", "front-left", "front-right", "side-left", "side-right", "back-left", "back-right", "LFE-channel"]
      ];
      class MpegFrameHeader {
        constructor(buf, off) {
          this.bitrateIndex = null;
          this.sampRateFreqIndex = null;
          this.padding = null;
          this.privateBit = null;
          this.channelModeIndex = null;
          this.modeExtension = null;
          this.isOriginalMedia = null;
          this.version = null;
          this.bitrate = null;
          this.samplingRate = null;
          this.frameLength = 0;
          this.versionIndex = getBitAllignedNumber(buf, off + 1, 3, 2);
          this.layer = MpegFrameHeader.LayerDescription[getBitAllignedNumber(buf, off + 1, 5, 2)];
          if (this.versionIndex > 1 && this.layer === 0) {
            this.parseAdtsHeader(buf, off);
          } else {
            this.parseMpegHeader(buf, off);
          }
          this.isProtectedByCRC = !isBitSet$1(buf, off + 1, 7);
        }
        calcDuration(numFrames) {
          return this.samplingRate == null ? null : numFrames * this.calcSamplesPerFrame() / this.samplingRate;
        }
        calcSamplesPerFrame() {
          return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
        }
        calculateSideInfoLength() {
          if (this.layer !== 3)
            return 2;
          if (this.channelModeIndex === 3) {
            if (this.version === 1) {
              return 17;
            }
            if (this.version === 2 || this.version === 2.5) {
              return 9;
            }
          } else {
            if (this.version === 1) {
              return 32;
            }
            if (this.version === 2 || this.version === 2.5) {
              return 17;
            }
          }
          return null;
        }
        calcSlotSize() {
          return [null, 4, 1, 1][this.layer];
        }
        parseMpegHeader(buf, off) {
          this.container = "MPEG";
          this.bitrateIndex = getBitAllignedNumber(buf, off + 2, 0, 4);
          this.sampRateFreqIndex = getBitAllignedNumber(buf, off + 2, 4, 2);
          this.padding = isBitSet$1(buf, off + 2, 6);
          this.privateBit = isBitSet$1(buf, off + 2, 7);
          this.channelModeIndex = getBitAllignedNumber(buf, off + 3, 0, 2);
          this.modeExtension = getBitAllignedNumber(buf, off + 3, 2, 2);
          this.isCopyrighted = isBitSet$1(buf, off + 3, 4);
          this.isOriginalMedia = isBitSet$1(buf, off + 3, 5);
          this.emphasis = getBitAllignedNumber(buf, off + 3, 7, 2);
          this.version = MpegFrameHeader.VersionID[this.versionIndex];
          this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];
          this.codec = `MPEG ${this.version} Layer ${this.layer}`;
          const bitrateInKbps = this.calcBitrate();
          if (!bitrateInKbps) {
            throw new MpegContentError("Cannot determine bit-rate");
          }
          this.bitrate = bitrateInKbps * 1e3;
          this.samplingRate = this.calcSamplingRate();
          if (this.samplingRate == null) {
            throw new MpegContentError("Cannot determine sampling-rate");
          }
        }
        parseAdtsHeader(buf, off) {
          debug("layer=0 => ADTS");
          this.version = this.versionIndex === 2 ? 4 : 2;
          this.container = `ADTS/MPEG-${this.version}`;
          const profileIndex = getBitAllignedNumber(buf, off + 2, 0, 2);
          this.codec = "AAC";
          this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];
          debug(`MPEG-4 audio-codec=${this.codec}`);
          const samplingFrequencyIndex = getBitAllignedNumber(buf, off + 2, 2, 4);
          this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];
          debug(`sampling-rate=${this.samplingRate}`);
          const channelIndex = getBitAllignedNumber(buf, off + 2, 7, 3);
          this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];
          debug(`channel-config=${this.mp4ChannelConfig ? this.mp4ChannelConfig.join("+") : "?"}`);
          this.frameLength = getBitAllignedNumber(buf, off + 3, 6, 2) << 11;
        }
        calcBitrate() {
          if (this.bitrateIndex === 0 ||
this.bitrateIndex === 15) {
            return null;
          }
          if (this.version && this.bitrateIndex) {
            const codecIndex = 10 * Math.floor(this.version) + this.layer;
            return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];
          }
          return null;
        }
        calcSamplingRate() {
          if (this.sampRateFreqIndex === 3 || this.version === null || this.sampRateFreqIndex == null)
            return null;
          return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
        }
      }
      MpegFrameHeader.SyncByte1 = 255;
      MpegFrameHeader.SyncByte2 = 224;
      MpegFrameHeader.VersionID = [2.5, null, 2, 1];
      MpegFrameHeader.LayerDescription = [0, 3, 2, 1];
      MpegFrameHeader.ChannelMode = ["stereo", "joint_stereo", "dual_channel", "mono"];
      MpegFrameHeader.bitrate_index = {
        1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
        2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
        3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
        4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
        5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
        6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
        7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
        8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
        9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
        10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
        11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
        12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
        13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
        14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }
      };
      MpegFrameHeader.sampling_rate_freq_index = {
        1: { 0: 44100, 1: 48e3, 2: 32e3 },
        2: { 0: 22050, 1: 24e3, 2: 16e3 },
        2.5: { 0: 11025, 1: 12e3, 2: 8e3 }
      };
      MpegFrameHeader.samplesInFrameTable = [
[0, 384, 1152, 1152],
[0, 384, 1152, 576]
];
      const FrameHeader = {
        len: 4,
        get: (buf, off) => {
          return new MpegFrameHeader(buf, off);
        }
      };
      function getVbrCodecProfile(vbrScale) {
        return `V${Math.floor((100 - vbrScale) / 10)}`;
      }
      class MpegParser extends AbstractID3Parser {
        constructor() {
          super(...arguments);
          this.frameCount = 0;
          this.syncFrameCount = -1;
          this.countSkipFrameData = 0;
          this.totalDataLength = 0;
          this.bitrates = [];
          this.offset = 0;
          this.frame_size = 0;
          this.crc = null;
          this.calculateEofDuration = false;
          this.samplesPerFrame = null;
          this.buf_frame_header = new Uint8Array(4);
          this.mpegOffset = null;
          this.syncPeek = {
            buf: new Uint8Array(maxPeekLen),
            len: 0
          };
        }
async postId3v2Parse() {
          this.metadata.setFormat("lossless", false);
          try {
            let quit = false;
            while (!quit) {
              await this.sync();
              quit = await this.parseCommonMpegHeader();
            }
          } catch (err) {
            if (err instanceof EndOfStreamError) {
              debug("End-of-stream");
              if (this.calculateEofDuration) {
                if (this.samplesPerFrame !== null) {
                  const numberOfSamples = this.frameCount * this.samplesPerFrame;
                  this.metadata.setFormat("numberOfSamples", numberOfSamples);
                  if (this.metadata.format.sampleRate) {
                    const duration = numberOfSamples / this.metadata.format.sampleRate;
                    debug(`Calculate duration at EOF: ${duration} sec.`, duration);
                    this.metadata.setFormat("duration", duration);
                  }
                }
              }
            } else {
              throw err;
            }
          }
        }
finalize() {
          const format = this.metadata.format;
          const hasID3v1 = !!this.metadata.native.ID3v1;
          if (this.mpegOffset !== null) {
            if (format.duration && this.tokenizer.fileInfo.size) {
              const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
              if (format.codecProfile && format.codecProfile[0] === "V") {
                this.metadata.setFormat("bitrate", mpegSize * 8 / format.duration);
              }
            }
            if (this.tokenizer.fileInfo.size && format.codecProfile === "CBR") {
              const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
              if (this.frame_size !== null && this.samplesPerFrame !== null) {
                const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;
                this.metadata.setFormat("numberOfSamples", numberOfSamples);
                if (format.sampleRate && !format.duration) {
                  const duration = numberOfSamples / format.sampleRate;
                  debug("Calculate CBR duration based on file size: %s", duration);
                  this.metadata.setFormat("duration", duration);
                }
              }
            }
          }
        }
        async sync() {
          let gotFirstSync = false;
          while (true) {
            let bo = 0;
            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });
            if (this.syncPeek.len <= 163) {
              throw new EndOfStreamError();
            }
            while (true) {
              if (gotFirstSync && (this.syncPeek.buf[bo] & 224) === 224) {
                this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;
                this.buf_frame_header[1] = this.syncPeek.buf[bo];
                await this.tokenizer.ignore(bo);
                debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);
                if (this.syncFrameCount === this.frameCount) {
                  debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);
                  this.frameCount = 0;
                  this.frame_size = 0;
                }
                this.syncFrameCount = this.frameCount;
                return;
              }
              gotFirstSync = false;
              bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);
              if (bo === -1) {
                if (this.syncPeek.len < this.syncPeek.buf.length) {
                  throw new EndOfStreamError();
                }
                await this.tokenizer.ignore(this.syncPeek.len);
                break;
              }
              ++bo;
              gotFirstSync = true;
            }
          }
        }
async parseCommonMpegHeader() {
          if (this.frameCount === 0) {
            this.mpegOffset = this.tokenizer.position - 1;
          }
          await this.tokenizer.peekBuffer(this.buf_frame_header.subarray(1), { length: 3 });
          let header;
          try {
            header = FrameHeader.get(this.buf_frame_header, 0);
          } catch (err) {
            await this.tokenizer.ignore(1);
            if (err instanceof Error) {
              this.metadata.addWarning(`Parse error: ${err.message}`);
              return false;
            }
            throw err;
          }
          await this.tokenizer.ignore(3);
          this.metadata.setFormat("container", header.container);
          this.metadata.setFormat("codec", header.codec);
          this.metadata.setFormat("lossless", false);
          this.metadata.setFormat("sampleRate", header.samplingRate);
          this.frameCount++;
          return header.version !== null && header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);
        }
async parseAudioFrameHeader(header) {
          this.metadata.setFormat("numberOfChannels", header.channelMode === "mono" ? 1 : 2);
          this.metadata.setFormat("bitrate", header.bitrate);
          if (this.frameCount < 20 * 1e4) {
            debug("offset=%s MP%s bitrate=%s sample-rate=%s", this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);
          }
          const slot_size = header.calcSlotSize();
          if (slot_size === null) {
            throw new MpegContentError("invalid slot_size");
          }
          const samples_per_frame = header.calcSamplesPerFrame();
          debug(`samples_per_frame=${samples_per_frame}`);
          const bps = samples_per_frame / 8;
          if (header.bitrate !== null && header.samplingRate != null) {
            const fsize = bps * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);
            this.frame_size = Math.floor(fsize);
          }
          this.audioFrameHeader = header;
          if (header.bitrate !== null) {
            this.bitrates.push(header.bitrate);
          }
          if (this.frameCount === 1) {
            this.offset = FrameHeader.len;
            await this.skipSideInformation();
            return false;
          }
          if (this.frameCount === 3) {
            if (this.areAllSame(this.bitrates)) {
              this.samplesPerFrame = samples_per_frame;
              this.metadata.setFormat("codecProfile", "CBR");
              if (this.tokenizer.fileInfo.size)
                return true;
            } else if (this.metadata.format.duration) {
              return true;
            }
            if (!this.options.duration) {
              return true;
            }
          }
          if (this.options.duration && this.frameCount === 4) {
            this.samplesPerFrame = samples_per_frame;
            this.calculateEofDuration = true;
          }
          this.offset = 4;
          if (header.isProtectedByCRC) {
            await this.parseCrc();
            return false;
          }
          await this.skipSideInformation();
          return false;
        }
        async parseAdts(header) {
          const buf = new Uint8Array(3);
          await this.tokenizer.readBuffer(buf);
          header.frameLength += getBitAllignedNumber(buf, 0, 0, 11);
          this.totalDataLength += header.frameLength;
          this.samplesPerFrame = 1024;
          if (header.samplingRate !== null) {
            const framesPerSec = header.samplingRate / this.samplesPerFrame;
            const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;
            const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;
            this.metadata.setFormat("bitrate", bitrate);
            debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);
          }
          await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);
          if (this.frameCount === 3) {
            this.metadata.setFormat("codecProfile", header.codecProfile);
            if (header.mp4ChannelConfig) {
              this.metadata.setFormat("numberOfChannels", header.mp4ChannelConfig.length);
            }
            if (this.options.duration) {
              this.calculateEofDuration = true;
            } else {
              return true;
            }
          }
          return false;
        }
        async parseCrc() {
          this.crc = await this.tokenizer.readNumber(INT16_BE);
          this.offset += 2;
          return this.skipSideInformation();
        }
        async skipSideInformation() {
          if (this.audioFrameHeader) {
            const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();
            if (sideinfo_length !== null) {
              await this.tokenizer.readToken(new Uint8ArrayType(sideinfo_length));
              this.offset += sideinfo_length;
              await this.readXtraInfoHeader();
              return;
            }
          }
        }
        async readXtraInfoHeader() {
          const headerTag = await this.tokenizer.readToken(InfoTagHeaderTag);
          this.offset += InfoTagHeaderTag.len;
          switch (headerTag) {
            case "Info":
              this.metadata.setFormat("codecProfile", "CBR");
              return this.readXingInfoHeader();
            case "Xing": {
              const infoTag = await this.readXingInfoHeader();
              if (infoTag.vbrScale !== null) {
                const codecProfile = getVbrCodecProfile(infoTag.vbrScale);
                this.metadata.setFormat("codecProfile", codecProfile);
              }
              return null;
            }
            case "Xtra":
              break;
            case "LAME": {
              const version = await this.tokenizer.readToken(LameEncoderVersion);
              if (this.frame_size !== null && this.frame_size >= this.offset + LameEncoderVersion.len) {
                this.offset += LameEncoderVersion.len;
                this.metadata.setFormat("tool", `LAME ${version}`);
                await this.skipFrameData(this.frame_size - this.offset);
                return null;
              }
              this.metadata.addWarning("Corrupt LAME header");
              break;
            }
          }
          const frameDataLeft = this.frame_size - this.offset;
          if (frameDataLeft < 0) {
            this.metadata.addWarning(`Frame ${this.frameCount}corrupt: negative frameDataLeft`);
          } else {
            await this.skipFrameData(frameDataLeft);
          }
          return null;
        }
async readXingInfoHeader() {
          const offset = this.tokenizer.position;
          const infoTag = await readXingHeader(this.tokenizer);
          this.offset += this.tokenizer.position - offset;
          if (infoTag.lame) {
            this.metadata.setFormat("tool", `LAME ${stripNulls(infoTag.lame.version)}`);
            if (infoTag.lame.extended) {
              this.metadata.setFormat("trackPeakLevel", infoTag.lame.extended.track_peak);
              if (infoTag.lame.extended.track_gain) {
                this.metadata.setFormat("trackGain", infoTag.lame.extended.track_gain.adjustment);
              }
              if (infoTag.lame.extended.album_gain) {
                this.metadata.setFormat("albumGain", infoTag.lame.extended.album_gain.adjustment);
              }
              this.metadata.setFormat("duration", infoTag.lame.extended.music_length / 1e3);
            }
          }
          if (infoTag.streamSize && this.audioFrameHeader && infoTag.numFrames !== null) {
            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);
            this.metadata.setFormat("duration", duration);
            debug("Get duration from Xing header: %s", this.metadata.format.duration);
            return infoTag;
          }
          const frameDataLeft = this.frame_size - this.offset;
          await this.skipFrameData(frameDataLeft);
          return infoTag;
        }
        async skipFrameData(frameDataLeft) {
          if (frameDataLeft < 0)
            throw new MpegContentError("frame-data-left cannot be negative");
          await this.tokenizer.ignore(frameDataLeft);
          this.countSkipFrameData += frameDataLeft;
        }
        areAllSame(array) {
          const first = array[0];
          return array.every((element) => {
            return element === first;
          });
        }
      } exports("MpegParser", MpegParser);

    })
  };
}));

System.register("./AsfParser-BKSZNp_1-zO0gX5bz.js", ['./__monkey.entry-DKLp9CGx.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var BasicParser, initDebug, TrackType, UINT32_LE, UINT64_LE, uint8ArrayToHex, hexToUint8Array, makeUnexpectedFileContentError, getBit, UINT16_LE, stripNulls, decodeString, StringType, AttachedPictureType;
  return {
    setters: [module => {
      BasicParser = module.B;
      initDebug = module.i;
      TrackType = module.T;
      UINT32_LE = module.e;
      UINT64_LE = module.f;
      uint8ArrayToHex = module.u;
      hexToUint8Array = module.h;
      makeUnexpectedFileContentError = module.m;
      getBit = module.j;
      UINT16_LE = module.k;
      stripNulls = module.s;
      decodeString = module.l;
      StringType = module.S;
      AttachedPictureType = module.A;
    }, null, null, null, null, null],
    execute: (function () {

      class GUID {
        static fromBin(bin, offset = 0) {
          return new GUID(GUID.decode(bin, offset));
        }
static decode(objectId, offset = 0) {
          const view = new DataView(objectId.buffer, offset);
          const guid = `${view.getUint32(0, true).toString(16)}-${view.getUint16(4, true).toString(16)}-${view.getUint16(6, true).toString(16)}-${view.getUint16(8).toString(16)}-${uint8ArrayToHex(objectId.slice(offset + 10, offset + 16))}`;
          return guid.toUpperCase();
        }
static decodeMediaType(mediaType) {
          switch (mediaType.str) {
            case GUID.AudioMedia.str:
              return "audio";
            case GUID.VideoMedia.str:
              return "video";
            case GUID.CommandMedia.str:
              return "command";
            case GUID.Degradable_JPEG_Media.str:
              return "degradable-jpeg";
            case GUID.FileTransferMedia.str:
              return "file-transfer";
            case GUID.BinaryMedia.str:
              return "binary";
          }
        }
static encode(str) {
          const bin = new Uint8Array(16);
          const view = new DataView(bin.buffer);
          view.setUint32(0, Number.parseInt(str.slice(0, 8), 16), true);
          view.setUint16(4, Number.parseInt(str.slice(9, 13), 16), true);
          view.setUint16(6, Number.parseInt(str.slice(14, 18), 16), true);
          bin.set(hexToUint8Array(str.slice(19, 23)), 8);
          bin.set(hexToUint8Array(str.slice(24)), 10);
          return bin;
        }
        constructor(str) {
          this.str = str;
        }
        equals(guid) {
          return this.str === guid.str;
        }
        toBin() {
          return GUID.encode(this.str);
        }
      }
      GUID.HeaderObject = new GUID("75B22630-668E-11CF-A6D9-00AA0062CE6C");
      GUID.DataObject = new GUID("75B22636-668E-11CF-A6D9-00AA0062CE6C");
      GUID.SimpleIndexObject = new GUID("33000890-E5B1-11CF-89F4-00A0C90349CB");
      GUID.IndexObject = new GUID("D6E229D3-35DA-11D1-9034-00A0C90349BE");
      GUID.MediaObjectIndexObject = new GUID("FEB103F8-12AD-4C64-840F-2A1D2F7AD48C");
      GUID.TimecodeIndexObject = new GUID("3CB73FD0-0C4A-4803-953D-EDF7B6228F0C");
      GUID.FilePropertiesObject = new GUID("8CABDCA1-A947-11CF-8EE4-00C00C205365");
      GUID.StreamPropertiesObject = new GUID("B7DC0791-A9B7-11CF-8EE6-00C00C205365");
      GUID.HeaderExtensionObject = new GUID("5FBF03B5-A92E-11CF-8EE3-00C00C205365");
      GUID.CodecListObject = new GUID("86D15240-311D-11D0-A3A4-00A0C90348F6");
      GUID.ScriptCommandObject = new GUID("1EFB1A30-0B62-11D0-A39B-00A0C90348F6");
      GUID.MarkerObject = new GUID("F487CD01-A951-11CF-8EE6-00C00C205365");
      GUID.BitrateMutualExclusionObject = new GUID("D6E229DC-35DA-11D1-9034-00A0C90349BE");
      GUID.ErrorCorrectionObject = new GUID("75B22635-668E-11CF-A6D9-00AA0062CE6C");
      GUID.ContentDescriptionObject = new GUID("75B22633-668E-11CF-A6D9-00AA0062CE6C");
      GUID.ExtendedContentDescriptionObject = new GUID("D2D0A440-E307-11D2-97F0-00A0C95EA850");
      GUID.ContentBrandingObject = new GUID("2211B3FA-BD23-11D2-B4B7-00A0C955FC6E");
      GUID.StreamBitratePropertiesObject = new GUID("7BF875CE-468D-11D1-8D82-006097C9A2B2");
      GUID.ContentEncryptionObject = new GUID("2211B3FB-BD23-11D2-B4B7-00A0C955FC6E");
      GUID.ExtendedContentEncryptionObject = new GUID("298AE614-2622-4C17-B935-DAE07EE9289C");
      GUID.DigitalSignatureObject = new GUID("2211B3FC-BD23-11D2-B4B7-00A0C955FC6E");
      GUID.PaddingObject = new GUID("1806D474-CADF-4509-A4BA-9AABCB96AAE8");
      GUID.ExtendedStreamPropertiesObject = new GUID("14E6A5CB-C672-4332-8399-A96952065B5A");
      GUID.AdvancedMutualExclusionObject = new GUID("A08649CF-4775-4670-8A16-6E35357566CD");
      GUID.GroupMutualExclusionObject = new GUID("D1465A40-5A79-4338-B71B-E36B8FD6C249");
      GUID.StreamPrioritizationObject = new GUID("D4FED15B-88D3-454F-81F0-ED5C45999E24");
      GUID.BandwidthSharingObject = new GUID("A69609E6-517B-11D2-B6AF-00C04FD908E9");
      GUID.LanguageListObject = new GUID("7C4346A9-EFE0-4BFC-B229-393EDE415C85");
      GUID.MetadataObject = new GUID("C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA");
      GUID.MetadataLibraryObject = new GUID("44231C94-9498-49D1-A141-1D134E457054");
      GUID.IndexParametersObject = new GUID("D6E229DF-35DA-11D1-9034-00A0C90349BE");
      GUID.MediaObjectIndexParametersObject = new GUID("6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7");
      GUID.TimecodeIndexParametersObject = new GUID("F55E496D-9797-4B5D-8C8B-604DFE9BFB24");
      GUID.CompatibilityObject = new GUID("26F18B5D-4584-47EC-9F5F-0E651F0452C9");
      GUID.AdvancedContentEncryptionObject = new GUID("43058533-6981-49E6-9B74-AD12CB86D58C");
      GUID.AudioMedia = new GUID("F8699E40-5B4D-11CF-A8FD-00805F5C442B");
      GUID.VideoMedia = new GUID("BC19EFC0-5B4D-11CF-A8FD-00805F5C442B");
      GUID.CommandMedia = new GUID("59DACFC0-59E6-11D0-A3AC-00A0C90348F6");
      GUID.JFIF_Media = new GUID("B61BE100-5B4E-11CF-A8FD-00805F5C442B");
      GUID.Degradable_JPEG_Media = new GUID("35907DE0-E415-11CF-A917-00805F5C442B");
      GUID.FileTransferMedia = new GUID("91BD222C-F21C-497A-8B6D-5AA86BFC0185");
      GUID.BinaryMedia = new GUID("3AFB65E2-47EF-40F2-AC2C-70A90D71D343");
      GUID.ASF_Index_Placeholder_Object = new GUID("D9AADE20-7C17-4F9C-BC28-8555DD98E2A2");
      function getParserForAttr(i) {
        return attributeParsers[i];
      }
      function parseUnicodeAttr(uint8Array) {
        return stripNulls(decodeString(uint8Array, "utf-16le"));
      }
      const attributeParsers = [
        parseUnicodeAttr,
        parseByteArrayAttr,
        parseBoolAttr,
        parseDWordAttr,
        parseQWordAttr,
        parseWordAttr,
        parseByteArrayAttr
      ];
      function parseByteArrayAttr(buf) {
        return new Uint8Array(buf);
      }
      function parseBoolAttr(buf, offset = 0) {
        return parseWordAttr(buf, offset) === 1;
      }
      function parseDWordAttr(buf, offset = 0) {
        return UINT32_LE.get(buf, offset);
      }
      function parseQWordAttr(buf, offset = 0) {
        return UINT64_LE.get(buf, offset);
      }
      function parseWordAttr(buf, offset = 0) {
        return UINT16_LE.get(buf, offset);
      }
      class AsfContentParseError extends makeUnexpectedFileContentError("ASF") {
      }
      const TopLevelHeaderObjectToken = {
        len: 30,
        get: (buf, off) => {
          return {
            objectId: GUID.fromBin(buf, off),
            objectSize: Number(UINT64_LE.get(buf, off + 16)),
            numberOfHeaderObjects: UINT32_LE.get(buf, off + 24)
};
        }
      };
      const HeaderObjectToken = {
        len: 24,
        get: (buf, off) => {
          return {
            objectId: GUID.fromBin(buf, off),
            objectSize: Number(UINT64_LE.get(buf, off + 16))
          };
        }
      };
      class State {
        constructor(header) {
          this.len = Number(header.objectSize) - HeaderObjectToken.len;
        }
        postProcessTag(tags, name, valueType, data) {
          if (name === "WM/Picture") {
            tags.push({ id: name, value: WmPictureToken.fromBuffer(data) });
          } else {
            const parseAttr = getParserForAttr(valueType);
            if (!parseAttr) {
              throw new AsfContentParseError(`unexpected value headerType: ${valueType}`);
            }
            tags.push({ id: name, value: parseAttr(data) });
          }
        }
      }
      class IgnoreObjectState extends State {
        get(buf, off) {
          return null;
        }
      }
      class FilePropertiesObject extends State {
        get(buf, off) {
          return {
            fileId: GUID.fromBin(buf, off),
            fileSize: UINT64_LE.get(buf, off + 16),
            creationDate: UINT64_LE.get(buf, off + 24),
            dataPacketsCount: UINT64_LE.get(buf, off + 32),
            playDuration: UINT64_LE.get(buf, off + 40),
            sendDuration: UINT64_LE.get(buf, off + 48),
            preroll: UINT64_LE.get(buf, off + 56),
            flags: {
              broadcast: getBit(buf, off + 64, 24),
              seekable: getBit(buf, off + 64, 25)
            },
minimumDataPacketSize: UINT32_LE.get(buf, off + 68),
            maximumDataPacketSize: UINT32_LE.get(buf, off + 72),
            maximumBitrate: UINT32_LE.get(buf, off + 76)
          };
        }
      }
      FilePropertiesObject.guid = GUID.FilePropertiesObject;
      class StreamPropertiesObject extends State {
        get(buf, off) {
          return {
            streamType: GUID.decodeMediaType(GUID.fromBin(buf, off)),
            errorCorrectionType: GUID.fromBin(buf, off + 8)
};
        }
      }
      StreamPropertiesObject.guid = GUID.StreamPropertiesObject;
      class HeaderExtensionObject {
        constructor() {
          this.len = 22;
        }
        get(buf, off) {
          const view = new DataView(buf.buffer, off);
          return {
            reserved1: GUID.fromBin(buf, off),
            reserved2: view.getUint16(16, true),
            extensionDataSize: view.getUint16(18, true)
          };
        }
      }
      HeaderExtensionObject.guid = GUID.HeaderExtensionObject;
      const CodecListObjectHeader = {
        len: 20,
        get: (buf, off) => {
          const view = new DataView(buf.buffer, off);
          return {
            entryCount: view.getUint16(16, true)
          };
        }
      };
      async function readString(tokenizer) {
        const length = await tokenizer.readNumber(UINT16_LE);
        return (await tokenizer.readToken(new StringType(length * 2, "utf-16le"))).replace("\0", "");
      }
      async function readCodecEntries(tokenizer) {
        const codecHeader = await tokenizer.readToken(CodecListObjectHeader);
        const entries = [];
        for (let i = 0; i < codecHeader.entryCount; ++i) {
          entries.push(await readCodecEntry(tokenizer));
        }
        return entries;
      }
      async function readInformation(tokenizer) {
        const length = await tokenizer.readNumber(UINT16_LE);
        const buf = new Uint8Array(length);
        await tokenizer.readBuffer(buf);
        return buf;
      }
      async function readCodecEntry(tokenizer) {
        const type = await tokenizer.readNumber(UINT16_LE);
        return {
          type: {
            videoCodec: (type & 1) === 1,
            audioCodec: (type & 2) === 2
          },
          codecName: await readString(tokenizer),
          description: await readString(tokenizer),
          information: await readInformation(tokenizer)
        };
      }
      class ContentDescriptionObjectState extends State {
        get(buf, off) {
          const tags = [];
          const view = new DataView(buf.buffer, off);
          let pos = 10;
          for (let i = 0; i < ContentDescriptionObjectState.contentDescTags.length; ++i) {
            const length = view.getUint16(i * 2, true);
            if (length > 0) {
              const tagName = ContentDescriptionObjectState.contentDescTags[i];
              const end = pos + length;
              tags.push({ id: tagName, value: parseUnicodeAttr(buf.slice(off + pos, off + end)) });
              pos = end;
            }
          }
          return tags;
        }
      }
      ContentDescriptionObjectState.guid = GUID.ContentDescriptionObject;
      ContentDescriptionObjectState.contentDescTags = ["Title", "Author", "Copyright", "Description", "Rating"];
      class ExtendedContentDescriptionObjectState extends State {
        get(buf, off) {
          const tags = [];
          const view = new DataView(buf.buffer, off);
          const attrCount = view.getUint16(0, true);
          let pos = 2;
          for (let i = 0; i < attrCount; i += 1) {
            const nameLen = view.getUint16(pos, true);
            pos += 2;
            const name = parseUnicodeAttr(buf.slice(off + pos, off + pos + nameLen));
            pos += nameLen;
            const valueType = view.getUint16(pos, true);
            pos += 2;
            const valueLen = view.getUint16(pos, true);
            pos += 2;
            const value = buf.slice(off + pos, off + pos + valueLen);
            pos += valueLen;
            this.postProcessTag(tags, name, valueType, value);
          }
          return tags;
        }
      }
      ExtendedContentDescriptionObjectState.guid = GUID.ExtendedContentDescriptionObject;
      class ExtendedStreamPropertiesObjectState extends State {
        get(buf, off) {
          const view = new DataView(buf.buffer, off);
          return {
            startTime: UINT64_LE.get(buf, off),
            endTime: UINT64_LE.get(buf, off + 8),
            dataBitrate: view.getInt32(12, true),
            bufferSize: view.getInt32(16, true),
            initialBufferFullness: view.getInt32(20, true),
            alternateDataBitrate: view.getInt32(24, true),
            alternateBufferSize: view.getInt32(28, true),
            alternateInitialBufferFullness: view.getInt32(32, true),
            maximumObjectSize: view.getInt32(36, true),
            flags: {
              reliableFlag: getBit(buf, off + 40, 0),
              seekableFlag: getBit(buf, off + 40, 1),
              resendLiveCleanpointsFlag: getBit(buf, off + 40, 2)
            },
streamNumber: view.getInt16(42, true),
            streamLanguageId: view.getInt16(44, true),
            averageTimePerFrame: view.getInt32(52, true),
            streamNameCount: view.getInt32(54, true),
            payloadExtensionSystems: view.getInt32(56, true),
            streamNames: [],
streamPropertiesObject: null
          };
        }
      }
      ExtendedStreamPropertiesObjectState.guid = GUID.ExtendedStreamPropertiesObject;
      class MetadataObjectState extends State {
        get(uint8Array, off) {
          const tags = [];
          const view = new DataView(uint8Array.buffer, off);
          const descriptionRecordsCount = view.getUint16(0, true);
          let pos = 2;
          for (let i = 0; i < descriptionRecordsCount; i += 1) {
            pos += 4;
            const nameLen = view.getUint16(pos, true);
            pos += 2;
            const dataType = view.getUint16(pos, true);
            pos += 2;
            const dataLen = view.getUint32(pos, true);
            pos += 4;
            const name = parseUnicodeAttr(uint8Array.slice(off + pos, off + pos + nameLen));
            pos += nameLen;
            const data = uint8Array.slice(off + pos, off + pos + dataLen);
            pos += dataLen;
            this.postProcessTag(tags, name, dataType, data);
          }
          return tags;
        }
      }
      MetadataObjectState.guid = GUID.MetadataObject;
      class MetadataLibraryObjectState extends MetadataObjectState {
      }
      MetadataLibraryObjectState.guid = GUID.MetadataLibraryObject;
      class WmPictureToken {
        static fromBuffer(buffer) {
          const pic = new WmPictureToken(buffer.length);
          return pic.get(buffer, 0);
        }
        constructor(len) {
          this.len = len;
        }
        get(buffer, offset) {
          const view = new DataView(buffer.buffer, offset);
          const typeId = view.getUint8(0);
          const size = view.getInt32(1, true);
          let index = 5;
          while (view.getUint16(index) !== 0) {
            index += 2;
          }
          const format = new StringType(index - 5, "utf-16le").get(buffer, 5);
          while (view.getUint16(index) !== 0) {
            index += 2;
          }
          const description = new StringType(index - 5, "utf-16le").get(buffer, 5);
          return {
            type: AttachedPictureType[typeId],
            format,
            description,
            size,
            data: buffer.slice(index + 4)
          };
        }
      }
      const debug = initDebug("music-metadata:parser:ASF");
      const headerType = "asf";
      class AsfParser extends BasicParser {
        async parse() {
          const header = await this.tokenizer.readToken(TopLevelHeaderObjectToken);
          if (!header.objectId.equals(GUID.HeaderObject)) {
            throw new AsfContentParseError(`expected asf header; but was not found; got: ${header.objectId.str}`);
          }
          try {
            await this.parseObjectHeader(header.numberOfHeaderObjects);
          } catch (err) {
            debug("Error while parsing ASF: %s", err);
          }
        }
        async parseObjectHeader(numberOfObjectHeaders) {
          let tags;
          do {
            const header = await this.tokenizer.readToken(HeaderObjectToken);
            debug("header GUID=%s", header.objectId.str);
            switch (header.objectId.str) {
              case FilePropertiesObject.guid.str: {
                const fpo = await this.tokenizer.readToken(new FilePropertiesObject(header));
                this.metadata.setFormat("duration", Number(fpo.playDuration / BigInt(1e3)) / 1e4 - Number(fpo.preroll) / 1e3);
                this.metadata.setFormat("bitrate", fpo.maximumBitrate);
                break;
              }
              case StreamPropertiesObject.guid.str: {
                const spo = await this.tokenizer.readToken(new StreamPropertiesObject(header));
                this.metadata.setFormat("container", `ASF/${spo.streamType}`);
                break;
              }
              case HeaderExtensionObject.guid.str: {
                const extHeader = await this.tokenizer.readToken(new HeaderExtensionObject());
                await this.parseExtensionObject(extHeader.extensionDataSize);
                break;
              }
              case ContentDescriptionObjectState.guid.str:
                tags = await this.tokenizer.readToken(new ContentDescriptionObjectState(header));
                await this.addTags(tags);
                break;
              case ExtendedContentDescriptionObjectState.guid.str:
                tags = await this.tokenizer.readToken(new ExtendedContentDescriptionObjectState(header));
                await this.addTags(tags);
                break;
              case GUID.CodecListObject.str: {
                const codecs = await readCodecEntries(this.tokenizer);
                codecs.forEach((codec) => {
                  this.metadata.addStreamInfo({
                    type: codec.type.videoCodec ? TrackType.video : TrackType.audio,
                    codecName: codec.codecName
                  });
                });
                const audioCodecs = codecs.filter((codec) => codec.type.audioCodec).map((codec) => codec.codecName).join("/");
                this.metadata.setFormat("codec", audioCodecs);
                break;
              }
              case GUID.StreamBitratePropertiesObject.str:
                await this.tokenizer.ignore(header.objectSize - HeaderObjectToken.len);
                break;
              case GUID.PaddingObject.str:
                debug("Padding: %s bytes", header.objectSize - HeaderObjectToken.len);
                await this.tokenizer.ignore(header.objectSize - HeaderObjectToken.len);
                break;
              default:
                this.metadata.addWarning(`Ignore ASF-Object-GUID: ${header.objectId.str}`);
                debug("Ignore ASF-Object-GUID: %s", header.objectId.str);
                await this.tokenizer.readToken(new IgnoreObjectState(header));
            }
          } while (--numberOfObjectHeaders);
        }
        async addTags(tags) {
          await Promise.all(tags.map(({ id, value }) => this.metadata.addTag(headerType, id, value)));
        }
        async parseExtensionObject(extensionSize) {
          do {
            const header = await this.tokenizer.readToken(HeaderObjectToken);
            const remaining = header.objectSize - HeaderObjectToken.len;
            switch (header.objectId.str) {
              case ExtendedStreamPropertiesObjectState.guid.str:
                await this.tokenizer.readToken(new ExtendedStreamPropertiesObjectState(header));
                break;
              case MetadataObjectState.guid.str: {
                const moTags = await this.tokenizer.readToken(new MetadataObjectState(header));
                await this.addTags(moTags);
                break;
              }
              case MetadataLibraryObjectState.guid.str: {
                const mlTags = await this.tokenizer.readToken(new MetadataLibraryObjectState(header));
                await this.addTags(mlTags);
                break;
              }
              case GUID.PaddingObject.str:
                await this.tokenizer.ignore(remaining);
                break;
              case GUID.CompatibilityObject.str:
                await this.tokenizer.ignore(remaining);
                break;
              case GUID.ASF_Index_Placeholder_Object.str:
                await this.tokenizer.ignore(remaining);
                break;
              default:
                this.metadata.addWarning(`Ignore ASF-Object-GUID: ${header.objectId.str}`);
                await this.tokenizer.readToken(new IgnoreObjectState(header));
                break;
            }
            extensionSize -= header.objectSize;
          } while (extensionSize > 0);
        }
      } exports("AsfParser", AsfParser);

    })
  };
}));

System.register("./DsdiffParser-CHjTZSpt-Bplvt7ms.js", ['./__monkey.entry-DKLp9CGx.js', './ID3v2Parser-Bm2mHbjm-CPeRbws5.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var BasicParser, FourCcToken, initDebug, Uint8ArrayType, fromBuffer, UINT32_LE, UINT16_BE, UINT8, UINT32_BE, StringType, INT64_BE, makeUnexpectedFileContentError, ID3v2Parser;
  return {
    setters: [module => {
      BasicParser = module.B;
      FourCcToken = module.F;
      initDebug = module.i;
      Uint8ArrayType = module.U;
      fromBuffer = module.n;
      UINT32_LE = module.e;
      UINT16_BE = module.c;
      UINT8 = module.d;
      UINT32_BE = module.b;
      StringType = module.S;
      INT64_BE = module.o;
      makeUnexpectedFileContentError = module.m;
    }, module => {
      ID3v2Parser = module.I;
    }, null, null, null, null, null],
    execute: (function () {

      const ChunkHeader64 = {
        len: 12,
        get: (buf, off) => {
          return {
chunkID: FourCcToken.get(buf, off),
chunkSize: INT64_BE.get(buf, off + 4)
          };
        }
      };
      const debug = initDebug("music-metadata:parser:aiff");
      class DsdiffContentParseError extends makeUnexpectedFileContentError("DSDIFF") {
      } exports("DsdiffContentParseError", DsdiffContentParseError);
      class DsdiffParser extends BasicParser {
        async parse() {
          const header = await this.tokenizer.readToken(ChunkHeader64);
          if (header.chunkID !== "FRM8")
            throw new DsdiffContentParseError("Unexpected chunk-ID");
          const type = (await this.tokenizer.readToken(FourCcToken)).trim();
          switch (type) {
            case "DSD":
              this.metadata.setFormat("container", `DSDIFF/${type}`);
              this.metadata.setFormat("lossless", true);
              return this.readFmt8Chunks(header.chunkSize - BigInt(FourCcToken.len));
            default:
              throw new DsdiffContentParseError(`Unsupported DSDIFF type: ${type}`);
          }
        }
        async readFmt8Chunks(remainingSize) {
          while (remainingSize >= ChunkHeader64.len) {
            const chunkHeader = await this.tokenizer.readToken(ChunkHeader64);
            debug(`Chunk id=${chunkHeader.chunkID}`);
            await this.readData(chunkHeader);
            remainingSize -= BigInt(ChunkHeader64.len) + chunkHeader.chunkSize;
          }
        }
        async readData(header) {
          debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
          const p0 = this.tokenizer.position;
          switch (header.chunkID.trim()) {
            case "FVER": {
              const version = await this.tokenizer.readToken(UINT32_LE);
              debug(`DSDIFF version=${version}`);
              break;
            }
            case "PROP": {
              const propType = await this.tokenizer.readToken(FourCcToken);
              if (propType !== "SND ")
                throw new DsdiffContentParseError("Unexpected PROP-chunk ID");
              await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCcToken.len));
              break;
            }
            case "ID3": {
              const id3_data = await this.tokenizer.readToken(new Uint8ArrayType(Number(header.chunkSize)));
              const rst = fromBuffer(id3_data);
              await new ID3v2Parser().parse(this.metadata, rst, this.options);
              break;
            }
            case "DSD":
              if (this.metadata.format.numberOfChannels) {
                this.metadata.setFormat("numberOfSamples", Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));
              }
              if (this.metadata.format.numberOfSamples && this.metadata.format.sampleRate) {
                this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
              }
              break;
            default:
              debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
              break;
          }
          const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);
          if (remaining > 0) {
            debug(`After Parsing chunk, remaining ${remaining} bytes`);
            await this.tokenizer.ignore(Number(remaining));
          }
        }
        async handleSoundPropertyChunks(remainingSize) {
          debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
          while (remainingSize > 0) {
            const sndPropHeader = await this.tokenizer.readToken(ChunkHeader64);
            debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
            const p0 = this.tokenizer.position;
            switch (sndPropHeader.chunkID.trim()) {
              case "FS": {
                const sampleRate = await this.tokenizer.readToken(UINT32_BE);
                this.metadata.setFormat("sampleRate", sampleRate);
                break;
              }
              case "CHNL": {
                const numChannels = await this.tokenizer.readToken(UINT16_BE);
                this.metadata.setFormat("numberOfChannels", numChannels);
                await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(UINT16_BE.len));
                break;
              }
              case "CMPR": {
                const compressionIdCode = (await this.tokenizer.readToken(FourCcToken)).trim();
                const count = await this.tokenizer.readToken(UINT8);
                const compressionName = await this.tokenizer.readToken(new StringType(count, "ascii"));
                if (compressionIdCode === "DSD") {
                  this.metadata.setFormat("lossless", true);
                  this.metadata.setFormat("bitsPerSample", 1);
                }
                this.metadata.setFormat("codec", `${compressionIdCode} (${compressionName})`);
                break;
              }
              case "ABSS": {
                const hours = await this.tokenizer.readToken(UINT16_BE);
                const minutes = await this.tokenizer.readToken(UINT8);
                const seconds = await this.tokenizer.readToken(UINT8);
                const samples = await this.tokenizer.readToken(UINT32_BE);
                debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);
                break;
              }
              case "LSCO": {
                const lsConfig = await this.tokenizer.readToken(UINT16_BE);
                debug(`LSCO lsConfig=${lsConfig}`);
                break;
              }
              default:
                debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
                await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));
            }
            const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);
            if (remaining > 0) {
              debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);
              await this.tokenizer.ignore(Number(remaining));
            }
            remainingSize -= BigInt(ChunkHeader64.len) + sndPropHeader.chunkSize;
            debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
          }
          if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {
            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;
            this.metadata.setFormat("bitrate", bitrate);
          }
        }
        async handleChannelChunks(remainingSize) {
          debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);
          const channels = [];
          while (remainingSize >= FourCcToken.len) {
            const channelId = await this.tokenizer.readToken(FourCcToken);
            debug(`Channel[ID=${channelId}]`);
            channels.push(channelId);
            remainingSize -= BigInt(FourCcToken.len);
          }
          debug(`Channels: ${channels.join(", ")}`);
          return channels;
        }
      } exports("DsdiffParser", DsdiffParser);

    })
  };
}));

System.register("./AiffParser-MlFVZ_c0-Bn78UYfD.js", ['./__monkey.entry-DKLp9CGx.js', './ID3v2Parser-Bm2mHbjm-CPeRbws5.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var BasicParser, FourCcToken, initDebug, EndOfStreamError, Uint8ArrayType, fromBuffer, StringType, UINT32_BE, makeUnexpectedFileContentError, UINT16_BE, UINT8, ID3v2Parser;
  return {
    setters: [module => {
      BasicParser = module.B;
      FourCcToken = module.F;
      initDebug = module.i;
      EndOfStreamError = module.E;
      Uint8ArrayType = module.U;
      fromBuffer = module.n;
      StringType = module.S;
      UINT32_BE = module.b;
      makeUnexpectedFileContentError = module.m;
      UINT16_BE = module.c;
      UINT8 = module.d;
    }, module => {
      ID3v2Parser = module.I;
    }, null, null, null, null, null],
    execute: (function () {

      const compressionTypes = {
        NONE: "not compressed	PCM	Apple Computer",
        sowt: "PCM (byte swapped)",
        fl32: "32-bit floating point IEEE 32-bit float",
        fl64: "64-bit floating point IEEE 64-bit float	Apple Computer",
        alaw: "ALaw 2:1	8-bit ITU-T G.711 A-law",
        ulaw: "µLaw 2:1	8-bit ITU-T G.711 µ-law	Apple Computer",
        ULAW: "CCITT G.711 u-law 8-bit ITU-T G.711 µ-law",
        ALAW: "CCITT G.711 A-law 8-bit ITU-T G.711 A-law",
        FL32: "Float 32	IEEE 32-bit float "
      };
      class AiffContentError extends makeUnexpectedFileContentError("AIFF") {
      }
      class Common {
        constructor(header, isAifc) {
          this.isAifc = isAifc;
          const minimumChunkSize = isAifc ? 22 : 18;
          if (header.chunkSize < minimumChunkSize)
            throw new AiffContentError(`COMMON CHUNK size should always be at least ${minimumChunkSize}`);
          this.len = header.chunkSize;
        }
        get(buf, off) {
          const shift = UINT16_BE.get(buf, off + 8) - 16398;
          const baseSampleRate = UINT16_BE.get(buf, off + 8 + 2);
          const res = {
            numChannels: UINT16_BE.get(buf, off),
            numSampleFrames: UINT32_BE.get(buf, off + 2),
            sampleSize: UINT16_BE.get(buf, off + 6),
            sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift
          };
          if (this.isAifc) {
            res.compressionType = FourCcToken.get(buf, off + 18);
            if (this.len > 22) {
              const strLen = UINT8.get(buf, off + 22);
              if (strLen > 0) {
                const padding = (strLen + 1) % 2;
                if (23 + strLen + padding === this.len) {
                  res.compressionName = new StringType(strLen, "latin1").get(buf, off + 23);
                } else {
                  throw new AiffContentError("Illegal pstring length");
                }
              } else {
                res.compressionName = void 0;
              }
            }
          } else {
            res.compressionName = "PCM";
          }
          return res;
        }
      }
      const Header = {
        len: 8,
        get: (buf, off) => {
          return {
chunkID: FourCcToken.get(buf, off),
chunkSize: Number(BigInt(UINT32_BE.get(buf, off + 4)))
          };
        }
      };
      const debug = initDebug("music-metadata:parser:aiff");
      class AIFFParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.isCompressed = null;
        }
        async parse() {
          const header = await this.tokenizer.readToken(Header);
          if (header.chunkID !== "FORM")
            throw new AiffContentError("Invalid Chunk-ID, expected 'FORM'");
          const type = await this.tokenizer.readToken(FourCcToken);
          switch (type) {
            case "AIFF":
              this.metadata.setFormat("container", type);
              this.isCompressed = false;
              break;
            case "AIFC":
              this.metadata.setFormat("container", "AIFF-C");
              this.isCompressed = true;
              break;
            default:
              throw new AiffContentError(`Unsupported AIFF type: ${type}`);
          }
          this.metadata.setFormat("lossless", !this.isCompressed);
          try {
            while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= Header.len) {
              debug(`Reading AIFF chunk at offset=${this.tokenizer.position}`);
              const chunkHeader = await this.tokenizer.readToken(Header);
              const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);
              const bytesRead = await this.readData(chunkHeader);
              await this.tokenizer.ignore(nextChunk - bytesRead);
            }
          } catch (err) {
            if (err instanceof EndOfStreamError) {
              debug("End-of-stream");
            } else {
              throw err;
            }
          }
        }
        async readData(header) {
          switch (header.chunkID) {
            case "COMM": {
              if (this.isCompressed === null) {
                throw new AiffContentError("Failed to parse AIFF.COMM chunk when compression type is unknown");
              }
              const common = await this.tokenizer.readToken(new Common(header, this.isCompressed));
              this.metadata.setFormat("bitsPerSample", common.sampleSize);
              this.metadata.setFormat("sampleRate", common.sampleRate);
              this.metadata.setFormat("numberOfChannels", common.numChannels);
              this.metadata.setFormat("numberOfSamples", common.numSampleFrames);
              this.metadata.setFormat("duration", common.numSampleFrames / common.sampleRate);
              if (common.compressionName || common.compressionType) {
                this.metadata.setFormat("codec", common.compressionName ?? compressionTypes[common.compressionType]);
              }
              return header.chunkSize;
            }
            case "ID3 ": {
              const id3_data = await this.tokenizer.readToken(new Uint8ArrayType(header.chunkSize));
              const rst = fromBuffer(id3_data);
              await new ID3v2Parser().parse(this.metadata, rst, this.options);
              return header.chunkSize;
            }
            case "SSND":
              if (this.metadata.format.duration) {
                this.metadata.setFormat("bitrate", 8 * header.chunkSize / this.metadata.format.duration);
              }
              return 0;
            case "NAME":
case "AUTH":
case "(c) ":
case "ANNO":
              return this.readTextChunk(header);
            default:
              debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);
              return 0;
          }
        }
        async readTextChunk(header) {
          const value = await this.tokenizer.readToken(new StringType(header.chunkSize, "ascii"));
          const values = value.split("\0").map((v) => v.trim()).filter((v) => v?.length);
          await Promise.all(values.map((v) => this.metadata.addTag("AIFF", header.chunkID, v)));
          return header.chunkSize;
        }
      } exports("AIFFParser", AIFFParser);

    })
  };
}));

System.register("./DsfParser-CtAKOhgc-CKUZVLlA.js", ['./__monkey.entry-DKLp9CGx.js', './AbstractID3Parser-Besqtu1X-CrHsEW-u.js', './ID3v2Parser-Bm2mHbjm-CPeRbws5.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var initDebug, UINT64_LE, FourCcToken, makeUnexpectedFileContentError, INT64_LE, INT32_LE, AbstractID3Parser, ID3v2Parser;
  return {
    setters: [module => {
      initDebug = module.i;
      UINT64_LE = module.f;
      FourCcToken = module.F;
      makeUnexpectedFileContentError = module.m;
      INT64_LE = module.p;
      INT32_LE = module.q;
    }, module => {
      AbstractID3Parser = module.A;
    }, module => {
      ID3v2Parser = module.I;
    }, null, null, null, null, null],
    execute: (function () {

      const ChunkHeader = {
        len: 12,
        get: (buf, off) => {
          return { id: FourCcToken.get(buf, off), size: UINT64_LE.get(buf, off + 4) };
        }
      };
      const DsdChunk = {
        len: 16,
        get: (buf, off) => {
          return {
            fileSize: INT64_LE.get(buf, off),
            metadataPointer: INT64_LE.get(buf, off + 8)
          };
        }
      };
      const FormatChunk = {
        len: 40,
        get: (buf, off) => {
          return {
            formatVersion: INT32_LE.get(buf, off),
            formatID: INT32_LE.get(buf, off + 4),
            channelType: INT32_LE.get(buf, off + 8),
            channelNum: INT32_LE.get(buf, off + 12),
            samplingFrequency: INT32_LE.get(buf, off + 16),
            bitsPerSample: INT32_LE.get(buf, off + 20),
            sampleCount: INT64_LE.get(buf, off + 24),
            blockSizePerChannel: INT32_LE.get(buf, off + 32)
          };
        }
      };
      const debug = initDebug("music-metadata:parser:DSF");
      class DsdContentParseError extends makeUnexpectedFileContentError("DSD") {
      } exports("DsdContentParseError", DsdContentParseError);
      class DsfParser extends AbstractID3Parser {
        async postId3v2Parse() {
          const p0 = this.tokenizer.position;
          const chunkHeader = await this.tokenizer.readToken(ChunkHeader);
          if (chunkHeader.id !== "DSD ")
            throw new DsdContentParseError("Invalid chunk signature");
          this.metadata.setFormat("container", "DSF");
          this.metadata.setFormat("lossless", true);
          const dsdChunk = await this.tokenizer.readToken(DsdChunk);
          if (dsdChunk.metadataPointer === BigInt(0)) {
            debug("No ID3v2 tag present");
          } else {
            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);
            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);
            await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);
            return new ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);
          }
        }
        async parseChunks(bytesRemaining) {
          while (bytesRemaining >= ChunkHeader.len) {
            const chunkHeader = await this.tokenizer.readToken(ChunkHeader);
            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);
            switch (chunkHeader.id) {
              case "fmt ": {
                const formatChunk = await this.tokenizer.readToken(FormatChunk);
                this.metadata.setFormat("numberOfChannels", formatChunk.channelNum);
                this.metadata.setFormat("sampleRate", formatChunk.samplingFrequency);
                this.metadata.setFormat("bitsPerSample", formatChunk.bitsPerSample);
                this.metadata.setFormat("numberOfSamples", formatChunk.sampleCount);
                this.metadata.setFormat("duration", Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);
                const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;
                this.metadata.setFormat("bitrate", bitrate);
                return;
              }
              default:
                this.tokenizer.ignore(Number(chunkHeader.size) - ChunkHeader.len);
                break;
            }
            bytesRemaining -= chunkHeader.size;
          }
        }
      } exports("DsfParser", DsfParser);

    })
  };
}));

System.register("./FlacParser-CDXQvU-n-BHThkOqb.js", ['./__monkey.entry-DKLp9CGx.js', './VorbisParser-CfoG9xo4-TBjWzkgb.js', './AbstractID3Parser-Besqtu1X-CrHsEW-u.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge', './ID3v2Parser-Bm2mHbjm-CPeRbws5.js'], (function (exports, module) {
  'use strict';
  var FourCcToken, initDebug, Uint8ArrayType, makeUnexpectedFileContentError, UINT24_BE, getBitAllignedNumber, getBit, UINT16_BE, VorbisParser, VorbisDecoder, VorbisPictureToken, AbstractID3Parser;
  return {
    setters: [module => {
      FourCcToken = module.F;
      initDebug = module.i;
      Uint8ArrayType = module.U;
      makeUnexpectedFileContentError = module.m;
      UINT24_BE = module.r;
      getBitAllignedNumber = module.g;
      getBit = module.j;
      UINT16_BE = module.c;
    }, module => {
      VorbisParser = module.V;
      VorbisDecoder = module.a;
      VorbisPictureToken = module.b;
    }, module => {
      AbstractID3Parser = module.A;
    }, null, null, null, null, null, null],
    execute: (function () {

      const debug = initDebug("music-metadata:parser:FLAC");
      class FlacContentError extends makeUnexpectedFileContentError("FLAC") {
      }
      const BlockType = {
        STREAMINFO: 0,
PADDING: 1,
APPLICATION: 2,
SEEKTABLE: 3,
VORBIS_COMMENT: 4,
CUESHEET: 5,
PICTURE: 6
};
      class FlacParser extends AbstractID3Parser {
        constructor() {
          super(...arguments);
          this.vorbisParser = new VorbisParser(this.metadata, this.options);
          this.padding = 0;
        }
        async postId3v2Parse() {
          const fourCC = await this.tokenizer.readToken(FourCcToken);
          if (fourCC.toString() !== "fLaC") {
            throw new FlacContentError("Invalid FLAC preamble");
          }
          let blockHeader;
          do {
            blockHeader = await this.tokenizer.readToken(BlockHeader);
            await this.parseDataBlock(blockHeader);
          } while (!blockHeader.lastBlock);
          if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {
            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;
            this.metadata.setFormat("bitrate", 8 * dataSize / this.metadata.format.duration);
          }
        }
        async parseDataBlock(blockHeader) {
          debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);
          switch (blockHeader.type) {
            case BlockType.STREAMINFO:
              return this.parseBlockStreamInfo(blockHeader.length);
            case BlockType.PADDING:
              this.padding += blockHeader.length;
              break;
            case BlockType.APPLICATION:
              break;
            case BlockType.SEEKTABLE:
              break;
            case BlockType.VORBIS_COMMENT:
              return this.parseComment(blockHeader.length);
            case BlockType.CUESHEET:
              break;
            case BlockType.PICTURE:
              await this.parsePicture(blockHeader.length);
              return;
            default:
              this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);
          }
          return this.tokenizer.ignore(blockHeader.length).then();
        }
async parseBlockStreamInfo(dataLen) {
          if (dataLen !== BlockStreamInfo.len)
            throw new FlacContentError("Unexpected block-stream-info length");
          const streamInfo = await this.tokenizer.readToken(BlockStreamInfo);
          this.metadata.setFormat("container", "FLAC");
          this.metadata.setFormat("codec", "FLAC");
          this.metadata.setFormat("lossless", true);
          this.metadata.setFormat("numberOfChannels", streamInfo.channels);
          this.metadata.setFormat("bitsPerSample", streamInfo.bitsPerSample);
          this.metadata.setFormat("sampleRate", streamInfo.sampleRate);
          if (streamInfo.totalSamples > 0) {
            this.metadata.setFormat("duration", streamInfo.totalSamples / streamInfo.sampleRate);
          }
        }
async parseComment(dataLen) {
          const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));
          const decoder = new VorbisDecoder(data, 0);
          decoder.readStringUtf8();
          const commentListLength = decoder.readInt32();
          const tags = new Array(commentListLength);
          for (let i = 0; i < commentListLength; i++) {
            tags[i] = decoder.parseUserComment();
          }
          await Promise.all(tags.map((tag) => this.vorbisParser.addTag(tag.key, tag.value)));
        }
        async parsePicture(dataLen) {
          if (this.options.skipCovers) {
            return this.tokenizer.ignore(dataLen);
          }
          const picture = await this.tokenizer.readToken(new VorbisPictureToken(dataLen));
          this.vorbisParser.addTag("METADATA_BLOCK_PICTURE", picture);
        }
      } exports("FlacParser", FlacParser);
      const BlockHeader = {
        len: 4,
        get: (buf, off) => {
          return {
            lastBlock: getBit(buf, off, 7),
            type: getBitAllignedNumber(buf, off, 1, 7),
            length: UINT24_BE.get(buf, off + 1)
          };
        }
      };
      const BlockStreamInfo = {
        len: 34,
        get: (buf, off) => {
          return {
minimumBlockSize: UINT16_BE.get(buf, off),

maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1e3,

minimumFrameSize: UINT24_BE.get(buf, off + 4),

maximumFrameSize: UINT24_BE.get(buf, off + 7),


sampleRate: UINT24_BE.get(buf, off + 10) >> 4,

channels: getBitAllignedNumber(buf, off + 12, 4, 3) + 1,

bitsPerSample: getBitAllignedNumber(buf, off + 12, 7, 5) + 1,


totalSamples: getBitAllignedNumber(buf, off + 13, 4, 36),
fileMD5: new Uint8ArrayType(16).get(buf, off + 18)
          };
        }
      };

    })
  };
}));

System.register("./MatroskaParser-DZIRNedW-DfvIL0R_.js", ['./__monkey.entry-DKLp9CGx.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var BasicParser, initDebug, TargetType, TrackType, EndOfStreamError, UINT8, Float64_BE, Float32_BE, StringType, makeUnexpectedFileContentError, UINT64_BE;
  return {
    setters: [module => {
      BasicParser = module.B;
      initDebug = module.i;
      TargetType = module.t;
      TrackType = module.T;
      EndOfStreamError = module.E;
      UINT8 = module.d;
      Float64_BE = module.v;
      Float32_BE = module.w;
      StringType = module.S;
      makeUnexpectedFileContentError = module.m;
      UINT64_BE = module.x;
    }, null, null, null, null, null],
    execute: (function () {

      const DataType = {
        string: 0,
        uint: 1,
        uid: 2,
        bool: 3,
        binary: 4,
        float: 5
      };
      const matroskaDtd = {
        name: "dtd",
        container: {
          440786851: {
            name: "ebml",
            container: {
              17030: { name: "ebmlVersion", value: DataType.uint },
17143: { name: "ebmlReadVersion", value: DataType.uint },
17138: { name: "ebmlMaxIDWidth", value: DataType.uint },
17139: { name: "ebmlMaxSizeWidth", value: DataType.uint },
17026: { name: "docType", value: DataType.string },
17031: { name: "docTypeVersion", value: DataType.uint },
17029: { name: "docTypeReadVersion", value: DataType.uint }
}
          },
408125543: {
            name: "segment",
            container: {
290298740: {
                name: "seekHead",
                container: {
                  19899: {
                    name: "seek",
                    multiple: true,
                    container: {
                      21419: { name: "id", value: DataType.binary },
                      21420: { name: "position", value: DataType.uint }
                    }
                  }
                }
              },
357149030: {
                name: "info",
                container: {
                  29604: { name: "uid", value: DataType.uid },
                  29572: { name: "filename", value: DataType.string },
                  3979555: { name: "prevUID", value: DataType.uid },
                  3965867: { name: "prevFilename", value: DataType.string },
                  4110627: { name: "nextUID", value: DataType.uid },
                  4096955: { name: "nextFilename", value: DataType.string },
                  2807729: { name: "timecodeScale", value: DataType.uint },
                  17545: { name: "duration", value: DataType.float },
                  17505: { name: "dateUTC", value: DataType.uint },
                  31657: { name: "title", value: DataType.string },
                  19840: { name: "muxingApp", value: DataType.string },
                  22337: { name: "writingApp", value: DataType.string }
                }
              },
524531317: {
                name: "cluster",
                multiple: true,
                container: {
                  231: { name: "timecode", value: DataType.uid },
                  22743: { name: "silentTracks ", multiple: true },
                  167: { name: "position", value: DataType.uid },
                  171: { name: "prevSize", value: DataType.uid },
                  160: { name: "blockGroup" },
                  163: { name: "simpleBlock" }
                }
              },
374648427: {
                name: "tracks",
                container: {
                  174: {
                    name: "entries",
                    multiple: true,
                    container: {
                      215: { name: "trackNumber", value: DataType.uint },
                      29637: { name: "uid", value: DataType.uid },
                      131: { name: "trackType", value: DataType.uint },
                      185: { name: "flagEnabled", value: DataType.bool },
                      136: { name: "flagDefault", value: DataType.bool },
                      21930: { name: "flagForced", value: DataType.bool },
156: { name: "flagLacing", value: DataType.bool },
                      28135: { name: "minCache", value: DataType.uint },
                      28136: { name: "maxCache", value: DataType.uint },
                      2352003: { name: "defaultDuration", value: DataType.uint },
                      2306383: { name: "timecodeScale", value: DataType.float },
                      21358: { name: "name", value: DataType.string },
                      2274716: { name: "language", value: DataType.string },
                      134: { name: "codecID", value: DataType.string },
                      25506: { name: "codecPrivate", value: DataType.binary },
                      2459272: { name: "codecName", value: DataType.string },
                      3839639: { name: "codecSettings", value: DataType.string },
                      3883072: { name: "codecInfoUrl", value: DataType.string },
                      2536e3: { name: "codecDownloadUrl", value: DataType.string },
                      170: { name: "codecDecodeAll", value: DataType.bool },
                      28587: { name: "trackOverlay", value: DataType.uint },
224: {
                        name: "video",
                        container: {
                          154: { name: "flagInterlaced", value: DataType.bool },
                          21432: { name: "stereoMode", value: DataType.uint },
                          176: { name: "pixelWidth", value: DataType.uint },
                          186: { name: "pixelHeight", value: DataType.uint },
                          21680: { name: "displayWidth", value: DataType.uint },
                          21690: { name: "displayHeight", value: DataType.uint },
                          21683: { name: "aspectRatioType", value: DataType.uint },
                          3061028: { name: "colourSpace", value: DataType.uint },
                          3126563: { name: "gammaValue", value: DataType.float }
                        }
                      },
225: {
                        name: "audio",
                        container: {
                          181: { name: "samplingFrequency", value: DataType.float },
                          30901: { name: "outputSamplingFrequency", value: DataType.float },
                          159: { name: "channels", value: DataType.uint },
148: { name: "channels", value: DataType.uint },
                          32123: { name: "channelPositions", value: DataType.binary },
                          25188: { name: "bitDepth", value: DataType.uint }
                        }
                      },
28032: {
                        name: "contentEncodings",
                        container: {
                          25152: {
                            name: "contentEncoding",
                            container: {
                              20529: { name: "order", value: DataType.uint },
                              20530: { name: "scope", value: DataType.bool },
                              20531: { name: "type", value: DataType.uint },
                              20532: {
                                name: "contentEncoding",
                                container: {
                                  16980: { name: "contentCompAlgo", value: DataType.uint },
                                  16981: { name: "contentCompSettings", value: DataType.binary }
                                }
                              },
                              20533: {
                                name: "contentEncoding",
                                container: {
                                  18401: { name: "contentEncAlgo", value: DataType.uint },
                                  18402: { name: "contentEncKeyID", value: DataType.binary },
                                  18403: { name: "contentSignature ", value: DataType.binary },
                                  18404: { name: "ContentSigKeyID  ", value: DataType.binary },
                                  18405: { name: "contentSigAlgo ", value: DataType.uint },
                                  18406: { name: "contentSigHashAlgo ", value: DataType.uint }
                                }
                              },
                              25188: { name: "bitDepth", value: DataType.uint }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
475249515: {
                name: "cues",
                container: {
                  187: {
                    name: "cuePoint",
                    container: {
                      179: { name: "cueTime", value: DataType.uid },
                      183: {
                        name: "positions",
                        container: {
                          247: { name: "track", value: DataType.uint },
                          241: { name: "clusterPosition", value: DataType.uint },
                          21368: { name: "blockNumber", value: DataType.uint },
                          234: { name: "codecState", value: DataType.uint },
                          219: {
                            name: "reference",
                            container: {
                              150: { name: "time", value: DataType.uint },
                              151: { name: "cluster", value: DataType.uint },
                              21343: { name: "number", value: DataType.uint },
                              235: { name: "codecState", value: DataType.uint }
                            }
                          },
                          240: { name: "relativePosition", value: DataType.uint }
}
                      }
                    }
                  }
                }
              },
423732329: {
                name: "attachments",
                container: {
                  24999: {
                    name: "attachedFiles",
                    multiple: true,
                    container: {
                      18046: { name: "description", value: DataType.string },
                      18030: { name: "name", value: DataType.string },
                      18016: { name: "mimeType", value: DataType.string },
                      18012: { name: "data", value: DataType.binary },
                      18094: { name: "uid", value: DataType.uid }
                    }
                  }
                }
              },
272869232: {
                name: "chapters",
                container: {
                  17849: {
                    name: "editionEntry",
                    container: {
                      182: {
                        name: "chapterAtom",
                        container: {
                          29636: { name: "uid", value: DataType.uid },
                          145: { name: "timeStart", value: DataType.uint },
                          146: { name: "timeEnd", value: DataType.uid },
                          152: { name: "hidden", value: DataType.bool },
                          17816: { name: "enabled", value: DataType.uid },
                          143: {
                            name: "track",
                            container: {
                              137: { name: "trackNumber", value: DataType.uid },
                              128: {
                                name: "display",
                                container: {
                                  133: { name: "string", value: DataType.string },
                                  17276: { name: "language ", value: DataType.string },
                                  17278: { name: "country ", value: DataType.string }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
307544935: {
                name: "tags",
                container: {
                  29555: {
                    name: "tag",
                    multiple: true,
                    container: {
                      25536: {
                        name: "target",
                        container: {
                          25541: { name: "tagTrackUID", value: DataType.uid },
                          25540: { name: "tagChapterUID", value: DataType.uint },
                          25542: { name: "tagAttachmentUID", value: DataType.uid },
                          25546: { name: "targetType", value: DataType.string },
26826: { name: "targetTypeValue", value: DataType.uint },
25545: { name: "tagEditionUID", value: DataType.uid }
}
                      },
                      26568: {
                        name: "simpleTags",
                        multiple: true,
                        container: {
                          17827: { name: "name", value: DataType.string },
                          17543: { name: "string", value: DataType.string },
                          17541: { name: "binary", value: DataType.binary },
                          17530: { name: "language", value: DataType.string },
17531: { name: "languageIETF", value: DataType.string },
17540: { name: "default", value: DataType.bool }
}
                      }
                    }
                  }
                }
              }
            }
          }
        }
      };
      const debug$1 = initDebug("music-metadata:parser:ebml");
      class EbmlContentError extends makeUnexpectedFileContentError("EBML") {
      }
      const ParseAction = {
        ReadNext: 0,
IgnoreElement: 2,
SkipSiblings: 3,
TerminateParsing: 4,
SkipElement: 5
};
      class EbmlIterator {
constructor(tokenizer) {
          this.padding = 0;
          this.parserMap = new Map();
          this.ebmlMaxIDLength = 4;
          this.ebmlMaxSizeLength = 8;
          this.tokenizer = tokenizer;
          this.parserMap.set(DataType.uint, (e) => this.readUint(e));
          this.parserMap.set(DataType.string, (e) => this.readString(e));
          this.parserMap.set(DataType.binary, (e) => this.readBuffer(e));
          this.parserMap.set(DataType.uid, async (e) => this.readBuffer(e));
          this.parserMap.set(DataType.bool, (e) => this.readFlag(e));
          this.parserMap.set(DataType.float, (e) => this.readFloat(e));
        }
        async iterate(dtdElement, posDone, listener) {
          return this.parseContainer(linkParents(dtdElement), posDone, listener);
        }
        async parseContainer(dtdElement, posDone, listener) {
          const tree = {};
          while (this.tokenizer.position < posDone) {
            let element;
            const elementPosition = this.tokenizer.position;
            try {
              element = await this.readElement();
            } catch (error) {
              if (error instanceof EndOfStreamError) {
                break;
              }
              throw error;
            }
            const child = dtdElement.container[element.id];
            if (child) {
              const action = listener.startNext(child);
              switch (action) {
                case ParseAction.ReadNext:
                  {
                    if (element.id === 524531317) ;
                    debug$1(`Read element: name=${getElementPath(child)}{id=0x${element.id.toString(16)}, container=${!!child.container}} at position=${elementPosition}`);
                    if (child.container) {
                      const res = await this.parseContainer(child, element.len >= 0 ? this.tokenizer.position + element.len : -1, listener);
                      if (child.multiple) {
                        if (!tree[child.name]) {
                          tree[child.name] = [];
                        }
                        tree[child.name].push(res);
                      } else {
                        tree[child.name] = res;
                      }
                      await listener.elementValue(child, res, elementPosition);
                    } else {
                      const parser = this.parserMap.get(child.value);
                      if (typeof parser === "function") {
                        const value = await parser(element);
                        tree[child.name] = value;
                        await listener.elementValue(child, value, elementPosition);
                      }
                    }
                  }
                  break;
                case ParseAction.SkipElement:
                  debug$1(`Go to next element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
                  break;
                case ParseAction.IgnoreElement:
                  debug$1(`Ignore element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
                  await this.tokenizer.ignore(element.len);
                  break;
                case ParseAction.SkipSiblings:
                  debug$1(`Ignore remaining container, at: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
                  await this.tokenizer.ignore(posDone - this.tokenizer.position);
                  break;
                case ParseAction.TerminateParsing:
                  debug$1(`Terminate parsing at element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
                  return tree;
              }
            } else {
              switch (element.id) {
                case 236:
                  this.padding += element.len;
                  await this.tokenizer.ignore(element.len);
                  break;
                default:
                  debug$1(`parseEbml: parent=${getElementPath(dtdElement)}, unknown child: id=${element.id.toString(16)} at position=${elementPosition}`);
                  this.padding += element.len;
                  await this.tokenizer.ignore(element.len);
              }
            }
          }
          return tree;
        }
        async readVintData(maxLength) {
          const msb = await this.tokenizer.peekNumber(UINT8);
          let mask = 128;
          let oc = 1;
          while ((msb & mask) === 0) {
            if (oc > maxLength) {
              throw new EbmlContentError("VINT value exceeding maximum size");
            }
            ++oc;
            mask >>= 1;
          }
          const id = new Uint8Array(oc);
          await this.tokenizer.readBuffer(id);
          return id;
        }
        async readElement() {
          const id = await this.readVintData(this.ebmlMaxIDLength);
          const lenField = await this.readVintData(this.ebmlMaxSizeLength);
          lenField[0] ^= 128 >> lenField.length - 1;
          return {
            id: readUIntBE(id, id.length),
            len: readUIntBE(lenField, lenField.length)
          };
        }
        async readFloat(e) {
          switch (e.len) {
            case 0:
              return 0;
            case 4:
              return this.tokenizer.readNumber(Float32_BE);
            case 8:
              return this.tokenizer.readNumber(Float64_BE);
            case 10:
              return this.tokenizer.readNumber(Float64_BE);
            default:
              throw new EbmlContentError(`Invalid IEEE-754 float length: ${e.len}`);
          }
        }
        async readFlag(e) {
          return await this.readUint(e) === 1;
        }
        async readUint(e) {
          const buf = await this.readBuffer(e);
          return readUIntBE(buf, e.len);
        }
        async readString(e) {
          const rawString = await this.tokenizer.readToken(new StringType(e.len, "utf-8"));
          return rawString.replace(/\x00.*$/g, "");
        }
        async readBuffer(e) {
          const buf = new Uint8Array(e.len);
          await this.tokenizer.readBuffer(buf);
          return buf;
        }
      }
      function readUIntBE(buf, len) {
        return Number(readUIntBeAsBigInt(buf, len));
      }
      function readUIntBeAsBigInt(buf, len) {
        const normalizedNumber = new Uint8Array(8);
        const cleanNumber = buf.subarray(0, len);
        try {
          normalizedNumber.set(cleanNumber, 8 - len);
          return UINT64_BE.get(normalizedNumber, 0);
        } catch (error) {
          return BigInt(-1);
        }
      }
      function linkParents(element) {
        if (element.container) {
          Object.keys(element.container).map((id) => {
            const child = element.container[id];
            child.id = Number.parseInt(id);
            return child;
          }).forEach((child) => {
            child.parent = element;
            linkParents(child);
          });
        }
        return element;
      }
      function getElementPath(element) {
        let path = "";
        if (element.parent && element.parent.name !== "dtd") {
          path += `${getElementPath(element.parent)}/`;
        }
        return path + element.name;
      }
      const debug = initDebug("music-metadata:parser:matroska");
      class MatroskaParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.seekHeadOffset = 0;
          this.flagUseIndexToSkipClusters = this.options.mkvUseIndex ?? false;
        }
        async parse() {
          const containerSize = this.tokenizer.fileInfo.size ?? Number.MAX_SAFE_INTEGER;
          const matroskaIterator = new EbmlIterator(this.tokenizer);
          debug("Initializing DTD end MatroskaIterator");
          await matroskaIterator.iterate(matroskaDtd, containerSize, {
            startNext: (element) => {
              switch (element.id) {
case 475249515:
                  debug(`Skip element: name=${element.name}, id=0x${element.id.toString(16)}`);
                  return ParseAction.IgnoreElement;
                case 524531317:
                  if (this.flagUseIndexToSkipClusters && this.seekHead) {
                    const index = this.seekHead.seek.find((index2) => index2.position + this.seekHeadOffset > this.tokenizer.position);
                    if (index) {
                      const ignoreSize = index.position + this.seekHeadOffset - this.tokenizer.position;
                      debug(`Use index to go to next position, ignoring ${ignoreSize} bytes`);
                      this.tokenizer.ignore(ignoreSize);
                      return ParseAction.SkipElement;
                    }
                  }
                  return ParseAction.IgnoreElement;
                default:
                  return ParseAction.ReadNext;
              }
            },
            elementValue: async (element, value, offset) => {
              debug(`Received: name=${element.name}, value=${value}`);
              switch (element.id) {
                case 17026:
                  this.metadata.setFormat("container", `EBML/${value}`);
                  break;
                case 290298740:
                  this.seekHead = value;
                  this.seekHeadOffset = offset;
                  break;
                case 357149030:
                  {
                    const info = value;
                    const timecodeScale = info.timecodeScale ? info.timecodeScale : 1e6;
                    if (typeof info.duration === "number") {
                      const duration = info.duration * timecodeScale / 1e9;
                      await this.addTag("segment:title", info.title);
                      this.metadata.setFormat("duration", Number(duration));
                    }
                  }
                  break;
                case 374648427:
                  {
                    const audioTracks = value;
                    if (audioTracks?.entries) {
                      audioTracks.entries.forEach((entry) => {
                        const stream = {
                          codecName: entry.codecID.replace("A_", "").replace("V_", ""),
                          codecSettings: entry.codecSettings,
                          flagDefault: entry.flagDefault,
                          flagLacing: entry.flagLacing,
                          flagEnabled: entry.flagEnabled,
                          language: entry.language,
                          name: entry.name,
                          type: entry.trackType,
                          audio: entry.audio,
                          video: entry.video
                        };
                        this.metadata.addStreamInfo(stream);
                      });
                      const audioTrack = audioTracks.entries.filter((entry) => entry.trackType === TrackType.audio).reduce((acc, cur) => {
                        if (!acc)
                          return cur;
                        if (cur.flagDefault && !acc.flagDefault)
                          return cur;
                        if (cur.trackNumber < acc.trackNumber)
                          return cur;
                        return acc;
                      }, null);
                      if (audioTrack) {
                        this.metadata.setFormat("codec", audioTrack.codecID.replace("A_", ""));
                        this.metadata.setFormat("sampleRate", audioTrack.audio.samplingFrequency);
                        this.metadata.setFormat("numberOfChannels", audioTrack.audio.channels);
                      }
                    }
                  }
                  break;
                case 307544935:
                  {
                    const tags = value;
                    await Promise.all(tags.tag.map(async (tag) => {
                      const target = tag.target;
                      const targetType = target?.targetTypeValue ? TargetType[target.targetTypeValue] : target?.targetType ? target.targetType : "track";
                      await Promise.all(tag.simpleTags.map(async (simpleTag) => {
                        const value2 = simpleTag.string ? simpleTag.string : simpleTag.binary;
                        await this.addTag(`${targetType}:${simpleTag.name}`, value2);
                      }));
                    }));
                  }
                  break;
                case 423732329:
                  {
                    const attachments = value;
                    await Promise.all(attachments.attachedFiles.filter((file) => file.mimeType.startsWith("image/")).map((file) => this.addTag("picture", {
                      data: file.data,
                      format: file.mimeType,
                      description: file.description,
                      name: file.name
                    })));
                  }
                  break;
              }
            }
          });
        }
        async addTag(tagId, value) {
          await this.metadata.addTag("matroska", tagId, value);
        }
      } exports("MatroskaParser", MatroskaParser);

    })
  };
}));

System.register("./MP4Parser-CWip5UUj-B4R5O7d5.js", ['./__monkey.entry-DKLp9CGx.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var BasicParser, StringType, initDebug, UINT32_BE, Token, Uint8ArrayType, uint8ArrayToHex, uint8ArrayToString, UINT16_BE, UINT8, Genres, TrackType, INT32_BE, INT24_BE, INT8, UINT24_BE, makeUnexpectedFileContentError, FourCcToken, UINT64_BE, INT16_BE;
  return {
    setters: [module => {
      BasicParser = module.B;
      StringType = module.S;
      initDebug = module.i;
      UINT32_BE = module.b;
      Token = module.y;
      Uint8ArrayType = module.U;
      uint8ArrayToHex = module.u;
      uint8ArrayToString = module.z;
      UINT16_BE = module.c;
      UINT8 = module.d;
      Genres = module.G;
      TrackType = module.T;
      INT32_BE = module.C;
      INT24_BE = module.D;
      INT8 = module.H;
      UINT24_BE = module.r;
      makeUnexpectedFileContentError = module.m;
      FourCcToken = module.F;
      UINT64_BE = module.x;
      INT16_BE = module.I;
    }, null, null, null, null, null],
    execute: (function () {

      const debug$2 = initDebug("music-metadata:parser:MP4:atom");
      class Mp4ContentError extends makeUnexpectedFileContentError("MP4") {
      }
      const Header = {
        len: 8,
        get: (buf, off) => {
          const length = UINT32_BE.get(buf, off);
          if (length < 0)
            throw new Mp4ContentError("Invalid atom header length");
          return {
            length: BigInt(length),
            name: new StringType(4, "latin1").get(buf, off + 4)
          };
        },
        put: (buf, off, hdr) => {
          UINT32_BE.put(buf, off, Number(hdr.length));
          return FourCcToken.put(buf, off + 4, hdr.name);
        }
      };
      const ExtendedSize = UINT64_BE;
      const ftyp = {
        len: 4,
        get: (buf, off) => {
          return {
            type: new StringType(4, "ascii").get(buf, off)
          };
        }
      };
      class FixedLengthAtom {
constructor(len, expLen, atomId) {
          if (len < expLen) {
            throw new Mp4ContentError(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);
          }
          if (len > expLen) {
            debug$2(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);
          }
          this.len = len;
        }
      }
      const SecondsSinceMacEpoch = {
        len: 4,
        get: (buf, off) => {
          const secondsSinceUnixEpoch = UINT32_BE.get(buf, off) - 2082844800;
          return new Date(secondsSinceUnixEpoch * 1e3);
        }
      };
      class MdhdAtom extends FixedLengthAtom {
        constructor(len) {
          super(len, 24, "mdhd");
        }
        get(buf, off) {
          return {
            version: UINT8.get(buf, off + 0),
            flags: UINT24_BE.get(buf, off + 1),
            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
            timeScale: UINT32_BE.get(buf, off + 12),
            duration: UINT32_BE.get(buf, off + 16),
            language: UINT16_BE.get(buf, off + 20),
            quality: UINT16_BE.get(buf, off + 22)
          };
        }
      }
      class MvhdAtom extends FixedLengthAtom {
        constructor(len) {
          super(len, 100, "mvhd");
        }
        get(buf, off) {
          return {
            version: UINT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
            timeScale: UINT32_BE.get(buf, off + 12),
            duration: UINT32_BE.get(buf, off + 16),
            preferredRate: UINT32_BE.get(buf, off + 20),
            preferredVolume: UINT16_BE.get(buf, off + 24),

previewTime: UINT32_BE.get(buf, off + 72),
            previewDuration: UINT32_BE.get(buf, off + 76),
            posterTime: UINT32_BE.get(buf, off + 80),
            selectionTime: UINT32_BE.get(buf, off + 84),
            selectionDuration: UINT32_BE.get(buf, off + 88),
            currentTime: UINT32_BE.get(buf, off + 92),
            nextTrackID: UINT32_BE.get(buf, off + 96)
          };
        }
      }
      class DataAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          return {
            type: {
              set: UINT8.get(buf, off + 0),
              type: UINT24_BE.get(buf, off + 1)
            },
            locale: UINT24_BE.get(buf, off + 4),
            value: new Uint8ArrayType(this.len - 8).get(buf, off + 8)
          };
        }
      }
      class NameAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          return {
            version: UINT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            name: new StringType(this.len - 4, "utf-8").get(buf, off + 4)
          };
        }
      }
      class TrackHeaderAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          return {
            version: UINT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
            trackId: UINT32_BE.get(buf, off + 12),
duration: UINT32_BE.get(buf, off + 20),
            layer: UINT16_BE.get(buf, off + 24),
            alternateGroup: UINT16_BE.get(buf, off + 26),
            volume: UINT16_BE.get(buf, off + 28)

};
        }
      }
      const stsdHeader = {
        len: 8,
        get: (buf, off) => {
          return {
            version: UINT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            numberOfEntries: UINT32_BE.get(buf, off + 4)
          };
        }
      };
      class SampleDescriptionTable {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const descrLen = this.len - 12;
          return {
            dataFormat: FourCcToken.get(buf, off),
            dataReferenceIndex: UINT16_BE.get(buf, off + 10),
            description: descrLen > 0 ? new Uint8ArrayType(descrLen).get(buf, off + 12) : void 0
          };
        }
      }
      class StsdAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const header = stsdHeader.get(buf, off);
          off += stsdHeader.len;
          const table = [];
          for (let n = 0; n < header.numberOfEntries; ++n) {
            const size = UINT32_BE.get(buf, off);
            off += UINT32_BE.len;
            table.push(new SampleDescriptionTable(size - UINT32_BE.len).get(buf, off));
            off += size;
          }
          return {
            header,
            table
          };
        }
      }
      const SoundSampleDescriptionVersion = {
        len: 8,
        get(buf, off) {
          return {
            version: INT16_BE.get(buf, off),
            revision: INT16_BE.get(buf, off + 2),
            vendor: INT32_BE.get(buf, off + 4)
          };
        }
      };
      const SoundSampleDescriptionV0 = {
        len: 12,
        get(buf, off) {
          return {
            numAudioChannels: INT16_BE.get(buf, off + 0),
            sampleSize: INT16_BE.get(buf, off + 2),
            compressionId: INT16_BE.get(buf, off + 4),
            packetSize: INT16_BE.get(buf, off + 6),
            sampleRate: UINT16_BE.get(buf, off + 8) + UINT16_BE.get(buf, off + 10) / 1e4
          };
        }
      };
      class SimpleTableAtom {
        constructor(len, token) {
          this.len = len;
          this.token = token;
        }
        get(buf, off) {
          const nrOfEntries = INT32_BE.get(buf, off + 4);
          return {
            version: INT8.get(buf, off + 0),
            flags: INT24_BE.get(buf, off + 1),
            numberOfEntries: nrOfEntries,
            entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)
          };
        }
      }
      const TimeToSampleToken = {
        len: 8,
        get(buf, off) {
          return {
            count: INT32_BE.get(buf, off + 0),
            duration: INT32_BE.get(buf, off + 4)
          };
        }
      };
      class SttsAtom extends SimpleTableAtom {
        constructor(len) {
          super(len, TimeToSampleToken);
        }
      }
      const SampleToChunkToken = {
        len: 12,
        get(buf, off) {
          return {
            firstChunk: INT32_BE.get(buf, off),
            samplesPerChunk: INT32_BE.get(buf, off + 4),
            sampleDescriptionId: INT32_BE.get(buf, off + 8)
          };
        }
      };
      class StscAtom extends SimpleTableAtom {
        constructor(len) {
          super(len, SampleToChunkToken);
        }
      }
      class StszAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const nrOfEntries = INT32_BE.get(buf, off + 8);
          return {
            version: INT8.get(buf, off),
            flags: INT24_BE.get(buf, off + 1),
            sampleSize: INT32_BE.get(buf, off + 4),
            numberOfEntries: nrOfEntries,
            entries: readTokenTable(buf, INT32_BE, off + 12, this.len - 12, nrOfEntries)
          };
        }
      }
      class StcoAtom extends SimpleTableAtom {
        constructor(len) {
          super(len, INT32_BE);
          this.len = len;
        }
      }
      class ChapterText {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const titleLen = INT16_BE.get(buf, off + 0);
          const str = new StringType(titleLen, "utf-8");
          return str.get(buf, off + 2);
        }
      }
      function readTokenTable(buf, token, off, remainingLen, numberOfEntries) {
        debug$2(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`);
        if (remainingLen === 0)
          return [];
        if (remainingLen !== numberOfEntries * token.len)
          throw new Mp4ContentError("mismatch number-of-entries with remaining atom-length");
        const entries = [];
        for (let n = 0; n < numberOfEntries; ++n) {
          entries.push(token.get(buf, off));
          off += token.len;
        }
        return entries;
      }
      const debug$1 = initDebug("music-metadata:parser:MP4:Atom");
      class Atom {
        static async readAtom(tokenizer, dataHandler, parent, remaining) {
          const offset = tokenizer.position;
          debug$1(`Reading next token on offset=${offset}...`);
          const header = await tokenizer.readToken(Header);
          const extended = header.length === 1n;
          if (extended) {
            header.length = await tokenizer.readToken(ExtendedSize);
          }
          const atomBean = new Atom(header, extended, parent);
          const payloadLength = atomBean.getPayloadLength(remaining);
          debug$1(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`);
          await atomBean.readData(tokenizer, dataHandler, payloadLength);
          return atomBean;
        }
        constructor(header, extended, parent) {
          this.header = header;
          this.extended = extended;
          this.parent = parent;
          this.children = [];
          this.atomPath = (this.parent ? `${this.parent.atomPath}.` : "") + this.header.name;
        }
        getHeaderLength() {
          return this.extended ? 16 : 8;
        }
        getPayloadLength(remaining) {
          return (this.header.length === 0n ? remaining : Number(this.header.length)) - this.getHeaderLength();
        }
        async readAtoms(tokenizer, dataHandler, size) {
          while (size > 0) {
            const atomBean = await Atom.readAtom(tokenizer, dataHandler, this, size);
            this.children.push(atomBean);
            size -= atomBean.header.length === 0n ? size : Number(atomBean.header.length);
          }
        }
        async readData(tokenizer, dataHandler, remaining) {
          switch (this.header.name) {
case "moov":
case "udta":
case "trak":
            case "mdia":
case "minf":
case "stbl":
case "<id>":
            case "ilst":
            case "tref":
              return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining));
            case "meta": {
              const peekHeader = await tokenizer.peekToken(Header);
              const paddingLength = peekHeader.name === "hdlr" ? 0 : 4;
              await tokenizer.ignore(paddingLength);
              return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength);
            }
            default:
              return dataHandler(this, remaining);
          }
        }
      }
      const debug = initDebug("music-metadata:parser:MP4");
      const tagFormat = "iTunes";
      const encoderDict = {
        raw: {
          lossy: false,
          format: "raw"
        },
        MAC3: {
          lossy: true,
          format: "MACE 3:1"
        },
        MAC6: {
          lossy: true,
          format: "MACE 6:1"
        },
        ima4: {
          lossy: true,
          format: "IMA 4:1"
        },
        ulaw: {
          lossy: true,
          format: "uLaw 2:1"
        },
        alaw: {
          lossy: true,
          format: "uLaw 2:1"
        },
        Qclp: {
          lossy: true,
          format: "QUALCOMM PureVoice"
        },
        ".mp3": {
          lossy: true,
          format: "MPEG-1 layer 3"
        },
        alac: {
          lossy: false,
          format: "ALAC"
        },
        "ac-3": {
          lossy: true,
          format: "AC-3"
        },
        mp4a: {
          lossy: true,
          format: "MPEG-4/AAC"
        },
        mp4s: {
          lossy: true,
          format: "MP4S"
        },
c608: {
          lossy: true,
          format: "CEA-608"
        },
        c708: {
          lossy: true,
          format: "CEA-708"
        }
      };
      function distinct(value, index, self) {
        return self.indexOf(value) === index;
      }
      class MP4Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.tracks = [];
          this.atomParsers = {
mvhd: async (len) => {
              const mvhd = await this.tokenizer.readToken(new MvhdAtom(len));
              this.metadata.setFormat("creationTime", mvhd.creationTime);
              this.metadata.setFormat("modificationTime", mvhd.modificationTime);
            },
mdhd: async (len) => {
              const mdhd_data = await this.tokenizer.readToken(new MdhdAtom(len));
              const td = this.getTrackDescription();
              td.creationTime = mdhd_data.creationTime;
              td.modificationTime = mdhd_data.modificationTime;
              td.timeScale = mdhd_data.timeScale;
              td.duration = mdhd_data.duration;
            },
            chap: async (len) => {
              const td = this.getTrackDescription();
              const trackIds = [];
              while (len >= UINT32_BE.len) {
                trackIds.push(await this.tokenizer.readNumber(UINT32_BE));
                len -= UINT32_BE.len;
              }
              td.chapterList = trackIds;
            },
            tkhd: async (len) => {
              const track = await this.tokenizer.readToken(new TrackHeaderAtom(len));
              this.tracks.push(track);
            },
mdat: async (len) => {
              this.audioLengthInBytes = len;
              this.calculateBitRate();
              if (this.options.includeChapters) {
                const trackWithChapters = this.tracks.filter((track) => track.chapterList);
                if (trackWithChapters.length === 1) {
                  const chapterTrackIds = trackWithChapters[0].chapterList;
                  const chapterTracks = this.tracks.filter((track) => chapterTrackIds.indexOf(track.trackId) !== -1);
                  if (chapterTracks.length === 1) {
                    return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);
                  }
                }
              }
              await this.tokenizer.ignore(len);
            },
            ftyp: async (len) => {
              const types = [];
              while (len > 0) {
                const ftype = await this.tokenizer.readToken(ftyp);
                len -= ftyp.len;
                const value = ftype.type.replace(/\W/g, "");
                if (value.length > 0) {
                  types.push(value);
                }
              }
              debug(`ftyp: ${types.join("/")}`);
              const x = types.filter(distinct).join("/");
              this.metadata.setFormat("container", x);
            },
stsd: async (len) => {
              const stsd = await this.tokenizer.readToken(new StsdAtom(len));
              const trackDescription = this.getTrackDescription();
              trackDescription.soundSampleDescription = stsd.table.map((dfEntry) => this.parseSoundSampleDescription(dfEntry));
            },
stsc: async (len) => {
              const stsc = await this.tokenizer.readToken(new StscAtom(len));
              this.getTrackDescription().sampleToChunkTable = stsc.entries;
            },
stts: async (len) => {
              const stts = await this.tokenizer.readToken(new SttsAtom(len));
              this.getTrackDescription().timeToSampleTable = stts.entries;
            },
stsz: async (len) => {
              const stsz = await this.tokenizer.readToken(new StszAtom(len));
              const td = this.getTrackDescription();
              td.sampleSize = stsz.sampleSize;
              td.sampleSizeTable = stsz.entries;
            },
stco: async (len) => {
              const stco = await this.tokenizer.readToken(new StcoAtom(len));
              this.getTrackDescription().chunkOffsetTable = stco.entries;
            },
            date: async (len) => {
              const date = await this.tokenizer.readToken(new StringType(len, "utf-8"));
              await this.addTag("date", date);
            }
          };
        }
        static read_BE_Integer(array, signed) {
          const integerType = (signed ? "INT" : "UINT") + array.length * 8 + (array.length > 1 ? "_BE" : "");
          const token = Token[integerType];
          if (!token) {
            throw new Mp4ContentError(`Token for integer type not found: "${integerType}"`);
          }
          return Number(token.get(array, 0));
        }
        async parse() {
          this.tracks = [];
          let remainingFileSize = this.tokenizer.fileInfo.size || 0;
          while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {
            try {
              const token = await this.tokenizer.peekToken(Header);
              if (token.name === "\0\0\0\0") {
                const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;
                debug(errMsg);
                this.addWarning(errMsg);
                break;
              }
            } catch (error) {
              if (error instanceof Error) {
                const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;
                debug(errMsg);
                this.addWarning(errMsg);
              } else
                throw error;
              break;
            }
            const rootAtom = await Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);
            remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);
          }
          const formatList = [];
          this.tracks.forEach((track) => {
            const trackFormats = [];
            track.soundSampleDescription.forEach((ssd) => {
              const streamInfo = {};
              const encoderInfo = encoderDict[ssd.dataFormat];
              if (encoderInfo) {
                trackFormats.push(encoderInfo.format);
                streamInfo.codecName = encoderInfo.format;
              } else {
                streamInfo.codecName = `<${ssd.dataFormat}>`;
              }
              if (ssd.description) {
                const { description } = ssd;
                if (description.sampleRate > 0) {
                  streamInfo.type = TrackType.audio;
                  streamInfo.audio = {
                    samplingFrequency: description.sampleRate,
                    bitDepth: description.sampleSize,
                    channels: description.numAudioChannels
                  };
                }
              }
              this.metadata.addStreamInfo(streamInfo);
            });
            if (trackFormats.length >= 1) {
              formatList.push(trackFormats.join("/"));
            }
          });
          if (formatList.length > 0) {
            this.metadata.setFormat("codec", formatList.filter(distinct).join("+"));
          }
          const audioTracks = this.tracks.filter((track) => {
            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;
          });
          if (audioTracks.length >= 1) {
            const audioTrack = audioTracks[0];
            if (audioTrack.timeScale > 0) {
              const duration = audioTrack.duration / audioTrack.timeScale;
              this.metadata.setFormat("duration", duration);
            }
            const ssd = audioTrack.soundSampleDescription[0];
            if (ssd.description) {
              this.metadata.setFormat("sampleRate", ssd.description.sampleRate);
              this.metadata.setFormat("bitsPerSample", ssd.description.sampleSize);
              this.metadata.setFormat("numberOfChannels", ssd.description.numAudioChannels);
              if (audioTrack.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {
                const totalSampleSize = audioTrack.timeToSampleTable.map((ttstEntry) => ttstEntry.count * ttstEntry.duration).reduce((total, sampleSize) => total + sampleSize);
                const duration = totalSampleSize / ssd.description.sampleRate;
                this.metadata.setFormat("duration", duration);
              }
            }
            const encoderInfo = encoderDict[ssd.dataFormat];
            if (encoderInfo) {
              this.metadata.setFormat("lossless", !encoderInfo.lossy);
            }
            this.calculateBitRate();
          }
        }
        async handleAtom(atom, remaining) {
          if (atom.parent) {
            switch (atom.parent.header.name) {
              case "ilst":
              case "<id>":
                return this.parseMetadataItemData(atom);
            }
          }
          if (this.atomParsers[atom.header.name]) {
            return this.atomParsers[atom.header.name](remaining);
          }
          debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);
          await this.tokenizer.ignore(remaining);
        }
        getTrackDescription() {
          return this.tracks[this.tracks.length - 1];
        }
        calculateBitRate() {
          if (this.audioLengthInBytes && this.metadata.format.duration) {
            this.metadata.setFormat("bitrate", 8 * this.audioLengthInBytes / this.metadata.format.duration);
          }
        }
        async addTag(id, value) {
          await this.metadata.addTag(tagFormat, id, value);
        }
        addWarning(message) {
          debug(`Warning: ${message}`);
          this.metadata.addWarning(message);
        }
parseMetadataItemData(metaAtom) {
          let tagKey = metaAtom.header.name;
          return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {
            const payLoadLength = child.getPayloadLength(remaining);
            switch (child.header.name) {
              case "data":
                return this.parseValueAtom(tagKey, child);
              case "name":
case "mean":
              case "rate": {
                const name = await this.tokenizer.readToken(new NameAtom(payLoadLength));
                tagKey += `:${name.name}`;
                break;
              }
              default: {
                const uint8Array = await this.tokenizer.readToken(new Uint8ArrayType(payLoadLength));
                this.addWarning(`Unsupported meta-item: ${tagKey}[${child.header.name}] => value=${uint8ArrayToHex(uint8Array)} ascii=${uint8ArrayToString(uint8Array, "ascii")}`);
              }
            }
          }, metaAtom.getPayloadLength(0));
        }
        async parseValueAtom(tagKey, metaAtom) {
          const dataAtom = await this.tokenizer.readToken(new DataAtom(Number(metaAtom.header.length) - Header.len));
          if (dataAtom.type.set !== 0) {
            throw new Mp4ContentError(`Unsupported type-set != 0: ${dataAtom.type.set}`);
          }
          switch (dataAtom.type.type) {
            case 0:
              switch (tagKey) {
                case "trkn":
                case "disk": {
                  const num = UINT8.get(dataAtom.value, 3);
                  const of = UINT8.get(dataAtom.value, 5);
                  await this.addTag(tagKey, `${num}/${of}`);
                  break;
                }
                case "gnre": {
                  const genreInt = UINT8.get(dataAtom.value, 1);
                  const genreStr = Genres[genreInt - 1];
                  await this.addTag(tagKey, genreStr);
                  break;
                }
                case "rate": {
                  const rate = new TextDecoder("ascii").decode(dataAtom.value);
                  await this.addTag(tagKey, rate);
                  break;
                }
                default:
                  debug(`unknown proprietary value type for: ${metaAtom.atomPath}`);
              }
              break;
            case 1:
case 18:
              await this.addTag(tagKey, new TextDecoder("utf-8").decode(dataAtom.value));
              break;
            case 13:
              if (this.options.skipCovers)
                break;
              await this.addTag(tagKey, {
                format: "image/jpeg",
                data: Uint8Array.from(dataAtom.value)
              });
              break;
            case 14:
              if (this.options.skipCovers)
                break;
              await this.addTag(tagKey, {
                format: "image/png",
                data: Uint8Array.from(dataAtom.value)
              });
              break;
            case 21:
              await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));
              break;
            case 22:
              await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));
              break;
            case 65:
              await this.addTag(tagKey, UINT8.get(dataAtom.value, 0));
              break;
            case 66:
              await this.addTag(tagKey, UINT16_BE.get(dataAtom.value, 0));
              break;
            case 67:
              await this.addTag(tagKey, UINT32_BE.get(dataAtom.value, 0));
              break;
            default:
              this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);
          }
        }
parseSoundSampleDescription(sampleDescription) {
          const ssd = {
            dataFormat: sampleDescription.dataFormat,
            dataReferenceIndex: sampleDescription.dataReferenceIndex
          };
          let offset = 0;
          if (sampleDescription.description) {
            const version = SoundSampleDescriptionVersion.get(sampleDescription.description, offset);
            offset += SoundSampleDescriptionVersion.len;
            if (version.version === 0 || version.version === 1) {
              ssd.description = SoundSampleDescriptionV0.get(sampleDescription.description, offset);
            } else {
              debug(`Warning: sound-sample-description ${version} not implemented`);
            }
          }
          return ssd;
        }
        async parseChapterTrack(chapterTrack, track, len) {
          if (!chapterTrack.sampleSize) {
            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)
              throw new Error("Expected equal chunk-offset-table & sample-size-table length.");
          }
          const chapters = [];
          for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {
            const start = chapterTrack.timeToSampleTable.slice(0, i).reduce((acc, cur) => acc + cur.duration, 0);
            const chunkOffset = chapterTrack.chunkOffsetTable[i];
            const nextChunkLen = chunkOffset - this.tokenizer.position;
            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];
            len -= nextChunkLen + sampleSize;
            if (len < 0)
              throw new Mp4ContentError("Chapter chunk exceeding token length");
            await this.tokenizer.ignore(nextChunkLen);
            const title = await this.tokenizer.readToken(new ChapterText(sampleSize));
            debug(`Chapter ${i + 1}: ${title}`);
            const chapter = {
              title,
              timeScale: chapterTrack.timeScale,
              start,
              sampleOffset: this.findSampleOffset(track, this.tokenizer.position)
            };
            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);
            chapters.push(chapter);
          }
          this.metadata.setFormat("chapters", chapters);
          await this.tokenizer.ignore(len);
        }
        findSampleOffset(track, chapterOffset) {
          let totalDuration = 0;
          track.timeToSampleTable.forEach((e) => {
            totalDuration += e.count * e.duration;
          });
          debug(`Total duration=${totalDuration}`);
          let chunkIndex = 0;
          while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {
            ++chunkIndex;
          }
          return this.getChunkDuration(chunkIndex + 1, track);
        }
        getChunkDuration(chunkId, track) {
          let ttsi = 0;
          let ttsc = track.timeToSampleTable[ttsi].count;
          let ttsd = track.timeToSampleTable[ttsi].duration;
          let curChunkId = 1;
          let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
          let totalDuration = 0;
          while (curChunkId < chunkId) {
            const nrOfSamples = Math.min(ttsc, samplesPerChunk);
            totalDuration += nrOfSamples * ttsd;
            ttsc -= nrOfSamples;
            samplesPerChunk -= nrOfSamples;
            if (samplesPerChunk === 0) {
              ++curChunkId;
              samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
            } else {
              ++ttsi;
              ttsc = track.timeToSampleTable[ttsi].count;
              ttsd = track.timeToSampleTable[ttsi].duration;
            }
          }
          return totalDuration;
        }
        getSamplesPerChunk(chunkId, stcTable) {
          for (let i = 0; i < stcTable.length - 1; ++i) {
            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {
              return stcTable[i].samplesPerChunk;
            }
          }
          return stcTable[stcTable.length - 1].samplesPerChunk;
        }
      } exports("MP4Parser", MP4Parser);

    })
  };
}));

System.register("./MusepackParser-CH73a0C_-C0L_t5L8.js", ['./__monkey.entry-DKLp9CGx.js', './AbstractID3Parser-Besqtu1X-CrHsEW-u.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge', './ID3v2Parser-Bm2mHbjm-CPeRbws5.js'], (function (exports, module) {
  'use strict';
  var StringType, initDebug, makeUnexpectedFileContentError, BasicParser, FourCcToken, APEv2Parser, UINT8, isBitSet$1, UINT32_LE, UINT16_LE, getBitAllignedNumber, AbstractID3Parser;
  return {
    setters: [module => {
      StringType = module.S;
      initDebug = module.i;
      makeUnexpectedFileContentError = module.m;
      BasicParser = module.B;
      FourCcToken = module.F;
      APEv2Parser = module.J;
      UINT8 = module.d;
      isBitSet$1 = module.a;
      UINT32_LE = module.e;
      UINT16_LE = module.k;
      getBitAllignedNumber = module.g;
    }, module => {
      AbstractID3Parser = module.A;
    }, null, null, null, null, null, null],
    execute: (function () {

      const debug$3 = initDebug("music-metadata:parser:musepack:sv8");
      const PacketKey = new StringType(2, "latin1");
      const SH_part1 = {
        len: 5,
        get: (buf, off) => {
          return {
            crc: UINT32_LE.get(buf, off),
            streamVersion: UINT8.get(buf, off + 4)
          };
        }
      };
      const SH_part3 = {
        len: 2,
        get: (buf, off) => {
          return {
            sampleFrequency: [44100, 48e3, 37800, 32e3][getBitAllignedNumber(buf, off, 0, 3)],
            maxUsedBands: getBitAllignedNumber(buf, off, 3, 5),
            channelCount: getBitAllignedNumber(buf, off + 1, 0, 4) + 1,
            msUsed: isBitSet$1(buf, off + 1, 4),
            audioBlockFrames: getBitAllignedNumber(buf, off + 1, 5, 3)
          };
        }
      };
      class StreamReader {
        get tokenizer() {
          return this._tokenizer;
        }
        set tokenizer(value) {
          this._tokenizer = value;
        }
        constructor(_tokenizer) {
          this._tokenizer = _tokenizer;
        }
        async readPacketHeader() {
          const key = await this.tokenizer.readToken(PacketKey);
          const size = await this.readVariableSizeField();
          return {
            key,
            payloadLength: size.value - 2 - size.len
          };
        }
        async readStreamHeader(size) {
          const streamHeader = {};
          debug$3(`Reading SH at offset=${this.tokenizer.position}`);
          const part1 = await this.tokenizer.readToken(SH_part1);
          size -= SH_part1.len;
          Object.assign(streamHeader, part1);
          debug$3(`SH.streamVersion = ${part1.streamVersion}`);
          const sampleCount = await this.readVariableSizeField();
          size -= sampleCount.len;
          streamHeader.sampleCount = sampleCount.value;
          const bs = await this.readVariableSizeField();
          size -= bs.len;
          streamHeader.beginningOfSilence = bs.value;
          const part3 = await this.tokenizer.readToken(SH_part3);
          size -= SH_part3.len;
          Object.assign(streamHeader, part3);
          await this.tokenizer.ignore(size);
          return streamHeader;
        }
        async readVariableSizeField(len = 1, hb = 0) {
          let n = await this.tokenizer.readNumber(UINT8);
          if ((n & 128) === 0) {
            return { len, value: hb + n };
          }
          n &= 127;
          n += hb;
          return this.readVariableSizeField(len + 1, n << 7);
        }
      }
      class MusepackContentError extends makeUnexpectedFileContentError("Musepack") {
      }
      const debug$2 = initDebug("music-metadata:parser:musepack");
      class MpcSv8Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.audioLength = 0;
        }
        async parse() {
          const signature = await this.tokenizer.readToken(FourCcToken);
          if (signature !== "MPCK")
            throw new MusepackContentError("Invalid Magic number");
          this.metadata.setFormat("container", "Musepack, SV8");
          return this.parsePacket();
        }
        async parsePacket() {
          const sv8reader = new StreamReader(this.tokenizer);
          do {
            const header = await sv8reader.readPacketHeader();
            debug$2(`packet-header key=${header.key}, payloadLength=${header.payloadLength}`);
            switch (header.key) {
              case "SH": {
                const sh = await sv8reader.readStreamHeader(header.payloadLength);
                this.metadata.setFormat("numberOfSamples", sh.sampleCount);
                this.metadata.setFormat("sampleRate", sh.sampleFrequency);
                this.metadata.setFormat("duration", sh.sampleCount / sh.sampleFrequency);
                this.metadata.setFormat("numberOfChannels", sh.channelCount);
                break;
              }
              case "AP":
                this.audioLength += header.payloadLength;
                await this.tokenizer.ignore(header.payloadLength);
                break;
              case "RG":
case "EI":
case "SO":
case "ST":
case "CT":
                await this.tokenizer.ignore(header.payloadLength);
                break;
              case "SE":
                if (this.metadata.format.duration) {
                  this.metadata.setFormat("bitrate", this.audioLength * 8 / this.metadata.format.duration);
                }
                return APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
              default:
                throw new MusepackContentError(`Unexpected header: ${header.key}`);
            }
          } while (true);
        }
      }
      class BitReader {
        constructor(tokenizer) {
          this.pos = 0;
          this.dword = null;
          this.tokenizer = tokenizer;
        }
async read(bits) {
          while (this.dword === null) {
            this.dword = await this.tokenizer.readToken(UINT32_LE);
          }
          let out = this.dword;
          this.pos += bits;
          if (this.pos < 32) {
            out >>>= 32 - this.pos;
            return out & (1 << bits) - 1;
          }
          this.pos -= 32;
          if (this.pos === 0) {
            this.dword = null;
            return out & (1 << bits) - 1;
          }
          this.dword = await this.tokenizer.readToken(UINT32_LE);
          if (this.pos) {
            out <<= this.pos;
            out |= this.dword >>> 32 - this.pos;
          }
          return out & (1 << bits) - 1;
        }
        async ignore(bits) {
          if (this.pos > 0) {
            const remaining = 32 - this.pos;
            this.dword = null;
            bits -= remaining;
            this.pos = 0;
          }
          const remainder = bits % 32;
          const numOfWords = (bits - remainder) / 32;
          await this.tokenizer.ignore(numOfWords * 4);
          return this.read(remainder);
        }
      }
      const Header = {
        len: 6 * 4,
        get: (buf, off) => {
          const header = {
signature: new TextDecoder("latin1").decode(buf.subarray(off, off + 3)),
streamMinorVersion: getBitAllignedNumber(buf, off + 3, 0, 4),
            streamMajorVersion: getBitAllignedNumber(buf, off + 3, 4, 4),
frameCount: UINT32_LE.get(buf, off + 4),
maxLevel: UINT16_LE.get(buf, off + 8),
            sampleFrequency: [44100, 48e3, 37800, 32e3][getBitAllignedNumber(buf, off + 10, 0, 2)],
            link: getBitAllignedNumber(buf, off + 10, 2, 2),
            profile: getBitAllignedNumber(buf, off + 10, 4, 4),
            maxBand: getBitAllignedNumber(buf, off + 11, 0, 6),
            intensityStereo: isBitSet$1(buf, off + 11, 6),
            midSideStereo: isBitSet$1(buf, off + 11, 7),
titlePeak: UINT16_LE.get(buf, off + 12),
            titleGain: UINT16_LE.get(buf, off + 14),
albumPeak: UINT16_LE.get(buf, off + 16),
            albumGain: UINT16_LE.get(buf, off + 18),
lastFrameLength: UINT32_LE.get(buf, off + 20) >>> 20 & 2047,
            trueGapless: isBitSet$1(buf, off + 23, 0)
          };
          header.lastFrameLength = header.trueGapless ? UINT32_LE.get(buf, 20) >>> 20 & 2047 : 0;
          return header;
        }
      };
      const debug$1 = initDebug("music-metadata:parser:musepack");
      class MpcSv7Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.bitreader = null;
          this.audioLength = 0;
          this.duration = null;
        }
        async parse() {
          const header = await this.tokenizer.readToken(Header);
          if (header.signature !== "MP+")
            throw new MusepackContentError("Unexpected magic number");
          debug$1(`stream-version=${header.streamMajorVersion}.${header.streamMinorVersion}`);
          this.metadata.setFormat("container", "Musepack, SV7");
          this.metadata.setFormat("sampleRate", header.sampleFrequency);
          const numberOfSamples = 1152 * (header.frameCount - 1) + header.lastFrameLength;
          this.metadata.setFormat("numberOfSamples", numberOfSamples);
          this.duration = numberOfSamples / header.sampleFrequency;
          this.metadata.setFormat("duration", this.duration);
          this.bitreader = new BitReader(this.tokenizer);
          this.metadata.setFormat("numberOfChannels", header.midSideStereo || header.intensityStereo ? 2 : 1);
          const version = await this.bitreader.read(8);
          this.metadata.setFormat("codec", (version / 100).toFixed(2));
          await this.skipAudioData(header.frameCount);
          debug$1(`End of audio stream, switching to APEv2, offset=${this.tokenizer.position}`);
          return APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
        }
        async skipAudioData(frameCount) {
          while (frameCount-- > 0) {
            const frameLength = await this.bitreader.read(20);
            this.audioLength += 20 + frameLength;
            await this.bitreader.ignore(frameLength);
          }
          const lastFrameLength = await this.bitreader.read(11);
          this.audioLength += lastFrameLength;
          if (this.duration !== null) {
            this.metadata.setFormat("bitrate", this.audioLength / this.duration);
          }
        }
      }
      const debug = initDebug("music-metadata:parser:musepack");
      class MusepackParser extends AbstractID3Parser {
        async postId3v2Parse() {
          const signature = await this.tokenizer.peekToken(new StringType(3, "latin1"));
          let mpcParser;
          switch (signature) {
            case "MP+": {
              debug("Stream-version 7");
              mpcParser = new MpcSv7Parser(this.metadata, this.tokenizer, this.options);
              break;
            }
            case "MPC": {
              debug("Stream-version 8");
              mpcParser = new MpcSv8Parser(this.metadata, this.tokenizer, this.options);
              break;
            }
            default: {
              throw new MusepackContentError("Invalid signature prefix");
            }
          }
          return mpcParser.parse();
        }
      } exports("MusepackParser", MusepackParser);

    })
  };
}));

System.register("./AbstractID3Parser-Besqtu1X-CrHsEW-u.js", ['./__monkey.entry-DKLp9CGx.js', './ID3v2Parser-Bm2mHbjm-CPeRbws5.js'], (function (exports, module) {
  'use strict';
  var BasicParser, ID3v2Header, EndOfStreamError, initDebug, ID3v1Parser, ID3v2Parser;
  return {
    setters: [module => {
      BasicParser = module.B;
      ID3v2Header = module.K;
      EndOfStreamError = module.E;
      initDebug = module.i;
      ID3v1Parser = module.L;
    }, module => {
      ID3v2Parser = module.I;
    }],
    execute: (function () {

      const debug = initDebug("music-metadata:parser:ID3");
      class AbstractID3Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.id3parser = new ID3v2Parser();
        }
        static async startsWithID3v2Header(tokenizer) {
          return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === "ID3";
        }
        async parse() {
          try {
            await this.parseID3v2();
          } catch (err) {
            if (err instanceof EndOfStreamError) {
              debug("End-of-stream");
            } else {
              throw err;
            }
          }
        }
        finalize() {
          return;
        }
        async parseID3v2() {
          await this.tryReadId3v2Headers();
          debug("End of ID3v2 header, go to MPEG-parser: pos=%s", this.tokenizer.position);
          await this.postId3v2Parse();
          if (this.options.skipPostHeaders && this.metadata.hasAny()) {
            this.finalize();
          } else {
            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);
            await id3v1parser.parse();
            this.finalize();
          }
        }
        async tryReadId3v2Headers() {
          const id3Header = await this.tokenizer.peekToken(ID3v2Header);
          if (id3Header.fileIdentifier === "ID3") {
            debug("Found ID3v2 header, pos=%s", this.tokenizer.position);
            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);
            return this.tryReadId3v2Headers();
          }
        }
      } exports("A", AbstractID3Parser);

    })
  };
}));

System.register("./OggParser-BylYP5pO-BC5AeNrm.js", ['./__monkey.entry-DKLp9CGx.js', './VorbisParser-CfoG9xo4-TBjWzkgb.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var BasicParser, initDebug, Uint8ArrayType, EndOfStreamError, makeUnexpectedFileContentError, StringType, UINT8, UINT24_BE, UINT16_BE, INT32_LE, trimRightNull, UINT16_LE, UINT32_LE, getBit, FourCcToken, UINT64_LE, VorbisParser;
  return {
    setters: [module => {
      BasicParser = module.B;
      initDebug = module.i;
      Uint8ArrayType = module.U;
      EndOfStreamError = module.E;
      makeUnexpectedFileContentError = module.m;
      StringType = module.S;
      UINT8 = module.d;
      UINT24_BE = module.r;
      UINT16_BE = module.c;
      INT32_LE = module.q;
      trimRightNull = module.M;
      UINT16_LE = module.k;
      UINT32_LE = module.e;
      getBit = module.j;
      FourCcToken = module.F;
      UINT64_LE = module.f;
    }, module => {
      VorbisParser = module.V;
    }, null, null, null, null, null],
    execute: (function () {

      class OpusContentError extends makeUnexpectedFileContentError("Opus") {
      }
      class IdHeader {
        constructor(len) {
          if (len < 19) {
            throw new OpusContentError("ID-header-page 0 should be at least 19 bytes long");
          }
          this.len = len;
        }
        get(buf, off) {
          return {
            magicSignature: new StringType(8, "ascii").get(buf, off + 0),
            version: UINT8.get(buf, off + 8),
            channelCount: UINT8.get(buf, off + 9),
            preSkip: UINT16_LE.get(buf, off + 10),
            inputSampleRate: UINT32_LE.get(buf, off + 12),
            outputGain: UINT16_LE.get(buf, off + 16),
            channelMapping: UINT8.get(buf, off + 18)
          };
        }
      }
      class OpusParser extends VorbisParser {
        constructor(metadata, options, tokenizer) {
          super(metadata, options);
          this.idHeader = null;
          this.lastPos = -1;
          this.tokenizer = tokenizer;
        }
parseFirstPage(header, pageData) {
          this.metadata.setFormat("codec", "Opus");
          this.idHeader = new IdHeader(pageData.length).get(pageData, 0);
          if (this.idHeader.magicSignature !== "OpusHead")
            throw new OpusContentError("Illegal ogg/Opus magic-signature");
          this.metadata.setFormat("sampleRate", this.idHeader.inputSampleRate);
          this.metadata.setFormat("numberOfChannels", this.idHeader.channelCount);
        }
        async parseFullPage(pageData) {
          const magicSignature = new StringType(8, "ascii").get(pageData, 0);
          switch (magicSignature) {
            case "OpusTags":
              await this.parseUserCommentList(pageData, 8);
              this.lastPos = this.tokenizer.position - pageData.length;
              break;
          }
        }
        calculateDuration(header) {
          if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {
            const pos_48bit = header.absoluteGranulePosition - this.idHeader.preSkip;
            this.metadata.setFormat("numberOfSamples", pos_48bit);
            this.metadata.setFormat("duration", pos_48bit / 48e3);
            if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {
              const dataSize = this.tokenizer.fileInfo.size - this.lastPos;
              this.metadata.setFormat("bitrate", 8 * dataSize / this.metadata.format.duration);
            }
          }
        }
      }
      const Header = {
        len: 80,
        get: (buf, off) => {
          return {
            speex: new StringType(8, "ascii").get(buf, off + 0),
            version: trimRightNull(new StringType(20, "ascii").get(buf, off + 8)),
            version_id: INT32_LE.get(buf, off + 28),
            header_size: INT32_LE.get(buf, off + 32),
            rate: INT32_LE.get(buf, off + 36),
            mode: INT32_LE.get(buf, off + 40),
            mode_bitstream_version: INT32_LE.get(buf, off + 44),
            nb_channels: INT32_LE.get(buf, off + 48),
            bitrate: INT32_LE.get(buf, off + 52),
            frame_size: INT32_LE.get(buf, off + 56),
            vbr: INT32_LE.get(buf, off + 60),
            frames_per_packet: INT32_LE.get(buf, off + 64),
            extra_headers: INT32_LE.get(buf, off + 68),
            reserved1: INT32_LE.get(buf, off + 72),
            reserved2: INT32_LE.get(buf, off + 76)
          };
        }
      };
      const debug$2 = initDebug("music-metadata:parser:ogg:speex");
      class SpeexParser extends VorbisParser {
        constructor(metadata, options, tokenizer) {
          super(metadata, options);
          this.tokenizer = tokenizer;
        }
parseFirstPage(header, pageData) {
          debug$2("First Ogg/Speex page");
          const speexHeader = Header.get(pageData, 0);
          this.metadata.setFormat("codec", `Speex ${speexHeader.version}`);
          this.metadata.setFormat("numberOfChannels", speexHeader.nb_channels);
          this.metadata.setFormat("sampleRate", speexHeader.rate);
          if (speexHeader.bitrate !== -1) {
            this.metadata.setFormat("bitrate", speexHeader.bitrate);
          }
        }
      }
      const IdentificationHeader = {
        len: 42,
        get: (buf, off) => {
          return {
            id: new StringType(7, "ascii").get(buf, off),
            vmaj: UINT8.get(buf, off + 7),
            vmin: UINT8.get(buf, off + 8),
            vrev: UINT8.get(buf, off + 9),
            vmbw: UINT16_BE.get(buf, off + 10),
            vmbh: UINT16_BE.get(buf, off + 17),
            nombr: UINT24_BE.get(buf, off + 37),
            nqual: UINT8.get(buf, off + 40)
          };
        }
      };
      const debug$1 = initDebug("music-metadata:parser:ogg:theora");
      class TheoraParser {
        constructor(metadata, options, tokenizer) {
          this.metadata = metadata;
          this.tokenizer = tokenizer;
        }
async parsePage(header, pageData) {
          if (header.headerType.firstPage) {
            await this.parseFirstPage(header, pageData);
          }
        }
        async flush() {
          debug$1("flush");
        }
        calculateDuration(header) {
          debug$1("duration calculation not implemented");
        }
async parseFirstPage(header, pageData) {
          debug$1("First Ogg/Theora page");
          this.metadata.setFormat("codec", "Theora");
          const idHeader = IdentificationHeader.get(pageData, 0);
          this.metadata.setFormat("bitrate", idHeader.nombr);
        }
      }
      class OggContentError extends makeUnexpectedFileContentError("Ogg") {
      } exports("OggContentError", OggContentError);
      const debug = initDebug("music-metadata:parser:ogg");
      class SegmentTable {
        static sum(buf, off, len) {
          const dv = new DataView(buf.buffer, 0);
          let s = 0;
          for (let i = off; i < off + len; ++i) {
            s += dv.getUint8(i);
          }
          return s;
        }
        constructor(header) {
          this.len = header.page_segments;
        }
        get(buf, off) {
          return {
            totalPageSize: SegmentTable.sum(buf, off, this.len)
          };
        }
      } exports("SegmentTable", SegmentTable);
      class OggParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.header = null;
          this.pageNumber = 0;
          this.pageConsumer = null;
        }
async parse() {
          debug("pos=%s, parsePage()", this.tokenizer.position);
          try {
            let header;
            do {
              header = await this.tokenizer.readToken(OggParser.Header);
              if (header.capturePattern !== "OggS")
                throw new OggContentError("Invalid Ogg capture pattern");
              this.metadata.setFormat("container", "Ogg");
              this.header = header;
              this.pageNumber = header.pageSequenceNo;
              debug("page#=%s, Ogg.id=%s", header.pageSequenceNo, header.capturePattern);
              const segmentTable = await this.tokenizer.readToken(new SegmentTable(header));
              debug("totalPageSize=%s", segmentTable.totalPageSize);
              const pageData = await this.tokenizer.readToken(new Uint8ArrayType(segmentTable.totalPageSize));
              debug("firstPage=%s, lastPage=%s, continued=%s", header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);
              if (header.headerType.firstPage) {
                const id = new TextDecoder("ascii").decode(pageData.subarray(0, 7));
                switch (id) {
                  case "vorbis":
                    debug("Set page consumer to Ogg/Vorbis");
                    this.pageConsumer = new VorbisParser(this.metadata, this.options);
                    break;
                  case "OpusHea":
                    debug("Set page consumer to Ogg/Opus");
                    this.pageConsumer = new OpusParser(this.metadata, this.options, this.tokenizer);
                    break;
                  case "Speex  ":
                    debug("Set page consumer to Ogg/Speex");
                    this.pageConsumer = new SpeexParser(this.metadata, this.options, this.tokenizer);
                    break;
                  case "fishead":
                  case "\0theora":
                    debug("Set page consumer to Ogg/Theora");
                    this.pageConsumer = new TheoraParser(this.metadata, this.options, this.tokenizer);
                    break;
                  default:
                    throw new OggContentError(`gg audio-codec not recognized (id=${id})`);
                }
              }
              await this.pageConsumer.parsePage(header, pageData);
            } while (!header.headerType.lastPage);
          } catch (err) {
            if (err instanceof Error) {
              if (err instanceof EndOfStreamError) {
                this.metadata.addWarning("Last OGG-page is not marked with last-page flag");
                debug("End-of-stream");
                this.metadata.addWarning("Last OGG-page is not marked with last-page flag");
                if (this.header) {
                  this.pageConsumer.calculateDuration(this.header);
                }
              } else if (err.message.startsWith("FourCC")) {
                if (this.pageNumber > 0) {
                  this.metadata.addWarning("Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag");
                  await this.pageConsumer.flush();
                }
              }
            } else
              throw err;
          }
        }
      } exports("OggParser", OggParser);
      OggParser.Header = {
        len: 27,
        get: (buf, off) => {
          return {
            capturePattern: FourCcToken.get(buf, off),
            version: UINT8.get(buf, off + 4),
            headerType: {
              continued: getBit(buf, off + 5, 0),
              firstPage: getBit(buf, off + 5, 1),
              lastPage: getBit(buf, off + 5, 2)
            },
absoluteGranulePosition: Number(UINT64_LE.get(buf, off + 6)),
            streamSerialNumber: UINT32_LE.get(buf, off + 14),
            pageSequenceNo: UINT32_LE.get(buf, off + 18),
            pageChecksum: UINT32_LE.get(buf, off + 22),
            page_segments: UINT8.get(buf, off + 26)
          };
        }
      };

    })
  };
}));

System.register("./VorbisParser-CfoG9xo4-TBjWzkgb.js", ['./__monkey.entry-DKLp9CGx.js'], (function (exports, module) {
  'use strict';
  var initDebug, UINT32_LE, AttachedPictureType, UINT32_BE, StringType, makeUnexpectedFileContentError, UINT8;
  return {
    setters: [module => {
      initDebug = module.i;
      UINT32_LE = module.e;
      AttachedPictureType = module.A;
      UINT32_BE = module.b;
      StringType = module.S;
      makeUnexpectedFileContentError = module.m;
      UINT8 = module.d;
    }],
    execute: (function () {

      class VorbisPictureToken {
        static fromBase64(base64str) {
          return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), (c) => c.charCodeAt(0)));
        }
        static fromBuffer(buffer) {
          const pic = new VorbisPictureToken(buffer.length);
          return pic.get(buffer, 0);
        }
        constructor(len) {
          this.len = len;
        }
        get(buffer, offset) {
          const type = AttachedPictureType[UINT32_BE.get(buffer, offset)];
          offset += 4;
          const mimeLen = UINT32_BE.get(buffer, offset);
          offset += 4;
          const format = new StringType(mimeLen, "utf-8").get(buffer, offset);
          offset += mimeLen;
          const descLen = UINT32_BE.get(buffer, offset);
          offset += 4;
          const description = new StringType(descLen, "utf-8").get(buffer, offset);
          offset += descLen;
          const width = UINT32_BE.get(buffer, offset);
          offset += 4;
          const height = UINT32_BE.get(buffer, offset);
          offset += 4;
          const colour_depth = UINT32_BE.get(buffer, offset);
          offset += 4;
          const indexed_color = UINT32_BE.get(buffer, offset);
          offset += 4;
          const picDataLen = UINT32_BE.get(buffer, offset);
          offset += 4;
          const data = Uint8Array.from(buffer.slice(offset, offset + picDataLen));
          return {
            type,
            format,
            description,
            width,
            height,
            colour_depth,
            indexed_color,
            data
          };
        }
      } exports("b", VorbisPictureToken);
      const CommonHeader = {
        len: 7,
        get: (buf, off) => {
          return {
            packetType: UINT8.get(buf, off),
            vorbis: new StringType(6, "ascii").get(buf, off + 1)
          };
        }
      };
      const IdentificationHeader = {
        len: 23,
        get: (uint8Array, off) => {
          return {
            version: UINT32_LE.get(uint8Array, off + 0),
            channelMode: UINT8.get(uint8Array, off + 4),
            sampleRate: UINT32_LE.get(uint8Array, off + 5),
            bitrateMax: UINT32_LE.get(uint8Array, off + 9),
            bitrateNominal: UINT32_LE.get(uint8Array, off + 13),
            bitrateMin: UINT32_LE.get(uint8Array, off + 17)
          };
        }
      };
      class VorbisDecoder {
        constructor(data, offset) {
          this.data = data;
          this.offset = offset;
        }
        readInt32() {
          const value = UINT32_LE.get(this.data, this.offset);
          this.offset += 4;
          return value;
        }
        readStringUtf8() {
          const len = this.readInt32();
          const value = new TextDecoder("utf-8").decode(this.data.subarray(this.offset, this.offset + len));
          this.offset += len;
          return value;
        }
        parseUserComment() {
          const offset0 = this.offset;
          const v = this.readStringUtf8();
          const idx = v.indexOf("=");
          return {
            key: v.slice(0, idx).toUpperCase(),
            value: v.slice(idx + 1),
            len: this.offset - offset0
          };
        }
      } exports("a", VorbisDecoder);
      const debug = initDebug("music-metadata:parser:ogg:vorbis1");
      class VorbisContentError extends makeUnexpectedFileContentError("Vorbis") {
      }
      class VorbisParser {
        constructor(metadata, options) {
          this.pageSegments = [];
          this.metadata = metadata;
          this.options = options;
        }
async parsePage(header, pageData) {
          if (header.headerType.firstPage) {
            this.parseFirstPage(header, pageData);
          } else {
            if (header.headerType.continued) {
              if (this.pageSegments.length === 0) {
                throw new VorbisContentError("Cannot continue on previous page");
              }
              this.pageSegments.push(pageData);
            }
            if (header.headerType.lastPage || !header.headerType.continued) {
              if (this.pageSegments.length > 0) {
                const fullPage = VorbisParser.mergeUint8Arrays(this.pageSegments);
                await this.parseFullPage(fullPage);
              }
              this.pageSegments = header.headerType.lastPage ? [] : [pageData];
            }
          }
          if (header.headerType.lastPage) {
            this.calculateDuration(header);
          }
        }
        static mergeUint8Arrays(arrays) {
          const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);
          const merged = new Uint8Array(totalSize);
          arrays.forEach((array, i, _arrays) => {
            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);
            merged.set(array, offset);
          });
          return merged;
        }
        async flush() {
          await this.parseFullPage(VorbisParser.mergeUint8Arrays(this.pageSegments));
        }
        async parseUserComment(pageData, offset) {
          const decoder = new VorbisDecoder(pageData, offset);
          const tag = decoder.parseUserComment();
          await this.addTag(tag.key, tag.value);
          return tag.len;
        }
        async addTag(id, value) {
          if (id === "METADATA_BLOCK_PICTURE" && typeof value === "string") {
            if (this.options.skipCovers) {
              debug("Ignore picture");
              return;
            }
            value = VorbisPictureToken.fromBase64(value);
            debug(`Push picture: id=${id}, format=${value.format}`);
          } else {
            debug(`Push tag: id=${id}, value=${value}`);
          }
          await this.metadata.addTag("vorbis", id, value);
        }
        calculateDuration(header) {
          if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {
            this.metadata.setFormat("numberOfSamples", header.absoluteGranulePosition);
            this.metadata.setFormat("duration", header.absoluteGranulePosition / this.metadata.format.sampleRate);
          }
        }
parseFirstPage(header, pageData) {
          this.metadata.setFormat("codec", "Vorbis I");
          debug("Parse first page");
          const commonHeader = CommonHeader.get(pageData, 0);
          if (commonHeader.vorbis !== "vorbis")
            throw new VorbisContentError("Metadata does not look like Vorbis");
          if (commonHeader.packetType === 1) {
            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);
            this.metadata.setFormat("sampleRate", idHeader.sampleRate);
            this.metadata.setFormat("bitrate", idHeader.bitrateNominal);
            this.metadata.setFormat("numberOfChannels", idHeader.channelMode);
            debug("sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);
          } else
            throw new VorbisContentError("First Ogg page should be type 1: the identification header");
        }
        async parseFullPage(pageData) {
          const commonHeader = CommonHeader.get(pageData, 0);
          debug("Parse full page: type=%s, byteLength=%s", commonHeader.packetType, pageData.byteLength);
          switch (commonHeader.packetType) {
            case 3:
              return this.parseUserCommentList(pageData, CommonHeader.len);
          }
        }
async parseUserCommentList(pageData, offset) {
          const strLen = UINT32_LE.get(pageData, offset);
          offset += 4;
          offset += strLen;
          let userCommentListLength = UINT32_LE.get(pageData, offset);
          offset += 4;
          while (userCommentListLength-- > 0) {
            offset += await this.parseUserComment(pageData, offset);
          }
        }
      } exports("V", VorbisParser);

    })
  };
}));

System.register("./WavPackParser-COdXYliS-Cq5Wc3fD.js", ['./__monkey.entry-DKLp9CGx.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var BasicParser, APEv2Parser, FourCcToken, initDebug, UINT24_LE, UINT8, uint8ArrayToHex, UINT32_LE, Uint8ArrayType, UINT16_LE, makeUnexpectedFileContentError;
  return {
    setters: [module => {
      BasicParser = module.B;
      APEv2Parser = module.J;
      FourCcToken = module.F;
      initDebug = module.i;
      UINT24_LE = module.N;
      UINT8 = module.d;
      uint8ArrayToHex = module.u;
      UINT32_LE = module.e;
      Uint8ArrayType = module.U;
      UINT16_LE = module.k;
      makeUnexpectedFileContentError = module.m;
    }, null, null, null, null, null],
    execute: (function () {

      const SampleRates = [
        6e3,
        8e3,
        9600,
        11025,
        12e3,
        16e3,
        22050,
        24e3,
        32e3,
        44100,
        48e3,
        64e3,
        88200,
        96e3,
        192e3,
        -1
      ];
      const BlockHeaderToken = {
        len: 32,
        get: (buf, off) => {
          const flags = UINT32_LE.get(buf, off + 24);
          const res = {
BlockID: FourCcToken.get(buf, off),
blockSize: UINT32_LE.get(buf, off + 4),
version: UINT16_LE.get(buf, off + 8),
totalSamples: (
UINT32_LE.get(buf, off + 12)
            ),
blockIndex: (
UINT32_LE.get(buf, off + 16)
            ),
blockSamples: UINT32_LE.get(buf, off + 20),
flags: {
              bitsPerSample: (1 + getBitAllignedNumber(flags, 0, 2)) * 8,
              isMono: isBitSet(flags, 2),
              isHybrid: isBitSet(flags, 3),
              isJointStereo: isBitSet(flags, 4),
              crossChannel: isBitSet(flags, 5),
              hybridNoiseShaping: isBitSet(flags, 6),
              floatingPoint: isBitSet(flags, 7),
              samplingRate: SampleRates[getBitAllignedNumber(flags, 23, 4)],
              isDSD: isBitSet(flags, 31)
            },
crc: new Uint8ArrayType(4).get(buf, off + 28)
          };
          if (res.flags.isDSD) {
            res.totalSamples *= 8;
          }
          return res;
        }
      };
      const MetadataIdToken = {
        len: 1,
        get: (buf, off) => {
          return {
            functionId: getBitAllignedNumber(buf[off], 0, 6),
isOptional: isBitSet(buf[off], 5),
            isOddSize: isBitSet(buf[off], 6),
            largeBlock: isBitSet(buf[off], 7)
          };
        }
      };
      function isBitSet(flags, bitOffset) {
        return getBitAllignedNumber(flags, bitOffset, 1) === 1;
      }
      function getBitAllignedNumber(flags, bitOffset, len) {
        return flags >>> bitOffset & 4294967295 >>> 32 - len;
      }
      const debug = initDebug("music-metadata:parser:WavPack");
      class WavPackContentError extends makeUnexpectedFileContentError("WavPack") {
      } exports("WavPackContentError", WavPackContentError);
      class WavPackParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.audioDataSize = 0;
        }
        async parse() {
          this.audioDataSize = 0;
          await this.parseWavPackBlocks();
          return APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
        }
        async parseWavPackBlocks() {
          do {
            const blockId = await this.tokenizer.peekToken(FourCcToken);
            if (blockId !== "wvpk")
              break;
            const header = await this.tokenizer.readToken(BlockHeaderToken);
            if (header.BlockID !== "wvpk")
              throw new WavPackContentError("Invalid WavPack Block-ID");
            debug(`WavPack header blockIndex=${header.blockIndex}, len=${BlockHeaderToken.len}`);
            if (header.blockIndex === 0 && !this.metadata.format.container) {
              this.metadata.setFormat("container", "WavPack");
              this.metadata.setFormat("lossless", !header.flags.isHybrid);
              this.metadata.setFormat("bitsPerSample", header.flags.bitsPerSample);
              if (!header.flags.isDSD) {
                this.metadata.setFormat("sampleRate", header.flags.samplingRate);
                this.metadata.setFormat("duration", header.totalSamples / header.flags.samplingRate);
              }
              this.metadata.setFormat("numberOfChannels", header.flags.isMono ? 1 : 2);
              this.metadata.setFormat("numberOfSamples", header.totalSamples);
              this.metadata.setFormat("codec", header.flags.isDSD ? "DSD" : "PCM");
            }
            const ignoreBytes = header.blockSize - (BlockHeaderToken.len - 8);
            await (header.blockIndex === 0 ? this.parseMetadataSubBlock(header, ignoreBytes) : this.tokenizer.ignore(ignoreBytes));
            if (header.blockSamples > 0) {
              this.audioDataSize += header.blockSize;
            }
          } while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= BlockHeaderToken.len);
          if (this.metadata.format.duration) {
            this.metadata.setFormat("bitrate", this.audioDataSize * 8 / this.metadata.format.duration);
          }
        }
async parseMetadataSubBlock(header, remainingLength) {
          let remaining = remainingLength;
          while (remaining > MetadataIdToken.len) {
            const id = await this.tokenizer.readToken(MetadataIdToken);
            const dataSizeInWords = await this.tokenizer.readNumber(id.largeBlock ? UINT24_LE : UINT8);
            const data = new Uint8Array(dataSizeInWords * 2 - (id.isOddSize ? 1 : 0));
            await this.tokenizer.readBuffer(data);
            debug(`Metadata Sub-Blocks functionId=0x${id.functionId.toString(16)}, id.largeBlock=${id.largeBlock},data-size=${data.length}`);
            switch (id.functionId) {
              case 0:
                break;
              case 14: {
                debug("ID_DSD_BLOCK");
                const mp = 1 << UINT8.get(data, 0);
                const samplingRate = header.flags.samplingRate * mp * 8;
                if (!header.flags.isDSD)
                  throw new WavPackContentError("Only expect DSD block if DSD-flag is set");
                this.metadata.setFormat("sampleRate", samplingRate);
                this.metadata.setFormat("duration", header.totalSamples / samplingRate);
                break;
              }
              case 36:
                debug("ID_ALT_TRAILER: trailer for non-wav files");
                break;
              case 38:
                this.metadata.setFormat("audioMD5", data);
                break;
              case 47:
                debug(`ID_BLOCK_CHECKSUM: checksum=${uint8ArrayToHex(data)}`);
                break;
              default:
                debug(`Ignore unsupported meta-sub-block-id functionId=0x${id.functionId.toString(16)}`);
                break;
            }
            remaining -= MetadataIdToken.len + (id.largeBlock ? UINT24_LE.len : UINT8.len) + dataSizeInWords * 2;
            debug(`remainingLength=${remaining}`);
            if (id.isOddSize)
              this.tokenizer.ignore(1);
          }
          if (remaining !== 0)
            throw new WavPackContentError("metadata-sub-block should fit it remaining length");
        }
      } exports("WavPackParser", WavPackParser);

    })
  };
}));

System.register("./WaveParser-_IoaL05V-BBzBiDCR.js", ['./__monkey.entry-DKLp9CGx.js', './ID3v2Parser-Bm2mHbjm-CPeRbws5.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var BasicParser, initDebug, EndOfStreamError, FourCcToken, Uint8ArrayType, fromBuffer, StringType, stripNulls, UINT32_LE, makeUnexpectedFileContentError, UINT16_LE, ID3v2Parser;
  return {
    setters: [module => {
      BasicParser = module.B;
      initDebug = module.i;
      EndOfStreamError = module.E;
      FourCcToken = module.F;
      Uint8ArrayType = module.U;
      fromBuffer = module.n;
      StringType = module.S;
      stripNulls = module.s;
      UINT32_LE = module.e;
      makeUnexpectedFileContentError = module.m;
      UINT16_LE = module.k;
    }, module => {
      ID3v2Parser = module.I;
    }, null, null, null, null, null],
    execute: (function () {

      const Header = {
        len: 8,
        get: (buf, off) => {
          return {
chunkID: new StringType(4, "latin1").get(buf, off),
chunkSize: UINT32_LE.get(buf, off + 4)
          };
        }
      };
      class ListInfoTagValue {
        constructor(tagHeader) {
          this.tagHeader = tagHeader;
          this.len = tagHeader.chunkSize;
          this.len += this.len & 1;
        }
        get(buf, off) {
          return new StringType(this.tagHeader.chunkSize, "ascii").get(buf, off);
        }
      }
      class WaveContentError extends makeUnexpectedFileContentError("Wave") {
      }
      const WaveFormat = {
        PCM: 1,
ADPCM: 2,
        IEEE_FLOAT: 3,
        MPEG_ADTS_AAC: 5632,
        MPEG_LOAS: 5634,
        RAW_AAC1: 255,
DOLBY_AC3_SPDIF: 146,
        DVM: 8192,
        RAW_SPORT: 576,
        ESST_AC3: 577,
        DRM: 9,
        DTS2: 8193,
        MPEG: 80
      };
      const WaveFormatNameMap = {
        [WaveFormat.PCM]: "PCM",
        [WaveFormat.ADPCM]: "ADPCM",
        [WaveFormat.IEEE_FLOAT]: "IEEE_FLOAT",
        [WaveFormat.MPEG_ADTS_AAC]: "MPEG_ADTS_AAC",
        [WaveFormat.MPEG_LOAS]: "MPEG_LOAS",
        [WaveFormat.RAW_AAC1]: "RAW_AAC1",
        [WaveFormat.DOLBY_AC3_SPDIF]: "DOLBY_AC3_SPDIF",
        [WaveFormat.DVM]: "DVM",
        [WaveFormat.RAW_SPORT]: "RAW_SPORT",
        [WaveFormat.ESST_AC3]: "ESST_AC3",
        [WaveFormat.DRM]: "DRM",
        [WaveFormat.DTS2]: "DTS2",
        [WaveFormat.MPEG]: "MPEG"
      };
      class Format {
        constructor(header) {
          if (header.chunkSize < 16)
            throw new WaveContentError("Invalid chunk size");
          this.len = header.chunkSize;
        }
        get(buf, off) {
          return {
            wFormatTag: UINT16_LE.get(buf, off),
            nChannels: UINT16_LE.get(buf, off + 2),
            nSamplesPerSec: UINT32_LE.get(buf, off + 4),
            nAvgBytesPerSec: UINT32_LE.get(buf, off + 8),
            nBlockAlign: UINT16_LE.get(buf, off + 12),
            wBitsPerSample: UINT16_LE.get(buf, off + 14)
          };
        }
      }
      class FactChunk {
        constructor(header) {
          if (header.chunkSize < 4) {
            throw new WaveContentError("Invalid fact chunk size.");
          }
          this.len = header.chunkSize;
        }
        get(buf, off) {
          return {
            dwSampleLength: UINT32_LE.get(buf, off)
          };
        }
      }
      const BroadcastAudioExtensionChunk = {
        len: 420,
        get: (uint8array, off) => {
          return {
            description: stripNulls(new StringType(256, "ascii").get(uint8array, off)).trim(),
            originator: stripNulls(new StringType(32, "ascii").get(uint8array, off + 256)).trim(),
            originatorReference: stripNulls(new StringType(32, "ascii").get(uint8array, off + 288)).trim(),
            originationDate: stripNulls(new StringType(10, "ascii").get(uint8array, off + 320)).trim(),
            originationTime: stripNulls(new StringType(8, "ascii").get(uint8array, off + 330)).trim(),
            timeReferenceLow: UINT32_LE.get(uint8array, off + 338),
            timeReferenceHigh: UINT32_LE.get(uint8array, off + 342),
            version: UINT16_LE.get(uint8array, off + 346),
            umid: new Uint8ArrayType(64).get(uint8array, off + 348),
            loudnessValue: UINT16_LE.get(uint8array, off + 412),
            maxTruePeakLevel: UINT16_LE.get(uint8array, off + 414),
            maxMomentaryLoudness: UINT16_LE.get(uint8array, off + 416),
            maxShortTermLoudness: UINT16_LE.get(uint8array, off + 418)
          };
        }
      };
      const debug = initDebug("music-metadata:parser:RIFF");
      class WaveParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.blockAlign = 0;
        }
        async parse() {
          const riffHeader = await this.tokenizer.readToken(Header);
          debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);
          if (riffHeader.chunkID !== "RIFF")
            return;
          return this.parseRiffChunk(riffHeader.chunkSize).catch((err) => {
            if (!(err instanceof EndOfStreamError)) {
              throw err;
            }
          });
        }
        async parseRiffChunk(chunkSize) {
          const type = await this.tokenizer.readToken(FourCcToken);
          this.metadata.setFormat("container", type);
          switch (type) {
            case "WAVE":
              return this.readWaveChunk(chunkSize - FourCcToken.len);
            default:
              throw new WaveContentError(`Unsupported RIFF format: RIFF/${type}`);
          }
        }
        async readWaveChunk(remaining) {
          while (remaining >= Header.len) {
            const header = await this.tokenizer.readToken(Header);
            remaining -= Header.len + header.chunkSize;
            if (header.chunkSize > remaining) {
              this.metadata.addWarning("Data chunk size exceeds file size");
            }
            this.header = header;
            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);
            switch (header.chunkID) {
              case "LIST":
                await this.parseListTag(header);
                break;
              case "fact":
                this.metadata.setFormat("lossless", false);
                this.fact = await this.tokenizer.readToken(new FactChunk(header));
                break;
              case "fmt ": {
                const fmt = await this.tokenizer.readToken(new Format(header));
                let subFormat = WaveFormatNameMap[fmt.wFormatTag];
                if (!subFormat) {
                  debug(`WAVE/non-PCM format=${fmt.wFormatTag}`);
                  subFormat = `non-PCM (${fmt.wFormatTag})`;
                }
                this.metadata.setFormat("codec", subFormat);
                this.metadata.setFormat("bitsPerSample", fmt.wBitsPerSample);
                this.metadata.setFormat("sampleRate", fmt.nSamplesPerSec);
                this.metadata.setFormat("numberOfChannels", fmt.nChannels);
                this.metadata.setFormat("bitrate", fmt.nBlockAlign * fmt.nSamplesPerSec * 8);
                this.blockAlign = fmt.nBlockAlign;
                break;
              }
              case "id3 ":
case "ID3 ": {
                const id3_data = await this.tokenizer.readToken(new Uint8ArrayType(header.chunkSize));
                const rst = fromBuffer(id3_data);
                await new ID3v2Parser().parse(this.metadata, rst, this.options);
                break;
              }
              case "data": {
                if (this.metadata.format.lossless !== false) {
                  this.metadata.setFormat("lossless", true);
                }
                let chunkSize = header.chunkSize;
                if (this.tokenizer.fileInfo.size) {
                  const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;
                  if (calcRemaining < chunkSize) {
                    this.metadata.addWarning("data chunk length exceeding file length");
                    chunkSize = calcRemaining;
                  }
                }
                const numberOfSamples = this.fact ? this.fact.dwSampleLength : chunkSize === 4294967295 ? void 0 : chunkSize / this.blockAlign;
                if (numberOfSamples) {
                  this.metadata.setFormat("numberOfSamples", numberOfSamples);
                  if (this.metadata.format.sampleRate) {
                    this.metadata.setFormat("duration", numberOfSamples / this.metadata.format.sampleRate);
                  }
                }
                if (this.metadata.format.codec === "ADPCM") {
                  this.metadata.setFormat("bitrate", 352e3);
                } else if (this.metadata.format.sampleRate) {
                  this.metadata.setFormat("bitrate", this.blockAlign * this.metadata.format.sampleRate * 8);
                }
                await this.tokenizer.ignore(header.chunkSize);
                break;
              }
              case "bext": {
                const bext = await this.tokenizer.readToken(BroadcastAudioExtensionChunk);
                Object.keys(bext).forEach((key) => {
                  this.metadata.addTag("exif", `bext.${key}`, bext[key]);
                });
                const bextRemaining = header.chunkSize - BroadcastAudioExtensionChunk.len;
                await this.tokenizer.ignore(bextRemaining);
                break;
              }
              case "\0\0\0\0":
                debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
                this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);
                await this.tokenizer.ignore(header.chunkSize);
                break;
              default:
                debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
                this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);
                await this.tokenizer.ignore(header.chunkSize);
            }
            if (this.header.chunkSize % 2 === 1) {
              debug("Read odd padding byte");
              await this.tokenizer.ignore(1);
            }
          }
        }
        async parseListTag(listHeader) {
          const listType = await this.tokenizer.readToken(new StringType(4, "latin1"));
          debug("pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s", this.tokenizer.position, listType);
          switch (listType) {
            case "INFO":
              return this.parseRiffInfoTags(listHeader.chunkSize - 4);
            default:
              this.metadata.addWarning(`Ignore chunk: RIFF/WAVE/LIST/${listType}`);
              debug(`Ignoring chunkID=RIFF/WAVE/LIST/${listType}`);
              return this.tokenizer.ignore(listHeader.chunkSize - 4).then();
          }
        }
        async parseRiffInfoTags(chunkSize) {
          while (chunkSize >= 8) {
            const header = await this.tokenizer.readToken(Header);
            const valueToken = new ListInfoTagValue(header);
            const value = await this.tokenizer.readToken(valueToken);
            this.addTag(header.chunkID, stripNulls(value));
            chunkSize -= 8 + valueToken.len;
          }
          if (chunkSize !== 0) {
            throw new WaveContentError(`Illegal remaining size: ${chunkSize}`);
          }
        }
        addTag(id, value) {
          this.metadata.addTag("exif", id, value);
        }
      } exports("WaveParser", WaveParser);

    })
  };
}));

System.register("./ID3v2Parser-Bm2mHbjm-CPeRbws5.js", ['./__monkey.entry-DKLp9CGx.js'], (function (exports, module) {
  'use strict';
  var getBit, ID3v2Header, ExtendedHeader, Uint8ArrayType, UINT32SYNCSAFE, UINT32_BE, UINT24_BE, TextEncodingToken, initDebug, decodeString, findZero, UINT8, TextHeader, SyncTextHeader, AttachedPictureType, makeUnexpectedFileContentError, Genres;
  return {
    setters: [module => {
      getBit = module.j;
      ID3v2Header = module.K;
      ExtendedHeader = module.O;
      Uint8ArrayType = module.U;
      UINT32SYNCSAFE = module.P;
      UINT32_BE = module.b;
      UINT24_BE = module.r;
      TextEncodingToken = module.Q;
      initDebug = module.i;
      decodeString = module.l;
      findZero = module.R;
      UINT8 = module.d;
      TextHeader = module.V;
      SyncTextHeader = module.W;
      AttachedPictureType = module.A;
      makeUnexpectedFileContentError = module.m;
      Genres = module.G;
    }],
    execute: (function () {

      const debug = initDebug("music-metadata:id3v2:frame-parser");
      const defaultEnc = "latin1";
      function parseGenre(origVal) {
        const genres = [];
        let code;
        let word = "";
        for (const c of origVal) {
          if (typeof code === "string") {
            if (c === "(" && code === "") {
              word += "(";
              code = void 0;
            } else if (c === ")") {
              if (word !== "") {
                genres.push(word);
                word = "";
              }
              const genre = parseGenreCode(code);
              if (genre) {
                genres.push(genre);
              }
              code = void 0;
            } else
              code += c;
          } else if (c === "(") {
            code = "";
          } else {
            word += c;
          }
        }
        if (word) {
          if (genres.length === 0 && word.match(/^\d*$/)) {
            word = parseGenreCode(word);
          }
          if (word) {
            genres.push(word);
          }
        }
        return genres;
      }
      function parseGenreCode(code) {
        if (code === "RX")
          return "Remix";
        if (code === "CR")
          return "Cover";
        if (code.match(/^\d*$/)) {
          return Genres[Number.parseInt(code)];
        }
      }
      class FrameParser {
constructor(major, warningCollector) {
          this.major = major;
          this.warningCollector = warningCollector;
        }
        readData(uint8Array, type, includeCovers) {
          if (uint8Array.length === 0) {
            this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);
            return;
          }
          const { encoding, bom } = TextEncodingToken.get(uint8Array, 0);
          const length = uint8Array.length;
          let offset = 0;
          let output = [];
          const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);
          let fzero;
          debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);
          switch (type !== "TXXX" && type[0] === "T" ? "T*" : type) {
            case "T*":
case "GRP1":
case "IPLS":
case "MVIN":
            case "MVNM":
            case "PCS":
            case "PCST": {
              let text;
              try {
                text = decodeString(uint8Array.slice(1), encoding).replace(/\x00+$/, "");
              } catch (error) {
                if (error instanceof Error) {
                  this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);
                  break;
                }
                throw error;
              }
              switch (type) {
                case "TMCL":
case "TIPL":
case "IPLS":
                  output = FrameParser.functionList(this.splitValue(type, text));
                  break;
                case "TRK":
                case "TRCK":
                case "TPOS":
                  output = text;
                  break;
                case "TCOM":
                case "TEXT":
                case "TOLY":
                case "TOPE":
                case "TPE1":
                case "TSRC":
                  output = this.splitValue(type, text);
                  break;
                case "TCO":
                case "TCON":
                  output = this.splitValue(type, text).map((v) => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);
                  break;
                case "PCS":
                case "PCST":
                  output = this.major >= 4 ? this.splitValue(type, text) : [text];
                  output = Array.isArray(output) && output[0] === "" ? 1 : 0;
                  break;
                default:
                  output = this.major >= 4 ? this.splitValue(type, text) : [text];
              }
              break;
            }
            case "TXXX": {
              const idAndData = FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);
              const textTag = {
                description: idAndData.id,
                text: this.splitValue(type, decodeString(idAndData.data, encoding).replace(/\x00+$/, ""))
              };
              output = textTag;
              break;
            }
            case "PIC":
            case "APIC":
              if (includeCovers) {
                const pic = {};
                offset += 1;
                switch (this.major) {
                  case 2:
                    pic.format = decodeString(uint8Array.slice(offset, offset + 3), "latin1");
                    offset += 3;
                    break;
                  case 3:
                  case 4:
                    fzero = findZero(uint8Array, offset, length, defaultEnc);
                    pic.format = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
                    offset = fzero + 1;
                    break;
                  default:
                    throw makeUnexpectedMajorVersionError$1(this.major);
                }
                pic.format = FrameParser.fixPictureMimeType(pic.format);
                pic.type = AttachedPictureType[uint8Array[offset]];
                offset += 1;
                fzero = findZero(uint8Array, offset, length, encoding);
                pic.description = decodeString(uint8Array.slice(offset, fzero), encoding);
                offset = fzero + nullTerminatorLength;
                pic.data = uint8Array.slice(offset, length);
                output = pic;
              }
              break;
            case "CNT":
            case "PCNT":
              output = UINT32_BE.get(uint8Array, 0);
              break;
            case "SYLT": {
              const syltHeader = SyncTextHeader.get(uint8Array, 0);
              offset += SyncTextHeader.len;
              const result = {
                descriptor: "",
                language: syltHeader.language,
                contentType: syltHeader.contentType,
                timeStampFormat: syltHeader.timeStampFormat,
                syncText: []
              };
              let readSyllables = false;
              while (offset < length) {
                const nullStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), syltHeader.encoding);
                offset += nullStr.len;
                if (readSyllables) {
                  const timestamp = UINT32_BE.get(uint8Array, offset);
                  offset += UINT32_BE.len;
                  result.syncText.push({
                    text: nullStr.text,
                    timestamp
                  });
                } else {
                  result.descriptor = nullStr.text;
                  readSyllables = true;
                }
              }
              output = result;
              break;
            }
            case "ULT":
            case "USLT":
            case "COM":
            case "COMM": {
              const textHeader = TextHeader.get(uint8Array, offset);
              offset += TextHeader.len;
              const descriptorStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);
              offset += descriptorStr.len;
              const textStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);
              const comment = {
                language: textHeader.language,
                descriptor: descriptorStr.text,
                text: textStr.text
              };
              output = comment;
              break;
            }
            case "UFID": {
              const ufid = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
              output = { owner_identifier: ufid.id, identifier: ufid.data };
              break;
            }
            case "PRIV": {
              const priv = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
              output = { owner_identifier: priv.id, data: priv.data };
              break;
            }
            case "POPM": {
              fzero = findZero(uint8Array, offset, length, defaultEnc);
              const email = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
              offset = fzero + 1;
              const dataLen = length - offset;
              output = {
                email,
                rating: UINT8.get(uint8Array, offset),
                counter: dataLen >= 5 ? UINT32_BE.get(uint8Array, offset + 1) : void 0
              };
              break;
            }
            case "GEOB": {
              fzero = findZero(uint8Array, offset + 1, length, encoding);
              const mimeType = decodeString(uint8Array.slice(offset + 1, fzero), defaultEnc);
              offset = fzero + 1;
              fzero = findZero(uint8Array, offset, length, encoding);
              const filename = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
              offset = fzero + 1;
              fzero = findZero(uint8Array, offset, length, encoding);
              const description = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
              offset = fzero + 1;
              const geob = {
                type: mimeType,
                filename,
                description,
                data: uint8Array.slice(offset, length)
              };
              output = geob;
              break;
            }
case "WCOM":
            case "WCOP":
            case "WOAF":
            case "WOAR":
            case "WOAS":
            case "WORS":
            case "WPAY":
            case "WPUB":
              fzero = findZero(uint8Array, offset + 1, length, encoding);
              output = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
              break;
            case "WXXX": {
              fzero = findZero(uint8Array, offset + 1, length, encoding);
              const description = decodeString(uint8Array.slice(offset + 1, fzero), encoding);
              offset = fzero + (encoding === "utf-16le" ? 2 : 1);
              output = { description, url: decodeString(uint8Array.slice(offset, length), defaultEnc) };
              break;
            }
            case "WFD":
            case "WFED":
              output = decodeString(uint8Array.slice(offset + 1, findZero(uint8Array, offset + 1, length, encoding)), encoding);
              break;
            case "MCDI": {
              output = uint8Array.slice(0, length);
              break;
            }
            default:
              debug(`Warning: unsupported id3v2-tag-type: ${type}`);
              break;
          }
          return output;
        }
        static readNullTerminatedString(uint8Array, encoding) {
          let offset = encoding.bom ? 2 : 0;
          const zeroIndex = findZero(uint8Array, offset, uint8Array.length, encoding.encoding);
          const txt = uint8Array.slice(offset, zeroIndex);
          if (encoding.encoding === "utf-16le") {
            offset = zeroIndex + 2;
          } else {
            offset = zeroIndex + 1;
          }
          return {
            text: decodeString(txt, encoding.encoding),
            len: offset
          };
        }
        static fixPictureMimeType(pictureType) {
          pictureType = pictureType.toLocaleLowerCase();
          switch (pictureType) {
            case "jpg":
              return "image/jpeg";
            case "png":
              return "image/png";
          }
          return pictureType;
        }
static functionList(entries) {
          const res = {};
          for (let i = 0; i + 1 < entries.length; i += 2) {
            const names = entries[i + 1].split(",");
            res[entries[i]] = res[entries[i]] ? res[entries[i]].concat(names) : names;
          }
          return res;
        }
splitValue(tag, text) {
          let values;
          if (this.major < 4) {
            values = text.split(/\x00/g);
            if (values.length > 1) {
              this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);
            } else {
              values = text.split(/\//g);
            }
          } else {
            values = text.split(/\x00/g);
          }
          return FrameParser.trimArray(values);
        }
        static trimArray(values) {
          return values.map((value) => value.replace(/\x00+$/, "").trim());
        }
        static readIdentifierAndData(uint8Array, offset, length, encoding) {
          const fzero = findZero(uint8Array, offset, length, encoding);
          const id = decodeString(uint8Array.slice(offset, fzero), encoding);
          offset = fzero + FrameParser.getNullTerminatorLength(encoding);
          return { id, data: uint8Array.slice(offset, length) };
        }
        static getNullTerminatorLength(enc) {
          return enc === "utf-16le" ? 2 : 1;
        }
      }
      class Id3v2ContentError extends makeUnexpectedFileContentError("id3v2") {
      }
      function makeUnexpectedMajorVersionError$1(majorVer) {
        throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);
      }
      const asciiDecoder = new TextDecoder("ascii");
      class ID3v2Parser {
        constructor() {
          this.tokenizer = void 0;
          this.id3Header = void 0;
          this.metadata = void 0;
          this.headerType = void 0;
          this.options = void 0;
        }
        static removeUnsyncBytes(buffer) {
          let readI = 0;
          let writeI = 0;
          while (readI < buffer.length - 1) {
            if (readI !== writeI) {
              buffer[writeI] = buffer[readI];
            }
            readI += buffer[readI] === 255 && buffer[readI + 1] === 0 ? 2 : 1;
            writeI++;
          }
          if (readI < buffer.length) {
            buffer[writeI++] = buffer[readI];
          }
          return buffer.slice(0, writeI);
        }
        static getFrameHeaderLength(majorVer) {
          switch (majorVer) {
            case 2:
              return 6;
            case 3:
            case 4:
              return 10;
            default:
              throw makeUnexpectedMajorVersionError(majorVer);
          }
        }
        static readFrameFlags(b) {
          return {
            status: {
              tag_alter_preservation: getBit(b, 0, 6),
              file_alter_preservation: getBit(b, 0, 5),
              read_only: getBit(b, 0, 4)
            },
            format: {
              grouping_identity: getBit(b, 1, 7),
              compression: getBit(b, 1, 3),
              encryption: getBit(b, 1, 2),
              unsynchronisation: getBit(b, 1, 1),
              data_length_indicator: getBit(b, 1, 0)
            }
          };
        }
        static readFrameData(uint8Array, frameHeader, majorVer, includeCovers, warningCollector) {
          const frameParser = new FrameParser(majorVer, warningCollector);
          switch (majorVer) {
            case 2:
              return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
            case 3:
            case 4:
              if (frameHeader.flags?.format.unsynchronisation) {
                uint8Array = ID3v2Parser.removeUnsyncBytes(uint8Array);
              }
              if (frameHeader.flags?.format.data_length_indicator) {
                uint8Array = uint8Array.slice(4, uint8Array.length);
              }
              return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
            default:
              throw makeUnexpectedMajorVersionError(majorVer);
          }
        }
static makeDescriptionTagName(tag, description) {
          return tag + (description ? `:${description}` : "");
        }
        async parse(metadata, tokenizer, options) {
          this.tokenizer = tokenizer;
          this.metadata = metadata;
          this.options = options;
          const id3Header = await this.tokenizer.readToken(ID3v2Header);
          if (id3Header.fileIdentifier !== "ID3") {
            throw new Id3v2ContentError("expected ID3-header file-identifier 'ID3' was not found");
          }
          this.id3Header = id3Header;
          this.headerType = `ID3v2.${id3Header.version.major}`;
          return id3Header.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(id3Header.size);
        }
        async parseExtendedHeader() {
          const extendedHeader = await this.tokenizer.readToken(ExtendedHeader);
          const dataRemaining = extendedHeader.size - ExtendedHeader.len;
          return dataRemaining > 0 ? this.parseExtendedHeaderData(dataRemaining, extendedHeader.size) : this.parseId3Data(this.id3Header.size - extendedHeader.size);
        }
        async parseExtendedHeaderData(dataRemaining, extendedHeaderSize) {
          await this.tokenizer.ignore(dataRemaining);
          return this.parseId3Data(this.id3Header.size - extendedHeaderSize);
        }
        async parseId3Data(dataLen) {
          const uint8Array = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));
          for (const tag of this.parseMetadata(uint8Array)) {
            switch (tag.id) {
              case "TXXX":
                if (tag.value) {
                  await this.handleTag(tag, tag.value.text, () => tag.value.description);
                }
                break;
              default:
                await (Array.isArray(tag.value) ? Promise.all(tag.value.map((value) => this.addTag(tag.id, value))) : this.addTag(tag.id, tag.value));
            }
          }
        }
        async handleTag(tag, values, descriptor, resolveValue = (value) => value) {
          await Promise.all(values.map((value) => this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, descriptor(value)), resolveValue(value))));
        }
        async addTag(id, value) {
          await this.metadata.addTag(this.headerType, id, value);
        }
        parseMetadata(data) {
          let offset = 0;
          const tags = [];
          while (true) {
            if (offset === data.length)
              break;
            const frameHeaderLength = ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);
            if (offset + frameHeaderLength > data.length) {
              this.metadata.addWarning("Illegal ID3v2 tag length");
              break;
            }
            const frameHeaderBytes = data.slice(offset, offset + frameHeaderLength);
            offset += frameHeaderLength;
            const frameHeader = this.readFrameHeader(frameHeaderBytes, this.id3Header.version.major);
            const frameDataBytes = data.slice(offset, offset + frameHeader.length);
            offset += frameHeader.length;
            const values = ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers, this.metadata);
            if (values) {
              tags.push({ id: frameHeader.id, value: values });
            }
          }
          return tags;
        }
        readFrameHeader(uint8Array, majorVer) {
          let header;
          switch (majorVer) {
            case 2:
              header = {
                id: asciiDecoder.decode(uint8Array.slice(0, 3)),
                length: UINT24_BE.get(uint8Array, 3)
              };
              if (!header.id.match(/[A-Z0-9]{3}/g)) {
                this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
              }
              break;
            case 3:
            case 4:
              header = {
                id: asciiDecoder.decode(uint8Array.slice(0, 4)),
                length: (majorVer === 4 ? UINT32SYNCSAFE : UINT32_BE).get(uint8Array, 4),
                flags: ID3v2Parser.readFrameFlags(uint8Array.slice(8, 10))
              };
              if (!header.id.match(/[A-Z0-9]{4}/g)) {
                this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
              }
              break;
            default:
              throw makeUnexpectedMajorVersionError(majorVer);
          }
          return header;
        }
      } exports("I", ID3v2Parser);
      function makeUnexpectedMajorVersionError(majorVer) {
        throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);
      }

    })
  };
}));

System.import("./__entry.js", "./");