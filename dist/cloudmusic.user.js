// ==UserScript==
// @name         cloudmusic
// @namespace    https://github.com/520Qiuyu/CloudMusic
// @version      0.0.0
// @author       520Qiuyu
// @description  无需文件云盘快传歌曲(含周杰伦)、歌曲下载&转存云盘(可批量)、云盘匹配纠正、高音质试听、完整歌单列表、评论区显示IP属地、使用指定的IP地址发送评论、歌单歌曲排序(时间、红心数、评论数)、专辑页加载Disc信息、限免VIP歌曲下载上传、云盘音质提升、本地文件上传云
// @icon         https://vitejs.dev/logo.svg
// @homepage     https://github.com/520Qiuyu/CloudMusic
// @homepageURL  https://github.com/520Qiuyu/CloudMusic
// @match        https://music.163.com/**/*
// @require      https://cdn.jsdelivr.net/npm/dayjs@1.11.13/dayjs.min.js
// @require      https://cdn.jsdelivr.net/npm/react@18.3.1/umd/react.production.min.js
// @require      https://cdn.jsdelivr.net/npm/react-dom@18.3.1/umd/react-dom.production.min.js
// @require      https://cdn.jsdelivr.net/npm/antd@5.22.4/dist/antd.min.js
// @require      https://cdn.jsdelivr.net/npm/@ant-design/icons@5.5.2/dist/index.umd.min.js
// @require      https://cdn.jsdelivr.net/npm/node-forge@1.3.1/dist/forge.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.15.1/dist/system.min.js
// @require      https://cdn.jsdelivr.net/npm/systemjs@6.15.1/dist/extras/named-register.min.js
// @require      data:application/javascript,%3B(typeof%20System!%3D'undefined')%26%26(System%3Dnew%20System.constructor())%3B
// @connect      music.163.com
// @connect      interface.music.163.com
// @grant        GM_addStyle
// @grant        GM_xmlhttpRequest
// @grant        unsafeWindow
// ==/UserScript==

(_=>{if(typeof GM_addStyle=="function"){GM_addStyle(_);return}const o=document.createElement("style");o.textContent=_,document.head.append(o)})(" ._button-group_dcsms_1{position:fixed;right:20px;top:50%;width:44px;max-height:400px;overflow-y:auto;background:#ffffffe6;border-radius:22px;box-shadow:0 2px 10px #0000001a;padding:10px 0;z-index:999}._button-group_dcsms_1::-webkit-scrollbar{width:0;background:transparent}._button-group_dcsms_1 .ant-btn{width:36px;height:36px;padding:0;border:none;background:transparent;display:flex;align-items:center;justify-content:center;margin:4px auto;transition:all .3s}._button-group_dcsms_1 .ant-btn:hover{background:#c20c0c1a;color:#fff;transform:scale(1.1)}._button-group_dcsms_1 .ant-btn:active{transform:scale(.95)}._button-group_dcsms_1 .ant-btn .anticon{font-size:20px;color:#666}._button-group_dcsms_1 .ant-btn:hover .anticon{color:#fff}._button-group_dcsms_1 .ant-tooltip .ant-tooltip-inner{background-color:#000c;border-radius:4px;font-size:12px;padding:4px 8px}._button-group_dcsms_1 .ant-tooltip .ant-tooltip-arrow-content{background-color:#000c}._quick-upload-tabs_10bds_1 .ant-spin{width:100%;height:100%}._quick-upload-tabs_10bds_1 .ant-modal-footer .ant-btn-default{border-color:#d9d9d9;color:#333}._quick-upload-tabs_10bds_1 .ant-modal-footer .ant-btn-default:hover{border-color:#c20c0c;color:#c20c0c}._quick-upload-tabs_10bds_1 .ant-modal-footer .ant-btn-primary{background:#c20c0c;border-color:#c20c0c}._quick-upload-tabs_10bds_1 .ant-modal-footer .ant-btn-primary:hover{background:#a40a0a;border-color:#a40a0a}._quick-upload-tabs_10bds_1 ._select_10bds_21{width:100%}._quick-upload-tabs_10bds_1 ._option-label_10bds_24{display:flex;align-items:center;gap:8px;justify-content:space-between;width:100%}._quick-upload-tabs_10bds_1 ._option-label_10bds_24 ._singer-name_10bds_31{font-weight:500}._quick-upload-tabs_10bds_1 ._option-label_10bds_24 ._tag-group_10bds_34 ._tag_10bds_34:not(:last-child){margin-right:8px}._singer-choose_10bds_38 ._singer-choose-form_10bds_38{display:flex;flex-direction:column;justify-content:space-between;height:400px}._singer-choose_10bds_38 ._singer-choose-form_10bds_38 ._btn-group_10bds_44{display:flex;justify-content:flex-end}._upload-list_10bds_49 .ant-table{margin:16px 0}._upload-footer_10bds_53{width:100%;display:flex;justify-content:flex-end;align-items:center;gap:8px}._upload-stats_10bds_61{color:#666;font-size:13px;margin-right:auto}._upload-stats_10bds_61 ._size-text_10bds_66{color:#999}._upload-stats_10bds_61 ._divider_10bds_69{margin:0 8px;color:#d9d9d9}._upload-confirm_10bds_74{padding:16px 0;font-size:14px}._upload-confirm_10bds_74 ._confirm-item_10bds_78{display:flex;align-items:center;margin-bottom:12px}._upload-confirm_10bds_74 ._confirm-item_10bds_78:last-child{margin-bottom:0}._upload-confirm_10bds_74 ._confirm-item_10bds_78 ._label_10bds_86{color:#666;width:80px;flex-shrink:0}._upload-confirm_10bds_74 ._confirm-item_10bds_78 ._value_10bds_91{color:#333;font-weight:500}._upload-confirm_10bds_74 ._confirm-item_10bds_78 ._value_10bds_91 ._size_10bds_66{margin-left:4px;color:#999;font-weight:400}._upload-progress_10bds_101 ._progress-header_10bds_101{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;padding:0 4px}._upload-progress_10bds_101 ._progress-header_10bds_101 ._progress-info_10bds_108{font-size:14px;color:#333}._upload-progress_10bds_101 ._progress-header_10bds_101 ._percentage_10bds_112{font-size:14px;font-weight:500;color:#1890ff}._upload-progress_10bds_101 ._progress-list_10bds_117{max-height:300px;overflow-y:auto;padding:0 4px}._upload-progress_10bds_101 ._progress-list_10bds_117 ._progress-item_10bds_122{display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid #f0f0f0}._upload-progress_10bds_101 ._progress-list_10bds_117 ._progress-item_10bds_122:last-child{border-bottom:none}._upload-progress_10bds_101 ._progress-list_10bds_117 ._progress-item_10bds_122 ._song-info_10bds_132{flex:1;min-width:0;padding-right:16px}._upload-progress_10bds_101 ._progress-list_10bds_117 ._progress-item_10bds_122 ._song-info_10bds_132 ._name_10bds_137{font-size:14px;color:#333}._upload-progress_10bds_101 ._progress-list_10bds_117 ._progress-item_10bds_122 ._song-info_10bds_132 ._artist_10bds_141{font-size:14px;color:#666;margin-left:4px}._uploadProgressModal_10bds_147 .ant-modal-body{padding:24px}._uploadProgressModal_10bds_147 ._progressContent_10bds_150{display:flex;flex-direction:column;align-items:center;gap:24px}._uploadProgressModal_10bds_147 ._progressInfo_10bds_156{display:flex;flex-direction:column;align-items:center}._uploadProgressModal_10bds_147 ._progressInfo_10bds_156 ._percentage_10bds_112{font-size:24px;font-weight:500;color:#333}._uploadProgressModal_10bds_147 ._progressInfo_10bds_156 ._detail_10bds_166{font-size:14px;color:#666;margin-top:4px}._uploadProgressModal_10bds_147 ._statsContainer_10bds_171{display:flex;justify-content:space-around;width:100%;padding:16px 0;border-top:1px solid #f0f0f0;border-bottom:1px solid #f0f0f0}._uploadProgressModal_10bds_147 ._statsContainer_10bds_171 ._statsItem_10bds_179{text-align:center}._uploadProgressModal_10bds_147 ._statsContainer_10bds_171 ._statsItem_10bds_179 ._label_10bds_86{font-size:14px;color:#666;margin-bottom:8px}._uploadProgressModal_10bds_147 ._statsContainer_10bds_171 ._statsItem_10bds_179 ._value_10bds_91 .ant-tag{margin:0;font-size:14px;padding:4px 12px}._uploadProgressModal_10bds_147 ._failedList_10bds_192{width:100%}._uploadProgressModal_10bds_147 ._failedList_10bds_192 ._failedTitle_10bds_195{font-size:14px;color:#333;margin-bottom:12px;font-weight:500}._uploadProgressModal_10bds_147 ._failedList_10bds_192 ._failedItem_10bds_201{padding:8px 12px;background:#fff1f0;border-radius:4px;margin-bottom:8px}._uploadProgressModal_10bds_147 ._failedList_10bds_192 ._failedItem_10bds_201 ._songName_10bds_207{font-size:14px;color:#333;margin-bottom:4px}._uploadProgressModal_10bds_147 ._failedList_10bds_192 ._failedItem_10bds_201 ._errorMsg_10bds_212{font-size:12px;color:#ff4d4f}._uploadModal_10bds_217 .ant-modal-body{padding:24px}._progressSection_10bds_221{display:flex;flex-direction:column;align-items:center;margin-bottom:24px;padding-bottom:24px;border-bottom:1px solid #f0f0f0}._progressInfo_10bds_156{display:flex;flex-direction:column;align-items:center}._progressInfo_10bds_156 ._percentage_10bds_112{font-size:24px;font-weight:500;color:#333}._progressInfo_10bds_156 ._count_10bds_240{font-size:14px;color:#666;margin-top:4px}._statsContainer_10bds_171{display:flex;justify-content:center;gap:16px;margin-top:20px}._statsContainer_10bds_171 ._statsItem_10bds_179{text-align:center}._statsContainer_10bds_171 ._statsTag_10bds_255{padding:4px 12px;font-size:14px}._songList_10bds_260{max-height:300px;overflow-y:auto;padding-right:4px}._songList_10bds_260::-webkit-scrollbar{width:6px}._songList_10bds_260::-webkit-scrollbar-thumb{background-color:#d9d9d9;border-radius:3px}._songList_10bds_260::-webkit-scrollbar-thumb:hover{background-color:#bfbfbf}._songItem_10bds_276{display:flex;justify-content:space-between;align-items:center;padding:12px;border-radius:4px;background:#fafafa}._songItem_10bds_276:not(:last-child){margin-bottom:8px}._songItem_10bds_276:hover{background:#f5f5f5}._songInfo_10bds_291{display:flex;align-items:center;gap:8px;flex:1;min-width:0}._songInfo_10bds_291 ._songName_10bds_207{font-weight:500;color:#333;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._songInfo_10bds_291 ._artistName_10bds_305{color:#666;font-size:13px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._local-upload_ad6cg_1{display:flex;flex-direction:column;gap:16px}._local-upload_ad6cg_1 ._upload-section_ad6cg_6{flex:0 0 170px;display:flex;flex-direction:column;gap:16px}._local-upload_ad6cg_1 ._upload-section_ad6cg_6 ._dragger_ad6cg_12{flex:1;display:flex;flex-direction:column;justify-content:center;align-items:center;border:2px dashed #d9d9d9;border-radius:8px;background:#fafafa;transition:border-color .3s}._local-upload_ad6cg_1 ._upload-section_ad6cg_6 ._dragger_ad6cg_12:hover{border-color:#c20c0c}._local-upload_ad6cg_1 ._upload-section_ad6cg_6 ._dragger_ad6cg_12 ._upload-icon_ad6cg_26{font-size:48px;color:#999}._local-upload_ad6cg_1 ._upload-section_ad6cg_6 ._dragger_ad6cg_12 ._upload-text_ad6cg_30{margin-top:16px;color:#666}._local-upload_ad6cg_1 ._upload-section_ad6cg_6 ._dragger_ad6cg_12 ._upload-hint_ad6cg_34{margin-top:8px;color:#999;font-size:13px}._local-upload_ad6cg_1 ._file-list_ad6cg_39{flex:1;display:flex;flex-direction:column;gap:16px;overflow:hidden}._local-upload_ad6cg_1 ._file-list_ad6cg_39 .ant-table{flex:1}._local-upload_ad6cg_1 ._upload-stats_ad6cg_49{color:#666;font-size:13px}._local-upload_ad6cg_1 ._upload-stats_ad6cg_49 ._size-text_ad6cg_53{color:#999}._local-upload_ad6cg_1 ._upload-stats_ad6cg_49 ._divider_ad6cg_56{margin:0 8px;color:#d9d9d9}._songInfoColumn_19jjf_1{display:flex;align-items:center;gap:8px}._songInfoColumn_19jjf_1 ._songCover_19jjf_6{width:40px;height:40px;border-radius:4px}._songInfoColumn_19jjf_1 ._songInfo_19jjf_1{flex:1 1 0px;overflow:hidden}._songInfoColumn_19jjf_1 ._songInfo_19jjf_1 ._songName_19jjf_15{font-size:14px;color:#333;margin-bottom:4px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:100%}._songInfoColumn_19jjf_1 ._songInfo_19jjf_1 ._songId_19jjf_24{font-size:12px;color:#999}._footer_19jjf_29{margin-top:16px;display:flex;justify-content:space-between;align-items:center;border-top:1px solid #f0f0f0;padding:16px 0}._footer_19jjf_29 ._actions_19jjf_37{display:flex;gap:8px}._stats_19jjf_42{display:flex;align-items:center;gap:8px}._stats_19jjf_42 ._size_19jjf_47{color:#666}._stats_19jjf_42 ._divider_19jjf_50{color:#999;margin:0 4px}._stats_19jjf_42 .ant-tag{margin:0}._playlist_19jjf_58 .ant-modal-body{padding-bottom:0}._autoAddContent_19jjf_62 ._title_19jjf_62{font-size:16px;margin-bottom:8px}._autoAddContent_19jjf_62 ._statsWrapper_19jjf_66{margin-bottom:16px}._autoAddContent_19jjf_62 ._statsContent_19jjf_69{display:flex;gap:16px;background:#f5f5f5;padding:12px 16px;border-radius:8px}._autoAddContent_19jjf_62 ._statsContent_19jjf_69 ._label_19jjf_76{color:#666}._autoAddContent_19jjf_62 ._statsContent_19jjf_69 ._value_19jjf_79{color:#1890ff;font-size:18px;font-weight:700}._autoAddContent_19jjf_62 ._listHeader_19jjf_84{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}._autoAddContent_19jjf_62 ._listWrapper_19jjf_90{margin:8px 0;max-height:200px;overflow-y:auto;padding:12px;border:1px solid #d9d9d9;border-radius:8px;background:#fff}._autoAddContent_19jjf_62 ._listWrapper_19jjf_90::-webkit-scrollbar{width:6px;height:6px}._autoAddContent_19jjf_62 ._listWrapper_19jjf_90::-webkit-scrollbar-thumb{border-radius:3px;background:#0003}._autoAddContent_19jjf_62 ._listWrapper_19jjf_90::-webkit-scrollbar-track{border-radius:3px;background:#0000001a}._autoAddContent_19jjf_62 ._listItem_19jjf_111{margin-bottom:8px;display:flex;justify-content:space-between;padding:4px 8px;border-radius:4px;transition:all .3s;cursor:default;background:#fff}._autoAddContent_19jjf_62 ._listItem_19jjf_111:hover{background:#f5f5f5}._autoAddContent_19jjf_62 ._listItem_19jjf_111:last-child{margin-bottom:0}._autoAddContent_19jjf_62 ._listItem_19jjf_111 ._itemName_19jjf_127{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}._autoAddContent_19jjf_62 ._listItem_19jjf_111 ._itemCount_19jjf_133{color:#1890ff;margin-left:8px}._deleteConfirmation_19jjf_138{font-size:14px}._deleteConfirmation_19jjf_138 ._title_19jjf_62{font-size:16px;font-weight:700;margin-bottom:12px}._deleteConfirmation_19jjf_138 ._title_19jjf_62 ._count_19jjf_146{color:#1890ff}._deleteConfirmation_19jjf_138 ._songs_19jjf_149{max-height:220px;overflow-y:auto;margin:12px 0;padding:8px;background:#f8f8f8;border-radius:6px;border:1px solid #e8e8e8;line-height:1.6;color:#666}._deleteConfirmation_19jjf_138 ._songs_19jjf_149 ._songItem_19jjf_160{padding:4px 8px;border-radius:4px;transition:all .3s}._deleteConfirmation_19jjf_138 ._songs_19jjf_149 ._songItem_19jjf_160:hover{background:#f0f0f0}._deleteConfirmation_19jjf_138 ._songs_19jjf_149 ._songItem_19jjf_160:not(:last-child){margin-bottom:4px}._deleteConfirmation_19jjf_138 ._warning_19jjf_171{background:#fff2f0;border:1px solid #ffccc7;border-radius:6px;padding:5px;margin-top:12px}._deleteConfirmation_19jjf_138 ._warning_19jjf_171 ._text_19jjf_178{color:#ff4d4f;margin:0;display:flex;align-items:center;gap:8px}._deleteConfirmation_19jjf_138 ._warning_19jjf_171 ._icon_19jjf_185{flex:0 0 20px;display:inline-block;width:20px;height:20px;line-height:20px;text-align:center;border-radius:50%;background:#ff4d4f;color:#fff;font-size:14px;font-weight:700}._container_18cxg_1{display:flex;flex-direction:column;gap:16px;padding:16px;min-height:500px}._uploadArea_62myb_1{border:2px dashed #d9d9d9;border-radius:8px;padding:24px;text-align:center;background:#fafafa;cursor:pointer;transition:border-color .3s}._uploadArea_62myb_1:hover{border-color:#1890ff}._uploadContent_62myb_14{display:flex;flex-direction:column;align-items:center;gap:8px;cursor:pointer}._uploadIcon_62myb_22{font-size:48px;color:#1890ff}._uploadText_62myb_27{color:#666}._uploadText_62myb_27 p{margin:0}._uploadTip_62myb_34{font-size:12px;color:#999}._unlockList_gel3y_1{height:100%;padding:16px;background-color:#fff;border-radius:8px;box-shadow:0 2px 8px #0000001a}._unlockList_gel3y_1 .ant-table-wrapper,._unlockList_gel3y_1 .ant-table,._unlockList_gel3y_1 .ant-table-container{height:100%}._unlockList_gel3y_1 .ant-table-body{height:calc(100% - 55px)!important;overflow-y:auto!important}._unlockList_gel3y_1 .ant-progress,._unlockList_gel3y_1 .ant-tag{margin-right:0}::-webkit-scrollbar{width:6px;height:6px}::-webkit-scrollbar-track{background:transparent;border-radius:6px}::-webkit-scrollbar-thumb{background:#8080804d;border-radius:6px;transition:all .2s ease-in-out}::-webkit-scrollbar-thumb:hover{background:#80808080}*{scrollbar-width:thin;scrollbar-color:rgba(128,128,128,.3) transparent} ");

System.addImportMap({ imports: {"antd":"user:antd","react":"user:react","react-dom":"user:react-dom","@ant-design/icons":"user:@ant-design/icons","node-forge":"user:node-forge"} });
System.set("user:antd", (()=>{const _=antd;('default' in _)||(_.default=_);return _})());
System.set("user:react", (()=>{const _=React;('default' in _)||(_.default=_);return _})());
System.set("user:react-dom", (()=>{const _=ReactDOM;('default' in _)||(_.default=_);return _})());
System.set("user:@ant-design/icons", (()=>{const _=icons;('default' in _)||(_.default=_);return _})());
System.set("user:node-forge", (()=>{const _=forge;('default' in _)||(_.default=_);return _})());

System.register("./__entry.js", ['./__monkey.entry-SDvwpoNt.js'], (function (exports, module) {
	'use strict';
	return {
		setters: [null],
		execute: (function () {



		})
	};
}));

System.register("./__monkey.entry-SDvwpoNt.js", ['react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var forwardRef, useState, useImperativeHandle, useRef, useEffect, memo, useMemo, require$$0, Modal, Progress, Tag, Table, Form, Space, Input, Button, Upload, ConfigProvider, Tabs, Select, message, Spin, Empty, Image, Tooltip, require$$0$1, InboxOutlined, UploadOutlined, CopyrightOutlined, CloudUploadOutlined, CustomerServiceOutlined, UnlockOutlined, InfoCircleOutlined, forge;
  return {
    setters: [module => {
      forwardRef = module.forwardRef;
      useState = module.useState;
      useImperativeHandle = module.useImperativeHandle;
      useRef = module.useRef;
      useEffect = module.useEffect;
      memo = module.memo;
      useMemo = module.useMemo;
      require$$0 = module.default;
    }, module => {
      Modal = module.Modal;
      Progress = module.Progress;
      Tag = module.Tag;
      Table = module.Table;
      Form = module.Form;
      Space = module.Space;
      Input = module.Input;
      Button = module.Button;
      Upload = module.Upload;
      ConfigProvider = module.ConfigProvider;
      Tabs = module.Tabs;
      Select = module.Select;
      message = module.message;
      Spin = module.Spin;
      Empty = module.Empty;
      Image = module.Image;
      Tooltip = module.Tooltip;
    }, module => {
      require$$0$1 = module.default;
    }, module => {
      InboxOutlined = module.InboxOutlined;
      UploadOutlined = module.UploadOutlined;
      CopyrightOutlined = module.CopyrightOutlined;
      CloudUploadOutlined = module.CloudUploadOutlined;
      CustomerServiceOutlined = module.CustomerServiceOutlined;
      UnlockOutlined = module.UnlockOutlined;
      InfoCircleOutlined = module.InfoCircleOutlined;
    }, module => {
      forge = module.default;
    }],
    execute: (function () {

      exports({
        M: trimRightNull,
        R: findZero,
        b: isBitSet$1,
        g: getBitAllignedNumber,
        h: hexToUint8Array,
        j: getBit,
        l: decodeString,
        n: fromBuffer$1,
        s: stripNulls,
        u: uint8ArrayToHex,
        z: uint8ArrayToString
      });

      var __defProp = Object.defineProperty;
      var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
      var __publicField = (obj, key, value2) => __defNormalProp(obj, key + "" , value2);
      function getDefaultExportFromCjs(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      var jsxRuntime = { exports: {} };
      var reactJsxRuntime_production_min = {};
      /**
       * @license React
       * react-jsx-runtime.production.min.js
       *
       * Copyright (c) Facebook, Inc. and its affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      var f = require$$0, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m$1 = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
      function q(c, a, g) {
        var b, d = {}, e = null, h = null;
        void 0 !== g && (e = "" + g);
        void 0 !== a.key && (e = "" + a.key);
        void 0 !== a.ref && (h = a.ref);
        for (b in a) m$1.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
        if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
        return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
      }
      reactJsxRuntime_production_min.Fragment = l;
      reactJsxRuntime_production_min.jsx = q;
      reactJsxRuntime_production_min.jsxs = q;
      {
        jsxRuntime.exports = reactJsxRuntime_production_min;
      }
      var jsxRuntimeExports = jsxRuntime.exports;
      var client = {};
      var m = require$$0$1;
      {
        client.createRoot = m.createRoot;
        client.hydrateRoot = m.hydrateRoot;
      }
      const styles$6 = {
        "button-group": "_button-group_dcsms_1"
      };
      const QUALITY_LEVELS = {
        jymaster: "超清母带",
        dolby: "杜比全景声",
        sky: "沉浸环绕声",
        jyeffect: "高清环绕声",
        hires: "Hi-Res",
        lossless: "无损",
        exhigh: "极高",
        higher: "较高",
        standard: "标准",
        超清母带: "jymaster",
        杜比全景声: "dolby",
        沉浸环绕声: "sky",
        高清环绕声: "jyeffect",
        "Hi-Res": "hires",
        无损: "lossless",
        极高: "exhigh",
        较高: "higher",
        标准: "standard"
      };
      const BASE_CDN_URL = "https://fastly.jsdelivr.net/gh/520Qiuyu/cdn@latest/artist/";
      var md5$1 = { exports: {} };
      var crypt = { exports: {} };
      (function() {
        var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt$1 = {
          // Bit-wise rotation left
          rotl: function(n2, b) {
            return n2 << b | n2 >>> 32 - b;
          },
          // Bit-wise rotation right
          rotr: function(n2, b) {
            return n2 << 32 - b | n2 >>> b;
          },
          // Swap big-endian to little-endian and vice versa
          endian: function(n2) {
            if (n2.constructor == Number) {
              return crypt$1.rotl(n2, 8) & 16711935 | crypt$1.rotl(n2, 24) & 4278255360;
            }
            for (var i = 0; i < n2.length; i++)
              n2[i] = crypt$1.endian(n2[i]);
            return n2;
          },
          // Generate an array of any length of random bytes
          randomBytes: function(n2) {
            for (var bytes = []; n2 > 0; n2--)
              bytes.push(Math.floor(Math.random() * 256));
            return bytes;
          },
          // Convert a byte array to big-endian 32-bit words
          bytesToWords: function(bytes) {
            for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
              words[b >>> 5] |= bytes[i] << 24 - b % 32;
            return words;
          },
          // Convert big-endian 32-bit words to a byte array
          wordsToBytes: function(words) {
            for (var bytes = [], b = 0; b < words.length * 32; b += 8)
              bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
            return bytes;
          },
          // Convert a byte array to a hex string
          bytesToHex: function(bytes) {
            for (var hex = [], i = 0; i < bytes.length; i++) {
              hex.push((bytes[i] >>> 4).toString(16));
              hex.push((bytes[i] & 15).toString(16));
            }
            return hex.join("");
          },
          // Convert a hex string to a byte array
          hexToBytes: function(hex) {
            for (var bytes = [], c = 0; c < hex.length; c += 2)
              bytes.push(parseInt(hex.substr(c, 2), 16));
            return bytes;
          },
          // Convert a byte array to a base-64 string
          bytesToBase64: function(bytes) {
            for (var base64 = [], i = 0; i < bytes.length; i += 3) {
              var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
              for (var j = 0; j < 4; j++)
                if (i * 8 + j * 6 <= bytes.length * 8)
                  base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
                else
                  base64.push("=");
            }
            return base64.join("");
          },
          // Convert a base-64 string to a byte array
          base64ToBytes: function(base64) {
            base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
            for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
              if (imod4 == 0) continue;
              bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
            }
            return bytes;
          }
        };
        crypt.exports = crypt$1;
      })();
      var cryptExports = crypt.exports;
      var charenc = {
        // UTF-8 encoding
        utf8: {
          // Convert a string to a byte array
          stringToBytes: function(str) {
            return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
          },
          // Convert a byte array to a string
          bytesToString: function(bytes) {
            return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
          }
        },
        // Binary encoding
        bin: {
          // Convert a string to a byte array
          stringToBytes: function(str) {
            for (var bytes = [], i = 0; i < str.length; i++)
              bytes.push(str.charCodeAt(i) & 255);
            return bytes;
          },
          // Convert a byte array to a string
          bytesToString: function(bytes) {
            for (var str = [], i = 0; i < bytes.length; i++)
              str.push(String.fromCharCode(bytes[i]));
            return str.join("");
          }
        }
      };
      var charenc_1 = charenc;
      /*!
       * Determine if an object is a Buffer
       *
       * @author   Feross Aboukhadijeh <https://feross.org>
       * @license  MIT
       */
      var isBuffer_1 = function(obj) {
        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
      };
      function isBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      }
      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
      }
      (function() {
        var crypt2 = cryptExports, utf8 = charenc_1.utf8, isBuffer2 = isBuffer_1, bin = charenc_1.bin, md52 = function(message2, options) {
          if (message2.constructor == String)
            if (options && options.encoding === "binary")
              message2 = bin.stringToBytes(message2);
            else
              message2 = utf8.stringToBytes(message2);
          else if (isBuffer2(message2))
            message2 = Array.prototype.slice.call(message2, 0);
          else if (!Array.isArray(message2) && message2.constructor !== Uint8Array)
            message2 = message2.toString();
          var m2 = crypt2.bytesToWords(message2), l2 = message2.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
          for (var i = 0; i < m2.length; i++) {
            m2[i] = (m2[i] << 8 | m2[i] >>> 24) & 16711935 | (m2[i] << 24 | m2[i] >>> 8) & 4278255360;
          }
          m2[l2 >>> 5] |= 128 << l2 % 32;
          m2[(l2 + 64 >>> 9 << 4) + 14] = l2;
          var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
          for (var i = 0; i < m2.length; i += 16) {
            var aa = a, bb = b, cc = c, dd = d;
            a = FF(a, b, c, d, m2[i + 0], 7, -680876936);
            d = FF(d, a, b, c, m2[i + 1], 12, -389564586);
            c = FF(c, d, a, b, m2[i + 2], 17, 606105819);
            b = FF(b, c, d, a, m2[i + 3], 22, -1044525330);
            a = FF(a, b, c, d, m2[i + 4], 7, -176418897);
            d = FF(d, a, b, c, m2[i + 5], 12, 1200080426);
            c = FF(c, d, a, b, m2[i + 6], 17, -1473231341);
            b = FF(b, c, d, a, m2[i + 7], 22, -45705983);
            a = FF(a, b, c, d, m2[i + 8], 7, 1770035416);
            d = FF(d, a, b, c, m2[i + 9], 12, -1958414417);
            c = FF(c, d, a, b, m2[i + 10], 17, -42063);
            b = FF(b, c, d, a, m2[i + 11], 22, -1990404162);
            a = FF(a, b, c, d, m2[i + 12], 7, 1804603682);
            d = FF(d, a, b, c, m2[i + 13], 12, -40341101);
            c = FF(c, d, a, b, m2[i + 14], 17, -1502002290);
            b = FF(b, c, d, a, m2[i + 15], 22, 1236535329);
            a = GG(a, b, c, d, m2[i + 1], 5, -165796510);
            d = GG(d, a, b, c, m2[i + 6], 9, -1069501632);
            c = GG(c, d, a, b, m2[i + 11], 14, 643717713);
            b = GG(b, c, d, a, m2[i + 0], 20, -373897302);
            a = GG(a, b, c, d, m2[i + 5], 5, -701558691);
            d = GG(d, a, b, c, m2[i + 10], 9, 38016083);
            c = GG(c, d, a, b, m2[i + 15], 14, -660478335);
            b = GG(b, c, d, a, m2[i + 4], 20, -405537848);
            a = GG(a, b, c, d, m2[i + 9], 5, 568446438);
            d = GG(d, a, b, c, m2[i + 14], 9, -1019803690);
            c = GG(c, d, a, b, m2[i + 3], 14, -187363961);
            b = GG(b, c, d, a, m2[i + 8], 20, 1163531501);
            a = GG(a, b, c, d, m2[i + 13], 5, -1444681467);
            d = GG(d, a, b, c, m2[i + 2], 9, -51403784);
            c = GG(c, d, a, b, m2[i + 7], 14, 1735328473);
            b = GG(b, c, d, a, m2[i + 12], 20, -1926607734);
            a = HH(a, b, c, d, m2[i + 5], 4, -378558);
            d = HH(d, a, b, c, m2[i + 8], 11, -2022574463);
            c = HH(c, d, a, b, m2[i + 11], 16, 1839030562);
            b = HH(b, c, d, a, m2[i + 14], 23, -35309556);
            a = HH(a, b, c, d, m2[i + 1], 4, -1530992060);
            d = HH(d, a, b, c, m2[i + 4], 11, 1272893353);
            c = HH(c, d, a, b, m2[i + 7], 16, -155497632);
            b = HH(b, c, d, a, m2[i + 10], 23, -1094730640);
            a = HH(a, b, c, d, m2[i + 13], 4, 681279174);
            d = HH(d, a, b, c, m2[i + 0], 11, -358537222);
            c = HH(c, d, a, b, m2[i + 3], 16, -722521979);
            b = HH(b, c, d, a, m2[i + 6], 23, 76029189);
            a = HH(a, b, c, d, m2[i + 9], 4, -640364487);
            d = HH(d, a, b, c, m2[i + 12], 11, -421815835);
            c = HH(c, d, a, b, m2[i + 15], 16, 530742520);
            b = HH(b, c, d, a, m2[i + 2], 23, -995338651);
            a = II(a, b, c, d, m2[i + 0], 6, -198630844);
            d = II(d, a, b, c, m2[i + 7], 10, 1126891415);
            c = II(c, d, a, b, m2[i + 14], 15, -1416354905);
            b = II(b, c, d, a, m2[i + 5], 21, -57434055);
            a = II(a, b, c, d, m2[i + 12], 6, 1700485571);
            d = II(d, a, b, c, m2[i + 3], 10, -1894986606);
            c = II(c, d, a, b, m2[i + 10], 15, -1051523);
            b = II(b, c, d, a, m2[i + 1], 21, -2054922799);
            a = II(a, b, c, d, m2[i + 8], 6, 1873313359);
            d = II(d, a, b, c, m2[i + 15], 10, -30611744);
            c = II(c, d, a, b, m2[i + 6], 15, -1560198380);
            b = II(b, c, d, a, m2[i + 13], 21, 1309151649);
            a = II(a, b, c, d, m2[i + 4], 6, -145523070);
            d = II(d, a, b, c, m2[i + 11], 10, -1120210379);
            c = II(c, d, a, b, m2[i + 2], 15, 718787259);
            b = II(b, c, d, a, m2[i + 9], 21, -343485551);
            a = a + aa >>> 0;
            b = b + bb >>> 0;
            c = c + cc >>> 0;
            d = d + dd >>> 0;
          }
          return crypt2.endian([a, b, c, d]);
        };
        md52._ff = function(a, b, c, d, x, s, t) {
          var n2 = a + (b & c | ~b & d) + (x >>> 0) + t;
          return (n2 << s | n2 >>> 32 - s) + b;
        };
        md52._gg = function(a, b, c, d, x, s, t) {
          var n2 = a + (b & d | c & ~d) + (x >>> 0) + t;
          return (n2 << s | n2 >>> 32 - s) + b;
        };
        md52._hh = function(a, b, c, d, x, s, t) {
          var n2 = a + (b ^ c ^ d) + (x >>> 0) + t;
          return (n2 << s | n2 >>> 32 - s) + b;
        };
        md52._ii = function(a, b, c, d, x, s, t) {
          var n2 = a + (c ^ (b | ~d)) + (x >>> 0) + t;
          return (n2 << s | n2 >>> 32 - s) + b;
        };
        md52._blocksize = 16;
        md52._digestsize = 16;
        md5$1.exports = function(message2, options) {
          if (message2 === void 0 || message2 === null)
            throw new Error("Illegal argument " + message2);
          var digestbytes = crypt2.wordsToBytes(md52(message2, options));
          return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt2.bytesToHex(digestbytes);
        };
      })();
      var md5Exports = md5$1.exports;
      const md5 = /* @__PURE__ */ getDefaultExportFromCjs(md5Exports);
      var _GM_xmlhttpRequest = /* @__PURE__ */ (() => typeof GM_xmlhttpRequest != "undefined" ? GM_xmlhttpRequest : void 0)();
      var _unsafeWindow = /* @__PURE__ */ (() => typeof unsafeWindow != "undefined" ? unsafeWindow : void 0)();
      const formatFileSize = (size2) => {
        if (!size2 || isNaN(size2)) return "0 B";
        const units = ["B", "KB", "MB", "GB", "TB"];
        size2 = Math.abs(Number(size2));
        let index = 0;
        while (size2 >= 1024 && index < units.length - 1) {
          size2 /= 1024;
          index++;
        }
        return `${size2.toFixed(index > 0 ? 1 : 0)} ${units[index]}`;
      };
      const formatDuration = (ms2) => {
        const totalSeconds = Math.floor(ms2 / 1e3);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
      };
      function chunkArray(array, size2) {
        const result = [];
        for (let i = 0; i < array.length; i += size2) {
          result.push(array.slice(i, i + size2));
        }
        return result;
      }
      const getArtistTextInSongDetail = (song2) => {
        var _a;
        return song2.ar ? song2.ar.map((ar) => ar.name).join() : ((_a = song2.pc) == null ? void 0 : _a.ar) || "";
      };
      const getAlbumTextInSongDetail = (song2) => {
        var _a;
        return song2.al ? song2.al.name : ((_a = song2.pc) == null ? void 0 : _a.alb) || "";
      };
      const uniqueArrayByKey = (arr, key) => {
        if (!Array.isArray(arr)) return [];
        if (!key) return arr;
        const seen2 = /* @__PURE__ */ new Map();
        return arr.filter((item) => {
          if (!item || typeof item !== "object") return false;
          const val = item[key];
          if (seen2.has(val)) return false;
          seen2.set(val, true);
          return true;
        });
      };
      const promiseLimit = (promiseArray, limit = 6) => {
        if (!Array.isArray(promiseArray)) {
          throw new Error("第一个参数必须是数组");
        }
        if (!Number.isInteger(limit) || limit < 1) {
          throw new Error("并发限制必须是正整数");
        }
        if (promiseArray.length === 0) {
          return Promise.resolve([]);
        }
        return new Promise((resolve, reject) => {
          const results = new Array(promiseArray.length);
          let completed = 0;
          let currentIndex = 0;
          const runTask = async () => {
            const index = currentIndex++;
            if (index >= promiseArray.length) {
              return;
            }
            try {
              const promise = promiseArray[index];
              if (typeof promise !== "function") {
                throw new Error(`数组中索引为 ${index} 的元素不是函数`);
              }
              results[index] = await promise();
            } catch (error) {
              results[index] = error;
            }
            completed++;
            if (currentIndex < promiseArray.length) {
              runTask();
            } else if (completed === promiseArray.length) {
              resolve(results);
            }
          };
          const tasksToStart = Math.min(limit, promiseArray.length);
          for (let i = 0; i < tasksToStart; i++) {
            try {
              runTask();
            } catch (error) {
              reject(error);
            }
          }
        });
      };
      const getGlobalThis = () => {
        return typeof _unsafeWindow !== "undefined" ? _unsafeWindow : window;
      };
      const getGUser = () => {
        const globalThis2 = getGlobalThis();
        return globalThis2.GUser || {};
      };
      const truncateString = (str, maxLength) => {
        let len = 0;
        let result = "";
        for (let char of str) {
          const charLen = char.charCodeAt(0) > 255 ? 2 : 1;
          if (len + charLen > maxLength) break;
          result += char;
          len += charLen;
        }
        return result;
      };
      const sleep = (ms2) => new Promise((resolve) => setTimeout(resolve, ms2));
      async function getFileMD5(file) {
        const arrayBuffer = await file.arrayBuffer();
        const uint8Array = new Uint8Array(arrayBuffer);
        return md5(uint8Array);
      }
      const msgSuccess = (content) => {
        message.success(content);
      };
      const msgWarning = (content) => {
        message.warning(content);
      };
      const msgError = (content) => {
        message.error(content);
      };
      const confirm = (content, title2, otherOptions = {}) => {
        return new Promise((resolve, reject) => {
          Modal.confirm({
            centered: true,
            content,
            icon: null,
            closable: true,
            title: title2 || "提示",
            width: 398,
            okButtonProps: {
              shape: "round",
              type: "primary"
            },
            cancelButtonProps: {
              shape: "round",
              type: "default"
            },
            okText: "确定",
            cancelText: "取消",
            onCancel: () => {
              reject(false);
            },
            onOk: () => {
              resolve(true);
            },
            ...otherOptions
          });
        });
      };
      const IV = "0102030405060708";
      const PRESET_KEY = "0CoJUm6Qyw8W8jud";
      const PUBLIC_KEY = "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDgtQn2JZ34ZC28NWYpAUd98iZ37BUrX/aKzmFbt7clFSs6sXqHauqKWqdtLkF2KexO40H1YTX8z2lSgBBOAxLsvaklV8k4cBFK9snQXE9/DDaFt6Rr7iVZMldczhC0JNgTz+SHXT6CBHuX3e9SdB1Ua44oncaTWz7OBGLbCiK45wIDAQAB\n-----END PUBLIC KEY-----";
      const BASE62 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
      const aesEncrypt = (text2, key, iv) => {
        const cipher = forge.cipher.createCipher("AES-CBC", key);
        cipher.start({ iv });
        cipher.update(forge.util.createBuffer(text2, "utf8"));
        cipher.finish();
        return forge.util.encode64(cipher.output.getBytes());
      };
      const rsaEncrypt = (text2, key) => {
        const publicKey = forge.pki.publicKeyFromPem(key);
        const encrypted = publicKey.encrypt(text2, "NONE");
        return forge.util.bytesToHex(encrypted);
      };
      const weapi = (object) => {
        const text2 = JSON.stringify(object);
        const secretKey = Array.from(
          { length: 16 },
          () => BASE62.charAt(Math.floor(Math.random() * 62))
        ).join("");
        return {
          params: aesEncrypt(aesEncrypt(text2, PRESET_KEY, IV), secretKey, IV),
          encSecKey: rsaEncrypt(secretKey.split("").reverse().join(""), PUBLIC_KEY)
        };
      };
      const CLIENT_CONFIG = {
        web: {
          cookie: true,
          userAgent: void 0
        },
        android: {
          cookie: "os=android;appver=9.1.78;channel=netease;osver=14;buildver=241009150147;",
          userAgent: "NeteaseMusic/9.1.78.241009150147(9001078);Dalvik/2.1.0 (Linux; U; Android 14; V2318A Build/TP1A.220624.014)"
        },
        pc: {
          cookie: "os=pc;appver=3.0.18.203152;channel=netease;osver=Microsoft-Windows-10-Professional-build-19045-64bit;",
          userAgent: "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Safari/537.36 Chrome/91.0.4472.164 NeteaseMusicDesktop/3.0.18.203152"
        }
      };
      const weapiRequest = (url, config) => {
        const {
          data = {},
          clientType = "pc",
          ip,
          onerror,
          onload,
          originResponse = false,
          ...rest
        } = config;
        const csrfToken = document.cookie.match(/_csrf=([^(;|$)]+)/);
        data.csrf_token = csrfToken ? csrfToken[1] : "";
        const encryptedData = weapi(data);
        console.log({
          url,
          data,
          encryptedData
        });
        const headers = {
          "content-type": "application/x-www-form-urlencoded",
          "user-agent": CLIENT_CONFIG[clientType].userAgent
        };
        if (ip) {
          headers["X-Real-IP"] = ip;
          headers["X-Forwarded-For"] = ip;
        }
        return new Promise((resolve, reject) => {
          _GM_xmlhttpRequest({
            url: url.replace("api", "weapi") + `?csrf_token=${data.csrf_token}`,
            method: "POST",
            responseType: "json",
            headers,
            cookie: CLIENT_CONFIG[clientType].cookie,
            data: `params=${encodeURIComponent(
        encryptedData.params
      )}&encSecKey=${encodeURIComponent(encryptedData.encSecKey)}`,
            onload: (res) => resolve(originResponse ? res : res.response),
            onerror: reject
          });
        });
      };
      const weapiFetch = async (url, config) => {
        const {
          data = {},
          clientType = "pc",
          ip,
          originResponse = false,
          ...rest
        } = config;
        const csrfToken = document.cookie.match(/_csrf=([^(;|$)]+)/);
        data.csrf_token = csrfToken ? csrfToken[1] : "";
        const encryptedData = weapi(data);
        console.log({
          url,
          data,
          encryptedData
        });
        const headers = {
          "content-type": "application/x-www-form-urlencoded",
          "user-agent": CLIENT_CONFIG[clientType].userAgent,
          accept: "application/json, text/plain, */*",
          "accept-language": "zh-CN,zh;q=0.9",
          origin: "https://music.163.com",
          referer: "https://music.163.com/"
        };
        if (ip) {
          headers["X-Real-IP"] = ip;
          headers["X-Forwarded-For"] = ip;
        }
        if (CLIENT_CONFIG[clientType].cookie) {
          headers.cookie = CLIENT_CONFIG[clientType].cookie;
        }
        try {
          const baseUrl = "https://music.163.com";
          const fullUrl = new URL(url.replace("api", "weapi"), baseUrl);
          fullUrl.searchParams.append("csrf_token", data.csrf_token);
          const response = await fetch(fullUrl.toString(), {
            method: "POST",
            headers,
            body: `params=${encodeURIComponent(
        encryptedData.params
      )}&encSecKey=${encodeURIComponent(encryptedData.encSecKey)}`,
            credentials: "include",
            // 包含cookies
            mode: "cors",
            // 启用CORS
            redirect: "follow"
            // 自动跟随重定向
          });
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(
              `HTTP error! status: ${response.status}, message: ${errorText}`
            );
          }
          const result = await response.json();
          if (result.code !== 200 && !originResponse) {
            throw new Error(result.msg || result.message || "API请求失败");
          }
          return originResponse ? {
            headers: response.headers,
            ...result
          } : result;
        } catch (error) {
          console.error("请求失败:", error);
          throw new Error(`请求失败: ${error.message || "未知错误"}`);
        }
      };
      var browser$1 = {};
      var canPromise$1 = function() {
        return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
      };
      var qrcode = {};
      var utils$1 = {};
      let toSJISFunction;
      const CODEWORDS_COUNT = [
        0,
        // Not used
        26,
        44,
        70,
        100,
        134,
        172,
        196,
        242,
        292,
        346,
        404,
        466,
        532,
        581,
        655,
        733,
        815,
        901,
        991,
        1085,
        1156,
        1258,
        1364,
        1474,
        1588,
        1706,
        1828,
        1921,
        2051,
        2185,
        2323,
        2465,
        2611,
        2761,
        2876,
        3034,
        3196,
        3362,
        3532,
        3706
      ];
      utils$1.getSymbolSize = function getSymbolSize(version2) {
        if (!version2) throw new Error('"version" cannot be null or undefined');
        if (version2 < 1 || version2 > 40) throw new Error('"version" should be in range from 1 to 40');
        return version2 * 4 + 17;
      };
      utils$1.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
        return CODEWORDS_COUNT[version2];
      };
      utils$1.getBCHDigit = function(data) {
        let digit = 0;
        while (data !== 0) {
          digit++;
          data >>>= 1;
        }
        return digit;
      };
      utils$1.setToSJISFunction = function setToSJISFunction(f2) {
        if (typeof f2 !== "function") {
          throw new Error('"toSJISFunc" is not a valid function.');
        }
        toSJISFunction = f2;
      };
      utils$1.isKanjiModeEnabled = function() {
        return typeof toSJISFunction !== "undefined";
      };
      utils$1.toSJIS = function toSJIS(kanji2) {
        return toSJISFunction(kanji2);
      };
      var errorCorrectionLevel = {};
      (function(exports) {
        exports.L = { bit: 1 };
        exports.M = { bit: 0 };
        exports.Q = { bit: 3 };
        exports.H = { bit: 2 };
        function fromString(string) {
          if (typeof string !== "string") {
            throw new Error("Param is not a string");
          }
          const lcStr = string.toLowerCase();
          switch (lcStr) {
            case "l":
            case "low":
              return exports.L;
            case "m":
            case "medium":
              return exports.M;
            case "q":
            case "quartile":
              return exports.Q;
            case "h":
            case "high":
              return exports.H;
            default:
              throw new Error("Unknown EC Level: " + string);
          }
        }
        exports.isValid = function isValid2(level) {
          return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
        };
        exports.from = function from(value2, defaultValue) {
          if (exports.isValid(value2)) {
            return value2;
          }
          try {
            return fromString(value2);
          } catch (e) {
            return defaultValue;
          }
        };
      })(errorCorrectionLevel);
      function BitBuffer$1() {
        this.buffer = [];
        this.length = 0;
      }
      BitBuffer$1.prototype = {
        get: function(index) {
          const bufIndex = Math.floor(index / 8);
          return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
        },
        put: function(num, length) {
          for (let i = 0; i < length; i++) {
            this.putBit((num >>> length - i - 1 & 1) === 1);
          }
        },
        getLengthInBits: function() {
          return this.length;
        },
        putBit: function(bit) {
          const bufIndex = Math.floor(this.length / 8);
          if (this.buffer.length <= bufIndex) {
            this.buffer.push(0);
          }
          if (bit) {
            this.buffer[bufIndex] |= 128 >>> this.length % 8;
          }
          this.length++;
        }
      };
      var bitBuffer = BitBuffer$1;
      function BitMatrix$1(size2) {
        if (!size2 || size2 < 1) {
          throw new Error("BitMatrix size must be defined and greater than 0");
        }
        this.size = size2;
        this.data = new Uint8Array(size2 * size2);
        this.reservedBit = new Uint8Array(size2 * size2);
      }
      BitMatrix$1.prototype.set = function(row, col, value2, reserved) {
        const index = row * this.size + col;
        this.data[index] = value2;
        if (reserved) this.reservedBit[index] = true;
      };
      BitMatrix$1.prototype.get = function(row, col) {
        return this.data[row * this.size + col];
      };
      BitMatrix$1.prototype.xor = function(row, col, value2) {
        this.data[row * this.size + col] ^= value2;
      };
      BitMatrix$1.prototype.isReserved = function(row, col) {
        return this.reservedBit[row * this.size + col];
      };
      var bitMatrix = BitMatrix$1;
      var alignmentPattern = {};
      (function(exports) {
        const getSymbolSize3 = utils$1.getSymbolSize;
        exports.getRowColCoords = function getRowColCoords(version2) {
          if (version2 === 1) return [];
          const posCount = Math.floor(version2 / 7) + 2;
          const size2 = getSymbolSize3(version2);
          const intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
          const positions = [size2 - 7];
          for (let i = 1; i < posCount - 1; i++) {
            positions[i] = positions[i - 1] - intervals;
          }
          positions.push(6);
          return positions.reverse();
        };
        exports.getPositions = function getPositions2(version2) {
          const coords = [];
          const pos = exports.getRowColCoords(version2);
          const posLength = pos.length;
          for (let i = 0; i < posLength; i++) {
            for (let j = 0; j < posLength; j++) {
              if (i === 0 && j === 0 || // top-left
              i === 0 && j === posLength - 1 || // bottom-left
              i === posLength - 1 && j === 0) {
                continue;
              }
              coords.push([pos[i], pos[j]]);
            }
          }
          return coords;
        };
      })(alignmentPattern);
      var finderPattern = {};
      const getSymbolSize2 = utils$1.getSymbolSize;
      const FINDER_PATTERN_SIZE = 7;
      finderPattern.getPositions = function getPositions(version2) {
        const size2 = getSymbolSize2(version2);
        return [
          // top-left
          [0, 0],
          // top-right
          [size2 - FINDER_PATTERN_SIZE, 0],
          // bottom-left
          [0, size2 - FINDER_PATTERN_SIZE]
        ];
      };
      var maskPattern = {};
      (function(exports) {
        exports.Patterns = {
          PATTERN000: 0,
          PATTERN001: 1,
          PATTERN010: 2,
          PATTERN011: 3,
          PATTERN100: 4,
          PATTERN101: 5,
          PATTERN110: 6,
          PATTERN111: 7
        };
        const PenaltyScores = {
          N1: 3,
          N2: 3,
          N3: 40,
          N4: 10
        };
        exports.isValid = function isValid2(mask) {
          return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
        };
        exports.from = function from(value2) {
          return exports.isValid(value2) ? parseInt(value2, 10) : void 0;
        };
        exports.getPenaltyN1 = function getPenaltyN1(data) {
          const size2 = data.size;
          let points = 0;
          let sameCountCol = 0;
          let sameCountRow = 0;
          let lastCol = null;
          let lastRow = null;
          for (let row = 0; row < size2; row++) {
            sameCountCol = sameCountRow = 0;
            lastCol = lastRow = null;
            for (let col = 0; col < size2; col++) {
              let module = data.get(row, col);
              if (module === lastCol) {
                sameCountCol++;
              } else {
                if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
                lastCol = module;
                sameCountCol = 1;
              }
              module = data.get(col, row);
              if (module === lastRow) {
                sameCountRow++;
              } else {
                if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
                lastRow = module;
                sameCountRow = 1;
              }
            }
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
          }
          return points;
        };
        exports.getPenaltyN2 = function getPenaltyN2(data) {
          const size2 = data.size;
          let points = 0;
          for (let row = 0; row < size2 - 1; row++) {
            for (let col = 0; col < size2 - 1; col++) {
              const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
              if (last === 4 || last === 0) points++;
            }
          }
          return points * PenaltyScores.N2;
        };
        exports.getPenaltyN3 = function getPenaltyN3(data) {
          const size2 = data.size;
          let points = 0;
          let bitsCol = 0;
          let bitsRow = 0;
          for (let row = 0; row < size2; row++) {
            bitsCol = bitsRow = 0;
            for (let col = 0; col < size2; col++) {
              bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
              if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
              bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
              if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
            }
          }
          return points * PenaltyScores.N3;
        };
        exports.getPenaltyN4 = function getPenaltyN4(data) {
          let darkCount = 0;
          const modulesCount = data.data.length;
          for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];
          const k2 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
          return k2 * PenaltyScores.N4;
        };
        function getMaskAt(maskPattern2, i, j) {
          switch (maskPattern2) {
            case exports.Patterns.PATTERN000:
              return (i + j) % 2 === 0;
            case exports.Patterns.PATTERN001:
              return i % 2 === 0;
            case exports.Patterns.PATTERN010:
              return j % 3 === 0;
            case exports.Patterns.PATTERN011:
              return (i + j) % 3 === 0;
            case exports.Patterns.PATTERN100:
              return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
            case exports.Patterns.PATTERN101:
              return i * j % 2 + i * j % 3 === 0;
            case exports.Patterns.PATTERN110:
              return (i * j % 2 + i * j % 3) % 2 === 0;
            case exports.Patterns.PATTERN111:
              return (i * j % 3 + (i + j) % 2) % 2 === 0;
            default:
              throw new Error("bad maskPattern:" + maskPattern2);
          }
        }
        exports.applyMask = function applyMask(pattern, data) {
          const size2 = data.size;
          for (let col = 0; col < size2; col++) {
            for (let row = 0; row < size2; row++) {
              if (data.isReserved(row, col)) continue;
              data.xor(row, col, getMaskAt(pattern, row, col));
            }
          }
        };
        exports.getBestMask = function getBestMask(data, setupFormatFunc) {
          const numPatterns = Object.keys(exports.Patterns).length;
          let bestPattern = 0;
          let lowerPenalty = Infinity;
          for (let p2 = 0; p2 < numPatterns; p2++) {
            setupFormatFunc(p2);
            exports.applyMask(p2, data);
            const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
            exports.applyMask(p2, data);
            if (penalty < lowerPenalty) {
              lowerPenalty = penalty;
              bestPattern = p2;
            }
          }
          return bestPattern;
        };
      })(maskPattern);
      var errorCorrectionCode = {};
      const ECLevel$1 = errorCorrectionLevel;
      const EC_BLOCKS_TABLE = [
        // L  M  Q  H
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        1,
        2,
        2,
        4,
        1,
        2,
        4,
        4,
        2,
        4,
        4,
        4,
        2,
        4,
        6,
        5,
        2,
        4,
        6,
        6,
        2,
        5,
        8,
        8,
        4,
        5,
        8,
        8,
        4,
        5,
        8,
        11,
        4,
        8,
        10,
        11,
        4,
        9,
        12,
        16,
        4,
        9,
        16,
        16,
        6,
        10,
        12,
        18,
        6,
        10,
        17,
        16,
        6,
        11,
        16,
        19,
        6,
        13,
        18,
        21,
        7,
        14,
        21,
        25,
        8,
        16,
        20,
        25,
        8,
        17,
        23,
        25,
        9,
        17,
        23,
        34,
        9,
        18,
        25,
        30,
        10,
        20,
        27,
        32,
        12,
        21,
        29,
        35,
        12,
        23,
        34,
        37,
        12,
        25,
        34,
        40,
        13,
        26,
        35,
        42,
        14,
        28,
        38,
        45,
        15,
        29,
        40,
        48,
        16,
        31,
        43,
        51,
        17,
        33,
        45,
        54,
        18,
        35,
        48,
        57,
        19,
        37,
        51,
        60,
        19,
        38,
        53,
        63,
        20,
        40,
        56,
        66,
        21,
        43,
        59,
        70,
        22,
        45,
        62,
        74,
        24,
        47,
        65,
        77,
        25,
        49,
        68,
        81
      ];
      const EC_CODEWORDS_TABLE = [
        // L  M  Q  H
        7,
        10,
        13,
        17,
        10,
        16,
        22,
        28,
        15,
        26,
        36,
        44,
        20,
        36,
        52,
        64,
        26,
        48,
        72,
        88,
        36,
        64,
        96,
        112,
        40,
        72,
        108,
        130,
        48,
        88,
        132,
        156,
        60,
        110,
        160,
        192,
        72,
        130,
        192,
        224,
        80,
        150,
        224,
        264,
        96,
        176,
        260,
        308,
        104,
        198,
        288,
        352,
        120,
        216,
        320,
        384,
        132,
        240,
        360,
        432,
        144,
        280,
        408,
        480,
        168,
        308,
        448,
        532,
        180,
        338,
        504,
        588,
        196,
        364,
        546,
        650,
        224,
        416,
        600,
        700,
        224,
        442,
        644,
        750,
        252,
        476,
        690,
        816,
        270,
        504,
        750,
        900,
        300,
        560,
        810,
        960,
        312,
        588,
        870,
        1050,
        336,
        644,
        952,
        1110,
        360,
        700,
        1020,
        1200,
        390,
        728,
        1050,
        1260,
        420,
        784,
        1140,
        1350,
        450,
        812,
        1200,
        1440,
        480,
        868,
        1290,
        1530,
        510,
        924,
        1350,
        1620,
        540,
        980,
        1440,
        1710,
        570,
        1036,
        1530,
        1800,
        570,
        1064,
        1590,
        1890,
        600,
        1120,
        1680,
        1980,
        630,
        1204,
        1770,
        2100,
        660,
        1260,
        1860,
        2220,
        720,
        1316,
        1950,
        2310,
        750,
        1372,
        2040,
        2430
      ];
      errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
        switch (errorCorrectionLevel2) {
          case ECLevel$1.L:
            return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
          case ECLevel$1.M:
            return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
          case ECLevel$1.Q:
            return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
          case ECLevel$1.H:
            return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
          default:
            return void 0;
        }
      };
      errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
        switch (errorCorrectionLevel2) {
          case ECLevel$1.L:
            return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
          case ECLevel$1.M:
            return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
          case ECLevel$1.Q:
            return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
          case ECLevel$1.H:
            return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
          default:
            return void 0;
        }
      };
      var polynomial = {};
      var galoisField = {};
      const EXP_TABLE = new Uint8Array(512);
      const LOG_TABLE = new Uint8Array(256);
      (function initTables() {
        let x = 1;
        for (let i = 0; i < 255; i++) {
          EXP_TABLE[i] = x;
          LOG_TABLE[x] = i;
          x <<= 1;
          if (x & 256) {
            x ^= 285;
          }
        }
        for (let i = 255; i < 512; i++) {
          EXP_TABLE[i] = EXP_TABLE[i - 255];
        }
      })();
      galoisField.log = function log(n2) {
        if (n2 < 1) throw new Error("log(" + n2 + ")");
        return LOG_TABLE[n2];
      };
      galoisField.exp = function exp(n2) {
        return EXP_TABLE[n2];
      };
      galoisField.mul = function mul(x, y) {
        if (x === 0 || y === 0) return 0;
        return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
      };
      (function(exports) {
        const GF = galoisField;
        exports.mul = function mul2(p1, p2) {
          const coeff = new Uint8Array(p1.length + p2.length - 1);
          for (let i = 0; i < p1.length; i++) {
            for (let j = 0; j < p2.length; j++) {
              coeff[i + j] ^= GF.mul(p1[i], p2[j]);
            }
          }
          return coeff;
        };
        exports.mod = function mod(divident, divisor) {
          let result = new Uint8Array(divident);
          while (result.length - divisor.length >= 0) {
            const coeff = result[0];
            for (let i = 0; i < divisor.length; i++) {
              result[i] ^= GF.mul(divisor[i], coeff);
            }
            let offset = 0;
            while (offset < result.length && result[offset] === 0) offset++;
            result = result.slice(offset);
          }
          return result;
        };
        exports.generateECPolynomial = function generateECPolynomial(degree) {
          let poly = new Uint8Array([1]);
          for (let i = 0; i < degree; i++) {
            poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
          }
          return poly;
        };
      })(polynomial);
      const Polynomial = polynomial;
      function ReedSolomonEncoder$1(degree) {
        this.genPoly = void 0;
        this.degree = degree;
        if (this.degree) this.initialize(this.degree);
      }
      ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
        this.degree = degree;
        this.genPoly = Polynomial.generateECPolynomial(this.degree);
      };
      ReedSolomonEncoder$1.prototype.encode = function encode(data) {
        if (!this.genPoly) {
          throw new Error("Encoder not initialized");
        }
        const paddedData = new Uint8Array(data.length + this.degree);
        paddedData.set(data);
        const remainder = Polynomial.mod(paddedData, this.genPoly);
        const start = this.degree - remainder.length;
        if (start > 0) {
          const buff = new Uint8Array(this.degree);
          buff.set(remainder, start);
          return buff;
        }
        return remainder;
      };
      var reedSolomonEncoder = ReedSolomonEncoder$1;
      var version = {};
      var mode = {};
      var versionCheck = {};
      versionCheck.isValid = function isValid(version2) {
        return !isNaN(version2) && version2 >= 1 && version2 <= 40;
      };
      var regex = {};
      const numeric = "[0-9]+";
      const alphanumeric = "[A-Z $%*+\\-./:]+";
      let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
      kanji = kanji.replace(/u/g, "\\u");
      const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
      regex.KANJI = new RegExp(kanji, "g");
      regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
      regex.BYTE = new RegExp(byte, "g");
      regex.NUMERIC = new RegExp(numeric, "g");
      regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
      const TEST_KANJI = new RegExp("^" + kanji + "$");
      const TEST_NUMERIC = new RegExp("^" + numeric + "$");
      const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
      regex.testKanji = function testKanji(str) {
        return TEST_KANJI.test(str);
      };
      regex.testNumeric = function testNumeric(str) {
        return TEST_NUMERIC.test(str);
      };
      regex.testAlphanumeric = function testAlphanumeric(str) {
        return TEST_ALPHANUMERIC.test(str);
      };
      (function(exports) {
        const VersionCheck = versionCheck;
        const Regex = regex;
        exports.NUMERIC = {
          id: "Numeric",
          bit: 1 << 0,
          ccBits: [10, 12, 14]
        };
        exports.ALPHANUMERIC = {
          id: "Alphanumeric",
          bit: 1 << 1,
          ccBits: [9, 11, 13]
        };
        exports.BYTE = {
          id: "Byte",
          bit: 1 << 2,
          ccBits: [8, 16, 16]
        };
        exports.KANJI = {
          id: "Kanji",
          bit: 1 << 3,
          ccBits: [8, 10, 12]
        };
        exports.MIXED = {
          bit: -1
        };
        exports.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
          if (!mode2.ccBits) throw new Error("Invalid mode: " + mode2);
          if (!VersionCheck.isValid(version2)) {
            throw new Error("Invalid version: " + version2);
          }
          if (version2 >= 1 && version2 < 10) return mode2.ccBits[0];
          else if (version2 < 27) return mode2.ccBits[1];
          return mode2.ccBits[2];
        };
        exports.getBestModeForData = function getBestModeForData(dataStr) {
          if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
          else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
          else if (Regex.testKanji(dataStr)) return exports.KANJI;
          else return exports.BYTE;
        };
        exports.toString = function toString(mode2) {
          if (mode2 && mode2.id) return mode2.id;
          throw new Error("Invalid mode");
        };
        exports.isValid = function isValid2(mode2) {
          return mode2 && mode2.bit && mode2.ccBits;
        };
        function fromString(string) {
          if (typeof string !== "string") {
            throw new Error("Param is not a string");
          }
          const lcStr = string.toLowerCase();
          switch (lcStr) {
            case "numeric":
              return exports.NUMERIC;
            case "alphanumeric":
              return exports.ALPHANUMERIC;
            case "kanji":
              return exports.KANJI;
            case "byte":
              return exports.BYTE;
            default:
              throw new Error("Unknown mode: " + string);
          }
        }
        exports.from = function from(value2, defaultValue) {
          if (exports.isValid(value2)) {
            return value2;
          }
          try {
            return fromString(value2);
          } catch (e) {
            return defaultValue;
          }
        };
      })(mode);
      (function(exports) {
        const Utils2 = utils$1;
        const ECCode2 = errorCorrectionCode;
        const ECLevel2 = errorCorrectionLevel;
        const Mode2 = mode;
        const VersionCheck = versionCheck;
        const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
        const G18_BCH = Utils2.getBCHDigit(G18);
        function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
          for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
            if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
              return currentVersion;
            }
          }
          return void 0;
        }
        function getReservedBitsCount(mode2, version2) {
          return Mode2.getCharCountIndicator(mode2, version2) + 4;
        }
        function getTotalBitsFromDataArray(segments2, version2) {
          let totalBits = 0;
          segments2.forEach(function(data) {
            const reservedBits = getReservedBitsCount(data.mode, version2);
            totalBits += reservedBits + data.getBitsLength();
          });
          return totalBits;
        }
        function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
          for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
            const length = getTotalBitsFromDataArray(segments2, currentVersion);
            if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)) {
              return currentVersion;
            }
          }
          return void 0;
        }
        exports.from = function from(value2, defaultValue) {
          if (VersionCheck.isValid(value2)) {
            return parseInt(value2, 10);
          }
          return defaultValue;
        };
        exports.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
          if (!VersionCheck.isValid(version2)) {
            throw new Error("Invalid QR Code version");
          }
          if (typeof mode2 === "undefined") mode2 = Mode2.BYTE;
          const totalCodewords = Utils2.getSymbolTotalCodewords(version2);
          const ecTotalCodewords = ECCode2.getTotalCodewordsCount(version2, errorCorrectionLevel2);
          const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
          if (mode2 === Mode2.MIXED) return dataTotalCodewordsBits;
          const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
          switch (mode2) {
            case Mode2.NUMERIC:
              return Math.floor(usableBits / 10 * 3);
            case Mode2.ALPHANUMERIC:
              return Math.floor(usableBits / 11 * 2);
            case Mode2.KANJI:
              return Math.floor(usableBits / 13);
            case Mode2.BYTE:
            default:
              return Math.floor(usableBits / 8);
          }
        };
        exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel2) {
          let seg;
          const ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M);
          if (Array.isArray(data)) {
            if (data.length > 1) {
              return getBestVersionForMixedData(data, ecl);
            }
            if (data.length === 0) {
              return 1;
            }
            seg = data[0];
          } else {
            seg = data;
          }
          return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
        };
        exports.getEncodedBits = function getEncodedBits2(version2) {
          if (!VersionCheck.isValid(version2) || version2 < 7) {
            throw new Error("Invalid QR Code version");
          }
          let d = version2 << 12;
          while (Utils2.getBCHDigit(d) - G18_BCH >= 0) {
            d ^= G18 << Utils2.getBCHDigit(d) - G18_BCH;
          }
          return version2 << 12 | d;
        };
      })(version);
      var formatInfo = {};
      const Utils$3 = utils$1;
      const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
      const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
      const G15_BCH = Utils$3.getBCHDigit(G15);
      formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask) {
        const data = errorCorrectionLevel2.bit << 3 | mask;
        let d = data << 10;
        while (Utils$3.getBCHDigit(d) - G15_BCH >= 0) {
          d ^= G15 << Utils$3.getBCHDigit(d) - G15_BCH;
        }
        return (data << 10 | d) ^ G15_MASK;
      };
      var segments = {};
      const Mode$4 = mode;
      function NumericData(data) {
        this.mode = Mode$4.NUMERIC;
        this.data = data.toString();
      }
      NumericData.getBitsLength = function getBitsLength(length) {
        return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
      };
      NumericData.prototype.getLength = function getLength() {
        return this.data.length;
      };
      NumericData.prototype.getBitsLength = function getBitsLength2() {
        return NumericData.getBitsLength(this.data.length);
      };
      NumericData.prototype.write = function write(bitBuffer2) {
        let i, group, value2;
        for (i = 0; i + 3 <= this.data.length; i += 3) {
          group = this.data.substr(i, 3);
          value2 = parseInt(group, 10);
          bitBuffer2.put(value2, 10);
        }
        const remainingNum = this.data.length - i;
        if (remainingNum > 0) {
          group = this.data.substr(i);
          value2 = parseInt(group, 10);
          bitBuffer2.put(value2, remainingNum * 3 + 1);
        }
      };
      var numericData = NumericData;
      const Mode$3 = mode;
      const ALPHA_NUM_CHARS = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        " ",
        "$",
        "%",
        "*",
        "+",
        "-",
        ".",
        "/",
        ":"
      ];
      function AlphanumericData(data) {
        this.mode = Mode$3.ALPHANUMERIC;
        this.data = data;
      }
      AlphanumericData.getBitsLength = function getBitsLength3(length) {
        return 11 * Math.floor(length / 2) + 6 * (length % 2);
      };
      AlphanumericData.prototype.getLength = function getLength2() {
        return this.data.length;
      };
      AlphanumericData.prototype.getBitsLength = function getBitsLength4() {
        return AlphanumericData.getBitsLength(this.data.length);
      };
      AlphanumericData.prototype.write = function write2(bitBuffer2) {
        let i;
        for (i = 0; i + 2 <= this.data.length; i += 2) {
          let value2 = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
          value2 += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
          bitBuffer2.put(value2, 11);
        }
        if (this.data.length % 2) {
          bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
        }
      };
      var alphanumericData = AlphanumericData;
      const Mode$2 = mode;
      function ByteData(data) {
        this.mode = Mode$2.BYTE;
        if (typeof data === "string") {
          this.data = new TextEncoder().encode(data);
        } else {
          this.data = new Uint8Array(data);
        }
      }
      ByteData.getBitsLength = function getBitsLength5(length) {
        return length * 8;
      };
      ByteData.prototype.getLength = function getLength3() {
        return this.data.length;
      };
      ByteData.prototype.getBitsLength = function getBitsLength6() {
        return ByteData.getBitsLength(this.data.length);
      };
      ByteData.prototype.write = function(bitBuffer2) {
        for (let i = 0, l2 = this.data.length; i < l2; i++) {
          bitBuffer2.put(this.data[i], 8);
        }
      };
      var byteData = ByteData;
      const Mode$1 = mode;
      const Utils$2 = utils$1;
      function KanjiData(data) {
        this.mode = Mode$1.KANJI;
        this.data = data;
      }
      KanjiData.getBitsLength = function getBitsLength7(length) {
        return length * 13;
      };
      KanjiData.prototype.getLength = function getLength4() {
        return this.data.length;
      };
      KanjiData.prototype.getBitsLength = function getBitsLength8() {
        return KanjiData.getBitsLength(this.data.length);
      };
      KanjiData.prototype.write = function(bitBuffer2) {
        let i;
        for (i = 0; i < this.data.length; i++) {
          let value2 = Utils$2.toSJIS(this.data[i]);
          if (value2 >= 33088 && value2 <= 40956) {
            value2 -= 33088;
          } else if (value2 >= 57408 && value2 <= 60351) {
            value2 -= 49472;
          } else {
            throw new Error(
              "Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8"
            );
          }
          value2 = (value2 >>> 8 & 255) * 192 + (value2 & 255);
          bitBuffer2.put(value2, 13);
        }
      };
      var kanjiData = KanjiData;
      var dijkstra = { exports: {} };
      (function(module) {
        var dijkstra2 = {
          single_source_shortest_paths: function(graph, s, d) {
            var predecessors = {};
            var costs = {};
            costs[s] = 0;
            var open = dijkstra2.PriorityQueue.make();
            open.push(s, 0);
            var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
            while (!open.empty()) {
              closest = open.pop();
              u = closest.value;
              cost_of_s_to_u = closest.cost;
              adjacent_nodes = graph[u] || {};
              for (v in adjacent_nodes) {
                if (adjacent_nodes.hasOwnProperty(v)) {
                  cost_of_e = adjacent_nodes[v];
                  cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
                  cost_of_s_to_v = costs[v];
                  first_visit = typeof costs[v] === "undefined";
                  if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                    costs[v] = cost_of_s_to_u_plus_cost_of_e;
                    open.push(v, cost_of_s_to_u_plus_cost_of_e);
                    predecessors[v] = u;
                  }
                }
              }
            }
            if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
              var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
              throw new Error(msg);
            }
            return predecessors;
          },
          extract_shortest_path_from_predecessor_list: function(predecessors, d) {
            var nodes = [];
            var u = d;
            while (u) {
              nodes.push(u);
              predecessors[u];
              u = predecessors[u];
            }
            nodes.reverse();
            return nodes;
          },
          find_path: function(graph, s, d) {
            var predecessors = dijkstra2.single_source_shortest_paths(graph, s, d);
            return dijkstra2.extract_shortest_path_from_predecessor_list(
              predecessors,
              d
            );
          },
          /**
           * A very naive priority queue implementation.
           */
          PriorityQueue: {
            make: function(opts) {
              var T = dijkstra2.PriorityQueue, t = {}, key;
              opts = opts || {};
              for (key in T) {
                if (T.hasOwnProperty(key)) {
                  t[key] = T[key];
                }
              }
              t.queue = [];
              t.sorter = opts.sorter || T.default_sorter;
              return t;
            },
            default_sorter: function(a, b) {
              return a.cost - b.cost;
            },
            /**
             * Add a new item to the queue and ensure the highest priority element
             * is at the front of the queue.
             */
            push: function(value2, cost) {
              var item = { value: value2, cost };
              this.queue.push(item);
              this.queue.sort(this.sorter);
            },
            /**
             * Return the highest priority element in the queue.
             */
            pop: function() {
              return this.queue.shift();
            },
            empty: function() {
              return this.queue.length === 0;
            }
          }
        };
        {
          module.exports = dijkstra2;
        }
      })(dijkstra);
      var dijkstraExports = dijkstra.exports;
      (function(exports) {
        const Mode2 = mode;
        const NumericData2 = numericData;
        const AlphanumericData2 = alphanumericData;
        const ByteData2 = byteData;
        const KanjiData2 = kanjiData;
        const Regex = regex;
        const Utils2 = utils$1;
        const dijkstra2 = dijkstraExports;
        function getStringByteLength(str) {
          return unescape(encodeURIComponent(str)).length;
        }
        function getSegments(regex2, mode2, str) {
          const segments2 = [];
          let result;
          while ((result = regex2.exec(str)) !== null) {
            segments2.push({
              data: result[0],
              index: result.index,
              mode: mode2,
              length: result[0].length
            });
          }
          return segments2;
        }
        function getSegmentsFromString(dataStr) {
          const numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr);
          const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode2.ALPHANUMERIC, dataStr);
          let byteSegs;
          let kanjiSegs;
          if (Utils2.isKanjiModeEnabled()) {
            byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr);
            kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr);
          } else {
            byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr);
            kanjiSegs = [];
          }
          const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
          return segs.sort(function(s1, s2) {
            return s1.index - s2.index;
          }).map(function(obj) {
            return {
              data: obj.data,
              mode: obj.mode,
              length: obj.length
            };
          });
        }
        function getSegmentBitsLength(length, mode2) {
          switch (mode2) {
            case Mode2.NUMERIC:
              return NumericData2.getBitsLength(length);
            case Mode2.ALPHANUMERIC:
              return AlphanumericData2.getBitsLength(length);
            case Mode2.KANJI:
              return KanjiData2.getBitsLength(length);
            case Mode2.BYTE:
              return ByteData2.getBitsLength(length);
          }
        }
        function mergeSegments(segs) {
          return segs.reduce(function(acc, curr) {
            const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
            if (prevSeg && prevSeg.mode === curr.mode) {
              acc[acc.length - 1].data += curr.data;
              return acc;
            }
            acc.push(curr);
            return acc;
          }, []);
        }
        function buildNodes(segs) {
          const nodes = [];
          for (let i = 0; i < segs.length; i++) {
            const seg = segs[i];
            switch (seg.mode) {
              case Mode2.NUMERIC:
                nodes.push([
                  seg,
                  { data: seg.data, mode: Mode2.ALPHANUMERIC, length: seg.length },
                  { data: seg.data, mode: Mode2.BYTE, length: seg.length }
                ]);
                break;
              case Mode2.ALPHANUMERIC:
                nodes.push([
                  seg,
                  { data: seg.data, mode: Mode2.BYTE, length: seg.length }
                ]);
                break;
              case Mode2.KANJI:
                nodes.push([
                  seg,
                  { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
                ]);
                break;
              case Mode2.BYTE:
                nodes.push([
                  { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
                ]);
            }
          }
          return nodes;
        }
        function buildGraph(nodes, version2) {
          const table = {};
          const graph = { start: {} };
          let prevNodeIds = ["start"];
          for (let i = 0; i < nodes.length; i++) {
            const nodeGroup = nodes[i];
            const currentNodeIds = [];
            for (let j = 0; j < nodeGroup.length; j++) {
              const node = nodeGroup[j];
              const key = "" + i + j;
              currentNodeIds.push(key);
              table[key] = { node, lastCount: 0 };
              graph[key] = {};
              for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
                const prevNodeId = prevNodeIds[n2];
                if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
                  graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
                  table[prevNodeId].lastCount += node.length;
                } else {
                  if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
                  graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode2.getCharCountIndicator(node.mode, version2);
                }
              }
            }
            prevNodeIds = currentNodeIds;
          }
          for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
            graph[prevNodeIds[n2]].end = 0;
          }
          return { map: graph, table };
        }
        function buildSingleSegment(data, modesHint) {
          let mode2;
          const bestMode = Mode2.getBestModeForData(data);
          mode2 = Mode2.from(modesHint, bestMode);
          if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
            throw new Error('"' + data + '" cannot be encoded with mode ' + Mode2.toString(mode2) + ".\n Suggested mode is: " + Mode2.toString(bestMode));
          }
          if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
            mode2 = Mode2.BYTE;
          }
          switch (mode2) {
            case Mode2.NUMERIC:
              return new NumericData2(data);
            case Mode2.ALPHANUMERIC:
              return new AlphanumericData2(data);
            case Mode2.KANJI:
              return new KanjiData2(data);
            case Mode2.BYTE:
              return new ByteData2(data);
          }
        }
        exports.fromArray = function fromArray(array) {
          return array.reduce(function(acc, seg) {
            if (typeof seg === "string") {
              acc.push(buildSingleSegment(seg, null));
            } else if (seg.data) {
              acc.push(buildSingleSegment(seg.data, seg.mode));
            }
            return acc;
          }, []);
        };
        exports.fromString = function fromString(data, version2) {
          const segs = getSegmentsFromString(data, Utils2.isKanjiModeEnabled());
          const nodes = buildNodes(segs);
          const graph = buildGraph(nodes, version2);
          const path = dijkstra2.find_path(graph.map, "start", "end");
          const optimizedSegs = [];
          for (let i = 1; i < path.length - 1; i++) {
            optimizedSegs.push(graph.table[path[i]].node);
          }
          return exports.fromArray(mergeSegments(optimizedSegs));
        };
        exports.rawSplit = function rawSplit(data) {
          return exports.fromArray(
            getSegmentsFromString(data, Utils2.isKanjiModeEnabled())
          );
        };
      })(segments);
      const Utils$1 = utils$1;
      const ECLevel = errorCorrectionLevel;
      const BitBuffer = bitBuffer;
      const BitMatrix = bitMatrix;
      const AlignmentPattern = alignmentPattern;
      const FinderPattern = finderPattern;
      const MaskPattern = maskPattern;
      const ECCode = errorCorrectionCode;
      const ReedSolomonEncoder = reedSolomonEncoder;
      const Version = version;
      const FormatInfo = formatInfo;
      const Mode = mode;
      const Segments = segments;
      function setupFinderPattern(matrix, version2) {
        const size2 = matrix.size;
        const pos = FinderPattern.getPositions(version2);
        for (let i = 0; i < pos.length; i++) {
          const row = pos[i][0];
          const col = pos[i][1];
          for (let r = -1; r <= 7; r++) {
            if (row + r <= -1 || size2 <= row + r) continue;
            for (let c = -1; c <= 7; c++) {
              if (col + c <= -1 || size2 <= col + c) continue;
              if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
                matrix.set(row + r, col + c, true, true);
              } else {
                matrix.set(row + r, col + c, false, true);
              }
            }
          }
        }
      }
      function setupTimingPattern(matrix) {
        const size2 = matrix.size;
        for (let r = 8; r < size2 - 8; r++) {
          const value2 = r % 2 === 0;
          matrix.set(r, 6, value2, true);
          matrix.set(6, r, value2, true);
        }
      }
      function setupAlignmentPattern(matrix, version2) {
        const pos = AlignmentPattern.getPositions(version2);
        for (let i = 0; i < pos.length; i++) {
          const row = pos[i][0];
          const col = pos[i][1];
          for (let r = -2; r <= 2; r++) {
            for (let c = -2; c <= 2; c++) {
              if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
                matrix.set(row + r, col + c, true, true);
              } else {
                matrix.set(row + r, col + c, false, true);
              }
            }
          }
        }
      }
      function setupVersionInfo(matrix, version2) {
        const size2 = matrix.size;
        const bits = Version.getEncodedBits(version2);
        let row, col, mod;
        for (let i = 0; i < 18; i++) {
          row = Math.floor(i / 3);
          col = i % 3 + size2 - 8 - 3;
          mod = (bits >> i & 1) === 1;
          matrix.set(row, col, mod, true);
          matrix.set(col, row, mod, true);
        }
      }
      function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
        const size2 = matrix.size;
        const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
        let i, mod;
        for (i = 0; i < 15; i++) {
          mod = (bits >> i & 1) === 1;
          if (i < 6) {
            matrix.set(i, 8, mod, true);
          } else if (i < 8) {
            matrix.set(i + 1, 8, mod, true);
          } else {
            matrix.set(size2 - 15 + i, 8, mod, true);
          }
          if (i < 8) {
            matrix.set(8, size2 - i - 1, mod, true);
          } else if (i < 9) {
            matrix.set(8, 15 - i - 1 + 1, mod, true);
          } else {
            matrix.set(8, 15 - i - 1, mod, true);
          }
        }
        matrix.set(size2 - 8, 8, 1, true);
      }
      function setupData(matrix, data) {
        const size2 = matrix.size;
        let inc = -1;
        let row = size2 - 1;
        let bitIndex = 7;
        let byteIndex = 0;
        for (let col = size2 - 1; col > 0; col -= 2) {
          if (col === 6) col--;
          while (true) {
            for (let c = 0; c < 2; c++) {
              if (!matrix.isReserved(row, col - c)) {
                let dark = false;
                if (byteIndex < data.length) {
                  dark = (data[byteIndex] >>> bitIndex & 1) === 1;
                }
                matrix.set(row, col - c, dark);
                bitIndex--;
                if (bitIndex === -1) {
                  byteIndex++;
                  bitIndex = 7;
                }
              }
            }
            row += inc;
            if (row < 0 || size2 <= row) {
              row -= inc;
              inc = -inc;
              break;
            }
          }
        }
      }
      function createData(version2, errorCorrectionLevel2, segments2) {
        const buffer = new BitBuffer();
        segments2.forEach(function(data) {
          buffer.put(data.mode.bit, 4);
          buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version2));
          data.write(buffer);
        });
        const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
        const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
        if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
          buffer.put(0, 4);
        }
        while (buffer.getLengthInBits() % 8 !== 0) {
          buffer.putBit(0);
        }
        const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
        for (let i = 0; i < remainingByte; i++) {
          buffer.put(i % 2 ? 17 : 236, 8);
        }
        return createCodewords(buffer, version2, errorCorrectionLevel2);
      }
      function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
        const totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
        const dataTotalCodewords = totalCodewords - ecTotalCodewords;
        const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
        const blocksInGroup2 = totalCodewords % ecTotalBlocks;
        const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
        const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
        const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
        const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
        const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
        const rs = new ReedSolomonEncoder(ecCount);
        let offset = 0;
        const dcData = new Array(ecTotalBlocks);
        const ecData = new Array(ecTotalBlocks);
        let maxDataSize = 0;
        const buffer = new Uint8Array(bitBuffer2.buffer);
        for (let b = 0; b < ecTotalBlocks; b++) {
          const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
          dcData[b] = buffer.slice(offset, offset + dataSize);
          ecData[b] = rs.encode(dcData[b]);
          offset += dataSize;
          maxDataSize = Math.max(maxDataSize, dataSize);
        }
        const data = new Uint8Array(totalCodewords);
        let index = 0;
        let i, r;
        for (i = 0; i < maxDataSize; i++) {
          for (r = 0; r < ecTotalBlocks; r++) {
            if (i < dcData[r].length) {
              data[index++] = dcData[r][i];
            }
          }
        }
        for (i = 0; i < ecCount; i++) {
          for (r = 0; r < ecTotalBlocks; r++) {
            data[index++] = ecData[r][i];
          }
        }
        return data;
      }
      function createSymbol(data, version2, errorCorrectionLevel2, maskPattern2) {
        let segments2;
        if (Array.isArray(data)) {
          segments2 = Segments.fromArray(data);
        } else if (typeof data === "string") {
          let estimatedVersion = version2;
          if (!estimatedVersion) {
            const rawSegments = Segments.rawSplit(data);
            estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
          }
          segments2 = Segments.fromString(data, estimatedVersion || 40);
        } else {
          throw new Error("Invalid data");
        }
        const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
        if (!bestVersion) {
          throw new Error("The amount of data is too big to be stored in a QR Code");
        }
        if (!version2) {
          version2 = bestVersion;
        } else if (version2 < bestVersion) {
          throw new Error(
            "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
          );
        }
        const dataBits = createData(version2, errorCorrectionLevel2, segments2);
        const moduleCount = Utils$1.getSymbolSize(version2);
        const modules = new BitMatrix(moduleCount);
        setupFinderPattern(modules, version2);
        setupTimingPattern(modules);
        setupAlignmentPattern(modules, version2);
        setupFormatInfo(modules, errorCorrectionLevel2, 0);
        if (version2 >= 7) {
          setupVersionInfo(modules, version2);
        }
        setupData(modules, dataBits);
        if (isNaN(maskPattern2)) {
          maskPattern2 = MaskPattern.getBestMask(
            modules,
            setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
          );
        }
        MaskPattern.applyMask(maskPattern2, modules);
        setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
        return {
          modules,
          version: version2,
          errorCorrectionLevel: errorCorrectionLevel2,
          maskPattern: maskPattern2,
          segments: segments2
        };
      }
      qrcode.create = function create(data, options) {
        if (typeof data === "undefined" || data === "") {
          throw new Error("No input text");
        }
        let errorCorrectionLevel2 = ECLevel.M;
        let version2;
        let mask;
        if (typeof options !== "undefined") {
          errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
          version2 = Version.from(options.version);
          mask = MaskPattern.from(options.maskPattern);
          if (options.toSJISFunc) {
            Utils$1.setToSJISFunction(options.toSJISFunc);
          }
        }
        return createSymbol(data, version2, errorCorrectionLevel2, mask);
      };
      var canvas = {};
      var utils = {};
      (function(exports) {
        function hex2rgba(hex) {
          if (typeof hex === "number") {
            hex = hex.toString();
          }
          if (typeof hex !== "string") {
            throw new Error("Color should be defined as hex string");
          }
          let hexCode = hex.slice().replace("#", "").split("");
          if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
            throw new Error("Invalid hex color: " + hex);
          }
          if (hexCode.length === 3 || hexCode.length === 4) {
            hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
              return [c, c];
            }));
          }
          if (hexCode.length === 6) hexCode.push("F", "F");
          const hexValue = parseInt(hexCode.join(""), 16);
          return {
            r: hexValue >> 24 & 255,
            g: hexValue >> 16 & 255,
            b: hexValue >> 8 & 255,
            a: hexValue & 255,
            hex: "#" + hexCode.slice(0, 6).join("")
          };
        }
        exports.getOptions = function getOptions(options) {
          if (!options) options = {};
          if (!options.color) options.color = {};
          const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
          const width = options.width && options.width >= 21 ? options.width : void 0;
          const scale = options.scale || 4;
          return {
            width,
            scale: width ? 4 : scale,
            margin,
            color: {
              dark: hex2rgba(options.color.dark || "#000000ff"),
              light: hex2rgba(options.color.light || "#ffffffff")
            },
            type: options.type,
            rendererOpts: options.rendererOpts || {}
          };
        };
        exports.getScale = function getScale(qrSize, opts) {
          return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
        };
        exports.getImageWidth = function getImageWidth(qrSize, opts) {
          const scale = exports.getScale(qrSize, opts);
          return Math.floor((qrSize + opts.margin * 2) * scale);
        };
        exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
          const size2 = qr.modules.size;
          const data = qr.modules.data;
          const scale = exports.getScale(size2, opts);
          const symbolSize = Math.floor((size2 + opts.margin * 2) * scale);
          const scaledMargin = opts.margin * scale;
          const palette = [opts.color.light, opts.color.dark];
          for (let i = 0; i < symbolSize; i++) {
            for (let j = 0; j < symbolSize; j++) {
              let posDst = (i * symbolSize + j) * 4;
              let pxColor = opts.color.light;
              if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
                const iSrc = Math.floor((i - scaledMargin) / scale);
                const jSrc = Math.floor((j - scaledMargin) / scale);
                pxColor = palette[data[iSrc * size2 + jSrc] ? 1 : 0];
              }
              imgData[posDst++] = pxColor.r;
              imgData[posDst++] = pxColor.g;
              imgData[posDst++] = pxColor.b;
              imgData[posDst] = pxColor.a;
            }
          }
        };
      })(utils);
      (function(exports) {
        const Utils2 = utils;
        function clearCanvas(ctx, canvas2, size2) {
          ctx.clearRect(0, 0, canvas2.width, canvas2.height);
          if (!canvas2.style) canvas2.style = {};
          canvas2.height = size2;
          canvas2.width = size2;
          canvas2.style.height = size2 + "px";
          canvas2.style.width = size2 + "px";
        }
        function getCanvasElement() {
          try {
            return document.createElement("canvas");
          } catch (e) {
            throw new Error("You need to specify a canvas element");
          }
        }
        exports.render = function render2(qrData, canvas2, options) {
          let opts = options;
          let canvasEl = canvas2;
          if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
            opts = canvas2;
            canvas2 = void 0;
          }
          if (!canvas2) {
            canvasEl = getCanvasElement();
          }
          opts = Utils2.getOptions(opts);
          const size2 = Utils2.getImageWidth(qrData.modules.size, opts);
          const ctx = canvasEl.getContext("2d");
          const image = ctx.createImageData(size2, size2);
          Utils2.qrToImageData(image.data, qrData, opts);
          clearCanvas(ctx, canvasEl, size2);
          ctx.putImageData(image, 0, 0);
          return canvasEl;
        };
        exports.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
          let opts = options;
          if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
            opts = canvas2;
            canvas2 = void 0;
          }
          if (!opts) opts = {};
          const canvasEl = exports.render(qrData, canvas2, opts);
          const type = opts.type || "image/png";
          const rendererOpts = opts.rendererOpts || {};
          return canvasEl.toDataURL(type, rendererOpts.quality);
        };
      })(canvas);
      var svgTag = {};
      const Utils = utils;
      function getColorAttrib(color, attrib) {
        const alpha = color.a / 255;
        const str = attrib + '="' + color.hex + '"';
        return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
      }
      function svgCmd(cmd, x, y) {
        let str = cmd + x;
        if (typeof y !== "undefined") str += " " + y;
        return str;
      }
      function qrToPath(data, size2, margin) {
        let path = "";
        let moveBy = 0;
        let newRow = false;
        let lineLength = 0;
        for (let i = 0; i < data.length; i++) {
          const col = Math.floor(i % size2);
          const row = Math.floor(i / size2);
          if (!col && !newRow) newRow = true;
          if (data[i]) {
            lineLength++;
            if (!(i > 0 && col > 0 && data[i - 1])) {
              path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
              moveBy = 0;
              newRow = false;
            }
            if (!(col + 1 < size2 && data[i + 1])) {
              path += svgCmd("h", lineLength);
              lineLength = 0;
            }
          } else {
            moveBy++;
          }
        }
        return path;
      }
      svgTag.render = function render(qrData, options, cb) {
        const opts = Utils.getOptions(options);
        const size2 = qrData.modules.size;
        const data = qrData.modules.data;
        const qrcodesize = size2 + opts.margin * 2;
        const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
        const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size2, opts.margin) + '"/>';
        const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
        const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
        const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
        if (typeof cb === "function") {
          cb(null, svgTag2);
        }
        return svgTag2;
      };
      const canPromise = canPromise$1;
      const QRCode = qrcode;
      const CanvasRenderer = canvas;
      const SvgRenderer = svgTag;
      function renderCanvas(renderFunc, canvas2, text2, opts, cb) {
        const args = [].slice.call(arguments, 1);
        const argsNum = args.length;
        const isLastArgCb = typeof args[argsNum - 1] === "function";
        if (!isLastArgCb && !canPromise()) {
          throw new Error("Callback required as last argument");
        }
        if (isLastArgCb) {
          if (argsNum < 2) {
            throw new Error("Too few arguments provided");
          }
          if (argsNum === 2) {
            cb = text2;
            text2 = canvas2;
            canvas2 = opts = void 0;
          } else if (argsNum === 3) {
            if (canvas2.getContext && typeof cb === "undefined") {
              cb = opts;
              opts = void 0;
            } else {
              cb = opts;
              opts = text2;
              text2 = canvas2;
              canvas2 = void 0;
            }
          }
        } else {
          if (argsNum < 1) {
            throw new Error("Too few arguments provided");
          }
          if (argsNum === 1) {
            text2 = canvas2;
            canvas2 = opts = void 0;
          } else if (argsNum === 2 && !canvas2.getContext) {
            opts = text2;
            text2 = canvas2;
            canvas2 = void 0;
          }
          return new Promise(function(resolve, reject) {
            try {
              const data = QRCode.create(text2, opts);
              resolve(renderFunc(data, canvas2, opts));
            } catch (e) {
              reject(e);
            }
          });
        }
        try {
          const data = QRCode.create(text2, opts);
          cb(null, renderFunc(data, canvas2, opts));
        } catch (e) {
          cb(e);
        }
      }
      browser$1.create = QRCode.create;
      browser$1.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
      browser$1.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
      browser$1.toString = renderCanvas.bind(null, function(data, _, opts) {
        return SvgRenderer.render(data, opts);
      });
      const generateQRCode = async (text2, options = {}) => {
        try {
          const defaultOptions = {
            errorCorrectionLevel: "H",
            type: "image/png",
            quality: 0.92,
            margin: 1,
            width: 200,
            ...options
          };
          const qrcode2 = await browser$1.toDataURL(text2, defaultOptions);
          return qrcode2;
        } catch (error) {
          console.error("生成二维码失败:", error);
          throw error;
        }
      };
      const defaultMessages$1 = "End-Of-Stream";
      let EndOfStreamError$1 = exports("E", class EndOfStreamError extends Error {
        constructor() {
          super(defaultMessages$1);
          this.name = "EndOfStreamError";
        }
      });
      class AbortError extends Error {
        constructor(message2 = "The operation was aborted") {
          super(message2);
          this.name = "AbortError";
        }
      }
      let AbstractStreamReader$1 = class AbstractStreamReader {
        constructor() {
          this.endOfStream = false;
          this.interrupted = false;
          this.peekQueue = [];
        }
        async peek(uint8Array, mayBeLess = false) {
          const bytesRead = await this.read(uint8Array, mayBeLess);
          this.peekQueue.push(uint8Array.subarray(0, bytesRead));
          return bytesRead;
        }
        async read(buffer, mayBeLess = false) {
          if (buffer.length === 0) {
            return 0;
          }
          let bytesRead = this.readFromPeekBuffer(buffer);
          if (!this.endOfStream) {
            bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
          }
          if (bytesRead === 0) {
            throw new EndOfStreamError$1();
          }
          return bytesRead;
        }
        /**
         * Read chunk from stream
         * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
         * @returns Number of bytes read
         */
        readFromPeekBuffer(buffer) {
          let remaining = buffer.length;
          let bytesRead = 0;
          while (this.peekQueue.length > 0 && remaining > 0) {
            const peekData = this.peekQueue.pop();
            if (!peekData)
              throw new Error("peekData should be defined");
            const lenCopy = Math.min(peekData.length, remaining);
            buffer.set(peekData.subarray(0, lenCopy), bytesRead);
            bytesRead += lenCopy;
            remaining -= lenCopy;
            if (lenCopy < peekData.length) {
              this.peekQueue.push(peekData.subarray(lenCopy));
            }
          }
          return bytesRead;
        }
        async readRemainderFromStream(buffer, mayBeLess) {
          let bytesRead = 0;
          while (bytesRead < buffer.length && !this.endOfStream) {
            if (this.interrupted) {
              throw new AbortError();
            }
            const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
            if (chunkLen === 0)
              break;
            bytesRead += chunkLen;
          }
          if (!mayBeLess && bytesRead < buffer.length) {
            throw new EndOfStreamError$1();
          }
          return bytesRead;
        }
      };
      let WebStreamReader$1 = class WebStreamReader extends AbstractStreamReader$1 {
        constructor(reader) {
          super();
          this.reader = reader;
        }
        async abort() {
          return this.close();
        }
        async close() {
          this.reader.releaseLock();
        }
      };
      class WebStreamByobReader extends WebStreamReader$1 {
        /**
         * Read from stream
         * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
         * @param mayBeLess - If true, may fill the buffer partially
         * @protected Bytes read
         */
        async readFromStream(buffer, mayBeLess) {
          if (buffer.length === 0)
            return 0;
          const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? void 0 : buffer.length });
          if (result.done) {
            this.endOfStream = result.done;
          }
          if (result.value) {
            buffer.set(result.value);
            return result.value.length;
          }
          return 0;
        }
      }
      class WebStreamDefaultReader extends AbstractStreamReader$1 {
        constructor(reader) {
          super();
          this.reader = reader;
          this.buffer = null;
        }
        /**
         * Copy chunk to target, and store the remainder in this.buffer
         */
        writeChunk(target, chunk) {
          const written = Math.min(chunk.length, target.length);
          target.set(chunk.subarray(0, written));
          if (written < chunk.length) {
            this.buffer = chunk.subarray(written);
          } else {
            this.buffer = null;
          }
          return written;
        }
        /**
         * Read from stream
         * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
         * @param mayBeLess - If true, may fill the buffer partially
         * @protected Bytes read
         */
        async readFromStream(buffer, mayBeLess) {
          if (buffer.length === 0)
            return 0;
          let totalBytesRead = 0;
          if (this.buffer) {
            totalBytesRead += this.writeChunk(buffer, this.buffer);
          }
          while (totalBytesRead < buffer.length && !this.endOfStream) {
            const result = await this.reader.read();
            if (result.done) {
              this.endOfStream = true;
              break;
            }
            if (result.value) {
              totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
            }
          }
          if (totalBytesRead === 0 && this.endOfStream) {
            throw new EndOfStreamError$1();
          }
          return totalBytesRead;
        }
        abort() {
          this.interrupted = true;
          return this.reader.cancel();
        }
        async close() {
          await this.abort();
          this.reader.releaseLock();
        }
      }
      function makeWebStreamReader(stream) {
        try {
          const reader = stream.getReader({ mode: "byob" });
          if (reader instanceof ReadableStreamDefaultReader) {
            return new WebStreamDefaultReader(reader);
          }
          return new WebStreamByobReader(reader);
        } catch (error) {
          if (error instanceof TypeError) {
            return new WebStreamDefaultReader(stream.getReader());
          }
          throw error;
        }
      }
      let AbstractTokenizer$1 = class AbstractTokenizer {
        /**
         * Constructor
         * @param options Tokenizer options
         * @protected
         */
        constructor(options) {
          this.numBuffer = new Uint8Array(8);
          this.position = 0;
          this.onClose = options == null ? void 0 : options.onClose;
          if (options == null ? void 0 : options.abortSignal) {
            options.abortSignal.addEventListener("abort", () => {
              this.abort();
            });
          }
        }
        /**
         * Read a token from the tokenizer-stream
         * @param token - The token to read
         * @param position - If provided, the desired position in the tokenizer-stream
         * @returns Promise with token data
         */
        async readToken(token, position = this.position) {
          const uint8Array = new Uint8Array(token.len);
          const len = await this.readBuffer(uint8Array, { position });
          if (len < token.len)
            throw new EndOfStreamError$1();
          return token.get(uint8Array, 0);
        }
        /**
         * Peek a token from the tokenizer-stream.
         * @param token - Token to peek from the tokenizer-stream.
         * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
         * @returns Promise with token data
         */
        async peekToken(token, position = this.position) {
          const uint8Array = new Uint8Array(token.len);
          const len = await this.peekBuffer(uint8Array, { position });
          if (len < token.len)
            throw new EndOfStreamError$1();
          return token.get(uint8Array, 0);
        }
        /**
         * Read a numeric token from the stream
         * @param token - Numeric token
         * @returns Promise with number
         */
        async readNumber(token) {
          const len = await this.readBuffer(this.numBuffer, { length: token.len });
          if (len < token.len)
            throw new EndOfStreamError$1();
          return token.get(this.numBuffer, 0);
        }
        /**
         * Read a numeric token from the stream
         * @param token - Numeric token
         * @returns Promise with number
         */
        async peekNumber(token) {
          const len = await this.peekBuffer(this.numBuffer, { length: token.len });
          if (len < token.len)
            throw new EndOfStreamError$1();
          return token.get(this.numBuffer, 0);
        }
        /**
         * Ignore number of bytes, advances the pointer in under tokenizer-stream.
         * @param length - Number of bytes to ignore
         * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
         */
        async ignore(length) {
          if (this.fileInfo.size !== void 0) {
            const bytesLeft = this.fileInfo.size - this.position;
            if (length > bytesLeft) {
              this.position += bytesLeft;
              return bytesLeft;
            }
          }
          this.position += length;
          return length;
        }
        async close() {
          var _a;
          await this.abort();
          await ((_a = this.onClose) == null ? void 0 : _a.call(this));
        }
        normalizeOptions(uint8Array, options) {
          if (!this.supportsRandomAccess() && options && options.position !== void 0 && options.position < this.position) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          return {
            ...{
              mayBeLess: false,
              offset: 0,
              length: uint8Array.length,
              position: this.position
            },
            ...options
          };
        }
        abort() {
          return Promise.resolve();
        }
      };
      const maxBufferSize$1 = 256e3;
      let ReadStreamTokenizer$1 = class ReadStreamTokenizer extends AbstractTokenizer$1 {
        /**
         * Constructor
         * @param streamReader stream-reader to read from
         * @param options Tokenizer options
         */
        constructor(streamReader, options) {
          super(options);
          this.streamReader = streamReader;
          this.fileInfo = (options == null ? void 0 : options.fileInfo) ?? {};
        }
        /**
         * Read buffer from tokenizer
         * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
         * @param options - Read behaviour options
         * @returns Promise with number of bytes read
         */
        async readBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          const skipBytes = normOptions.position - this.position;
          if (skipBytes > 0) {
            await this.ignore(skipBytes);
            return this.readBuffer(uint8Array, options);
          }
          if (skipBytes < 0) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          if (normOptions.length === 0) {
            return 0;
          }
          const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
          this.position += bytesRead;
          if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
            throw new EndOfStreamError$1();
          }
          return bytesRead;
        }
        /**
         * Peek (read ahead) buffer from tokenizer
         * @param uint8Array - Uint8Array (or Buffer) to write data to
         * @param options - Read behaviour options
         * @returns Promise with number of bytes peeked
         */
        async peekBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          let bytesRead = 0;
          if (normOptions.position) {
            const skipBytes = normOptions.position - this.position;
            if (skipBytes > 0) {
              const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
              bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
              uint8Array.set(skipBuffer.subarray(skipBytes));
              return bytesRead - skipBytes;
            }
            if (skipBytes < 0) {
              throw new Error("Cannot peek from a negative offset in a stream");
            }
          }
          if (normOptions.length > 0) {
            try {
              bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
            } catch (err) {
              if ((options == null ? void 0 : options.mayBeLess) && err instanceof EndOfStreamError$1) {
                return 0;
              }
              throw err;
            }
            if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
              throw new EndOfStreamError$1();
            }
          }
          return bytesRead;
        }
        async ignore(length) {
          const bufSize = Math.min(maxBufferSize$1, length);
          const buf = new Uint8Array(bufSize);
          let totBytesRead = 0;
          while (totBytesRead < length) {
            const remaining = length - totBytesRead;
            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
            if (bytesRead < 0) {
              return bytesRead;
            }
            totBytesRead += bytesRead;
          }
          return totBytesRead;
        }
        abort() {
          return this.streamReader.abort();
        }
        async close() {
          return this.streamReader.close();
        }
        supportsRandomAccess() {
          return false;
        }
      };
      let BufferTokenizer$1 = class BufferTokenizer extends AbstractTokenizer$1 {
        /**
         * Construct BufferTokenizer
         * @param uint8Array - Uint8Array to tokenize
         * @param options Tokenizer options
         */
        constructor(uint8Array, options) {
          super(options);
          this.uint8Array = uint8Array;
          this.fileInfo = { ...(options == null ? void 0 : options.fileInfo) ?? {}, ...{ size: uint8Array.length } };
        }
        /**
         * Read buffer from tokenizer
         * @param uint8Array - Uint8Array to tokenize
         * @param options - Read behaviour options
         * @returns {Promise<number>}
         */
        async readBuffer(uint8Array, options) {
          if (options == null ? void 0 : options.position) {
            this.position = options.position;
          }
          const bytesRead = await this.peekBuffer(uint8Array, options);
          this.position += bytesRead;
          return bytesRead;
        }
        /**
         * Peek (read ahead) buffer from tokenizer
         * @param uint8Array
         * @param options - Read behaviour options
         * @returns {Promise<number>}
         */
        async peekBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
          if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
            throw new EndOfStreamError$1();
          }
          uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
          return bytes2read;
        }
        close() {
          return super.close();
        }
        supportsRandomAccess() {
          return true;
        }
        setPosition(position) {
          this.position = position;
        }
      };
      function fromWebStream$1(webStream, options) {
        const webStreamReader = makeWebStreamReader(webStream);
        const _options = options ?? {};
        const chainedClose = _options.onClose;
        _options.onClose = async () => {
          await webStreamReader.close();
          if (chainedClose) {
            return chainedClose();
          }
        };
        return new ReadStreamTokenizer$1(webStreamReader, _options);
      }
      function fromBuffer$1(uint8Array, options) {
        return new BufferTokenizer$1(uint8Array, options);
      }
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m2;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m2 = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m2 ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m2 = m2 + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
      };
      var write3 = function(buffer, value2, offset, isLE, mLen, nBytes) {
        var e, m2, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
        value2 = Math.abs(value2);
        if (isNaN(value2) || value2 === Infinity) {
          m2 = isNaN(value2) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value2) / Math.LN2);
          if (value2 * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value2 += rt / c;
          } else {
            value2 += rt * Math.pow(2, 1 - eBias);
          }
          if (value2 * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m2 = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m2 = (value2 * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
        }
        e = e << mLen | m2;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
      function dv(array) {
        return new DataView(array.buffer, array.byteOffset);
      }
      const UINT8 = exports("c", {
        len: 1,
        get(array, offset) {
          return dv(array).getUint8(offset);
        },
        put(array, offset, value2) {
          dv(array).setUint8(offset, value2);
          return offset + 1;
        }
      });
      const UINT16_LE = exports("k", {
        len: 2,
        get(array, offset) {
          return dv(array).getUint16(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setUint16(offset, value2, true);
          return offset + 2;
        }
      });
      const UINT16_BE = exports("d", {
        len: 2,
        get(array, offset) {
          return dv(array).getUint16(offset);
        },
        put(array, offset, value2) {
          dv(array).setUint16(offset, value2);
          return offset + 2;
        }
      });
      const UINT24_LE = exports("N", {
        len: 3,
        get(array, offset) {
          const dataView = dv(array);
          return dataView.getUint8(offset) + (dataView.getUint16(offset + 1, true) << 8);
        },
        put(array, offset, value2) {
          const dataView = dv(array);
          dataView.setUint8(offset, value2 & 255);
          dataView.setUint16(offset + 1, value2 >> 8, true);
          return offset + 3;
        }
      });
      const UINT24_BE = exports("r", {
        len: 3,
        get(array, offset) {
          const dataView = dv(array);
          return (dataView.getUint16(offset) << 8) + dataView.getUint8(offset + 2);
        },
        put(array, offset, value2) {
          const dataView = dv(array);
          dataView.setUint16(offset, value2 >> 8);
          dataView.setUint8(offset + 2, value2 & 255);
          return offset + 3;
        }
      });
      const UINT32_LE = exports("f", {
        len: 4,
        get(array, offset) {
          return dv(array).getUint32(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setUint32(offset, value2, true);
          return offset + 4;
        }
      });
      const UINT32_BE = exports("a", {
        len: 4,
        get(array, offset) {
          return dv(array).getUint32(offset);
        },
        put(array, offset, value2) {
          dv(array).setUint32(offset, value2);
          return offset + 4;
        }
      });
      const INT8 = exports("D", {
        len: 1,
        get(array, offset) {
          return dv(array).getInt8(offset);
        },
        put(array, offset, value2) {
          dv(array).setInt8(offset, value2);
          return offset + 1;
        }
      });
      const INT16_BE = exports("I", {
        len: 2,
        get(array, offset) {
          return dv(array).getInt16(offset);
        },
        put(array, offset, value2) {
          dv(array).setInt16(offset, value2);
          return offset + 2;
        }
      });
      const INT16_LE = {
        len: 2,
        get(array, offset) {
          return dv(array).getInt16(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setInt16(offset, value2, true);
          return offset + 2;
        }
      };
      const INT24_LE = {
        len: 3,
        get(array, offset) {
          const unsigned = UINT24_LE.get(array, offset);
          return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
        },
        put(array, offset, value2) {
          const dataView = dv(array);
          dataView.setUint8(offset, value2 & 255);
          dataView.setUint16(offset + 1, value2 >> 8, true);
          return offset + 3;
        }
      };
      const INT24_BE = exports("G", {
        len: 3,
        get(array, offset) {
          const unsigned = UINT24_BE.get(array, offset);
          return unsigned > 8388607 ? unsigned - 16777216 : unsigned;
        },
        put(array, offset, value2) {
          const dataView = dv(array);
          dataView.setUint16(offset, value2 >> 8);
          dataView.setUint8(offset + 2, value2 & 255);
          return offset + 3;
        }
      });
      const INT32_BE = exports("C", {
        len: 4,
        get(array, offset) {
          return dv(array).getInt32(offset);
        },
        put(array, offset, value2) {
          dv(array).setInt32(offset, value2);
          return offset + 4;
        }
      });
      const INT32_LE = exports("q", {
        len: 4,
        get(array, offset) {
          return dv(array).getInt32(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setInt32(offset, value2, true);
          return offset + 4;
        }
      });
      const UINT64_LE = exports("e", {
        len: 8,
        get(array, offset) {
          return dv(array).getBigUint64(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setBigUint64(offset, value2, true);
          return offset + 8;
        }
      });
      const INT64_LE = exports("p", {
        len: 8,
        get(array, offset) {
          return dv(array).getBigInt64(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setBigInt64(offset, value2, true);
          return offset + 8;
        }
      });
      const UINT64_BE = exports("x", {
        len: 8,
        get(array, offset) {
          return dv(array).getBigUint64(offset);
        },
        put(array, offset, value2) {
          dv(array).setBigUint64(offset, value2);
          return offset + 8;
        }
      });
      const INT64_BE = exports("o", {
        len: 8,
        get(array, offset) {
          return dv(array).getBigInt64(offset);
        },
        put(array, offset, value2) {
          dv(array).setBigInt64(offset, value2);
          return offset + 8;
        }
      });
      const Float16_BE = {
        len: 2,
        get(dataView, offset) {
          return read(dataView, offset, false, 10, this.len);
        },
        put(dataView, offset, value2) {
          write3(dataView, value2, offset, false, 10, this.len);
          return offset + this.len;
        }
      };
      const Float16_LE = {
        len: 2,
        get(array, offset) {
          return read(array, offset, true, 10, this.len);
        },
        put(array, offset, value2) {
          write3(array, value2, offset, true, 10, this.len);
          return offset + this.len;
        }
      };
      const Float32_BE = exports("w", {
        len: 4,
        get(array, offset) {
          return dv(array).getFloat32(offset);
        },
        put(array, offset, value2) {
          dv(array).setFloat32(offset, value2);
          return offset + 4;
        }
      });
      const Float32_LE = {
        len: 4,
        get(array, offset) {
          return dv(array).getFloat32(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setFloat32(offset, value2, true);
          return offset + 4;
        }
      };
      const Float64_BE = exports("v", {
        len: 8,
        get(array, offset) {
          return dv(array).getFloat64(offset);
        },
        put(array, offset, value2) {
          dv(array).setFloat64(offset, value2);
          return offset + 8;
        }
      });
      const Float64_LE = {
        len: 8,
        get(array, offset) {
          return dv(array).getFloat64(offset, true);
        },
        put(array, offset, value2) {
          dv(array).setFloat64(offset, value2, true);
          return offset + 8;
        }
      };
      const Float80_BE = {
        len: 10,
        get(array, offset) {
          return read(array, offset, false, 63, this.len);
        },
        put(array, offset, value2) {
          write3(array, value2, offset, false, 63, this.len);
          return offset + this.len;
        }
      };
      const Float80_LE = {
        len: 10,
        get(array, offset) {
          return read(array, offset, true, 63, this.len);
        },
        put(array, offset, value2) {
          write3(array, value2, offset, true, 63, this.len);
          return offset + this.len;
        }
      };
      class IgnoreType {
        /**
         * @param len number of bytes to ignore
         */
        constructor(len) {
          this.len = len;
        }
        // ToDo: don't read, but skip data
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        get(array, off) {
        }
      }
      class Uint8ArrayType {
        constructor(len) {
          this.len = len;
        }
        get(array, offset) {
          return array.subarray(offset, offset + this.len);
        }
      } exports("U", Uint8ArrayType);
      class StringType {
        constructor(len, encoding) {
          this.len = len;
          this.encoding = encoding;
          this.textDecoder = new TextDecoder(encoding);
        }
        get(uint8Array, offset) {
          return this.textDecoder.decode(uint8Array.subarray(offset, offset + this.len));
        }
      } exports("S", StringType);
      class AnsiStringType {
        constructor(len) {
          this.len = len;
          this.textDecoder = new TextDecoder("windows-1252");
        }
        get(uint8Array, offset = 0) {
          return this.textDecoder.decode(uint8Array.subarray(offset, offset + this.len));
        }
      }
      const Token = exports("y", /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        AnsiStringType,
        Float16_BE,
        Float16_LE,
        Float32_BE,
        Float32_LE,
        Float64_BE,
        Float64_LE,
        Float80_BE,
        Float80_LE,
        INT16_BE,
        INT16_LE,
        INT24_BE,
        INT24_LE,
        INT32_BE,
        INT32_LE,
        INT64_BE,
        INT64_LE,
        INT8,
        IgnoreType,
        StringType,
        UINT16_BE,
        UINT16_LE,
        UINT24_BE,
        UINT24_LE,
        UINT32_BE,
        UINT32_LE,
        UINT64_BE,
        UINT64_LE,
        UINT8,
        Uint8ArrayType
      }, Symbol.toStringTag, { value: "Module" })));
      const defaultMessages = "End-Of-Stream";
      class EndOfStreamError2 extends Error {
        constructor() {
          super(defaultMessages);
        }
      }
      class AbstractStreamReader2 {
        constructor() {
          this.maxStreamReadSize = 1 * 1024 * 1024;
          this.endOfStream = false;
          this.peekQueue = [];
        }
        async peek(uint8Array, offset, length) {
          const bytesRead = await this.read(uint8Array, offset, length);
          this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
          return bytesRead;
        }
        async read(buffer, offset, length) {
          if (length === 0) {
            return 0;
          }
          let bytesRead = this.readFromPeekBuffer(buffer, offset, length);
          bytesRead += await this.readRemainderFromStream(buffer, offset + bytesRead, length - bytesRead);
          if (bytesRead === 0) {
            throw new EndOfStreamError2();
          }
          return bytesRead;
        }
        /**
         * Read chunk from stream
         * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in
         * @param offset - Offset target
         * @param length - Number of bytes to read
         * @returns Number of bytes read
         */
        readFromPeekBuffer(buffer, offset, length) {
          let remaining = length;
          let bytesRead = 0;
          while (this.peekQueue.length > 0 && remaining > 0) {
            const peekData = this.peekQueue.pop();
            if (!peekData)
              throw new Error("peekData should be defined");
            const lenCopy = Math.min(peekData.length, remaining);
            buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
            bytesRead += lenCopy;
            remaining -= lenCopy;
            if (lenCopy < peekData.length) {
              this.peekQueue.push(peekData.subarray(lenCopy));
            }
          }
          return bytesRead;
        }
        async readRemainderFromStream(buffer, offset, initialRemaining) {
          let remaining = initialRemaining;
          let bytesRead = 0;
          while (remaining > 0 && !this.endOfStream) {
            const reqLen = Math.min(remaining, this.maxStreamReadSize);
            const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
            if (chunkLen === 0)
              break;
            bytesRead += chunkLen;
            remaining -= chunkLen;
          }
          return bytesRead;
        }
      }
      class WebStreamReader2 extends AbstractStreamReader2 {
        constructor(stream) {
          super();
          this.reader = stream.getReader({ mode: "byob" });
        }
        async readFromStream(buffer, offset, length) {
          if (this.endOfStream) {
            throw new EndOfStreamError2();
          }
          const result = await this.reader.read(new Uint8Array(length));
          if (result.done) {
            this.endOfStream = result.done;
          }
          if (result.value) {
            buffer.set(result.value, offset);
            return result.value.byteLength;
          }
          return 0;
        }
        abort() {
          return this.reader.cancel();
        }
        async close() {
          await this.abort();
          this.reader.releaseLock();
        }
      }
      class AbstractTokenizer2 {
        /**
         * Constructor
         * @param options Tokenizer options
         * @protected
         */
        constructor(options) {
          this.numBuffer = new Uint8Array(8);
          this.position = 0;
          this.onClose = options == null ? void 0 : options.onClose;
          if (options == null ? void 0 : options.abortSignal) {
            options.abortSignal.addEventListener("abort", () => {
              this.abort();
            });
          }
        }
        /**
         * Read a token from the tokenizer-stream
         * @param token - The token to read
         * @param position - If provided, the desired position in the tokenizer-stream
         * @returns Promise with token data
         */
        async readToken(token, position = this.position) {
          const uint8Array = new Uint8Array(token.len);
          const len = await this.readBuffer(uint8Array, { position });
          if (len < token.len)
            throw new EndOfStreamError2();
          return token.get(uint8Array, 0);
        }
        /**
         * Peek a token from the tokenizer-stream.
         * @param token - Token to peek from the tokenizer-stream.
         * @param position - Offset where to begin reading within the file. If position is null, data will be read from the current file position.
         * @returns Promise with token data
         */
        async peekToken(token, position = this.position) {
          const uint8Array = new Uint8Array(token.len);
          const len = await this.peekBuffer(uint8Array, { position });
          if (len < token.len)
            throw new EndOfStreamError2();
          return token.get(uint8Array, 0);
        }
        /**
         * Read a numeric token from the stream
         * @param token - Numeric token
         * @returns Promise with number
         */
        async readNumber(token) {
          const len = await this.readBuffer(this.numBuffer, { length: token.len });
          if (len < token.len)
            throw new EndOfStreamError2();
          return token.get(this.numBuffer, 0);
        }
        /**
         * Read a numeric token from the stream
         * @param token - Numeric token
         * @returns Promise with number
         */
        async peekNumber(token) {
          const len = await this.peekBuffer(this.numBuffer, { length: token.len });
          if (len < token.len)
            throw new EndOfStreamError2();
          return token.get(this.numBuffer, 0);
        }
        /**
         * Ignore number of bytes, advances the pointer in under tokenizer-stream.
         * @param length - Number of bytes to ignore
         * @return resolves the number of bytes ignored, equals length if this available, otherwise the number of bytes available
         */
        async ignore(length) {
          if (this.fileInfo.size !== void 0) {
            const bytesLeft = this.fileInfo.size - this.position;
            if (length > bytesLeft) {
              this.position += bytesLeft;
              return bytesLeft;
            }
          }
          this.position += length;
          return length;
        }
        async close() {
          var _a;
          await this.abort();
          await ((_a = this.onClose) == null ? void 0 : _a.call(this));
        }
        normalizeOptions(uint8Array, options) {
          if (options && options.position !== void 0 && options.position < this.position) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          if (options) {
            return {
              mayBeLess: options.mayBeLess === true,
              offset: options.offset ? options.offset : 0,
              length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
              position: options.position ? options.position : this.position
            };
          }
          return {
            mayBeLess: false,
            offset: 0,
            length: uint8Array.length,
            position: this.position
          };
        }
        abort() {
          return Promise.resolve();
        }
      }
      const maxBufferSize = 256e3;
      class ReadStreamTokenizer2 extends AbstractTokenizer2 {
        /**
         * Constructor
         * @param streamReader stream-reader to read from
         * @param options Tokenizer options
         */
        constructor(streamReader, options) {
          super(options);
          this.streamReader = streamReader;
          this.fileInfo = (options == null ? void 0 : options.fileInfo) ?? {};
        }
        /**
         * Read buffer from tokenizer
         * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream
         * @param options - Read behaviour options
         * @returns Promise with number of bytes read
         */
        async readBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          const skipBytes = normOptions.position - this.position;
          if (skipBytes > 0) {
            await this.ignore(skipBytes);
            return this.readBuffer(uint8Array, options);
          }
          if (skipBytes < 0) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          if (normOptions.length === 0) {
            return 0;
          }
          const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
          this.position += bytesRead;
          if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
            throw new EndOfStreamError2();
          }
          return bytesRead;
        }
        /**
         * Peek (read ahead) buffer from tokenizer
         * @param uint8Array - Uint8Array (or Buffer) to write data to
         * @param options - Read behaviour options
         * @returns Promise with number of bytes peeked
         */
        async peekBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          let bytesRead = 0;
          if (normOptions.position) {
            const skipBytes = normOptions.position - this.position;
            if (skipBytes > 0) {
              const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
              bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
              uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
              return bytesRead - skipBytes;
            }
            if (skipBytes < 0) {
              throw new Error("Cannot peek from a negative offset in a stream");
            }
          }
          if (normOptions.length > 0) {
            try {
              bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
            } catch (err) {
              if ((options == null ? void 0 : options.mayBeLess) && err instanceof EndOfStreamError2) {
                return 0;
              }
              throw err;
            }
            if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
              throw new EndOfStreamError2();
            }
          }
          return bytesRead;
        }
        async ignore(length) {
          const bufSize = Math.min(maxBufferSize, length);
          const buf = new Uint8Array(bufSize);
          let totBytesRead = 0;
          while (totBytesRead < length) {
            const remaining = length - totBytesRead;
            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
            if (bytesRead < 0) {
              return bytesRead;
            }
            totBytesRead += bytesRead;
          }
          return totBytesRead;
        }
        abort() {
          return this.streamReader.abort();
        }
        supportsRandomAccess() {
          return false;
        }
      }
      class BufferTokenizer2 extends AbstractTokenizer2 {
        /**
         * Construct BufferTokenizer
         * @param uint8Array - Uint8Array to tokenize
         * @param options Tokenizer options
         */
        constructor(uint8Array, options) {
          super(options);
          this.uint8Array = uint8Array;
          this.fileInfo = { ...(options == null ? void 0 : options.fileInfo) ?? {}, ...{ size: uint8Array.length } };
        }
        /**
         * Read buffer from tokenizer
         * @param uint8Array - Uint8Array to tokenize
         * @param options - Read behaviour options
         * @returns {Promise<number>}
         */
        async readBuffer(uint8Array, options) {
          if (options == null ? void 0 : options.position) {
            if (options.position < this.position) {
              throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
            }
            this.position = options.position;
          }
          const bytesRead = await this.peekBuffer(uint8Array, options);
          this.position += bytesRead;
          return bytesRead;
        }
        /**
         * Peek (read ahead) buffer from tokenizer
         * @param uint8Array
         * @param options - Read behaviour options
         * @returns {Promise<number>}
         */
        async peekBuffer(uint8Array, options) {
          const normOptions = this.normalizeOptions(uint8Array, options);
          const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
          if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
            throw new EndOfStreamError2();
          }
          uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
          return bytes2read;
        }
        close() {
          return super.close();
        }
        supportsRandomAccess() {
          return true;
        }
        setPosition(position) {
          this.position = position;
        }
      }
      function fromWebStream(webStream, options) {
        return new ReadStreamTokenizer2(new WebStreamReader2(webStream), options);
      }
      function fromBuffer(uint8Array, options) {
        return new BufferTokenizer2(uint8Array, options);
      }
      const objectToString = Object.prototype.toString;
      const uint8ArrayStringified = "[object Uint8Array]";
      const arrayBufferStringified = "[object ArrayBuffer]";
      function isType(value2, typeConstructor, typeStringified) {
        if (!value2) {
          return false;
        }
        if (value2.constructor === typeConstructor) {
          return true;
        }
        return objectToString.call(value2) === typeStringified;
      }
      function isUint8Array(value2) {
        return isType(value2, Uint8Array, uint8ArrayStringified);
      }
      function isArrayBuffer(value2) {
        return isType(value2, ArrayBuffer, arrayBufferStringified);
      }
      function isUint8ArrayOrArrayBuffer(value2) {
        return isUint8Array(value2) || isArrayBuffer(value2);
      }
      function assertUint8Array(value2) {
        if (!isUint8Array(value2)) {
          throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof value2}\``);
        }
      }
      function assertUint8ArrayOrArrayBuffer(value2) {
        if (!isUint8ArrayOrArrayBuffer(value2)) {
          throw new TypeError(`Expected \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof value2}\``);
        }
      }
      const cachedDecoders = {
        utf8: new globalThis.TextDecoder("utf8")
      };
      function uint8ArrayToString(array, encoding = "utf8") {
        assertUint8ArrayOrArrayBuffer(array);
        cachedDecoders[encoding] ?? (cachedDecoders[encoding] = new globalThis.TextDecoder(encoding));
        return cachedDecoders[encoding].decode(array);
      }
      function assertString(value2) {
        if (typeof value2 !== "string") {
          throw new TypeError(`Expected \`string\`, got \`${typeof value2}\``);
        }
      }
      const cachedEncoder = new globalThis.TextEncoder();
      function stringToUint8Array(string) {
        assertString(string);
        return cachedEncoder.encode(string);
      }
      const byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
      function uint8ArrayToHex(array) {
        assertUint8Array(array);
        let hexString = "";
        for (let index = 0; index < array.length; index++) {
          hexString += byteToHexLookupTable[array[index]];
        }
        return hexString;
      }
      const hexToDecimalLookupTable = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        b: 11,
        c: 12,
        d: 13,
        e: 14,
        f: 15,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15
      };
      function hexToUint8Array(hexString) {
        assertString(hexString);
        if (hexString.length % 2 !== 0) {
          throw new Error("Invalid Hex string length.");
        }
        const resultLength = hexString.length / 2;
        const bytes = new Uint8Array(resultLength);
        for (let index = 0; index < resultLength; index++) {
          const highNibble = hexToDecimalLookupTable[hexString[index * 2]];
          const lowNibble = hexToDecimalLookupTable[hexString[index * 2 + 1]];
          if (highNibble === void 0 || lowNibble === void 0) {
            throw new Error(`Invalid Hex character encountered at position ${index * 2}`);
          }
          bytes[index] = highNibble << 4 | lowNibble;
        }
        return bytes;
      }
      function getUintBE(view) {
        const { byteLength } = view;
        if (byteLength === 6) {
          return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
        }
        if (byteLength === 5) {
          return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
        }
        if (byteLength === 4) {
          return view.getUint32(0);
        }
        if (byteLength === 3) {
          return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
        }
        if (byteLength === 2) {
          return view.getUint16(0);
        }
        if (byteLength === 1) {
          return view.getUint8(0);
        }
      }
      function indexOf(array, value2) {
        const arrayLength = array.length;
        const valueLength = value2.length;
        if (valueLength === 0) {
          return -1;
        }
        if (valueLength > arrayLength) {
          return -1;
        }
        const validOffsetLength = arrayLength - valueLength;
        for (let index = 0; index <= validOffsetLength; index++) {
          let isMatch = true;
          for (let index2 = 0; index2 < valueLength; index2++) {
            if (array[index + index2] !== value2[index2]) {
              isMatch = false;
              break;
            }
          }
          if (isMatch) {
            return index;
          }
        }
        return -1;
      }
      function includes(array, value2) {
        return indexOf(array, value2) !== -1;
      }
      function stringToBytes(string) {
        return [...string].map((character) => character.charCodeAt(0));
      }
      function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
        const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
        if (Number.isNaN(readSum)) {
          return false;
        }
        let sum = 8 * 32;
        for (let index = offset; index < offset + 148; index++) {
          sum += arrayBuffer[index];
        }
        for (let index = offset + 156; index < offset + 512; index++) {
          sum += arrayBuffer[index];
        }
        return readSum === sum;
      }
      const uint32SyncSafeToken = {
        get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
        len: 4
      };
      const extensions = [
        "jpg",
        "png",
        "apng",
        "gif",
        "webp",
        "flif",
        "xcf",
        "cr2",
        "cr3",
        "orf",
        "arw",
        "dng",
        "nef",
        "rw2",
        "raf",
        "tif",
        "bmp",
        "icns",
        "jxr",
        "psd",
        "indd",
        "zip",
        "tar",
        "rar",
        "gz",
        "bz2",
        "7z",
        "dmg",
        "mp4",
        "mid",
        "mkv",
        "webm",
        "mov",
        "avi",
        "mpg",
        "mp2",
        "mp3",
        "m4a",
        "oga",
        "ogg",
        "ogv",
        "opus",
        "flac",
        "wav",
        "spx",
        "amr",
        "pdf",
        "epub",
        "elf",
        "macho",
        "exe",
        "swf",
        "rtf",
        "wasm",
        "woff",
        "woff2",
        "eot",
        "ttf",
        "otf",
        "ico",
        "flv",
        "ps",
        "xz",
        "sqlite",
        "nes",
        "crx",
        "xpi",
        "cab",
        "deb",
        "ar",
        "rpm",
        "Z",
        "lz",
        "cfb",
        "mxf",
        "mts",
        "blend",
        "bpg",
        "docx",
        "pptx",
        "xlsx",
        "3gp",
        "3g2",
        "j2c",
        "jp2",
        "jpm",
        "jpx",
        "mj2",
        "aif",
        "qcp",
        "odt",
        "ods",
        "odp",
        "xml",
        "mobi",
        "heic",
        "cur",
        "ktx",
        "ape",
        "wv",
        "dcm",
        "ics",
        "glb",
        "pcap",
        "dsf",
        "lnk",
        "alias",
        "voc",
        "ac3",
        "m4v",
        "m4p",
        "m4b",
        "f4v",
        "f4p",
        "f4b",
        "f4a",
        "mie",
        "asf",
        "ogm",
        "ogx",
        "mpc",
        "arrow",
        "shp",
        "aac",
        "mp1",
        "it",
        "s3m",
        "xm",
        "ai",
        "skp",
        "avif",
        "eps",
        "lzh",
        "pgp",
        "asar",
        "stl",
        "chm",
        "3mf",
        "zst",
        "jxl",
        "vcf",
        "jls",
        "pst",
        "dwg",
        "parquet",
        "class",
        "arj",
        "cpio",
        "ace",
        "avro",
        "icc",
        "fbx",
        "vsdx",
        "vtt",
        "apk"
      ];
      const mimeTypes = [
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "image/flif",
        "image/x-xcf",
        "image/x-canon-cr2",
        "image/x-canon-cr3",
        "image/tiff",
        "image/bmp",
        "image/vnd.ms-photo",
        "image/vnd.adobe.photoshop",
        "application/x-indesign",
        "application/epub+zip",
        "application/x-xpinstall",
        "application/vnd.oasis.opendocument.text",
        "application/vnd.oasis.opendocument.spreadsheet",
        "application/vnd.oasis.opendocument.presentation",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/zip",
        "application/x-tar",
        "application/x-rar-compressed",
        "application/gzip",
        "application/x-bzip2",
        "application/x-7z-compressed",
        "application/x-apple-diskimage",
        "application/x-apache-arrow",
        "video/mp4",
        "audio/midi",
        "video/x-matroska",
        "video/webm",
        "video/quicktime",
        "video/vnd.avi",
        "audio/wav",
        "audio/qcelp",
        "audio/x-ms-asf",
        "video/x-ms-asf",
        "application/vnd.ms-asf",
        "video/mpeg",
        "video/3gpp",
        "audio/mpeg",
        "audio/mp4",
        // RFC 4337
        "video/ogg",
        "audio/ogg",
        "audio/ogg; codecs=opus",
        "application/ogg",
        "audio/x-flac",
        "audio/ape",
        "audio/wavpack",
        "audio/amr",
        "application/pdf",
        "application/x-elf",
        "application/x-mach-binary",
        "application/x-msdownload",
        "application/x-shockwave-flash",
        "application/rtf",
        "application/wasm",
        "font/woff",
        "font/woff2",
        "application/vnd.ms-fontobject",
        "font/ttf",
        "font/otf",
        "image/x-icon",
        "video/x-flv",
        "application/postscript",
        "application/eps",
        "application/x-xz",
        "application/x-sqlite3",
        "application/x-nintendo-nes-rom",
        "application/x-google-chrome-extension",
        "application/vnd.ms-cab-compressed",
        "application/x-deb",
        "application/x-unix-archive",
        "application/x-rpm",
        "application/x-compress",
        "application/x-lzip",
        "application/x-cfb",
        "application/x-mie",
        "application/mxf",
        "video/mp2t",
        "application/x-blender",
        "image/bpg",
        "image/j2c",
        "image/jp2",
        "image/jpx",
        "image/jpm",
        "image/mj2",
        "audio/aiff",
        "application/xml",
        "application/x-mobipocket-ebook",
        "image/heif",
        "image/heif-sequence",
        "image/heic",
        "image/heic-sequence",
        "image/icns",
        "image/ktx",
        "application/dicom",
        "audio/x-musepack",
        "text/calendar",
        "text/vcard",
        "text/vtt",
        "model/gltf-binary",
        "application/vnd.tcpdump.pcap",
        "audio/x-dsf",
        // Non-standard
        "application/x.ms.shortcut",
        // Invented by us
        "application/x.apple.alias",
        // Invented by us
        "audio/x-voc",
        "audio/vnd.dolby.dd-raw",
        "audio/x-m4a",
        "image/apng",
        "image/x-olympus-orf",
        "image/x-sony-arw",
        "image/x-adobe-dng",
        "image/x-nikon-nef",
        "image/x-panasonic-rw2",
        "image/x-fujifilm-raf",
        "video/x-m4v",
        "video/3gpp2",
        "application/x-esri-shape",
        "audio/aac",
        "audio/x-it",
        "audio/x-s3m",
        "audio/x-xm",
        "video/MP1S",
        "video/MP2P",
        "application/vnd.sketchup.skp",
        "image/avif",
        "application/x-lzh-compressed",
        "application/pgp-encrypted",
        "application/x-asar",
        "model/stl",
        "application/vnd.ms-htmlhelp",
        "model/3mf",
        "image/jxl",
        "application/zstd",
        "image/jls",
        "application/vnd.ms-outlook",
        "image/vnd.dwg",
        "application/x-parquet",
        "application/java-vm",
        "application/x-arj",
        "application/x-cpio",
        "application/x-ace-compressed",
        "application/avro",
        "application/vnd.iccprofile",
        "application/x.autodesk.fbx",
        // Invented by us
        "application/vnd.visio",
        "application/vnd.android.package-archive"
      ];
      const reasonableDetectionSizeInBytes = 4100;
      async function fileTypeFromBuffer(input) {
        return new FileTypeParser().fromBuffer(input);
      }
      function _check(buffer, headers, options) {
        options = {
          offset: 0,
          ...options
        };
        for (const [index, header] of headers.entries()) {
          if (options.mask) {
            if (header !== (options.mask[index] & buffer[index + options.offset])) {
              return false;
            }
          } else if (header !== buffer[index + options.offset]) {
            return false;
          }
        }
        return true;
      }
      class FileTypeParser {
        constructor(options) {
          this.detectors = options == null ? void 0 : options.customDetectors;
          this.tokenizerOptions = {
            abortSignal: options == null ? void 0 : options.signal
          };
          this.fromTokenizer = this.fromTokenizer.bind(this);
          this.fromBuffer = this.fromBuffer.bind(this);
          this.parse = this.parse.bind(this);
        }
        async fromTokenizer(tokenizer) {
          const initialPosition = tokenizer.position;
          for (const detector of this.detectors || []) {
            const fileType = await detector(tokenizer);
            if (fileType) {
              return fileType;
            }
            if (initialPosition !== tokenizer.position) {
              return void 0;
            }
          }
          return this.parse(tokenizer);
        }
        async fromBuffer(input) {
          if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
            throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
          }
          const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
          if (!((buffer == null ? void 0 : buffer.length) > 1)) {
            return;
          }
          return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
        }
        async fromBlob(blob) {
          return this.fromStream(blob.stream());
        }
        async fromStream(stream) {
          const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
          try {
            return await this.fromTokenizer(tokenizer);
          } finally {
            await tokenizer.close();
          }
        }
        async toDetectionStream(stream, options) {
          const { sampleSize = reasonableDetectionSizeInBytes } = options;
          let detectedFileType;
          let firstChunk;
          const reader = stream.getReader({ mode: "byob" });
          try {
            const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
            firstChunk = chunk;
            if (!done && chunk) {
              try {
                detectedFileType = await this.fromBuffer(chunk.slice(0, sampleSize));
              } catch (error) {
                if (!(error instanceof EndOfStreamError2)) {
                  throw error;
                }
                detectedFileType = void 0;
              }
            }
            firstChunk = chunk;
          } finally {
            reader.releaseLock();
          }
          const transformStream = new TransformStream({
            async start(controller) {
              controller.enqueue(firstChunk);
            },
            transform(chunk, controller) {
              controller.enqueue(chunk);
            }
          });
          const newStream = stream.pipeThrough(transformStream);
          newStream.fileType = detectedFileType;
          return newStream;
        }
        check(header, options) {
          return _check(this.buffer, header, options);
        }
        checkString(header, options) {
          return this.check(stringToBytes(header), options);
        }
        async parse(tokenizer) {
          this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
          if (tokenizer.fileInfo.size === void 0) {
            tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
          }
          this.tokenizer = tokenizer;
          await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
          if (this.check([66, 77])) {
            return {
              ext: "bmp",
              mime: "image/bmp"
            };
          }
          if (this.check([11, 119])) {
            return {
              ext: "ac3",
              mime: "audio/vnd.dolby.dd-raw"
            };
          }
          if (this.check([120, 1])) {
            return {
              ext: "dmg",
              mime: "application/x-apple-diskimage"
            };
          }
          if (this.check([77, 90])) {
            return {
              ext: "exe",
              mime: "application/x-msdownload"
            };
          }
          if (this.check([37, 33])) {
            await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
            if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
              return {
                ext: "eps",
                mime: "application/eps"
              };
            }
            return {
              ext: "ps",
              mime: "application/postscript"
            };
          }
          if (this.check([31, 160]) || this.check([31, 157])) {
            return {
              ext: "Z",
              mime: "application/x-compress"
            };
          }
          if (this.check([199, 113])) {
            return {
              ext: "cpio",
              mime: "application/x-cpio"
            };
          }
          if (this.check([96, 234])) {
            return {
              ext: "arj",
              mime: "application/x-arj"
            };
          }
          if (this.check([239, 187, 191])) {
            this.tokenizer.ignore(3);
            return this.parse(tokenizer);
          }
          if (this.check([71, 73, 70])) {
            return {
              ext: "gif",
              mime: "image/gif"
            };
          }
          if (this.check([73, 73, 188])) {
            return {
              ext: "jxr",
              mime: "image/vnd.ms-photo"
            };
          }
          if (this.check([31, 139, 8])) {
            return {
              ext: "gz",
              mime: "application/gzip"
            };
          }
          if (this.check([66, 90, 104])) {
            return {
              ext: "bz2",
              mime: "application/x-bzip2"
            };
          }
          if (this.checkString("ID3")) {
            await tokenizer.ignore(6);
            const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
            if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
              return {
                ext: "mp3",
                mime: "audio/mpeg"
              };
            }
            await tokenizer.ignore(id3HeaderLength);
            return this.fromTokenizer(tokenizer);
          }
          if (this.checkString("MP+")) {
            return {
              ext: "mpc",
              mime: "audio/x-musepack"
            };
          }
          if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
            return {
              ext: "swf",
              mime: "application/x-shockwave-flash"
            };
          }
          if (this.check([255, 216, 255])) {
            if (this.check([247], { offset: 3 })) {
              return {
                ext: "jls",
                mime: "image/jls"
              };
            }
            return {
              ext: "jpg",
              mime: "image/jpeg"
            };
          }
          if (this.check([79, 98, 106, 1])) {
            return {
              ext: "avro",
              mime: "application/avro"
            };
          }
          if (this.checkString("FLIF")) {
            return {
              ext: "flif",
              mime: "image/flif"
            };
          }
          if (this.checkString("8BPS")) {
            return {
              ext: "psd",
              mime: "image/vnd.adobe.photoshop"
            };
          }
          if (this.checkString("WEBP", { offset: 8 })) {
            return {
              ext: "webp",
              mime: "image/webp"
            };
          }
          if (this.checkString("MPCK")) {
            return {
              ext: "mpc",
              mime: "audio/x-musepack"
            };
          }
          if (this.checkString("FORM")) {
            return {
              ext: "aif",
              mime: "audio/aiff"
            };
          }
          if (this.checkString("icns", { offset: 0 })) {
            return {
              ext: "icns",
              mime: "image/icns"
            };
          }
          if (this.check([80, 75, 3, 4])) {
            try {
              while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
                await tokenizer.readBuffer(this.buffer, { length: 30 });
                const view = new DataView(this.buffer.buffer);
                const zipHeader = {
                  compressedSize: view.getUint32(18, true),
                  uncompressedSize: view.getUint32(22, true),
                  filenameLength: view.getUint16(26, true),
                  extraFieldLength: view.getUint16(28, true)
                };
                zipHeader.filename = await tokenizer.readToken(new StringType(zipHeader.filenameLength, "utf-8"));
                await tokenizer.ignore(zipHeader.extraFieldLength);
                if (/classes\d*\.dex/.test(zipHeader.filename)) {
                  return {
                    ext: "apk",
                    mime: "application/vnd.android.package-archive"
                  };
                }
                if (zipHeader.filename === "META-INF/mozilla.rsa") {
                  return {
                    ext: "xpi",
                    mime: "application/x-xpinstall"
                  };
                }
                if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
                  const type = zipHeader.filename.split("/")[0];
                  switch (type) {
                    case "_rels":
                      break;
                    case "word":
                      return {
                        ext: "docx",
                        mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                      };
                    case "ppt":
                      return {
                        ext: "pptx",
                        mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                      };
                    case "xl":
                      return {
                        ext: "xlsx",
                        mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                      };
                    case "visio":
                      return {
                        ext: "vsdx",
                        mime: "application/vnd.visio"
                      };
                    default:
                      break;
                  }
                }
                if (zipHeader.filename.startsWith("xl/")) {
                  return {
                    ext: "xlsx",
                    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                  };
                }
                if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) {
                  return {
                    ext: "3mf",
                    mime: "model/3mf"
                  };
                }
                if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
                  let mimeType = await tokenizer.readToken(new StringType(zipHeader.compressedSize, "utf-8"));
                  mimeType = mimeType.trim();
                  switch (mimeType) {
                    case "application/epub+zip":
                      return {
                        ext: "epub",
                        mime: "application/epub+zip"
                      };
                    case "application/vnd.oasis.opendocument.text":
                      return {
                        ext: "odt",
                        mime: "application/vnd.oasis.opendocument.text"
                      };
                    case "application/vnd.oasis.opendocument.spreadsheet":
                      return {
                        ext: "ods",
                        mime: "application/vnd.oasis.opendocument.spreadsheet"
                      };
                    case "application/vnd.oasis.opendocument.presentation":
                      return {
                        ext: "odp",
                        mime: "application/vnd.oasis.opendocument.presentation"
                      };
                    default:
                  }
                }
                if (zipHeader.compressedSize === 0) {
                  let nextHeaderIndex = -1;
                  while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
                    await tokenizer.peekBuffer(this.buffer, { mayBeLess: true });
                    nextHeaderIndex = indexOf(this.buffer, new Uint8Array([80, 75, 3, 4]));
                    await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : this.buffer.length);
                  }
                } else {
                  await tokenizer.ignore(zipHeader.compressedSize);
                }
              }
            } catch (error) {
              if (!(error instanceof EndOfStreamError2)) {
                throw error;
              }
            }
            return {
              ext: "zip",
              mime: "application/zip"
            };
          }
          if (this.checkString("OggS")) {
            await tokenizer.ignore(28);
            const type = new Uint8Array(8);
            await tokenizer.readBuffer(type);
            if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
              return {
                ext: "opus",
                mime: "audio/ogg; codecs=opus"
              };
            }
            if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
              return {
                ext: "ogv",
                mime: "video/ogg"
              };
            }
            if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
              return {
                ext: "ogm",
                mime: "video/ogg"
              };
            }
            if (_check(type, [127, 70, 76, 65, 67])) {
              return {
                ext: "oga",
                mime: "audio/ogg"
              };
            }
            if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
              return {
                ext: "spx",
                mime: "audio/ogg"
              };
            }
            if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
              return {
                ext: "ogg",
                mime: "audio/ogg"
              };
            }
            return {
              ext: "ogx",
              mime: "application/ogg"
            };
          }
          if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
            return {
              ext: "zip",
              mime: "application/zip"
            };
          }
          if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
            const brandMajor = new StringType(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
            switch (brandMajor) {
              case "avif":
              case "avis":
                return { ext: "avif", mime: "image/avif" };
              case "mif1":
                return { ext: "heic", mime: "image/heif" };
              case "msf1":
                return { ext: "heic", mime: "image/heif-sequence" };
              case "heic":
              case "heix":
                return { ext: "heic", mime: "image/heic" };
              case "hevc":
              case "hevx":
                return { ext: "heic", mime: "image/heic-sequence" };
              case "qt":
                return { ext: "mov", mime: "video/quicktime" };
              case "M4V":
              case "M4VH":
              case "M4VP":
                return { ext: "m4v", mime: "video/x-m4v" };
              case "M4P":
                return { ext: "m4p", mime: "video/mp4" };
              case "M4B":
                return { ext: "m4b", mime: "audio/mp4" };
              case "M4A":
                return { ext: "m4a", mime: "audio/x-m4a" };
              case "F4V":
                return { ext: "f4v", mime: "video/mp4" };
              case "F4P":
                return { ext: "f4p", mime: "video/mp4" };
              case "F4A":
                return { ext: "f4a", mime: "audio/mp4" };
              case "F4B":
                return { ext: "f4b", mime: "audio/mp4" };
              case "crx":
                return { ext: "cr3", mime: "image/x-canon-cr3" };
              default:
                if (brandMajor.startsWith("3g")) {
                  if (brandMajor.startsWith("3g2")) {
                    return { ext: "3g2", mime: "video/3gpp2" };
                  }
                  return { ext: "3gp", mime: "video/3gpp" };
                }
                return { ext: "mp4", mime: "video/mp4" };
            }
          }
          if (this.checkString("MThd")) {
            return {
              ext: "mid",
              mime: "audio/midi"
            };
          }
          if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
            return {
              ext: "woff",
              mime: "font/woff"
            };
          }
          if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
            return {
              ext: "woff2",
              mime: "font/woff2"
            };
          }
          if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
            return {
              ext: "pcap",
              mime: "application/vnd.tcpdump.pcap"
            };
          }
          if (this.checkString("DSD ")) {
            return {
              ext: "dsf",
              mime: "audio/x-dsf"
              // Non-standard
            };
          }
          if (this.checkString("LZIP")) {
            return {
              ext: "lz",
              mime: "application/x-lzip"
            };
          }
          if (this.checkString("fLaC")) {
            return {
              ext: "flac",
              mime: "audio/x-flac"
            };
          }
          if (this.check([66, 80, 71, 251])) {
            return {
              ext: "bpg",
              mime: "image/bpg"
            };
          }
          if (this.checkString("wvpk")) {
            return {
              ext: "wv",
              mime: "audio/wavpack"
            };
          }
          if (this.checkString("%PDF")) {
            try {
              await tokenizer.ignore(1350);
              const maxBufferSize2 = 10 * 1024 * 1024;
              const buffer = new Uint8Array(Math.min(maxBufferSize2, tokenizer.fileInfo.size));
              await tokenizer.readBuffer(buffer, { mayBeLess: true });
              if (includes(buffer, new TextEncoder().encode("AIPrivateData"))) {
                return {
                  ext: "ai",
                  mime: "application/postscript"
                };
              }
            } catch (error) {
              if (!(error instanceof EndOfStreamError2)) {
                throw error;
              }
            }
            return {
              ext: "pdf",
              mime: "application/pdf"
            };
          }
          if (this.check([0, 97, 115, 109])) {
            return {
              ext: "wasm",
              mime: "application/wasm"
            };
          }
          if (this.check([73, 73])) {
            const fileType = await this.readTiffHeader(false);
            if (fileType) {
              return fileType;
            }
          }
          if (this.check([77, 77])) {
            const fileType = await this.readTiffHeader(true);
            if (fileType) {
              return fileType;
            }
          }
          if (this.checkString("MAC ")) {
            return {
              ext: "ape",
              mime: "audio/ape"
            };
          }
          if (this.check([26, 69, 223, 163])) {
            async function readField() {
              const msb = await tokenizer.peekNumber(UINT8);
              let mask = 128;
              let ic = 0;
              while ((msb & mask) === 0 && mask !== 0) {
                ++ic;
                mask >>= 1;
              }
              const id = new Uint8Array(ic + 1);
              await tokenizer.readBuffer(id);
              return id;
            }
            async function readElement() {
              const idField = await readField();
              const lengthField = await readField();
              lengthField[0] ^= 128 >> lengthField.length - 1;
              const nrLength = Math.min(6, lengthField.length);
              const idView = new DataView(idField.buffer);
              const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
              return {
                id: getUintBE(idView),
                len: getUintBE(lengthView)
              };
            }
            async function readChildren(children) {
              while (children > 0) {
                const element = await readElement();
                if (element.id === 17026) {
                  const rawValue = await tokenizer.readToken(new StringType(element.len));
                  return rawValue.replaceAll(/\00.*$/g, "");
                }
                await tokenizer.ignore(element.len);
                --children;
              }
            }
            const re = await readElement();
            const docType = await readChildren(re.len);
            switch (docType) {
              case "webm":
                return {
                  ext: "webm",
                  mime: "video/webm"
                };
              case "matroska":
                return {
                  ext: "mkv",
                  mime: "video/x-matroska"
                };
              default:
                return;
            }
          }
          if (this.check([82, 73, 70, 70])) {
            if (this.check([65, 86, 73], { offset: 8 })) {
              return {
                ext: "avi",
                mime: "video/vnd.avi"
              };
            }
            if (this.check([87, 65, 86, 69], { offset: 8 })) {
              return {
                ext: "wav",
                mime: "audio/wav"
              };
            }
            if (this.check([81, 76, 67, 77], { offset: 8 })) {
              return {
                ext: "qcp",
                mime: "audio/qcelp"
              };
            }
          }
          if (this.checkString("SQLi")) {
            return {
              ext: "sqlite",
              mime: "application/x-sqlite3"
            };
          }
          if (this.check([78, 69, 83, 26])) {
            return {
              ext: "nes",
              mime: "application/x-nintendo-nes-rom"
            };
          }
          if (this.checkString("Cr24")) {
            return {
              ext: "crx",
              mime: "application/x-google-chrome-extension"
            };
          }
          if (this.checkString("MSCF") || this.checkString("ISc(")) {
            return {
              ext: "cab",
              mime: "application/vnd.ms-cab-compressed"
            };
          }
          if (this.check([237, 171, 238, 219])) {
            return {
              ext: "rpm",
              mime: "application/x-rpm"
            };
          }
          if (this.check([197, 208, 211, 198])) {
            return {
              ext: "eps",
              mime: "application/eps"
            };
          }
          if (this.check([40, 181, 47, 253])) {
            return {
              ext: "zst",
              mime: "application/zstd"
            };
          }
          if (this.check([127, 69, 76, 70])) {
            return {
              ext: "elf",
              mime: "application/x-elf"
            };
          }
          if (this.check([33, 66, 68, 78])) {
            return {
              ext: "pst",
              mime: "application/vnd.ms-outlook"
            };
          }
          if (this.checkString("PAR1")) {
            return {
              ext: "parquet",
              mime: "application/x-parquet"
            };
          }
          if (this.check([207, 250, 237, 254])) {
            return {
              ext: "macho",
              mime: "application/x-mach-binary"
            };
          }
          if (this.check([79, 84, 84, 79, 0])) {
            return {
              ext: "otf",
              mime: "font/otf"
            };
          }
          if (this.checkString("#!AMR")) {
            return {
              ext: "amr",
              mime: "audio/amr"
            };
          }
          if (this.checkString("{\\rtf")) {
            return {
              ext: "rtf",
              mime: "application/rtf"
            };
          }
          if (this.check([70, 76, 86, 1])) {
            return {
              ext: "flv",
              mime: "video/x-flv"
            };
          }
          if (this.checkString("IMPM")) {
            return {
              ext: "it",
              mime: "audio/x-it"
            };
          }
          if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
            return {
              ext: "lzh",
              mime: "application/x-lzh-compressed"
            };
          }
          if (this.check([0, 0, 1, 186])) {
            if (this.check([33], { offset: 4, mask: [241] })) {
              return {
                ext: "mpg",
                // May also be .ps, .mpeg
                mime: "video/MP1S"
              };
            }
            if (this.check([68], { offset: 4, mask: [196] })) {
              return {
                ext: "mpg",
                // May also be .mpg, .m2p, .vob or .sub
                mime: "video/MP2P"
              };
            }
          }
          if (this.checkString("ITSF")) {
            return {
              ext: "chm",
              mime: "application/vnd.ms-htmlhelp"
            };
          }
          if (this.check([202, 254, 186, 190])) {
            return {
              ext: "class",
              mime: "application/java-vm"
            };
          }
          if (this.check([253, 55, 122, 88, 90, 0])) {
            return {
              ext: "xz",
              mime: "application/x-xz"
            };
          }
          if (this.checkString("<?xml ")) {
            return {
              ext: "xml",
              mime: "application/xml"
            };
          }
          if (this.check([55, 122, 188, 175, 39, 28])) {
            return {
              ext: "7z",
              mime: "application/x-7z-compressed"
            };
          }
          if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
            return {
              ext: "rar",
              mime: "application/x-rar-compressed"
            };
          }
          if (this.checkString("solid ")) {
            return {
              ext: "stl",
              mime: "model/stl"
            };
          }
          if (this.checkString("AC")) {
            const version2 = new StringType(4, "latin1").get(this.buffer, 2);
            if (version2.match("^d*") && version2 >= 1e3 && version2 <= 1050) {
              return {
                ext: "dwg",
                mime: "image/vnd.dwg"
              };
            }
          }
          if (this.checkString("070707")) {
            return {
              ext: "cpio",
              mime: "application/x-cpio"
            };
          }
          if (this.checkString("BLENDER")) {
            return {
              ext: "blend",
              mime: "application/x-blender"
            };
          }
          if (this.checkString("!<arch>")) {
            await tokenizer.ignore(8);
            const string = await tokenizer.readToken(new StringType(13, "ascii"));
            if (string === "debian-binary") {
              return {
                ext: "deb",
                mime: "application/x-deb"
              };
            }
            return {
              ext: "ar",
              mime: "application/x-unix-archive"
            };
          }
          if (this.checkString("WEBVTT") && // One of LF, CR, tab, space, or end of file must follow "WEBVTT" per the spec (see `fixture/fixture-vtt-*.vtt` for examples). Note that `\0` is technically the null character (there is no such thing as an EOF character). However, checking for `\0` gives us the same result as checking for the end of the stream.
          ["\n", "\r", "	", " ", "\0"].some((char7) => this.checkString(char7, { offset: 6 }))) {
            return {
              ext: "vtt",
              mime: "text/vtt"
            };
          }
          if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
            await tokenizer.ignore(8);
            async function readChunkHeader() {
              return {
                length: await tokenizer.readToken(INT32_BE),
                type: await tokenizer.readToken(new StringType(4, "latin1"))
              };
            }
            do {
              const chunk = await readChunkHeader();
              if (chunk.length < 0) {
                return;
              }
              switch (chunk.type) {
                case "IDAT":
                  return {
                    ext: "png",
                    mime: "image/png"
                  };
                case "acTL":
                  return {
                    ext: "apng",
                    mime: "image/apng"
                  };
                default:
                  await tokenizer.ignore(chunk.length + 4);
              }
            } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
            return {
              ext: "png",
              mime: "image/png"
            };
          }
          if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
            return {
              ext: "arrow",
              mime: "application/x-apache-arrow"
            };
          }
          if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
            return {
              ext: "glb",
              mime: "model/gltf-binary"
            };
          }
          if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
            return {
              ext: "mov",
              mime: "video/quicktime"
            };
          }
          if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
            return {
              ext: "orf",
              mime: "image/x-olympus-orf"
            };
          }
          if (this.checkString("gimp xcf ")) {
            return {
              ext: "xcf",
              mime: "image/x-xcf"
            };
          }
          if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
            return {
              ext: "rw2",
              mime: "image/x-panasonic-rw2"
            };
          }
          if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
            async function readHeader() {
              const guid = new Uint8Array(16);
              await tokenizer.readBuffer(guid);
              return {
                id: guid,
                size: Number(await tokenizer.readToken(UINT64_LE))
              };
            }
            await tokenizer.ignore(30);
            while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
              const header = await readHeader();
              let payload = header.size - 24;
              if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
                const typeId = new Uint8Array(16);
                payload -= await tokenizer.readBuffer(typeId);
                if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
                  return {
                    ext: "asf",
                    mime: "audio/x-ms-asf"
                  };
                }
                if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
                  return {
                    ext: "asf",
                    mime: "video/x-ms-asf"
                  };
                }
                break;
              }
              await tokenizer.ignore(payload);
            }
            return {
              ext: "asf",
              mime: "application/vnd.ms-asf"
            };
          }
          if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
            return {
              ext: "ktx",
              mime: "image/ktx"
            };
          }
          if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
            return {
              ext: "mie",
              mime: "application/x-mie"
            };
          }
          if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
            return {
              ext: "shp",
              mime: "application/x-esri-shape"
            };
          }
          if (this.check([255, 79, 255, 81])) {
            return {
              ext: "j2c",
              mime: "image/j2c"
            };
          }
          if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
            await tokenizer.ignore(20);
            const type = await tokenizer.readToken(new StringType(4, "ascii"));
            switch (type) {
              case "jp2 ":
                return {
                  ext: "jp2",
                  mime: "image/jp2"
                };
              case "jpx ":
                return {
                  ext: "jpx",
                  mime: "image/jpx"
                };
              case "jpm ":
                return {
                  ext: "jpm",
                  mime: "image/jpm"
                };
              case "mjp2":
                return {
                  ext: "mj2",
                  mime: "image/mj2"
                };
              default:
                return;
            }
          }
          if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
            return {
              ext: "jxl",
              mime: "image/jxl"
            };
          }
          if (this.check([254, 255])) {
            if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
              return {
                ext: "xml",
                mime: "application/xml"
              };
            }
            return void 0;
          }
          if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
            return {
              ext: "mpg",
              mime: "video/mpeg"
            };
          }
          if (this.check([0, 1, 0, 0, 0])) {
            return {
              ext: "ttf",
              mime: "font/ttf"
            };
          }
          if (this.check([0, 0, 1, 0])) {
            return {
              ext: "ico",
              mime: "image/x-icon"
            };
          }
          if (this.check([0, 0, 2, 0])) {
            return {
              ext: "cur",
              mime: "image/x-icon"
            };
          }
          if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
            return {
              ext: "cfb",
              mime: "application/x-cfb"
            };
          }
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
          if (this.check([97, 99, 115, 112], { offset: 36 })) {
            return {
              ext: "icc",
              mime: "application/vnd.iccprofile"
            };
          }
          if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
            return {
              ext: "ace",
              mime: "application/x-ace-compressed"
            };
          }
          if (this.checkString("BEGIN:")) {
            if (this.checkString("VCARD", { offset: 6 })) {
              return {
                ext: "vcf",
                mime: "text/vcard"
              };
            }
            if (this.checkString("VCALENDAR", { offset: 6 })) {
              return {
                ext: "ics",
                mime: "text/calendar"
              };
            }
          }
          if (this.checkString("FUJIFILMCCD-RAW")) {
            return {
              ext: "raf",
              mime: "image/x-fujifilm-raf"
            };
          }
          if (this.checkString("Extended Module:")) {
            return {
              ext: "xm",
              mime: "audio/x-xm"
            };
          }
          if (this.checkString("Creative Voice File")) {
            return {
              ext: "voc",
              mime: "audio/x-voc"
            };
          }
          if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
            const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
            if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
              try {
                const header = new TextDecoder().decode(this.buffer.slice(16, jsonSize + 16));
                const json = JSON.parse(header);
                if (json.files) {
                  return {
                    ext: "asar",
                    mime: "application/x-asar"
                  };
                }
              } catch {
              }
            }
          }
          if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
            return {
              ext: "mxf",
              mime: "application/mxf"
            };
          }
          if (this.checkString("SCRM", { offset: 44 })) {
            return {
              ext: "s3m",
              mime: "audio/x-s3m"
            };
          }
          if (this.check([71]) && this.check([71], { offset: 188 })) {
            return {
              ext: "mts",
              mime: "video/mp2t"
            };
          }
          if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
            return {
              ext: "mts",
              mime: "video/mp2t"
            };
          }
          if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
            return {
              ext: "mobi",
              mime: "application/x-mobipocket-ebook"
            };
          }
          if (this.check([68, 73, 67, 77], { offset: 128 })) {
            return {
              ext: "dcm",
              mime: "application/dicom"
            };
          }
          if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
            return {
              ext: "lnk",
              mime: "application/x.ms.shortcut"
              // Invented by us
            };
          }
          if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
            return {
              ext: "alias",
              mime: "application/x.apple.alias"
              // Invented by us
            };
          }
          if (this.checkString("Kaydara FBX Binary  \0")) {
            return {
              ext: "fbx",
              mime: "application/x.autodesk.fbx"
              // Invented by us
            };
          }
          if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
            return {
              ext: "eot",
              mime: "application/vnd.ms-fontobject"
            };
          }
          if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
            return {
              ext: "indd",
              mime: "application/x-indesign"
            };
          }
          await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
          if (tarHeaderChecksumMatches(this.buffer)) {
            return {
              ext: "tar",
              mime: "application/x-tar"
            };
          }
          if (this.check([255, 254])) {
            if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
              return {
                ext: "xml",
                mime: "application/xml"
              };
            }
            if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
              return {
                ext: "skp",
                mime: "application/vnd.sketchup.skp"
              };
            }
            return void 0;
          }
          if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
            return {
              ext: "pgp",
              mime: "application/pgp-encrypted"
            };
          }
          if (this.buffer.length >= 2 && this.check([255, 224], { offset: 0, mask: [255, 224] })) {
            if (this.check([16], { offset: 1, mask: [22] })) {
              if (this.check([8], { offset: 1, mask: [8] })) {
                return {
                  ext: "aac",
                  mime: "audio/aac"
                };
              }
              return {
                ext: "aac",
                mime: "audio/aac"
              };
            }
            if (this.check([2], { offset: 1, mask: [6] })) {
              return {
                ext: "mp3",
                mime: "audio/mpeg"
              };
            }
            if (this.check([4], { offset: 1, mask: [6] })) {
              return {
                ext: "mp2",
                mime: "audio/mpeg"
              };
            }
            if (this.check([6], { offset: 1, mask: [6] })) {
              return {
                ext: "mp1",
                mime: "audio/mpeg"
              };
            }
          }
        }
        async readTiffTag(bigEndian) {
          const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
          this.tokenizer.ignore(10);
          switch (tagId) {
            case 50341:
              return {
                ext: "arw",
                mime: "image/x-sony-arw"
              };
            case 50706:
              return {
                ext: "dng",
                mime: "image/x-adobe-dng"
              };
          }
        }
        async readTiffIFD(bigEndian) {
          const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
          for (let n2 = 0; n2 < numberOfTags; ++n2) {
            const fileType = await this.readTiffTag(bigEndian);
            if (fileType) {
              return fileType;
            }
          }
        }
        async readTiffHeader(bigEndian) {
          const version2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
          const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
          if (version2 === 42) {
            if (ifdOffset >= 6) {
              if (this.checkString("CR", { offset: 8 })) {
                return {
                  ext: "cr2",
                  mime: "image/x-canon-cr2"
                };
              }
              if (ifdOffset >= 8 && (this.check([28, 0, 254, 0], { offset: 8 }) || this.check([31, 0, 11, 0], { offset: 8 }))) {
                return {
                  ext: "nef",
                  mime: "image/x-nikon-nef"
                };
              }
            }
            await this.tokenizer.ignore(ifdOffset);
            const fileType = await this.readTiffIFD(bigEndian);
            return fileType ?? {
              ext: "tif",
              mime: "image/tiff"
            };
          }
          if (version2 === 43) {
            return {
              ext: "tif",
              mime: "image/tiff"
            };
          }
        }
      }
      new Set(extensions);
      new Set(mimeTypes);
      var contentType = {};
      /*!
       * content-type
       * Copyright(c) 2015 Douglas Christopher Wilson
       * MIT Licensed
       */
      var PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
      var TEXT_REGEXP = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
      var TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
      var QESC_REGEXP = /\\([\u000b\u0020-\u00ff])/g;
      var QUOTE_REGEXP = /([\\"])/g;
      var TYPE_REGEXP$1 = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
      contentType.format = format;
      contentType.parse = parse$1;
      function format(obj) {
        if (!obj || typeof obj !== "object") {
          throw new TypeError("argument obj is required");
        }
        var parameters = obj.parameters;
        var type = obj.type;
        if (!type || !TYPE_REGEXP$1.test(type)) {
          throw new TypeError("invalid type");
        }
        var string = type;
        if (parameters && typeof parameters === "object") {
          var param;
          var params = Object.keys(parameters).sort();
          for (var i = 0; i < params.length; i++) {
            param = params[i];
            if (!TOKEN_REGEXP.test(param)) {
              throw new TypeError("invalid parameter name");
            }
            string += "; " + param + "=" + qstring(parameters[param]);
          }
        }
        return string;
      }
      function parse$1(string) {
        if (!string) {
          throw new TypeError("argument string is required");
        }
        var header = typeof string === "object" ? getcontenttype(string) : string;
        if (typeof header !== "string") {
          throw new TypeError("argument string is required to be a string");
        }
        var index = header.indexOf(";");
        var type = index !== -1 ? header.slice(0, index).trim() : header.trim();
        if (!TYPE_REGEXP$1.test(type)) {
          throw new TypeError("invalid media type");
        }
        var obj = new ContentType(type.toLowerCase());
        if (index !== -1) {
          var key;
          var match;
          var value2;
          PARAM_REGEXP.lastIndex = index;
          while (match = PARAM_REGEXP.exec(header)) {
            if (match.index !== index) {
              throw new TypeError("invalid parameter format");
            }
            index += match[0].length;
            key = match[1].toLowerCase();
            value2 = match[2];
            if (value2.charCodeAt(0) === 34) {
              value2 = value2.slice(1, -1);
              if (value2.indexOf("\\") !== -1) {
                value2 = value2.replace(QESC_REGEXP, "$1");
              }
            }
            obj.parameters[key] = value2;
          }
          if (index !== header.length) {
            throw new TypeError("invalid parameter format");
          }
        }
        return obj;
      }
      function getcontenttype(obj) {
        var header;
        if (typeof obj.getHeader === "function") {
          header = obj.getHeader("content-type");
        } else if (typeof obj.headers === "object") {
          header = obj.headers && obj.headers["content-type"];
        }
        if (typeof header !== "string") {
          throw new TypeError("content-type header is missing from object");
        }
        return header;
      }
      function qstring(val) {
        var str = String(val);
        if (TOKEN_REGEXP.test(str)) {
          return str;
        }
        if (str.length > 0 && !TEXT_REGEXP.test(str)) {
          throw new TypeError("invalid parameter value");
        }
        return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
      }
      function ContentType(type) {
        this.parameters = /* @__PURE__ */ Object.create(null);
        this.type = type;
      }
      /*!
       * media-typer
       * Copyright(c) 2014-2017 Douglas Christopher Wilson
       * MIT Licensed
       */
      var TYPE_REGEXP = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
      var parse_1 = parse;
      function parse(string) {
        if (!string) {
          throw new TypeError("argument string is required");
        }
        if (typeof string !== "string") {
          throw new TypeError("argument string is required to be a string");
        }
        var match = TYPE_REGEXP.exec(string.toLowerCase());
        if (!match) {
          throw new TypeError("invalid media type");
        }
        var type = match[1];
        var subtype = match[2];
        var suffix;
        var index = subtype.lastIndexOf("+");
        if (index !== -1) {
          suffix = subtype.substr(index + 1);
          subtype = subtype.substr(0, index);
        }
        return new MediaType(type, subtype, suffix);
      }
      function MediaType(type, subtype, suffix) {
        this.type = type;
        this.subtype = subtype;
        this.suffix = suffix;
      }
      var browser = { exports: {} };
      var ms;
      var hasRequiredMs;
      function requireMs() {
        if (hasRequiredMs) return ms;
        hasRequiredMs = 1;
        var s = 1e3;
        var m2 = s * 60;
        var h = m2 * 60;
        var d = h * 24;
        var w = d * 7;
        var y = d * 365.25;
        ms = function(val, options) {
          options = options || {};
          var type = typeof val;
          if (type === "string" && val.length > 0) {
            return parse2(val);
          } else if (type === "number" && isFinite(val)) {
            return options.long ? fmtLong(val) : fmtShort(val);
          }
          throw new Error(
            "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
          );
        };
        function parse2(str) {
          str = String(str);
          if (str.length > 100) {
            return;
          }
          var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str
          );
          if (!match) {
            return;
          }
          var n2 = parseFloat(match[1]);
          var type = (match[2] || "ms").toLowerCase();
          switch (type) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return n2 * y;
            case "weeks":
            case "week":
            case "w":
              return n2 * w;
            case "days":
            case "day":
            case "d":
              return n2 * d;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return n2 * h;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return n2 * m2;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return n2 * s;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return n2;
            default:
              return void 0;
          }
        }
        function fmtShort(ms2) {
          var msAbs = Math.abs(ms2);
          if (msAbs >= d) {
            return Math.round(ms2 / d) + "d";
          }
          if (msAbs >= h) {
            return Math.round(ms2 / h) + "h";
          }
          if (msAbs >= m2) {
            return Math.round(ms2 / m2) + "m";
          }
          if (msAbs >= s) {
            return Math.round(ms2 / s) + "s";
          }
          return ms2 + "ms";
        }
        function fmtLong(ms2) {
          var msAbs = Math.abs(ms2);
          if (msAbs >= d) {
            return plural(ms2, msAbs, d, "day");
          }
          if (msAbs >= h) {
            return plural(ms2, msAbs, h, "hour");
          }
          if (msAbs >= m2) {
            return plural(ms2, msAbs, m2, "minute");
          }
          if (msAbs >= s) {
            return plural(ms2, msAbs, s, "second");
          }
          return ms2 + " ms";
        }
        function plural(ms2, msAbs, n2, name2) {
          var isPlural = msAbs >= n2 * 1.5;
          return Math.round(ms2 / n2) + " " + name2 + (isPlural ? "s" : "");
        }
        return ms;
      }
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = requireMs();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug2(...args) {
            if (!debug2.enabled) {
              return;
            }
            const self = debug2;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms2 = curr - (prevTime || curr);
            self.diff = ms2;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format2];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
          }
          debug2.namespace = namespace;
          debug2.useColors = createDebug.useColors();
          debug2.color = createDebug.selectColor(namespace);
          debug2.extend = extend;
          debug2.destroy = createDebug.destroy;
          Object.defineProperty(debug2, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug2);
          }
          return debug2;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
          for (const ns of split) {
            if (ns[0] === "-") {
              createDebug.skips.push(ns.slice(1));
            } else {
              createDebug.names.push(ns);
            }
          }
        }
        function matchesTemplate(search, template) {
          let searchIndex = 0;
          let templateIndex = 0;
          let starIndex = -1;
          let matchIndex = 0;
          while (searchIndex < search.length) {
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
              if (template[templateIndex] === "*") {
                starIndex = templateIndex;
                matchIndex = searchIndex;
                templateIndex++;
              } else {
                searchIndex++;
                templateIndex++;
              }
            } else if (starIndex !== -1) {
              templateIndex = starIndex + 1;
              matchIndex++;
              searchIndex = matchIndex;
            } else {
              return false;
            }
          }
          while (templateIndex < template.length && template[templateIndex] === "*") {
            templateIndex++;
          }
          return templateIndex === template.length;
        }
        function disable() {
          const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name2) {
          for (const skip of createDebug.skips) {
            if (matchesTemplate(name2, skip)) {
              return false;
            }
          }
          for (const ns of createDebug.names) {
            if (matchesTemplate(name2, ns)) {
              return true;
            }
          }
          return false;
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      var common$1 = setup;
      (function(module, exports) {
        var define_process_env_default = {};
        exports.formatArgs = formatArgs;
        exports.save = save;
        exports.load = load;
        exports.useColors = useColors;
        exports.storage = localstorage();
        exports.destroy = /* @__PURE__ */ (() => {
          let warned = false;
          return () => {
            if (!warned) {
              warned = true;
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
          };
        })();
        exports.colors = [
          "#0000CC",
          "#0000FF",
          "#0033CC",
          "#0033FF",
          "#0066CC",
          "#0066FF",
          "#0099CC",
          "#0099FF",
          "#00CC00",
          "#00CC33",
          "#00CC66",
          "#00CC99",
          "#00CCCC",
          "#00CCFF",
          "#3300CC",
          "#3300FF",
          "#3333CC",
          "#3333FF",
          "#3366CC",
          "#3366FF",
          "#3399CC",
          "#3399FF",
          "#33CC00",
          "#33CC33",
          "#33CC66",
          "#33CC99",
          "#33CCCC",
          "#33CCFF",
          "#6600CC",
          "#6600FF",
          "#6633CC",
          "#6633FF",
          "#66CC00",
          "#66CC33",
          "#9900CC",
          "#9900FF",
          "#9933CC",
          "#9933FF",
          "#99CC00",
          "#99CC33",
          "#CC0000",
          "#CC0033",
          "#CC0066",
          "#CC0099",
          "#CC00CC",
          "#CC00FF",
          "#CC3300",
          "#CC3333",
          "#CC3366",
          "#CC3399",
          "#CC33CC",
          "#CC33FF",
          "#CC6600",
          "#CC6633",
          "#CC9900",
          "#CC9933",
          "#CCCC00",
          "#CCCC33",
          "#FF0000",
          "#FF0033",
          "#FF0066",
          "#FF0099",
          "#FF00CC",
          "#FF00FF",
          "#FF3300",
          "#FF3333",
          "#FF3366",
          "#FF3399",
          "#FF33CC",
          "#FF33FF",
          "#FF6600",
          "#FF6633",
          "#FF9900",
          "#FF9933",
          "#FFCC00",
          "#FFCC33"
        ];
        function useColors() {
          if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
            return true;
          }
          if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
            return false;
          }
          let m2;
          return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
          typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
          // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
          typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
          typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }
        function formatArgs(args) {
          args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
          if (!this.useColors) {
            return;
          }
          const c = "color: " + this.color;
          args.splice(1, 0, c, "color: inherit");
          let index = 0;
          let lastC = 0;
          args[0].replace(/%[a-zA-Z%]/g, (match) => {
            if (match === "%%") {
              return;
            }
            index++;
            if (match === "%c") {
              lastC = index;
            }
          });
          args.splice(lastC, 0, c);
        }
        exports.log = console.debug || console.log || (() => {
        });
        function save(namespaces) {
          try {
            if (namespaces) {
              exports.storage.setItem("debug", namespaces);
            } else {
              exports.storage.removeItem("debug");
            }
          } catch (error) {
          }
        }
        function load() {
          let r;
          try {
            r = exports.storage.getItem("debug");
          } catch (error) {
          }
          if (!r && typeof process !== "undefined" && "env" in process) {
            r = define_process_env_default.DEBUG;
          }
          return r;
        }
        function localstorage() {
          try {
            return localStorage;
          } catch (error) {
          }
        }
        module.exports = common$1(exports);
        const { formatters } = module.exports;
        formatters.j = function(v) {
          try {
            return JSON.stringify(v);
          } catch (error) {
            return "[UnexpectedJSONParseError]: " + error.message;
          }
        };
      })(browser, browser.exports);
      var browserExports = browser.exports;
      const initDebug = exports("i", /* @__PURE__ */ getDefaultExportFromCjs(browserExports));
      var TargetType; exports("t", TargetType);
      (function(TargetType2) {
        TargetType2[TargetType2["shot"] = 10] = "shot";
        TargetType2[TargetType2["scene"] = 20] = "scene";
        TargetType2[TargetType2["track"] = 30] = "track";
        TargetType2[TargetType2["part"] = 40] = "part";
        TargetType2[TargetType2["album"] = 50] = "album";
        TargetType2[TargetType2["edition"] = 60] = "edition";
        TargetType2[TargetType2["collection"] = 70] = "collection";
      })(TargetType || (exports("t", TargetType = {})));
      var TrackType; exports("T", TrackType);
      (function(TrackType2) {
        TrackType2[TrackType2["video"] = 1] = "video";
        TrackType2[TrackType2["audio"] = 2] = "audio";
        TrackType2[TrackType2["complex"] = 3] = "complex";
        TrackType2[TrackType2["logo"] = 4] = "logo";
        TrackType2[TrackType2["subtitle"] = 17] = "subtitle";
        TrackType2[TrackType2["button"] = 18] = "button";
        TrackType2[TrackType2["control"] = 32] = "control";
      })(TrackType || (exports("T", TrackType = {})));
      const makeParseError = (name2) => {
        return class ParseError extends Error {
          constructor(message2) {
            super(message2);
            this.name = name2;
          }
        };
      };
      class CouldNotDetermineFileTypeError extends makeParseError("CouldNotDetermineFileTypeError") {
      }
      class UnsupportedFileTypeError extends makeParseError("UnsupportedFileTypeError") {
      }
      class UnexpectedFileContentError extends makeParseError("UnexpectedFileContentError") {
        constructor(fileType, message2) {
          super(message2);
          this.fileType = fileType;
        }
        // Override toString to include file type information.
        toString() {
          return `${this.name} (FileType: ${this.fileType}): ${this.message}`;
        }
      }
      class FieldDecodingError extends makeParseError("FieldDecodingError") {
      }
      class InternalParserError extends makeParseError("InternalParserError") {
      }
      const makeUnexpectedFileContentError = exports("m", (fileType) => {
        return class extends UnexpectedFileContentError {
          constructor(message2) {
            super(fileType, message2);
          }
        };
      });
      function getBit(buf, off, bit) {
        return (buf[off] & 1 << bit) !== 0;
      }
      function findZero(uint8Array, start, end, encoding) {
        let i = start;
        if (encoding === "utf-16le") {
          while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {
            if (i >= end)
              return end;
            i += 2;
          }
          return i;
        }
        while (uint8Array[i] !== 0) {
          if (i >= end)
            return end;
          i++;
        }
        return i;
      }
      function trimRightNull(x) {
        const pos0 = x.indexOf("\0");
        return pos0 === -1 ? x : x.substr(0, pos0);
      }
      function swapBytes(uint8Array) {
        const l2 = uint8Array.length;
        if ((l2 & 1) !== 0)
          throw new FieldDecodingError("Buffer length must be even");
        for (let i = 0; i < l2; i += 2) {
          const a = uint8Array[i];
          uint8Array[i] = uint8Array[i + 1];
          uint8Array[i + 1] = a;
        }
        return uint8Array;
      }
      function decodeString(uint8Array, encoding) {
        if (uint8Array[0] === 255 && uint8Array[1] === 254) {
          return decodeString(uint8Array.subarray(2), encoding);
        }
        if (encoding === "utf-16le" && uint8Array[0] === 254 && uint8Array[1] === 255) {
          if ((uint8Array.length & 1) !== 0)
            throw new FieldDecodingError("Expected even number of octets for 16-bit unicode string");
          return decodeString(swapBytes(uint8Array), encoding);
        }
        return new StringType(uint8Array.length, encoding).get(uint8Array, 0);
      }
      function stripNulls(str) {
        str = str.replace(/^\x00+/g, "");
        str = str.replace(/\x00+$/g, "");
        return str;
      }
      function getBitAllignedNumber(source, byteOffset, bitOffset, len) {
        const byteOff = byteOffset + ~~(bitOffset / 8);
        const bitOff = bitOffset % 8;
        let value2 = source[byteOff];
        value2 &= 255 >> bitOff;
        const bitsRead = 8 - bitOff;
        const bitsLeft = len - bitsRead;
        if (bitsLeft < 0) {
          value2 >>= 8 - bitOff - len;
        } else if (bitsLeft > 0) {
          value2 <<= bitsLeft;
          value2 |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft);
        }
        return value2;
      }
      function isBitSet$1(source, byteOffset, bitOffset) {
        return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;
      }
      function a2hex(str) {
        const arr = [];
        for (let i = 0, l2 = str.length; i < l2; i++) {
          const hex = Number(str.charCodeAt(i)).toString(16);
          arr.push(hex.length === 1 ? `0${hex}` : hex);
        }
        return arr.join(" ");
      }
      function ratioToDb(ratio) {
        return 10 * Math.log10(ratio);
      }
      function dbToRatio(dB) {
        return 10 ** (dB / 10);
      }
      function toRatio(value2) {
        const ps = value2.split(" ").map((p2) => p2.trim().toLowerCase());
        if (ps.length >= 1) {
          const v = Number.parseFloat(ps[0]);
          return ps.length === 2 && ps[1] === "db" ? {
            dB: v,
            ratio: dbToRatio(v)
          } : {
            dB: ratioToDb(v),
            ratio: v
          };
        }
      }
      var AttachedPictureType; exports("A", AttachedPictureType);
      (function(AttachedPictureType2) {
        AttachedPictureType2[AttachedPictureType2["Other"] = 0] = "Other";
        AttachedPictureType2[AttachedPictureType2["32x32 pixels 'file icon' (PNG only)"] = 1] = "32x32 pixels 'file icon' (PNG only)";
        AttachedPictureType2[AttachedPictureType2["Other file icon"] = 2] = "Other file icon";
        AttachedPictureType2[AttachedPictureType2["Cover (front)"] = 3] = "Cover (front)";
        AttachedPictureType2[AttachedPictureType2["Cover (back)"] = 4] = "Cover (back)";
        AttachedPictureType2[AttachedPictureType2["Leaflet page"] = 5] = "Leaflet page";
        AttachedPictureType2[AttachedPictureType2["Media (e.g. label side of CD)"] = 6] = "Media (e.g. label side of CD)";
        AttachedPictureType2[AttachedPictureType2["Lead artist/lead performer/soloist"] = 7] = "Lead artist/lead performer/soloist";
        AttachedPictureType2[AttachedPictureType2["Artist/performer"] = 8] = "Artist/performer";
        AttachedPictureType2[AttachedPictureType2["Conductor"] = 9] = "Conductor";
        AttachedPictureType2[AttachedPictureType2["Band/Orchestra"] = 10] = "Band/Orchestra";
        AttachedPictureType2[AttachedPictureType2["Composer"] = 11] = "Composer";
        AttachedPictureType2[AttachedPictureType2["Lyricist/text writer"] = 12] = "Lyricist/text writer";
        AttachedPictureType2[AttachedPictureType2["Recording Location"] = 13] = "Recording Location";
        AttachedPictureType2[AttachedPictureType2["During recording"] = 14] = "During recording";
        AttachedPictureType2[AttachedPictureType2["During performance"] = 15] = "During performance";
        AttachedPictureType2[AttachedPictureType2["Movie/video screen capture"] = 16] = "Movie/video screen capture";
        AttachedPictureType2[AttachedPictureType2["A bright coloured fish"] = 17] = "A bright coloured fish";
        AttachedPictureType2[AttachedPictureType2["Illustration"] = 18] = "Illustration";
        AttachedPictureType2[AttachedPictureType2["Band/artist logotype"] = 19] = "Band/artist logotype";
        AttachedPictureType2[AttachedPictureType2["Publisher/Studio logotype"] = 20] = "Publisher/Studio logotype";
      })(AttachedPictureType || (exports("A", AttachedPictureType = {})));
      var LyricsContentType;
      (function(LyricsContentType2) {
        LyricsContentType2[LyricsContentType2["other"] = 0] = "other";
        LyricsContentType2[LyricsContentType2["lyrics"] = 1] = "lyrics";
        LyricsContentType2[LyricsContentType2["text"] = 2] = "text";
        LyricsContentType2[LyricsContentType2["movement_part"] = 3] = "movement_part";
        LyricsContentType2[LyricsContentType2["events"] = 4] = "events";
        LyricsContentType2[LyricsContentType2["chord"] = 5] = "chord";
        LyricsContentType2[LyricsContentType2["trivia_pop"] = 6] = "trivia_pop";
      })(LyricsContentType || (LyricsContentType = {}));
      var TimestampFormat;
      (function(TimestampFormat2) {
        TimestampFormat2[TimestampFormat2["notSynchronized0"] = 0] = "notSynchronized0";
        TimestampFormat2[TimestampFormat2["mpegFrameNumber"] = 1] = "mpegFrameNumber";
        TimestampFormat2[TimestampFormat2["milliseconds"] = 2] = "milliseconds";
      })(TimestampFormat || (TimestampFormat = {}));
      const UINT32SYNCSAFE = exports("P", {
        get: (buf, off) => {
          return buf[off + 3] & 127 | buf[off + 2] << 7 | buf[off + 1] << 14 | buf[off] << 21;
        },
        len: 4
      });
      const ID3v2Header = exports("K", {
        len: 10,
        get: (buf, off) => {
          return {
            // ID3v2/file identifier   "ID3"
            fileIdentifier: new StringType(3, "ascii").get(buf, off),
            // ID3v2 versionIndex
            version: {
              major: INT8.get(buf, off + 3),
              revision: INT8.get(buf, off + 4)
            },
            // ID3v2 flags
            flags: {
              // Unsynchronisation
              unsynchronisation: getBit(buf, off + 5, 7),
              // Extended header
              isExtendedHeader: getBit(buf, off + 5, 6),
              // Experimental indicator
              expIndicator: getBit(buf, off + 5, 5),
              footer: getBit(buf, off + 5, 4)
            },
            size: UINT32SYNCSAFE.get(buf, off + 6)
          };
        }
      });
      const ExtendedHeader = exports("O", {
        len: 10,
        get: (buf, off) => {
          return {
            // Extended header size
            size: UINT32_BE.get(buf, off),
            // Extended Flags
            extendedFlags: UINT16_BE.get(buf, off + 4),
            // Size of padding
            sizeOfPadding: UINT32_BE.get(buf, off + 6),
            // CRC data present
            crcDataPresent: getBit(buf, off + 4, 31)
          };
        }
      });
      const TextEncodingToken = exports("Q", {
        len: 1,
        get: (uint8Array, off) => {
          switch (uint8Array[off]) {
            case 0:
              return { encoding: "latin1" };
            case 1:
              return { encoding: "utf-16le", bom: true };
            case 2:
              return { encoding: "utf-16le", bom: false };
            case 3:
              return { encoding: "utf8", bom: false };
            default:
              return { encoding: "utf8", bom: false };
          }
        }
      });
      const TextHeader = exports("V", {
        len: 4,
        get: (uint8Array, off) => {
          return {
            encoding: TextEncodingToken.get(uint8Array, off),
            language: new StringType(3, "latin1").get(uint8Array, off + 1)
          };
        }
      });
      const SyncTextHeader = exports("W", {
        len: 6,
        get: (uint8Array, off) => {
          const text2 = TextHeader.get(uint8Array, off);
          return {
            encoding: text2.encoding,
            language: text2.language,
            timeStampFormat: UINT8.get(uint8Array, off + 4),
            contentType: UINT8.get(uint8Array, off + 5)
          };
        }
      });
      const commonTags = {
        year: { multiple: false },
        track: { multiple: false },
        disk: { multiple: false },
        title: { multiple: false },
        artist: { multiple: false },
        artists: { multiple: true, unique: true },
        albumartist: { multiple: false },
        album: { multiple: false },
        date: { multiple: false },
        originaldate: { multiple: false },
        originalyear: { multiple: false },
        releasedate: { multiple: false },
        comment: { multiple: true, unique: false },
        genre: { multiple: true, unique: true },
        picture: { multiple: true, unique: true },
        composer: { multiple: true, unique: true },
        lyrics: { multiple: true, unique: false },
        albumsort: { multiple: false, unique: true },
        titlesort: { multiple: false, unique: true },
        work: { multiple: false, unique: true },
        artistsort: { multiple: false, unique: true },
        albumartistsort: { multiple: false, unique: true },
        composersort: { multiple: false, unique: true },
        lyricist: { multiple: true, unique: true },
        writer: { multiple: true, unique: true },
        conductor: { multiple: true, unique: true },
        remixer: { multiple: true, unique: true },
        arranger: { multiple: true, unique: true },
        engineer: { multiple: true, unique: true },
        producer: { multiple: true, unique: true },
        technician: { multiple: true, unique: true },
        djmixer: { multiple: true, unique: true },
        mixer: { multiple: true, unique: true },
        label: { multiple: true, unique: true },
        grouping: { multiple: false },
        subtitle: { multiple: true },
        discsubtitle: { multiple: false },
        totaltracks: { multiple: false },
        totaldiscs: { multiple: false },
        compilation: { multiple: false },
        rating: { multiple: true },
        bpm: { multiple: false },
        mood: { multiple: false },
        media: { multiple: false },
        catalognumber: { multiple: true, unique: true },
        tvShow: { multiple: false },
        tvShowSort: { multiple: false },
        tvSeason: { multiple: false },
        tvEpisode: { multiple: false },
        tvEpisodeId: { multiple: false },
        tvNetwork: { multiple: false },
        podcast: { multiple: false },
        podcasturl: { multiple: false },
        releasestatus: { multiple: false },
        releasetype: { multiple: true },
        releasecountry: { multiple: false },
        script: { multiple: false },
        language: { multiple: false },
        copyright: { multiple: false },
        license: { multiple: false },
        encodedby: { multiple: false },
        encodersettings: { multiple: false },
        gapless: { multiple: false },
        barcode: { multiple: false },
        isrc: { multiple: true },
        asin: { multiple: false },
        musicbrainz_recordingid: { multiple: false },
        musicbrainz_trackid: { multiple: false },
        musicbrainz_albumid: { multiple: false },
        musicbrainz_artistid: { multiple: true },
        musicbrainz_albumartistid: { multiple: true },
        musicbrainz_releasegroupid: { multiple: false },
        musicbrainz_workid: { multiple: false },
        musicbrainz_trmid: { multiple: false },
        musicbrainz_discid: { multiple: false },
        acoustid_id: { multiple: false },
        acoustid_fingerprint: { multiple: false },
        musicip_puid: { multiple: false },
        musicip_fingerprint: { multiple: false },
        website: { multiple: false },
        "performer:instrument": { multiple: true, unique: true },
        averageLevel: { multiple: false },
        peakLevel: { multiple: false },
        notes: { multiple: true, unique: false },
        key: { multiple: false },
        originalalbum: { multiple: false },
        originalartist: { multiple: false },
        discogs_artist_id: { multiple: true, unique: true },
        discogs_release_id: { multiple: false },
        discogs_label_id: { multiple: false },
        discogs_master_release_id: { multiple: false },
        discogs_votes: { multiple: false },
        discogs_rating: { multiple: false },
        replaygain_track_peak: { multiple: false },
        replaygain_track_gain: { multiple: false },
        replaygain_album_peak: { multiple: false },
        replaygain_album_gain: { multiple: false },
        replaygain_track_minmax: { multiple: false },
        replaygain_album_minmax: { multiple: false },
        replaygain_undo: { multiple: false },
        description: { multiple: true },
        longDescription: { multiple: false },
        category: { multiple: true },
        hdVideo: { multiple: false },
        keywords: { multiple: true },
        movement: { multiple: false },
        movementIndex: { multiple: false },
        movementTotal: { multiple: false },
        podcastId: { multiple: false },
        showMovement: { multiple: false },
        stik: { multiple: false }
      };
      function isSingleton(alias) {
        return commonTags[alias] && !commonTags[alias].multiple;
      }
      function isUnique(alias) {
        return !commonTags[alias].multiple || commonTags[alias].unique || false;
      }
      class CommonTagMapper {
        static toIntOrNull(str) {
          const cleaned = Number.parseInt(str, 10);
          return Number.isNaN(cleaned) ? null : cleaned;
        }
        // TODO: a string of 1of1 would fail to be converted
        // converts 1/10 to no : 1, of : 10
        // or 1 to no : 1, of : 0
        static normalizeTrack(origVal) {
          const split = origVal.toString().split("/");
          return {
            no: Number.parseInt(split[0], 10) || null,
            of: Number.parseInt(split[1], 10) || null
          };
        }
        constructor(tagTypes, tagMap2) {
          this.tagTypes = tagTypes;
          this.tagMap = tagMap2;
        }
        /**
         * Process and set common tags
         * write common tags to
         * @param tag Native tag
         * @param warnings Register warnings
         * @return common name
         */
        mapGenericTag(tag2, warnings) {
          tag2 = { id: tag2.id, value: tag2.value };
          this.postMap(tag2, warnings);
          const id = this.getCommonName(tag2.id);
          return id ? { id, value: tag2.value } : null;
        }
        /**
         * Convert native tag key to common tag key
         * @param tag Native header tag
         * @return common tag name (alias)
         */
        getCommonName(tag2) {
          return this.tagMap[tag2];
        }
        /**
         * Handle post mapping exceptions / correction
         * @param tag Tag e.g. {"©alb", "Buena Vista Social Club")
         * @param warnings Used to register warnings
         */
        postMap(tag2, warnings) {
          return;
        }
      }
      CommonTagMapper.maxRatingScore = 1;
      const id3v1TagMap = {
        title: "title",
        artist: "artist",
        album: "album",
        year: "year",
        comment: "comment",
        track: "track",
        genre: "genre"
      };
      class ID3v1TagMapper extends CommonTagMapper {
        constructor() {
          super(["ID3v1"], id3v1TagMap);
        }
      }
      class CaseInsensitiveTagMap extends CommonTagMapper {
        constructor(tagTypes, tagMap2) {
          const upperCaseMap = {};
          for (const tag2 of Object.keys(tagMap2)) {
            upperCaseMap[tag2.toUpperCase()] = tagMap2[tag2];
          }
          super(tagTypes, upperCaseMap);
        }
        /**
         * @tag  Native header tag
         * @return common tag name (alias)
         */
        getCommonName(tag2) {
          return this.tagMap[tag2.toUpperCase()];
        }
      }
      const id3v24TagMap = {
        // id3v2.3
        TIT2: "title",
        TPE1: "artist",
        "TXXX:Artists": "artists",
        TPE2: "albumartist",
        TALB: "album",
        TDRV: "date",
        // [ 'date', 'year' ] ToDo: improve 'year' mapping
        /**
         * Original release year
         */
        TORY: "originalyear",
        TPOS: "disk",
        TCON: "genre",
        APIC: "picture",
        TCOM: "composer",
        USLT: "lyrics",
        TSOA: "albumsort",
        TSOT: "titlesort",
        TOAL: "originalalbum",
        TSOP: "artistsort",
        TSO2: "albumartistsort",
        TSOC: "composersort",
        TEXT: "lyricist",
        "TXXX:Writer": "writer",
        TPE3: "conductor",
        // 'IPLS:instrument': 'performer:instrument', // ToDo
        TPE4: "remixer",
        "IPLS:arranger": "arranger",
        "IPLS:engineer": "engineer",
        "IPLS:producer": "producer",
        "IPLS:DJ-mix": "djmixer",
        "IPLS:mix": "mixer",
        TPUB: "label",
        TIT1: "grouping",
        TIT3: "subtitle",
        TRCK: "track",
        TCMP: "compilation",
        POPM: "rating",
        TBPM: "bpm",
        TMED: "media",
        "TXXX:CATALOGNUMBER": "catalognumber",
        "TXXX:MusicBrainz Album Status": "releasestatus",
        "TXXX:MusicBrainz Album Type": "releasetype",
        /**
         * Release country as documented: https://picard.musicbrainz.org/docs/mappings/#cite_note-0
         */
        "TXXX:MusicBrainz Album Release Country": "releasecountry",
        /**
         * Release country as implemented // ToDo: report
         */
        "TXXX:RELEASECOUNTRY": "releasecountry",
        "TXXX:SCRIPT": "script",
        TLAN: "language",
        TCOP: "copyright",
        WCOP: "license",
        TENC: "encodedby",
        TSSE: "encodersettings",
        "TXXX:BARCODE": "barcode",
        "TXXX:ISRC": "isrc",
        TSRC: "isrc",
        "TXXX:ASIN": "asin",
        "TXXX:originalyear": "originalyear",
        "UFID:http://musicbrainz.org": "musicbrainz_recordingid",
        "TXXX:MusicBrainz Release Track Id": "musicbrainz_trackid",
        "TXXX:MusicBrainz Album Id": "musicbrainz_albumid",
        "TXXX:MusicBrainz Artist Id": "musicbrainz_artistid",
        "TXXX:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
        "TXXX:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
        "TXXX:MusicBrainz Work Id": "musicbrainz_workid",
        "TXXX:MusicBrainz TRM Id": "musicbrainz_trmid",
        "TXXX:MusicBrainz Disc Id": "musicbrainz_discid",
        "TXXX:ACOUSTID_ID": "acoustid_id",
        "TXXX:Acoustid Id": "acoustid_id",
        "TXXX:Acoustid Fingerprint": "acoustid_fingerprint",
        "TXXX:MusicIP PUID": "musicip_puid",
        "TXXX:MusicMagic Fingerprint": "musicip_fingerprint",
        WOAR: "website",
        // id3v2.4
        // ToDo: In same sequence as defined at http://id3.org/id3v2.4.0-frames
        TDRC: "date",
        // date YYYY-MM-DD
        TYER: "year",
        TDOR: "originaldate",
        // 'TMCL:instrument': 'performer:instrument',
        "TIPL:arranger": "arranger",
        "TIPL:engineer": "engineer",
        "TIPL:producer": "producer",
        "TIPL:DJ-mix": "djmixer",
        "TIPL:mix": "mixer",
        TMOO: "mood",
        // additional mappings:
        SYLT: "lyrics",
        TSST: "discsubtitle",
        TKEY: "key",
        COMM: "comment",
        TOPE: "originalartist",
        // Windows Media Player
        "PRIV:AverageLevel": "averageLevel",
        "PRIV:PeakLevel": "peakLevel",
        // Discogs
        "TXXX:DISCOGS_ARTIST_ID": "discogs_artist_id",
        "TXXX:DISCOGS_ARTISTS": "artists",
        "TXXX:DISCOGS_ARTIST_NAME": "artists",
        "TXXX:DISCOGS_ALBUM_ARTISTS": "albumartist",
        "TXXX:DISCOGS_CATALOG": "catalognumber",
        "TXXX:DISCOGS_COUNTRY": "releasecountry",
        "TXXX:DISCOGS_DATE": "originaldate",
        "TXXX:DISCOGS_LABEL": "label",
        "TXXX:DISCOGS_LABEL_ID": "discogs_label_id",
        "TXXX:DISCOGS_MASTER_RELEASE_ID": "discogs_master_release_id",
        "TXXX:DISCOGS_RATING": "discogs_rating",
        "TXXX:DISCOGS_RELEASED": "date",
        "TXXX:DISCOGS_RELEASE_ID": "discogs_release_id",
        "TXXX:DISCOGS_VOTES": "discogs_votes",
        "TXXX:CATALOGID": "catalognumber",
        "TXXX:STYLE": "genre",
        "TXXX:REPLAYGAIN_TRACK_PEAK": "replaygain_track_peak",
        "TXXX:REPLAYGAIN_TRACK_GAIN": "replaygain_track_gain",
        "TXXX:REPLAYGAIN_ALBUM_PEAK": "replaygain_album_peak",
        "TXXX:REPLAYGAIN_ALBUM_GAIN": "replaygain_album_gain",
        "TXXX:MP3GAIN_MINMAX": "replaygain_track_minmax",
        "TXXX:MP3GAIN_ALBUM_MINMAX": "replaygain_album_minmax",
        "TXXX:MP3GAIN_UNDO": "replaygain_undo",
        MVNM: "movement",
        MVIN: "movementIndex",
        PCST: "podcast",
        TCAT: "category",
        TDES: "description",
        TDRL: "releasedate",
        TGID: "podcastId",
        TKWD: "keywords",
        WFED: "podcasturl",
        GRP1: "grouping"
      };
      class ID3v24TagMapper extends CaseInsensitiveTagMap {
        static toRating(popm) {
          return {
            source: popm.email,
            rating: popm.rating > 0 ? (popm.rating - 1) / 254 * CommonTagMapper.maxRatingScore : void 0
          };
        }
        constructor() {
          super(["ID3v2.3", "ID3v2.4"], id3v24TagMap);
        }
        /**
         * Handle post mapping exceptions / correction
         * @param tag to post map
         * @param warnings Wil be used to register (collect) warnings
         */
        postMap(tag2, warnings) {
          switch (tag2.id) {
            case "UFID":
              {
                const idTag = tag2.value;
                if (idTag.owner_identifier === "http://musicbrainz.org") {
                  tag2.id += `:${idTag.owner_identifier}`;
                  tag2.value = decodeString(idTag.identifier, "latin1");
                }
              }
              break;
            case "PRIV":
              {
                const customTag = tag2.value;
                switch (customTag.owner_identifier) {
                  case "AverageLevel":
                  case "PeakValue":
                    tag2.id += `:${customTag.owner_identifier}`;
                    tag2.value = customTag.data.length === 4 ? UINT32_LE.get(customTag.data, 0) : null;
                    if (tag2.value === null) {
                      warnings.addWarning("Failed to parse PRIV:PeakValue");
                    }
                    break;
                  default:
                    warnings.addWarning(`Unknown PRIV owner-identifier: ${customTag.data}`);
                }
              }
              break;
            case "POPM":
              tag2.value = ID3v24TagMapper.toRating(tag2.value);
              break;
          }
        }
      }
      const asfTagMap = {
        Title: "title",
        Author: "artist",
        "WM/AlbumArtist": "albumartist",
        "WM/AlbumTitle": "album",
        "WM/Year": "date",
        // changed to 'year' to 'date' based on Picard mappings; ToDo: check me
        "WM/OriginalReleaseTime": "originaldate",
        "WM/OriginalReleaseYear": "originalyear",
        Description: "comment",
        "WM/TrackNumber": "track",
        "WM/PartOfSet": "disk",
        "WM/Genre": "genre",
        "WM/Composer": "composer",
        "WM/Lyrics": "lyrics",
        "WM/AlbumSortOrder": "albumsort",
        "WM/TitleSortOrder": "titlesort",
        "WM/ArtistSortOrder": "artistsort",
        "WM/AlbumArtistSortOrder": "albumartistsort",
        "WM/ComposerSortOrder": "composersort",
        "WM/Writer": "lyricist",
        "WM/Conductor": "conductor",
        "WM/ModifiedBy": "remixer",
        "WM/Engineer": "engineer",
        "WM/Producer": "producer",
        "WM/DJMixer": "djmixer",
        "WM/Mixer": "mixer",
        "WM/Publisher": "label",
        "WM/ContentGroupDescription": "grouping",
        "WM/SubTitle": "subtitle",
        "WM/SetSubTitle": "discsubtitle",
        // 'WM/PartOfSet': 'totaldiscs',
        "WM/IsCompilation": "compilation",
        "WM/SharedUserRating": "rating",
        "WM/BeatsPerMinute": "bpm",
        "WM/Mood": "mood",
        "WM/Media": "media",
        "WM/CatalogNo": "catalognumber",
        "MusicBrainz/Album Status": "releasestatus",
        "MusicBrainz/Album Type": "releasetype",
        "MusicBrainz/Album Release Country": "releasecountry",
        "WM/Script": "script",
        "WM/Language": "language",
        Copyright: "copyright",
        LICENSE: "license",
        "WM/EncodedBy": "encodedby",
        "WM/EncodingSettings": "encodersettings",
        "WM/Barcode": "barcode",
        "WM/ISRC": "isrc",
        "MusicBrainz/Track Id": "musicbrainz_recordingid",
        "MusicBrainz/Release Track Id": "musicbrainz_trackid",
        "MusicBrainz/Album Id": "musicbrainz_albumid",
        "MusicBrainz/Artist Id": "musicbrainz_artistid",
        "MusicBrainz/Album Artist Id": "musicbrainz_albumartistid",
        "MusicBrainz/Release Group Id": "musicbrainz_releasegroupid",
        "MusicBrainz/Work Id": "musicbrainz_workid",
        "MusicBrainz/TRM Id": "musicbrainz_trmid",
        "MusicBrainz/Disc Id": "musicbrainz_discid",
        "Acoustid/Id": "acoustid_id",
        "Acoustid/Fingerprint": "acoustid_fingerprint",
        "MusicIP/PUID": "musicip_puid",
        "WM/ARTISTS": "artists",
        "WM/InitialKey": "key",
        ASIN: "asin",
        "WM/Work": "work",
        "WM/AuthorURL": "website",
        "WM/Picture": "picture"
      };
      class AsfTagMapper extends CommonTagMapper {
        static toRating(rating) {
          return {
            rating: Number.parseFloat(rating + 1) / 5
          };
        }
        constructor() {
          super(["asf"], asfTagMap);
        }
        postMap(tag2) {
          switch (tag2.id) {
            case "WM/SharedUserRating": {
              const keys = tag2.id.split(":");
              tag2.value = AsfTagMapper.toRating(tag2.value);
              tag2.id = keys[0];
              break;
            }
          }
        }
      }
      const id3v22TagMap = {
        TT2: "title",
        TP1: "artist",
        TP2: "albumartist",
        TAL: "album",
        TYE: "year",
        COM: "comment",
        TRK: "track",
        TPA: "disk",
        TCO: "genre",
        PIC: "picture",
        TCM: "composer",
        TOR: "originaldate",
        TOT: "originalalbum",
        TXT: "lyricist",
        TP3: "conductor",
        TPB: "label",
        TT1: "grouping",
        TT3: "subtitle",
        TLA: "language",
        TCR: "copyright",
        WCP: "license",
        TEN: "encodedby",
        TSS: "encodersettings",
        WAR: "website",
        PCS: "podcast",
        TCP: "compilation",
        TDR: "date",
        TS2: "albumartistsort",
        TSA: "albumsort",
        TSC: "composersort",
        TSP: "artistsort",
        TST: "titlesort",
        WFD: "podcasturl",
        TBP: "bpm"
      };
      class ID3v22TagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super(["ID3v2.2"], id3v22TagMap);
        }
      }
      const apev2TagMap = {
        Title: "title",
        Artist: "artist",
        Artists: "artists",
        "Album Artist": "albumartist",
        Album: "album",
        Year: "date",
        Originalyear: "originalyear",
        Originaldate: "originaldate",
        Releasedate: "releasedate",
        Comment: "comment",
        Track: "track",
        Disc: "disk",
        DISCNUMBER: "disk",
        // ToDo: backwards compatibility', valid tag?
        Genre: "genre",
        "Cover Art (Front)": "picture",
        "Cover Art (Back)": "picture",
        Composer: "composer",
        Lyrics: "lyrics",
        ALBUMSORT: "albumsort",
        TITLESORT: "titlesort",
        WORK: "work",
        ARTISTSORT: "artistsort",
        ALBUMARTISTSORT: "albumartistsort",
        COMPOSERSORT: "composersort",
        Lyricist: "lyricist",
        Writer: "writer",
        Conductor: "conductor",
        // 'Performer=artist (instrument)': 'performer:instrument',
        MixArtist: "remixer",
        Arranger: "arranger",
        Engineer: "engineer",
        Producer: "producer",
        DJMixer: "djmixer",
        Mixer: "mixer",
        Label: "label",
        Grouping: "grouping",
        Subtitle: "subtitle",
        DiscSubtitle: "discsubtitle",
        Compilation: "compilation",
        BPM: "bpm",
        Mood: "mood",
        Media: "media",
        CatalogNumber: "catalognumber",
        MUSICBRAINZ_ALBUMSTATUS: "releasestatus",
        MUSICBRAINZ_ALBUMTYPE: "releasetype",
        RELEASECOUNTRY: "releasecountry",
        Script: "script",
        Language: "language",
        Copyright: "copyright",
        LICENSE: "license",
        EncodedBy: "encodedby",
        EncoderSettings: "encodersettings",
        Barcode: "barcode",
        ISRC: "isrc",
        ASIN: "asin",
        musicbrainz_trackid: "musicbrainz_recordingid",
        musicbrainz_releasetrackid: "musicbrainz_trackid",
        MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
        MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
        MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
        MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
        MUSICBRAINZ_WORKID: "musicbrainz_workid",
        MUSICBRAINZ_TRMID: "musicbrainz_trmid",
        MUSICBRAINZ_DISCID: "musicbrainz_discid",
        Acoustid_Id: "acoustid_id",
        ACOUSTID_FINGERPRINT: "acoustid_fingerprint",
        MUSICIP_PUID: "musicip_puid",
        Weblink: "website",
        REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
        REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
        MP3GAIN_MINMAX: "replaygain_track_minmax",
        MP3GAIN_UNDO: "replaygain_undo"
      };
      class APEv2TagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super(["APEv2"], apev2TagMap);
        }
      }
      const mp4TagMap = {
        "©nam": "title",
        "©ART": "artist",
        aART: "albumartist",
        /**
         * ToDo: Album artist seems to be stored here while Picard documentation says: aART
         */
        "----:com.apple.iTunes:Band": "albumartist",
        "©alb": "album",
        "©day": "date",
        "©cmt": "comment",
        "©com": "comment",
        trkn: "track",
        disk: "disk",
        "©gen": "genre",
        covr: "picture",
        "©wrt": "composer",
        "©lyr": "lyrics",
        soal: "albumsort",
        sonm: "titlesort",
        soar: "artistsort",
        soaa: "albumartistsort",
        soco: "composersort",
        "----:com.apple.iTunes:LYRICIST": "lyricist",
        "----:com.apple.iTunes:CONDUCTOR": "conductor",
        "----:com.apple.iTunes:REMIXER": "remixer",
        "----:com.apple.iTunes:ENGINEER": "engineer",
        "----:com.apple.iTunes:PRODUCER": "producer",
        "----:com.apple.iTunes:DJMIXER": "djmixer",
        "----:com.apple.iTunes:MIXER": "mixer",
        "----:com.apple.iTunes:LABEL": "label",
        "©grp": "grouping",
        "----:com.apple.iTunes:SUBTITLE": "subtitle",
        "----:com.apple.iTunes:DISCSUBTITLE": "discsubtitle",
        cpil: "compilation",
        tmpo: "bpm",
        "----:com.apple.iTunes:MOOD": "mood",
        "----:com.apple.iTunes:MEDIA": "media",
        "----:com.apple.iTunes:CATALOGNUMBER": "catalognumber",
        tvsh: "tvShow",
        tvsn: "tvSeason",
        tves: "tvEpisode",
        sosn: "tvShowSort",
        tven: "tvEpisodeId",
        tvnn: "tvNetwork",
        pcst: "podcast",
        purl: "podcasturl",
        "----:com.apple.iTunes:MusicBrainz Album Status": "releasestatus",
        "----:com.apple.iTunes:MusicBrainz Album Type": "releasetype",
        "----:com.apple.iTunes:MusicBrainz Album Release Country": "releasecountry",
        "----:com.apple.iTunes:SCRIPT": "script",
        "----:com.apple.iTunes:LANGUAGE": "language",
        cprt: "copyright",
        "©cpy": "copyright",
        "----:com.apple.iTunes:LICENSE": "license",
        "©too": "encodedby",
        pgap: "gapless",
        "----:com.apple.iTunes:BARCODE": "barcode",
        "----:com.apple.iTunes:ISRC": "isrc",
        "----:com.apple.iTunes:ASIN": "asin",
        "----:com.apple.iTunes:NOTES": "comment",
        "----:com.apple.iTunes:MusicBrainz Track Id": "musicbrainz_recordingid",
        "----:com.apple.iTunes:MusicBrainz Release Track Id": "musicbrainz_trackid",
        "----:com.apple.iTunes:MusicBrainz Album Id": "musicbrainz_albumid",
        "----:com.apple.iTunes:MusicBrainz Artist Id": "musicbrainz_artistid",
        "----:com.apple.iTunes:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
        "----:com.apple.iTunes:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
        "----:com.apple.iTunes:MusicBrainz Work Id": "musicbrainz_workid",
        "----:com.apple.iTunes:MusicBrainz TRM Id": "musicbrainz_trmid",
        "----:com.apple.iTunes:MusicBrainz Disc Id": "musicbrainz_discid",
        "----:com.apple.iTunes:Acoustid Id": "acoustid_id",
        "----:com.apple.iTunes:Acoustid Fingerprint": "acoustid_fingerprint",
        "----:com.apple.iTunes:MusicIP PUID": "musicip_puid",
        "----:com.apple.iTunes:fingerprint": "musicip_fingerprint",
        "----:com.apple.iTunes:replaygain_track_gain": "replaygain_track_gain",
        "----:com.apple.iTunes:replaygain_track_peak": "replaygain_track_peak",
        "----:com.apple.iTunes:replaygain_album_gain": "replaygain_album_gain",
        "----:com.apple.iTunes:replaygain_album_peak": "replaygain_album_peak",
        "----:com.apple.iTunes:replaygain_track_minmax": "replaygain_track_minmax",
        "----:com.apple.iTunes:replaygain_album_minmax": "replaygain_album_minmax",
        "----:com.apple.iTunes:replaygain_undo": "replaygain_undo",
        // Additional mappings:
        gnre: "genre",
        // ToDo: check mapping
        "----:com.apple.iTunes:ALBUMARTISTSORT": "albumartistsort",
        "----:com.apple.iTunes:ARTISTS": "artists",
        "----:com.apple.iTunes:ORIGINALDATE": "originaldate",
        "----:com.apple.iTunes:ORIGINALYEAR": "originalyear",
        "----:com.apple.iTunes:RELEASEDATE": "releasedate",
        // '----:com.apple.iTunes:PERFORMER': 'performer'
        desc: "description",
        ldes: "longDescription",
        "©mvn": "movement",
        "©mvi": "movementIndex",
        "©mvc": "movementTotal",
        "©wrk": "work",
        catg: "category",
        egid: "podcastId",
        hdvd: "hdVideo",
        keyw: "keywords",
        shwm: "showMovement",
        stik: "stik",
        rate: "rating"
      };
      const tagType = "iTunes";
      class MP4TagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super([tagType], mp4TagMap);
        }
        postMap(tag2, warnings) {
          switch (tag2.id) {
            case "rate":
              tag2.value = {
                source: void 0,
                rating: Number.parseFloat(tag2.value) / 100
              };
              break;
          }
        }
      }
      const vorbisTagMap = {
        TITLE: "title",
        ARTIST: "artist",
        ARTISTS: "artists",
        ALBUMARTIST: "albumartist",
        "ALBUM ARTIST": "albumartist",
        ALBUM: "album",
        DATE: "date",
        ORIGINALDATE: "originaldate",
        ORIGINALYEAR: "originalyear",
        RELEASEDATE: "releasedate",
        COMMENT: "comment",
        TRACKNUMBER: "track",
        DISCNUMBER: "disk",
        GENRE: "genre",
        METADATA_BLOCK_PICTURE: "picture",
        COMPOSER: "composer",
        LYRICS: "lyrics",
        ALBUMSORT: "albumsort",
        TITLESORT: "titlesort",
        WORK: "work",
        ARTISTSORT: "artistsort",
        ALBUMARTISTSORT: "albumartistsort",
        COMPOSERSORT: "composersort",
        LYRICIST: "lyricist",
        WRITER: "writer",
        CONDUCTOR: "conductor",
        // 'PERFORMER=artist (instrument)': 'performer:instrument', // ToDo
        REMIXER: "remixer",
        ARRANGER: "arranger",
        ENGINEER: "engineer",
        PRODUCER: "producer",
        DJMIXER: "djmixer",
        MIXER: "mixer",
        LABEL: "label",
        GROUPING: "grouping",
        SUBTITLE: "subtitle",
        DISCSUBTITLE: "discsubtitle",
        TRACKTOTAL: "totaltracks",
        DISCTOTAL: "totaldiscs",
        COMPILATION: "compilation",
        RATING: "rating",
        BPM: "bpm",
        KEY: "key",
        MOOD: "mood",
        MEDIA: "media",
        CATALOGNUMBER: "catalognumber",
        RELEASESTATUS: "releasestatus",
        RELEASETYPE: "releasetype",
        RELEASECOUNTRY: "releasecountry",
        SCRIPT: "script",
        LANGUAGE: "language",
        COPYRIGHT: "copyright",
        LICENSE: "license",
        ENCODEDBY: "encodedby",
        ENCODERSETTINGS: "encodersettings",
        BARCODE: "barcode",
        ISRC: "isrc",
        ASIN: "asin",
        MUSICBRAINZ_TRACKID: "musicbrainz_recordingid",
        MUSICBRAINZ_RELEASETRACKID: "musicbrainz_trackid",
        MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
        MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
        MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
        MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
        MUSICBRAINZ_WORKID: "musicbrainz_workid",
        MUSICBRAINZ_TRMID: "musicbrainz_trmid",
        MUSICBRAINZ_DISCID: "musicbrainz_discid",
        ACOUSTID_ID: "acoustid_id",
        ACOUSTID_ID_FINGERPRINT: "acoustid_fingerprint",
        MUSICIP_PUID: "musicip_puid",
        // 'FINGERPRINT=MusicMagic Fingerprint {fingerprint}': 'musicip_fingerprint', // ToDo
        WEBSITE: "website",
        NOTES: "notes",
        TOTALTRACKS: "totaltracks",
        TOTALDISCS: "totaldiscs",
        // Discogs
        DISCOGS_ARTIST_ID: "discogs_artist_id",
        DISCOGS_ARTISTS: "artists",
        DISCOGS_ARTIST_NAME: "artists",
        DISCOGS_ALBUM_ARTISTS: "albumartist",
        DISCOGS_CATALOG: "catalognumber",
        DISCOGS_COUNTRY: "releasecountry",
        DISCOGS_DATE: "originaldate",
        DISCOGS_LABEL: "label",
        DISCOGS_LABEL_ID: "discogs_label_id",
        DISCOGS_MASTER_RELEASE_ID: "discogs_master_release_id",
        DISCOGS_RATING: "discogs_rating",
        DISCOGS_RELEASED: "date",
        DISCOGS_RELEASE_ID: "discogs_release_id",
        DISCOGS_VOTES: "discogs_votes",
        CATALOGID: "catalognumber",
        STYLE: "genre",
        //
        REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
        REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak",
        REPLAYGAIN_ALBUM_GAIN: "replaygain_album_gain",
        REPLAYGAIN_ALBUM_PEAK: "replaygain_album_peak",
        // To Sure if these (REPLAYGAIN_MINMAX, REPLAYGAIN_ALBUM_MINMAX & REPLAYGAIN_UNDO) are used for Vorbis:
        REPLAYGAIN_MINMAX: "replaygain_track_minmax",
        REPLAYGAIN_ALBUM_MINMAX: "replaygain_album_minmax",
        REPLAYGAIN_UNDO: "replaygain_undo"
      };
      class VorbisTagMapper extends CommonTagMapper {
        static toRating(email, rating, maxScore) {
          return {
            source: email ? email.toLowerCase() : void 0,
            rating: Number.parseFloat(rating) / maxScore * CommonTagMapper.maxRatingScore
          };
        }
        constructor() {
          super(["vorbis"], vorbisTagMap);
        }
        postMap(tag2) {
          if (tag2.id === "RATING") {
            tag2.value = VorbisTagMapper.toRating(void 0, tag2.value, 100);
          } else if (tag2.id.indexOf("RATING:") === 0) {
            const keys = tag2.id.split(":");
            tag2.value = VorbisTagMapper.toRating(keys[1], tag2.value, 1);
            tag2.id = keys[0];
          }
        }
      }
      const riffInfoTagMap = {
        IART: "artist",
        // Artist
        ICRD: "date",
        // DateCreated
        INAM: "title",
        // Title
        TITL: "title",
        IPRD: "album",
        // Product
        ITRK: "track",
        IPRT: "track",
        // Additional tag for track index
        COMM: "comment",
        // Comments
        ICMT: "comment",
        // Country
        ICNT: "releasecountry",
        GNRE: "genre",
        // Genre
        IWRI: "writer",
        // WrittenBy
        RATE: "rating",
        YEAR: "year",
        ISFT: "encodedby",
        // Software
        CODE: "encodedby",
        // EncodedBy
        TURL: "website",
        // URL,
        IGNR: "genre",
        // Genre
        IENG: "engineer",
        // Engineer
        ITCH: "technician",
        // Technician
        IMED: "media",
        // Original Media
        IRPD: "album"
        // Product, where the file was intended for
      };
      class RiffInfoTagMapper extends CommonTagMapper {
        constructor() {
          super(["exif"], riffInfoTagMap);
        }
      }
      const ebmlTagMap = {
        "segment:title": "title",
        "album:ARTIST": "albumartist",
        "album:ARTISTSORT": "albumartistsort",
        "album:TITLE": "album",
        "album:DATE_RECORDED": "originaldate",
        "album:DATE_RELEASED": "releasedate",
        "album:PART_NUMBER": "disk",
        "album:TOTAL_PARTS": "totaltracks",
        "track:ARTIST": "artist",
        "track:ARTISTSORT": "artistsort",
        "track:TITLE": "title",
        "track:PART_NUMBER": "track",
        "track:MUSICBRAINZ_TRACKID": "musicbrainz_recordingid",
        "track:MUSICBRAINZ_ALBUMID": "musicbrainz_albumid",
        "track:MUSICBRAINZ_ARTISTID": "musicbrainz_artistid",
        "track:PUBLISHER": "label",
        "track:GENRE": "genre",
        "track:ENCODER": "encodedby",
        "track:ENCODER_OPTIONS": "encodersettings",
        "edition:TOTAL_PARTS": "totaldiscs",
        picture: "picture"
      };
      class MatroskaTagMapper extends CaseInsensitiveTagMap {
        constructor() {
          super(["matroska"], ebmlTagMap);
        }
      }
      const tagMap = {
        NAME: "title",
        AUTH: "artist",
        "(c) ": "copyright",
        ANNO: "comment"
      };
      class AiffTagMapper extends CommonTagMapper {
        constructor() {
          super(["AIFF"], tagMap);
        }
      }
      class CombinedTagMapper {
        constructor() {
          this.tagMappers = {};
          [
            new ID3v1TagMapper(),
            new ID3v22TagMapper(),
            new ID3v24TagMapper(),
            new MP4TagMapper(),
            new MP4TagMapper(),
            new VorbisTagMapper(),
            new APEv2TagMapper(),
            new AsfTagMapper(),
            new RiffInfoTagMapper(),
            new MatroskaTagMapper(),
            new AiffTagMapper()
          ].forEach((mapper) => {
            this.registerTagMapper(mapper);
          });
        }
        /**
         * Convert native to generic (common) tags
         * @param tagType Originating tag format
         * @param tag     Native tag to map to a generic tag id
         * @param warnings
         * @return Generic tag result (output of this function)
         */
        mapTag(tagType2, tag2, warnings) {
          const tagMapper = this.tagMappers[tagType2];
          if (tagMapper) {
            return this.tagMappers[tagType2].mapGenericTag(tag2, warnings);
          }
          throw new InternalParserError(`No generic tag mapper defined for tag-format: ${tagType2}`);
        }
        registerTagMapper(genericTagMapper) {
          for (const tagType2 of genericTagMapper.tagTypes) {
            this.tagMappers[tagType2] = genericTagMapper;
          }
        }
      }
      function parseLrc(lrcString) {
        const lines = lrcString.split("\n");
        const syncText = [];
        const timestampRegex = /\[(\d{2}):(\d{2})\.(\d{2})\]/;
        for (const line of lines) {
          const match = line.match(timestampRegex);
          if (match) {
            const minutes = Number.parseInt(match[1], 10);
            const seconds = Number.parseInt(match[2], 10);
            const hundredths = Number.parseInt(match[3], 10);
            const timestamp = (minutes * 60 + seconds) * 1e3 + hundredths * 10;
            const text2 = line.replace(timestampRegex, "").trim();
            syncText.push({ timestamp, text: text2 });
          }
        }
        return {
          contentType: LyricsContentType.lyrics,
          timeStampFormat: TimestampFormat.milliseconds,
          syncText
        };
      }
      const debug$3 = initDebug("music-metadata:collector");
      const TagPriority = ["matroska", "APEv2", "vorbis", "ID3v2.4", "ID3v2.3", "ID3v2.2", "exif", "asf", "iTunes", "AIFF", "ID3v1"];
      class MetadataCollector {
        constructor(opts) {
          this.opts = opts;
          this.format = {
            tagTypes: [],
            trackInfo: []
          };
          this.native = {};
          this.common = {
            track: { no: null, of: null },
            disk: { no: null, of: null },
            movementIndex: { no: null, of: null }
          };
          this.quality = {
            warnings: []
          };
          this.commonOrigin = {};
          this.originPriority = {};
          this.tagMapper = new CombinedTagMapper();
          let priority = 1;
          for (const tagType2 of TagPriority) {
            this.originPriority[tagType2] = priority++;
          }
          this.originPriority.artificial = 500;
          this.originPriority.id3v1 = 600;
        }
        /**
         * @returns {boolean} true if one or more tags have been found
         */
        hasAny() {
          return Object.keys(this.native).length > 0;
        }
        addStreamInfo(streamInfo) {
          debug$3(`streamInfo: type=${streamInfo.type ? TrackType[streamInfo.type] : "?"}, codec=${streamInfo.codecName}`);
          this.format.trackInfo.push(streamInfo);
        }
        setFormat(key, value2) {
          var _a;
          debug$3(`format: ${key} = ${value2}`);
          this.format[key] = value2;
          if ((_a = this.opts) == null ? void 0 : _a.observer) {
            this.opts.observer({ metadata: this, tag: { type: "format", id: key, value: value2 } });
          }
        }
        async addTag(tagType2, tagId, value2) {
          debug$3(`tag ${tagType2}.${tagId} = ${value2}`);
          if (!this.native[tagType2]) {
            this.format.tagTypes.push(tagType2);
            this.native[tagType2] = [];
          }
          this.native[tagType2].push({ id: tagId, value: value2 });
          await this.toCommon(tagType2, tagId, value2);
        }
        addWarning(warning2) {
          this.quality.warnings.push({ message: warning2 });
        }
        async postMap(tagType2, tag2) {
          switch (tag2.id) {
            case "artist":
              if (this.commonOrigin.artist === this.originPriority[tagType2]) {
                return this.postMap("artificial", { id: "artists", value: tag2.value });
              }
              if (!this.common.artists) {
                this.setGenericTag("artificial", { id: "artists", value: tag2.value });
              }
              break;
            case "artists":
              if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {
                if (!this.common.artists || this.common.artists.indexOf(tag2.value) === -1) {
                  const artists = (this.common.artists || []).concat([tag2.value]);
                  const value2 = joinArtists(artists);
                  const artistTag = { id: "artist", value: value2 };
                  this.setGenericTag("artificial", artistTag);
                }
              }
              break;
            case "picture":
              return this.postFixPicture(tag2.value).then((picture) => {
                if (picture !== null) {
                  tag2.value = picture;
                  this.setGenericTag(tagType2, tag2);
                }
              });
            case "totaltracks":
              this.common.track.of = CommonTagMapper.toIntOrNull(tag2.value);
              return;
            case "totaldiscs":
              this.common.disk.of = CommonTagMapper.toIntOrNull(tag2.value);
              return;
            case "movementTotal":
              this.common.movementIndex.of = CommonTagMapper.toIntOrNull(tag2.value);
              return;
            case "track":
            case "disk":
            case "movementIndex": {
              const of = this.common[tag2.id].of;
              this.common[tag2.id] = CommonTagMapper.normalizeTrack(tag2.value);
              this.common[tag2.id].of = of != null ? of : this.common[tag2.id].of;
              return;
            }
            case "bpm":
            case "year":
            case "originalyear":
              tag2.value = Number.parseInt(tag2.value, 10);
              break;
            case "date": {
              const year = Number.parseInt(tag2.value.substr(0, 4), 10);
              if (!Number.isNaN(year)) {
                this.common.year = year;
              }
              break;
            }
            case "discogs_label_id":
            case "discogs_release_id":
            case "discogs_master_release_id":
            case "discogs_artist_id":
            case "discogs_votes":
              tag2.value = typeof tag2.value === "string" ? Number.parseInt(tag2.value, 10) : tag2.value;
              break;
            case "replaygain_track_gain":
            case "replaygain_track_peak":
            case "replaygain_album_gain":
            case "replaygain_album_peak":
              tag2.value = toRatio(tag2.value);
              break;
            case "replaygain_track_minmax":
              tag2.value = tag2.value.split(",").map((v) => Number.parseInt(v, 10));
              break;
            case "replaygain_undo": {
              const minMix = tag2.value.split(",").map((v) => Number.parseInt(v, 10));
              tag2.value = {
                leftChannel: minMix[0],
                rightChannel: minMix[1]
              };
              break;
            }
            case "gapless":
            case "compilation":
            case "podcast":
            case "showMovement":
              tag2.value = tag2.value === "1" || tag2.value === 1;
              break;
            case "isrc": {
              const commonTag = this.common[tag2.id];
              if (commonTag && commonTag.indexOf(tag2.value) !== -1)
                return;
              break;
            }
            case "comment":
              if (typeof tag2.value === "string") {
                tag2.value = { text: tag2.value };
              }
              if (tag2.value.descriptor === "iTunPGAP") {
                this.setGenericTag(tagType2, { id: "gapless", value: tag2.value.text === "1" });
              }
              break;
            case "lyrics":
              if (typeof tag2.value === "string") {
                tag2.value = parseLrc(tag2.value);
              }
              break;
          }
          if (tag2.value !== null) {
            this.setGenericTag(tagType2, tag2);
          }
        }
        /**
         * Convert native tags to common tags
         * @returns {IAudioMetadata} Native + common tags
         */
        toCommonMetadata() {
          return {
            format: this.format,
            native: this.native,
            quality: this.quality,
            common: this.common
          };
        }
        /**
         * Fix some common issues with picture object
         * @param picture Picture
         */
        async postFixPicture(picture) {
          if (picture.data && picture.data.length > 0) {
            if (!picture.format) {
              const fileType = await fileTypeFromBuffer(Uint8Array.from(picture.data));
              if (fileType) {
                picture.format = fileType.mime;
              } else {
                return null;
              }
            }
            picture.format = picture.format.toLocaleLowerCase();
            switch (picture.format) {
              case "image/jpg":
                picture.format = "image/jpeg";
            }
            return picture;
          }
          this.addWarning("Empty picture tag found");
          return null;
        }
        /**
         * Convert native tag to common tags
         */
        async toCommon(tagType2, tagId, value2) {
          const tag2 = { id: tagId, value: value2 };
          const genericTag = this.tagMapper.mapTag(tagType2, tag2, this);
          if (genericTag) {
            await this.postMap(tagType2, genericTag);
          }
        }
        /**
         * Set generic tag
         */
        setGenericTag(tagType2, tag2) {
          var _a;
          debug$3(`common.${tag2.id} = ${tag2.value}`);
          const prio0 = this.commonOrigin[tag2.id] || 1e3;
          const prio1 = this.originPriority[tagType2];
          if (isSingleton(tag2.id)) {
            if (prio1 <= prio0) {
              this.common[tag2.id] = tag2.value;
              this.commonOrigin[tag2.id] = prio1;
            } else {
              return debug$3(`Ignore native tag (singleton): ${tagType2}.${tag2.id} = ${tag2.value}`);
            }
          } else {
            if (prio1 === prio0) {
              if (!isUnique(tag2.id) || this.common[tag2.id].indexOf(tag2.value) === -1) {
                this.common[tag2.id].push(tag2.value);
              } else {
                debug$3(`Ignore duplicate value: ${tagType2}.${tag2.id} = ${tag2.value}`);
              }
            } else if (prio1 < prio0) {
              this.common[tag2.id] = [tag2.value];
              this.commonOrigin[tag2.id] = prio1;
            } else {
              return debug$3(`Ignore native tag (list): ${tagType2}.${tag2.id} = ${tag2.value}`);
            }
          }
          if ((_a = this.opts) == null ? void 0 : _a.observer) {
            this.opts.observer({ metadata: this, tag: { type: "common", id: tag2.id, value: tag2.value } });
          }
        }
      }
      function joinArtists(artists) {
        if (artists.length > 2) {
          return `${artists.slice(0, artists.length - 1).join(", ")} & ${artists[artists.length - 1]}`;
        }
        return artists.join(" & ");
      }
      const scriptRel = function detectScriptRel() {
        const relList = typeof document !== "undefined" && document.createElement("link").relList;
        return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
      }();
      const assetsURL = function(dep) {
        return "/" + dep;
      };
      const seen = {};
      const __vitePreload = function preload(baseModule, deps, importerUrl) {
        let promise = Promise.resolve();
        if (deps && deps.length > 0) {
          document.getElementsByTagName("link");
          const cspNonceMeta = document.querySelector(
            "meta[property=csp-nonce]"
          );
          const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
          promise = Promise.allSettled(
            deps.map((dep) => {
              dep = assetsURL(dep);
              if (dep in seen) return;
              seen[dep] = true;
              const isCss = dep.endsWith(".css");
              const cssSelector = isCss ? '[rel="stylesheet"]' : "";
              if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
                return;
              }
              const link = document.createElement("link");
              link.rel = isCss ? "stylesheet" : scriptRel;
              if (!isCss) {
                link.as = "script";
              }
              link.crossOrigin = "";
              link.href = dep;
              if (cspNonce) {
                link.setAttribute("nonce", cspNonce);
              }
              document.head.appendChild(link);
              if (isCss) {
                return new Promise((res, rej) => {
                  link.addEventListener("load", res);
                  link.addEventListener(
                    "error",
                    () => rej(new Error(`Unable to preload CSS for ${dep}`))
                  );
                });
              }
            })
          );
        }
        function handlePreloadError(err) {
          const e = new Event("vite:preloadError", {
            cancelable: true
          });
          e.payload = err;
          window.dispatchEvent(e);
          if (!e.defaultPrevented) {
            throw err;
          }
        }
        return promise.then((res) => {
          for (const item of res || []) {
            if (item.status !== "rejected") continue;
            handlePreloadError(item.reason);
          }
          return baseModule().catch(handlePreloadError);
        });
      };
      const mpegParserLoader = {
        parserType: "mpeg",
        extensions: [".mp2", ".mp3", ".m2a", ".aac", "aacp"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { MpegParser } = await module.import('./MpegParser-t3JjS_bv-DP4MVn8J.js');
            return { MpegParser };
          }, void 0 )).MpegParser(metadata, tokenizer, options);
        }
      };
      const apeParserLoader = {
        parserType: "apev2",
        extensions: [".ape"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { APEv2Parser: APEv2Parser2 } = await Promise.resolve().then(() => APEv2Parser$1);
            return { APEv2Parser: APEv2Parser2 };
          }, void 0 )).APEv2Parser(metadata, tokenizer, options);
        }
      };
      const asfParserLoader = {
        parserType: "asf",
        extensions: [".asf"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { AsfParser } = await module.import('./AsfParser-6pj_dtO9-DydKPSph.js');
            return { AsfParser };
          }, void 0 )).AsfParser(metadata, tokenizer, options);
        }
      };
      const dsdiffParserLoader = {
        parserType: "dsdiff",
        extensions: [".dff"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { DsdiffParser } = await module.import('./DsdiffParser-DlPzwyIy-BSxVmTfk.js');
            return { DsdiffParser };
          }, void 0 )).DsdiffParser(metadata, tokenizer, options);
        }
      };
      const aiffParserLoader = {
        parserType: "aiff",
        extensions: [".aif", "aiff", "aifc"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { AIFFParser } = await module.import('./AiffParser-Bl4qv0ID-Bs_4-QGD.js');
            return { AIFFParser };
          }, void 0 )).AIFFParser(metadata, tokenizer, options);
        }
      };
      const dsfParserLoader = {
        parserType: "dsf",
        extensions: [".dsf"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { DsfParser } = await module.import('./DsfParser-D_jwx0gH-BdUENliv.js');
            return { DsfParser };
          }, void 0 )).DsfParser(metadata, tokenizer, options);
        }
      };
      const flacParserLoader = {
        parserType: "flac",
        extensions: [".flac"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { FlacParser } = await module.import('./FlacParser-CxiwFQBW-BzeYKlyb.js');
            return { FlacParser };
          }, void 0 )).FlacParser(metadata, tokenizer, options);
        }
      };
      const matroskaParserLoader = {
        parserType: "matroska",
        extensions: [".mka", ".mkv", ".mk3d", ".mks", "webm"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { MatroskaParser } = await module.import('./MatroskaParser-DlYom4Kd-CpEy0LtJ.js');
            return { MatroskaParser };
          }, void 0 )).MatroskaParser(metadata, tokenizer, options);
        }
      };
      const mp4ParserLoader = {
        parserType: "mp4",
        extensions: [".mp4", ".m4a", ".m4b", ".m4pa", "m4v", "m4r", "3gp"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { MP4Parser } = await module.import('./MP4Parser-CJGrwS9Y-yroBH10s.js');
            return { MP4Parser };
          }, void 0 )).MP4Parser(metadata, tokenizer, options);
        }
      };
      const musepackParserLoader = {
        parserType: "musepack",
        extensions: [".mpc"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { MusepackParser } = await module.import('./MusepackParser-ImJ4EqDU-CBDf08G9.js');
            return { MusepackParser };
          }, void 0 )).MusepackParser(metadata, tokenizer, options);
        }
      };
      const oggParserLoader = {
        parserType: "ogg",
        extensions: [".ogg", ".ogv", ".oga", ".ogm", ".ogx", ".opus", ".spx"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { OggParser } = await module.import('./OggParser-BBZnDK-h-D6aAHGsc.js');
            return { OggParser };
          }, void 0 )).OggParser(metadata, tokenizer, options);
        }
      };
      const wavpackParserLoader = {
        parserType: "wavpack",
        extensions: [".wv", ".wvp"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { WavPackParser } = await module.import('./WavPackParser-CP3cSPHA-DUluwt_e.js');
            return { WavPackParser };
          }, void 0 )).WavPackParser(metadata, tokenizer, options);
        }
      };
      const riffParserLoader = {
        parserType: "riff",
        extensions: [".wav", "wave", ".bwf"],
        async load(metadata, tokenizer, options) {
          return new (await __vitePreload(async () => {
            const { WaveParser } = await module.import('./WaveParser-BOR6tCgw-CFnjS9DE.js');
            return { WaveParser };
          }, void 0 )).WaveParser(metadata, tokenizer, options);
        }
      };
      const debug$2 = initDebug("music-metadata:parser:factory");
      function parseHttpContentType(contentType$1) {
        const type = contentType.parse(contentType$1);
        const mime = parse_1(type.type);
        return {
          type: mime.type,
          subtype: mime.subtype,
          suffix: mime.suffix,
          parameters: type.parameters
        };
      }
      class ParserFactory {
        constructor() {
          this.parsers = [];
          [
            flacParserLoader,
            mpegParserLoader,
            apeParserLoader,
            mp4ParserLoader,
            matroskaParserLoader,
            riffParserLoader,
            oggParserLoader,
            asfParserLoader,
            aiffParserLoader,
            wavpackParserLoader,
            musepackParserLoader,
            dsfParserLoader,
            dsdiffParserLoader
          ].forEach((parser) => this.registerParser(parser));
        }
        registerParser(parser) {
          this.parsers.push(parser);
        }
        async parse(tokenizer, parserLoader, opts) {
          if (tokenizer.supportsRandomAccess()) {
            debug$2("tokenizer supports random-access, scanning for appending headers");
            await scanAppendingHeaders(tokenizer, opts);
          } else {
            debug$2("tokenizer does not support random-access, cannot scan for appending headers");
          }
          if (!parserLoader) {
            const buf = new Uint8Array(4100);
            if (tokenizer.fileInfo.mimeType) {
              parserLoader = this.findLoaderForType(getParserIdForMimeType(tokenizer.fileInfo.mimeType));
            }
            if (!parserLoader && tokenizer.fileInfo.path) {
              parserLoader = this.findLoaderForExtension(tokenizer.fileInfo.path);
            }
            if (!parserLoader) {
              debug$2("Guess parser on content...");
              await tokenizer.peekBuffer(buf, { mayBeLess: true });
              const guessedType = await fileTypeFromBuffer(buf);
              if (!guessedType || !guessedType.mime) {
                throw new CouldNotDetermineFileTypeError("Failed to determine audio format");
              }
              debug$2(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);
              parserLoader = this.findLoaderForType(getParserIdForMimeType(guessedType.mime));
              if (!parserLoader) {
                throw new UnsupportedFileTypeError(`Guessed MIME-type not supported: ${guessedType.mime}`);
              }
            }
          }
          debug$2(`Loading ${parserLoader.parserType} parser...`);
          const metadata = new MetadataCollector(opts);
          const parser = await parserLoader.load(metadata, tokenizer, opts ?? {});
          debug$2(`Parser ${parserLoader.parserType} loaded`);
          await parser.parse();
          return metadata.toCommonMetadata();
        }
        /**
         * @param filePath - Path, filename or extension to audio file
         * @return Parser submodule name
         */
        findLoaderForExtension(filePath) {
          if (!filePath)
            return;
          const extension = getExtension(filePath).toLocaleLowerCase() || filePath;
          return this.parsers.find((parser) => parser.extensions.indexOf(extension) !== -1);
        }
        findLoaderForType(moduleName) {
          return moduleName ? this.parsers.find((parser) => parser.parserType === moduleName) : void 0;
        }
      }
      function getExtension(fname) {
        const i = fname.lastIndexOf(".");
        return i === -1 ? "" : fname.slice(i);
      }
      function getParserIdForMimeType(httpContentType) {
        let mime;
        if (!httpContentType)
          return;
        try {
          mime = parseHttpContentType(httpContentType);
        } catch (err) {
          debug$2(`Invalid HTTP Content-Type header value: ${httpContentType}`);
          return;
        }
        const subType = mime.subtype.indexOf("x-") === 0 ? mime.subtype.substring(2) : mime.subtype;
        switch (mime.type) {
          case "audio":
            switch (subType) {
              case "mp3":
              case "mpeg":
                return "mpeg";
              case "aac":
              case "aacp":
                return "mpeg";
              case "flac":
                return "flac";
              case "ape":
              case "monkeys-audio":
                return "apev2";
              case "mp4":
              case "m4a":
                return "mp4";
              case "ogg":
              case "opus":
              case "speex":
                return "ogg";
              case "ms-wma":
              case "ms-wmv":
              case "ms-asf":
                return "asf";
              case "aiff":
              case "aif":
              case "aifc":
                return "aiff";
              case "vnd.wave":
              case "wav":
              case "wave":
                return "riff";
              case "wavpack":
                return "wavpack";
              case "musepack":
                return "musepack";
              case "matroska":
              case "webm":
                return "matroska";
              case "dsf":
                return "dsf";
              case "amr":
                return "amr";
            }
            break;
          case "video":
            switch (subType) {
              case "ms-asf":
              case "ms-wmv":
                return "asf";
              case "m4v":
              case "mp4":
                return "mp4";
              case "ogg":
                return "ogg";
              case "matroska":
              case "webm":
                return "matroska";
            }
            break;
          case "application":
            switch (subType) {
              case "vnd.ms-asf":
                return "asf";
              case "ogg":
                return "ogg";
            }
            break;
        }
      }
      class BasicParser {
        /**
         * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
         * @param {INativeMetadataCollector} metadata Output
         * @param {ITokenizer} tokenizer Input
         * @param {IOptions} options Parsing options
         */
        constructor(metadata, tokenizer, options) {
          this.metadata = metadata;
          this.tokenizer = tokenizer;
          this.options = options;
        }
      } exports("B", BasicParser);
      const validFourCC = /^[\x21-\x7e©][\x20-\x7e\x00()]{3}/;
      const FourCcToken = exports("F", {
        len: 4,
        get: (buf, off) => {
          const id = uint8ArrayToString(buf.slice(off, off + FourCcToken.len), "latin1");
          if (!id.match(validFourCC)) {
            throw new FieldDecodingError(`FourCC contains invalid characters: ${a2hex(id)} "${id}"`);
          }
          return id;
        },
        put: (buffer, offset, id) => {
          const str = stringToUint8Array(id);
          if (str.length !== 4)
            throw new InternalParserError("Invalid length");
          buffer.set(str, offset);
          return offset + 4;
        }
      });
      var DataType;
      (function(DataType2) {
        DataType2[DataType2["text_utf8"] = 0] = "text_utf8";
        DataType2[DataType2["binary"] = 1] = "binary";
        DataType2[DataType2["external_info"] = 2] = "external_info";
        DataType2[DataType2["reserved"] = 3] = "reserved";
      })(DataType || (DataType = {}));
      const DescriptorParser = {
        len: 52,
        get: (buf, off) => {
          return {
            // should equal 'MAC '
            ID: FourCcToken.get(buf, off),
            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
            version: UINT32_LE.get(buf, off + 4) / 1e3,
            // the number of descriptor bytes (allows later expansion of this header)
            descriptorBytes: UINT32_LE.get(buf, off + 8),
            // the number of header APE_HEADER bytes
            headerBytes: UINT32_LE.get(buf, off + 12),
            // the number of header APE_HEADER bytes
            seekTableBytes: UINT32_LE.get(buf, off + 16),
            // the number of header data bytes (from original file)
            headerDataBytes: UINT32_LE.get(buf, off + 20),
            // the number of bytes of APE frame data
            apeFrameDataBytes: UINT32_LE.get(buf, off + 24),
            // the high order number of APE frame data bytes
            apeFrameDataBytesHigh: UINT32_LE.get(buf, off + 28),
            // the terminating data of the file (not including tag data)
            terminatingDataBytes: UINT32_LE.get(buf, off + 32),
            // the MD5 hash of the file (see notes for usage... it's a little tricky)
            fileMD5: new Uint8ArrayType(16).get(buf, off + 36)
          };
        }
      };
      const Header = {
        len: 24,
        get: (buf, off) => {
          return {
            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
            compressionLevel: UINT16_LE.get(buf, off),
            // any format flags (for future use)
            formatFlags: UINT16_LE.get(buf, off + 2),
            // the number of audio blocks in one frame
            blocksPerFrame: UINT32_LE.get(buf, off + 4),
            // the number of audio blocks in the final frame
            finalFrameBlocks: UINT32_LE.get(buf, off + 8),
            // the total number of frames
            totalFrames: UINT32_LE.get(buf, off + 12),
            // the bits per sample (typically 16)
            bitsPerSample: UINT16_LE.get(buf, off + 16),
            // the number of channels (1 or 2)
            channel: UINT16_LE.get(buf, off + 18),
            // the sample rate (typically 44100)
            sampleRate: UINT32_LE.get(buf, off + 20)
          };
        }
      };
      const TagFooter = {
        len: 32,
        get: (buf, off) => {
          return {
            // should equal 'APETAGEX'
            ID: new StringType(8, "ascii").get(buf, off),
            // equals CURRENT_APE_TAG_VERSION
            version: UINT32_LE.get(buf, off + 8),
            // the complete size of the tag, including this footer (excludes header)
            size: UINT32_LE.get(buf, off + 12),
            // the number of fields in the tag
            fields: UINT32_LE.get(buf, off + 16),
            // reserved for later use (must be zero),
            flags: parseTagFlags(UINT32_LE.get(buf, off + 20))
          };
        }
      };
      const TagItemHeader = {
        len: 8,
        get: (buf, off) => {
          return {
            // Length of assigned value in bytes
            size: UINT32_LE.get(buf, off),
            // reserved for later use (must be zero),
            flags: parseTagFlags(UINT32_LE.get(buf, off + 4))
          };
        }
      };
      function parseTagFlags(flags) {
        return {
          containsHeader: isBitSet(flags, 31),
          containsFooter: isBitSet(flags, 30),
          isHeader: isBitSet(flags, 29),
          readOnly: isBitSet(flags, 0),
          dataType: (flags & 6) >> 1
        };
      }
      function isBitSet(num, bit) {
        return (num & 1 << bit) !== 0;
      }
      const debug$1 = initDebug("music-metadata:parser:APEv2");
      const tagFormat = "APEv2";
      const preamble = "APETAGEX";
      class ApeContentError extends makeUnexpectedFileContentError("APEv2") {
      }
      class APEv2Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.ape = {};
        }
        static tryParseApeHeader(metadata, tokenizer, options) {
          const apeParser = new APEv2Parser(metadata, tokenizer, options);
          return apeParser.tryParseApeHeader();
        }
        /**
         * Calculate the media file duration
         * @param ah ApeHeader
         * @return {number} duration in seconds
         */
        static calculateDuration(ah) {
          let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;
          duration += ah.finalFrameBlocks;
          return duration / ah.sampleRate;
        }
        /**
         * Calculates the APEv1 / APEv2 first field offset
         * @param tokenizer
         * @param offset
         */
        static async findApeFooterOffset(tokenizer, offset) {
          const apeBuf = new Uint8Array(TagFooter.len);
          const position = tokenizer.position;
          await tokenizer.readBuffer(apeBuf, { position: offset - TagFooter.len });
          tokenizer.setPosition(position);
          const tagFooter = TagFooter.get(apeBuf, 0);
          if (tagFooter.ID === "APETAGEX") {
            if (tagFooter.flags.isHeader) {
              debug$1(`APE Header found at offset=${offset - TagFooter.len}`);
            } else {
              debug$1(`APE Footer found at offset=${offset - TagFooter.len}`);
              offset -= tagFooter.size;
            }
            return { footer: tagFooter, offset };
          }
        }
        static parseTagFooter(metadata, buffer, options) {
          const footer2 = TagFooter.get(buffer, buffer.length - TagFooter.len);
          if (footer2.ID !== preamble)
            throw new ApeContentError("Unexpected APEv2 Footer ID preamble value");
          fromBuffer$1(buffer);
          const apeParser = new APEv2Parser(metadata, fromBuffer$1(buffer), options);
          return apeParser.parseTags(footer2);
        }
        /**
         * Parse APEv1 / APEv2 header if header signature found
         */
        async tryParseApeHeader() {
          if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < TagFooter.len) {
            debug$1("No APEv2 header found, end-of-file reached");
            return;
          }
          const footer2 = await this.tokenizer.peekToken(TagFooter);
          if (footer2.ID === preamble) {
            await this.tokenizer.ignore(TagFooter.len);
            return this.parseTags(footer2);
          }
          debug$1(`APEv2 header not found at offset=${this.tokenizer.position}`);
          if (this.tokenizer.fileInfo.size) {
            const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position;
            const buffer = new Uint8Array(remaining);
            await this.tokenizer.readBuffer(buffer);
            return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);
          }
        }
        async parse() {
          const descriptor = await this.tokenizer.readToken(DescriptorParser);
          if (descriptor.ID !== "MAC ")
            throw new ApeContentError("Unexpected descriptor ID");
          this.ape.descriptor = descriptor;
          const lenExp = descriptor.descriptorBytes - DescriptorParser.len;
          const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());
          await this.tokenizer.ignore(header.forwardBytes);
          return this.tryParseApeHeader();
        }
        async parseTags(footer2) {
          const keyBuffer = new Uint8Array(256);
          let bytesRemaining = footer2.size - TagFooter.len;
          debug$1(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);
          for (let i = 0; i < footer2.fields; i++) {
            if (bytesRemaining < TagItemHeader.len) {
              this.metadata.addWarning(`APEv2 Tag-header: ${footer2.fields - i} items remaining, but no more tag data to read.`);
              break;
            }
            const tagItemHeader = await this.tokenizer.readToken(TagItemHeader);
            bytesRemaining -= TagItemHeader.len + tagItemHeader.size;
            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });
            let zero = findZero(keyBuffer, 0, keyBuffer.length);
            const key = await this.tokenizer.readToken(new StringType(zero, "ascii"));
            await this.tokenizer.ignore(1);
            bytesRemaining -= key.length + 1;
            switch (tagItemHeader.flags.dataType) {
              case DataType.text_utf8: {
                const value2 = await this.tokenizer.readToken(new StringType(tagItemHeader.size, "utf8"));
                const values = value2.split(/\x00/g);
                await Promise.all(values.map((val) => this.metadata.addTag(tagFormat, key, val)));
                break;
              }
              case DataType.binary:
                if (this.options.skipCovers) {
                  await this.tokenizer.ignore(tagItemHeader.size);
                } else {
                  const picData = new Uint8Array(tagItemHeader.size);
                  await this.tokenizer.readBuffer(picData);
                  zero = findZero(picData, 0, picData.length);
                  const description = uint8ArrayToString(picData.slice(0, zero));
                  const data = picData.slice(zero + 1);
                  await this.metadata.addTag(tagFormat, key, {
                    description,
                    data
                  });
                }
                break;
              case DataType.external_info:
                debug$1(`Ignore external info ${key}`);
                await this.tokenizer.ignore(tagItemHeader.size);
                break;
              case DataType.reserved:
                debug$1(`Ignore external info ${key}`);
                this.metadata.addWarning(`APEv2 header declares a reserved datatype for "${key}"`);
                await this.tokenizer.ignore(tagItemHeader.size);
                break;
            }
          }
        }
        async parseDescriptorExpansion(lenExp) {
          await this.tokenizer.ignore(lenExp);
          return this.parseHeader();
        }
        async parseHeader() {
          const header = await this.tokenizer.readToken(Header);
          this.metadata.setFormat("lossless", true);
          this.metadata.setFormat("container", "Monkey's Audio");
          this.metadata.setFormat("bitsPerSample", header.bitsPerSample);
          this.metadata.setFormat("sampleRate", header.sampleRate);
          this.metadata.setFormat("numberOfChannels", header.channel);
          this.metadata.setFormat("duration", APEv2Parser.calculateDuration(header));
          if (!this.ape.descriptor) {
            throw new ApeContentError("Missing APE descriptor");
          }
          return {
            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes
          };
        }
      } exports("J", APEv2Parser);
      const APEv2Parser$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
        __proto__: null,
        APEv2Parser,
        ApeContentError
      }, Symbol.toStringTag, { value: "Module" }));
      const debug = initDebug("music-metadata:parser:ID3v1");
      const Genres = exports("H", [
        "Blues",
        "Classic Rock",
        "Country",
        "Dance",
        "Disco",
        "Funk",
        "Grunge",
        "Hip-Hop",
        "Jazz",
        "Metal",
        "New Age",
        "Oldies",
        "Other",
        "Pop",
        "R&B",
        "Rap",
        "Reggae",
        "Rock",
        "Techno",
        "Industrial",
        "Alternative",
        "Ska",
        "Death Metal",
        "Pranks",
        "Soundtrack",
        "Euro-Techno",
        "Ambient",
        "Trip-Hop",
        "Vocal",
        "Jazz+Funk",
        "Fusion",
        "Trance",
        "Classical",
        "Instrumental",
        "Acid",
        "House",
        "Game",
        "Sound Clip",
        "Gospel",
        "Noise",
        "Alt. Rock",
        "Bass",
        "Soul",
        "Punk",
        "Space",
        "Meditative",
        "Instrumental Pop",
        "Instrumental Rock",
        "Ethnic",
        "Gothic",
        "Darkwave",
        "Techno-Industrial",
        "Electronic",
        "Pop-Folk",
        "Eurodance",
        "Dream",
        "Southern Rock",
        "Comedy",
        "Cult",
        "Gangsta Rap",
        "Top 40",
        "Christian Rap",
        "Pop/Funk",
        "Jungle",
        "Native American",
        "Cabaret",
        "New Wave",
        "Psychedelic",
        "Rave",
        "Showtunes",
        "Trailer",
        "Lo-Fi",
        "Tribal",
        "Acid Punk",
        "Acid Jazz",
        "Polka",
        "Retro",
        "Musical",
        "Rock & Roll",
        "Hard Rock",
        "Folk",
        "Folk/Rock",
        "National Folk",
        "Swing",
        "Fast-Fusion",
        "Bebob",
        "Latin",
        "Revival",
        "Celtic",
        "Bluegrass",
        "Avantgarde",
        "Gothic Rock",
        "Progressive Rock",
        "Psychedelic Rock",
        "Symphonic Rock",
        "Slow Rock",
        "Big Band",
        "Chorus",
        "Easy Listening",
        "Acoustic",
        "Humour",
        "Speech",
        "Chanson",
        "Opera",
        "Chamber Music",
        "Sonata",
        "Symphony",
        "Booty Bass",
        "Primus",
        "Porn Groove",
        "Satire",
        "Slow Jam",
        "Club",
        "Tango",
        "Samba",
        "Folklore",
        "Ballad",
        "Power Ballad",
        "Rhythmic Soul",
        "Freestyle",
        "Duet",
        "Punk Rock",
        "Drum Solo",
        "A Cappella",
        "Euro-House",
        "Dance Hall",
        "Goa",
        "Drum & Bass",
        "Club-House",
        "Hardcore",
        "Terror",
        "Indie",
        "BritPop",
        "Negerpunk",
        "Polsk Punk",
        "Beat",
        "Christian Gangsta Rap",
        "Heavy Metal",
        "Black Metal",
        "Crossover",
        "Contemporary Christian",
        "Christian Rock",
        "Merengue",
        "Salsa",
        "Thrash Metal",
        "Anime",
        "JPop",
        "Synthpop",
        "Abstract",
        "Art Rock",
        "Baroque",
        "Bhangra",
        "Big Beat",
        "Breakbeat",
        "Chillout",
        "Downtempo",
        "Dub",
        "EBM",
        "Eclectic",
        "Electro",
        "Electroclash",
        "Emo",
        "Experimental",
        "Garage",
        "Global",
        "IDM",
        "Illbient",
        "Industro-Goth",
        "Jam Band",
        "Krautrock",
        "Leftfield",
        "Lounge",
        "Math Rock",
        "New Romantic",
        "Nu-Breakz",
        "Post-Punk",
        "Post-Rock",
        "Psytrance",
        "Shoegaze",
        "Space Rock",
        "Trop Rock",
        "World Music",
        "Neoclassical",
        "Audiobook",
        "Audio Theatre",
        "Neue Deutsche Welle",
        "Podcast",
        "Indie Rock",
        "G-Funk",
        "Dubstep",
        "Garage Rock",
        "Psybient"
      ]);
      const Iid3v1Token = {
        len: 128,
        /**
         * @param buf Buffer possibly holding the 128 bytes ID3v1.1 metadata header
         * @param off Offset in buffer in bytes
         * @returns ID3v1.1 header if first 3 bytes equals 'TAG', otherwise null is returned
         */
        get: (buf, off) => {
          const header = new Id3v1StringType(3).get(buf, off);
          return header === "TAG" ? {
            header,
            title: new Id3v1StringType(30).get(buf, off + 3),
            artist: new Id3v1StringType(30).get(buf, off + 33),
            album: new Id3v1StringType(30).get(buf, off + 63),
            year: new Id3v1StringType(4).get(buf, off + 93),
            comment: new Id3v1StringType(28).get(buf, off + 97),
            // ID3v1.1 separator for track
            zeroByte: UINT8.get(buf, off + 127),
            // track: ID3v1.1 field added by Michael Mutschler
            track: UINT8.get(buf, off + 126),
            genre: UINT8.get(buf, off + 127)
          } : null;
        }
      };
      class Id3v1StringType {
        constructor(len) {
          this.len = len;
          this.stringType = new StringType(len, "latin1");
        }
        get(buf, off) {
          let value2 = this.stringType.get(buf, off);
          value2 = trimRightNull(value2);
          value2 = value2.trim();
          return value2.length > 0 ? value2 : void 0;
        }
      }
      class ID3v1Parser extends BasicParser {
        constructor(metadata, tokenizer, options) {
          super(metadata, tokenizer, options);
          this.apeHeader = options.apeHeader;
        }
        static getGenre(genreIndex) {
          if (genreIndex < Genres.length) {
            return Genres[genreIndex];
          }
          return void 0;
        }
        async parse() {
          if (!this.tokenizer.fileInfo.size) {
            debug("Skip checking for ID3v1 because the file-size is unknown");
            return;
          }
          if (this.apeHeader) {
            this.tokenizer.ignore(this.apeHeader.offset - this.tokenizer.position);
            const apeParser = new APEv2Parser(this.metadata, this.tokenizer, this.options);
            await apeParser.parseTags(this.apeHeader.footer);
          }
          const offset = this.tokenizer.fileInfo.size - Iid3v1Token.len;
          if (this.tokenizer.position > offset) {
            debug("Already consumed the last 128 bytes");
            return;
          }
          const header = await this.tokenizer.readToken(Iid3v1Token, offset);
          if (header) {
            debug("ID3v1 header found at: pos=%s", this.tokenizer.fileInfo.size - Iid3v1Token.len);
            const props = ["title", "artist", "album", "comment", "track", "year"];
            for (const id of props) {
              if (header[id] && header[id] !== "")
                await this.addTag(id, header[id]);
            }
            const genre = ID3v1Parser.getGenre(header.genre);
            if (genre)
              await this.addTag("genre", genre);
          } else {
            debug("ID3v1 header not found at: pos=%s", this.tokenizer.fileInfo.size - Iid3v1Token.len);
          }
        }
        async addTag(id, value2) {
          await this.metadata.addTag("ID3v1", id, value2);
        }
      } exports("L", ID3v1Parser);
      async function hasID3v1Header(tokenizer) {
        if (tokenizer.fileInfo.size >= 128) {
          const tag2 = new Uint8Array(3);
          const position = tokenizer.position;
          await tokenizer.readBuffer(tag2, { position: tokenizer.fileInfo.size - 128 });
          tokenizer.setPosition(position);
          return new TextDecoder("latin1").decode(tag2) === "TAG";
        }
        return false;
      }
      const endTag2 = "LYRICS200";
      async function getLyricsHeaderLength(tokenizer) {
        const fileSize = tokenizer.fileInfo.size;
        if (fileSize >= 143) {
          const buf = new Uint8Array(15);
          const position = tokenizer.position;
          await tokenizer.readBuffer(buf, { position: fileSize - 143 });
          tokenizer.setPosition(position);
          const txt = new TextDecoder("latin1").decode(buf);
          const tag2 = txt.slice(6);
          if (tag2 === endTag2) {
            return Number.parseInt(txt.slice(0, 6), 10) + 15;
          }
        }
        return 0;
      }
      async function parseBlob(blob, options = {}) {
        const fileInfo = { mimeType: blob.type, size: blob.size };
        if (blob instanceof File) {
          fileInfo.path = blob.name;
        }
        return parseWebStream(blob.stream(), fileInfo, options);
      }
      async function parseWebStream(webStream, fileInfo, options = {}) {
        const tokenizer = fromWebStream$1(webStream, { fileInfo: typeof fileInfo === "string" ? { mimeType: fileInfo } : fileInfo });
        try {
          return await parseFromTokenizer(tokenizer, options);
        } finally {
          await tokenizer.close();
        }
      }
      function parseFromTokenizer(tokenizer, options) {
        const parserFactory = new ParserFactory();
        return parserFactory.parse(tokenizer, void 0, options);
      }
      async function scanAppendingHeaders(tokenizer, options = {}) {
        let apeOffset = tokenizer.fileInfo.size;
        if (await hasID3v1Header(tokenizer)) {
          apeOffset -= 128;
          const lyricsLen = await getLyricsHeaderLength(tokenizer);
          apeOffset -= lyricsLen;
        }
        options.apeHeader = await APEv2Parser.findApeFooterOffset(tokenizer, apeOffset);
      }
      const getQrKey = () => weapiRequest("/api/login/qrcode/unikey", {
        data: {
          noCheckToken: 1,
          type: 1
        }
      });
      const getQrCode = (key) => {
        const loginUrl = `https://music.163.com/login?codekey=${key}`;
        return generateQRCode(loginUrl);
      };
      const getQrStatus = (key) => weapiFetch("/api/login/qrcode/client/login", {
        data: {
          key,
          type: 1
        },
        originResponse: true
      });
      const getArtists = () => fetch(`${BASE_CDN_URL}top.json`).then((res) => res.json());
      const getArtists2 = () => fetch(`${BASE_CDN_URL}summary.json`).then((res) => res.json());
      const getCDNConfig = (artistId) => fetch(`${BASE_CDN_URL}${artistId}.json`).then((res) => res.json());
      const getSongInfoList = async (songIds) => {
        const chunkArr = chunkArray(songIds, 1e3);
        const proArr = chunkArr.map(async (chunk) => {
          return weapiRequest("/api/v3/song/detail", {
            data: {
              c: JSON.stringify(chunk.map((item) => ({ id: item })))
            }
          });
        });
        const allInfo = await Promise.all(proArr);
        return allInfo.flat();
      };
      const matchCloudSong = async (cloudSongId, id) => {
        if (cloudSongId != id && id > 0) {
          const res = await weapiRequest("/api/cloud/user/song/match", {
            data: {
              songId: cloudSongId,
              adjustSongId: id
            }
          });
          if (res.code != 200 || res.data.length < 1) {
            msgError(`歌曲： ${song.name} 匹配失败`);
            throw new Error(res.message || res.msg || "歌曲匹配失败");
          }
          return res;
        }
        return;
      };
      const uploadSong = async (song2) => {
        try {
          let res = await weapiRequest("/api/cloud/upload/check/v2", {
            data: {
              uploadType: 0,
              songs: JSON.stringify([
                {
                  md5: song2.md5,
                  songId: song2.id,
                  bitrate: song2.bitrate,
                  fileSize: song2.size
                }
              ])
            }
          });
          if (res.code != 200 || res.data.length < 1) {
            msgError(`资源检查失败,请检查歌曲：${song2.name}是否已存在！`);
            throw new Error(res.message || res.msg || "资源检查失败");
          }
          const cloudId = res.data[0].songId;
          if (res.data[0].upload == 1) {
            const importRes = await weapiRequest("/api/cloud/user/song/import", {
              data: {
                uploadType: 0,
                songs: JSON.stringify([
                  {
                    songId: cloudId,
                    bitrate: song2.bitrate,
                    song: song2.filename,
                    artist: song2.artists,
                    album: song2.album,
                    fileName: song2.filename
                  }
                ])
              }
            });
            if (importRes.code != 200 || importRes.data.successSongs.length < 1) {
              msgError(`歌曲： ${song2.name} 上传失败`);
              throw new Error(importRes.message || importRes.msg || "歌曲上传失败");
            }
            const cloudSongId = importRes.data.successSongs[0].song.songId;
            await matchCloudSong(cloudSongId, song2.id);
            return {
              code: 200,
              msg: "歌曲上传成功",
              data: { song: song2 }
            };
          } else {
            const tokenRes = await weapiRequest("/api/nos/token/alloc", {
              data: {
                filename: song2.filename,
                length: song2.size,
                ext: song2.ext,
                md5: song2.md5,
                type: "audio",
                bucket: "jd-musicrep-privatecloud-audio-public",
                local: false,
                nos_product: 3
              }
            });
            if (tokenRes.code != 200) {
              msgError("获取上传token失败");
              throw new Error(tokenRes.message || tokenRes.msg || "获取上传token失败");
            }
            song2.resourceId = tokenRes.result.resourceId;
            const uploadRes = await weapiRequest("/api/upload/cloud/info/v2", {
              data: {
                token: tokenRes.result.token,
                objectKey: tokenRes.result.objectKey,
                resourceId: tokenRes.result.resourceId,
                // ...tokenRes.result,
                expireTime: Date.now() + 6e4,
                fileSize: song2.size,
                md5: song2.md5,
                songid: cloudId,
                filename: song2.filename,
                song: song2.name,
                album: song2.album,
                artist: song2.artists,
                bitrate: String(song2.bitrate || 128),
                resourceId: song2.resourceId
              }
            });
            if (uploadRes.code != 200) {
              msgError(`歌曲： ${song2.name} 上传失败`);
            }
            const pubRes = await weapiRequest("/api/cloud/pub/v2", {
              data: {
                songid: uploadRes.songId
              }
            });
            if (![200, 201].includes(pubRes.code)) {
              msgError(`歌曲： ${song2.name} 发布失败`);
              throw new Error(pubRes.message || pubRes.msg || "歌曲发布失败");
            }
            const cloudSongId = pubRes.privateCloud.songId;
            await matchCloudSong(cloudSongId, song2.id);
            return {
              code: 200,
              msg: "歌曲上传成功",
              data: { song: song2 }
            };
          }
        } catch (error) {
          console.log("error", error);
          throw error;
        }
      };
      const getCloudData = (limit = 200, offset = 0) => weapiRequest("/api/v1/cloud/get", {
        data: {
          limit,
          offset
        }
      });
      const deleteCloudSong = (songIds) => weapiRequest("/api/cloud/del", {
        data: {
          songIds
        }
      });
      const getPlaylistList = (uid = getGUser().userId, limit = 1001, offset = 0) => weapiRequest("/api/user/playlist", {
        data: {
          limit,
          offset,
          uid
        }
      });
      const createPlaylist = (name2) => weapiRequest("/api/playlist/create", {
        data: {
          name: name2
        }
      });
      const deletePlaylist = (pid) => weapiRequest("/api/playlist/delete", {
        data: {
          pid
        }
      });
      const addSongToPlaylist = (pid, trackIds) => weapiRequest("/api/playlist/manipulate/tracks", {
        data: {
          pid,
          // 歌单id
          trackIds,
          // 歌曲 id 数组
          op: "add"
          // 操作类型
        }
      });
      const getAlbumSongList = (id) => weapiRequest(`/api/v1/album/${id}`, {
        data: {}
      });
      const getSongUrl = (ids, encodeType = "flac", level = QUALITY_LEVELS.无损) => weapiRequest("/api/song/enhance/player/url/v1", {
        data: { ids, level, encodeType }
      });
      const getArtistTopSongList = (id) => weapiRequest("/api/artist/top/song", {
        data: {
          id,
          limit: 1e3,
          offset: 0
        }
      });
      const getArtistAllSongList = (id) => weapiRequest("/api/v1/artist/songs", {
        data: {
          id,
          private_cloud: "true",
          work_type: 1,
          order: "hot",
          //hot,time
          limit: 1e4,
          offset: 0
        }
      });
      const getArtistAlbumList = async (id, limit = 1e3, offset = 0) => {
        const res = await fetch(`/artist/album?id=${id}&limit=${limit}&offset=${offset}`);
        console.log("res", res);
        const html = await res.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        const albumList = Array.from(doc.querySelectorAll("#m-song-module li"));
        return albumList.map((item) => {
          const cover = item.querySelector("img").getAttribute("src");
          const id2 = item.querySelector('a[title="播放"]').getAttribute("data-res-id");
          const name2 = item.querySelector("p.dec a.tit").textContent;
          const time = item.querySelector("span.s-fc3").textContent;
          return { cover, id: id2, name: name2, time };
        });
      };
      const uploadLocalSong = async (file) => {
        try {
          const ext = file.name.split(".").pop();
          const fileMd5 = await getFileMD5(file);
          const bitrate = 999e3;
          const filename = file.name.replace("." + ext, "").replace(/\s/g, "").replace(/\./g, "_");
          const checkRes = await weapiRequest("/api/cloud/upload/check", {
            data: {
              ext: "",
              bitrate: String(bitrate),
              md5: fileMd5,
              length: file.size,
              songId: "0",
              version: 1
            }
          });
          console.log("checkRes", checkRes);
          if (checkRes.code != 200) {
            msgError("文件检查失败");
          }
          const { needUpload, songId: songId2 } = checkRes;
          const tokenRes = await weapiRequest("/api/nos/token/alloc", {
            data: {
              bucket: "",
              ext,
              filename,
              local: false,
              nos_product: 3,
              type: "audio",
              md5: fileMd5
            }
          });
          console.log("tokenRes", tokenRes);
          if (tokenRes.code != 200) {
            msgError("获取上传token失败");
          }
          const { bucket, docId, objectKey, outerUrl, resourceId, token } = tokenRes.result;
          const metadata = await parseBlob(file);
          console.log("metadata", metadata);
          const { album, artist: artist2, artists, title: title2 } = metadata.common || {};
          const uploadInfoRes = await weapiRequest("/api/upload/cloud/info/v2", {
            data: {
              md5: fileMd5,
              songid: songId2,
              filename,
              song: title2 || filename,
              album: album || "未知专辑",
              artist: artist2 || artists.join(",") || "未知歌手",
              bitrate: String(bitrate),
              resourceId
            }
          });
          console.log("uploadInfoRes", uploadInfoRes);
          if (uploadInfoRes.code != 200) {
            msgError("获取上传信息失败");
          }
          const pubRes = await weapiRequest("/api/cloud/pub/v2", {
            data: {
              songid: uploadInfoRes.songId
            }
          });
          console.log("pubRes", pubRes);
          if (![200, 201].includes(pubRes.code)) {
            msgError(`歌曲： ${song.name} 发布失败`);
          }
          const { songName: songName2, bitrate: realBitrate, fileSize } = pubRes.privateCloud;
          return {
            id: uploadInfoRes.songId,
            size: fileSize,
            md5: fileMd5,
            name: songName2,
            ext
          };
        } catch (error) {
          console.log("error", error);
        }
      };
      const select = "_select_10bds_21";
      const tag = "_tag_10bds_34";
      const divider$2 = "_divider_10bds_69";
      const label$1 = "_label_10bds_86";
      const value$1 = "_value_10bds_91";
      const size$1 = "_size_10bds_66";
      const percentage = "_percentage_10bds_112";
      const name = "_name_10bds_137";
      const artist = "_artist_10bds_141";
      const uploadProgressModal = "_uploadProgressModal_10bds_147";
      const progressContent = "_progressContent_10bds_150";
      const progressInfo = "_progressInfo_10bds_156";
      const detail = "_detail_10bds_166";
      const statsContainer = "_statsContainer_10bds_171";
      const statsItem = "_statsItem_10bds_179";
      const failedList = "_failedList_10bds_192";
      const failedTitle = "_failedTitle_10bds_195";
      const failedItem = "_failedItem_10bds_201";
      const songName$1 = "_songName_10bds_207";
      const errorMsg = "_errorMsg_10bds_212";
      const uploadModal = "_uploadModal_10bds_217";
      const progressSection = "_progressSection_10bds_221";
      const count$1 = "_count_10bds_240";
      const statsTag = "_statsTag_10bds_255";
      const songList = "_songList_10bds_260";
      const songItem$1 = "_songItem_10bds_276";
      const songInfo$1 = "_songInfo_10bds_291";
      const artistName = "_artistName_10bds_305";
      const styles$5 = {
        "quick-upload-tabs": "_quick-upload-tabs_10bds_1",
        select,
        "option-label": "_option-label_10bds_24",
        "singer-name": "_singer-name_10bds_31",
        "tag-group": "_tag-group_10bds_34",
        tag,
        "singer-choose": "_singer-choose_10bds_38",
        "singer-choose-form": "_singer-choose-form_10bds_38",
        "btn-group": "_btn-group_10bds_44",
        "upload-list": "_upload-list_10bds_49",
        "upload-footer": "_upload-footer_10bds_53",
        "upload-stats": "_upload-stats_10bds_61",
        "size-text": "_size-text_10bds_66",
        divider: divider$2,
        "upload-confirm": "_upload-confirm_10bds_74",
        "confirm-item": "_confirm-item_10bds_78",
        label: label$1,
        value: value$1,
        size: size$1,
        "upload-progress": "_upload-progress_10bds_101",
        "progress-header": "_progress-header_10bds_101",
        "progress-info": "_progress-info_10bds_108",
        percentage,
        "progress-list": "_progress-list_10bds_117",
        "progress-item": "_progress-item_10bds_122",
        "song-info": "_song-info_10bds_132",
        name,
        artist,
        uploadProgressModal,
        progressContent,
        progressInfo,
        detail,
        statsContainer,
        statsItem,
        failedList,
        failedTitle,
        failedItem,
        songName: songName$1,
        errorMsg,
        uploadModal,
        progressSection,
        count: count$1,
        statsTag,
        songList,
        songItem: songItem$1,
        songInfo: songInfo$1,
        artistName
      };
      function SingerChoose({ singerList, onChoose, loading }) {
        const renderSingerList = useMemo(() => {
          return singerList.map((item) => {
            const { id, name: name2, count: count2, size: size2, sizeDesc } = item;
            return {
              ...item,
              label: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["option-label"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5["singer-name"], children: name2 }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["tag-group"], children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Tag, { color: "blue", className: styles$5["tag"], children: [
                    count2,
                    "首"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "green", className: styles$5["tag"], children: sizeDesc })
                ] })
              ] }),
              value: id
            };
          });
        }, [singerList]);
        const [formRef] = Form.useForm();
        const handleChoose = (values) => {
          const { singer } = values;
          onChoose([...singer]);
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["singer-choose"], children: loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spin, { tip: "正在加载中" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Form,
          {
            form: formRef,
            onFinish: handleChoose,
            className: styles$5["singer-choose-form"],
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { name: "singer", label: "歌手", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select,
                {
                  mode: "multiple",
                  placeholder: "请选择歌手",
                  allowClear: true,
                  className: styles$5["select"],
                  filterOption: (input, option) => {
                    var _a;
                    return ((_a = option.name) == null ? void 0 : _a.toLowerCase().indexOf(input.toLowerCase())) >= 0;
                  },
                  options: renderSingerList,
                  getPopupContainer: (trigger) => trigger.parentNode
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { style: { marginBottom: 0 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["btn-group"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", htmlType: "submit", children: "选择" }) }) })
            ]
          }
        ) });
      }
      const SearchForm$1 = ({ onSearch, songList: songList2 }) => {
        const [form] = Form.useForm();
        const getUniqueOptions = (key) => {
          const uniqueList = uniqueArrayByKey(songList2, key);
          return uniqueList.map((item) => ({
            label: item[key],
            value: item[key]
          }));
        };
        const handleSearch = () => {
          const values = form.getFieldsValue();
          onSearch(values);
        };
        const handleReset = () => {
          form.resetFields();
          onSearch({});
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { form, style: { marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { wrap: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { name: "name", style: { marginBottom: 0, minWidth: 200 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Select,
            {
              mode: "multiple",
              allowClear: true,
              showSearch: true,
              placeholder: "歌名",
              maxTagCount: "responsive",
              options: getUniqueOptions("name"),
              filterOption: (input, option) => ((option == null ? void 0 : option.label) ?? "").toLowerCase().includes(input.toLowerCase())
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { name: "artists", style: { marginBottom: 0, minWidth: 200 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Select,
            {
              mode: "multiple",
              allowClear: true,
              showSearch: true,
              placeholder: "歌手",
              maxTagCount: "responsive",
              options: getUniqueOptions("artists"),
              filterOption: (input, option) => ((option == null ? void 0 : option.label) ?? "").toLowerCase().includes(input.toLowerCase())
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { name: "album", style: { marginBottom: 0, minWidth: 200 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Select,
            {
              mode: "multiple",
              allowClear: true,
              showSearch: true,
              placeholder: "专辑",
              maxTagCount: "responsive",
              options: getUniqueOptions("album"),
              filterOption: (input, option) => ((option == null ? void 0 : option.label) ?? "").toLowerCase().includes(input.toLowerCase())
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleSearch, children: "搜索" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleReset, children: "重置" })
        ] }) });
      };
      const UploadProgress = forwardRef(
        ({ uploadedList, total, uploadFailedSongList, onClose }, ref) => {
          const [visible, setVisible] = useState(false);
          const open = () => setVisible(true);
          const close = () => {
            setVisible(false);
            onClose == null ? void 0 : onClose();
          };
          const reset = () => {
          };
          useImperativeHandle(ref, () => ({
            open,
            close,
            reset
          }));
          const uploadedCount = uploadedList.length;
          const failedCount = uploadFailedSongList.length;
          const percent = Math.floor((uploadedCount + failedCount) / total * 100);
          const isCompleted = uploadedCount + failedCount === total;
          const songListRef = useRef(null);
          useEffect(() => {
            let timeId;
            if (visible) {
              timeId = setInterval(() => {
                var _a;
                (_a = songListRef.current) == null ? void 0 : _a.scrollTo({
                  top: songListRef.current.scrollHeight,
                  behavior: "smooth"
                });
              }, 500);
            }
            return () => {
              clearInterval(timeId);
            };
          }, [visible]);
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Modal,
            {
              title: "上传进度",
              open: visible,
              onCancel: close,
              width: 520,
              maskClosable: false,
              footer: null,
              centered: true,
              className: styles$5.uploadModal,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.progressSection, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Progress,
                    {
                      type: "circle",
                      percent,
                      status: isCompleted ? failedCount > 0 ? "exception" : "success" : "active",
                      format: () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.progressInfo, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.percentage, children: [
                          percent,
                          "%"
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.count, children: [
                          uploadedCount + failedCount,
                          "/",
                          total
                        ] })
                      ] })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.statsContainer, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.statsItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tag, { color: "success", className: styles$5.statsTag, children: [
                      "成功：",
                      uploadedCount
                    ] }) }),
                    failedCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5.statsItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tag, { color: "error", className: styles$5.statsTag, children: [
                      "失败：",
                      failedCount
                    ] }) })
                  ] })
                ] }),
                (uploadedList.length > 0 || uploadFailedSongList.length > 0) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.songList, ref: songListRef, children: [
                  uploadFailedSongList.map((song2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.songItem, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.songInfo, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.songName, children: song2.name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.artistName, children: [
                        "- ",
                        song2.artists
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "error", children: "上传失败" })
                  ] }, song2.id)),
                  uploadedList.map((song2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.songItem, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.songInfo, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.songName, children: song2.name }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.artistName, children: [
                        "- ",
                        song2.artists
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "success", children: "已上传" })
                  ] }, song2.id))
                ] })
              ]
            }
          );
        }
      );
      const UploadStats = memo(({ selectedRows, filteredSongList }) => {
        const selectedSize = selectedRows.reduce((acc, cur) => acc + cur.size, 0);
        const totalSize = filteredSongList.reduce((acc, cur) => acc + cur.size, 0);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["upload-stats"], children: [
          "已选择",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Tag, { color: "blue", style: { margin: 0 }, children: [
            selectedRows.length,
            " 首"
          ] }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5["size-text"], children: +selectedSize && formatFileSize(selectedSize) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.divider, children: "/" }),
          "共",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Tag, { color: "green", style: { margin: 0 }, children: [
            filteredSongList.length,
            " 首"
          ] }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5["size-text"], children: formatFileSize(totalSize) })
        ] });
      });
      UploadStats.displayName = "UploadStats";
      function UploadList({ singerList }) {
        const [songList2, setSongList] = useState([]);
        const [loading, setLoading] = useState(false);
        const getSongList = async (ids) => {
          try {
            setLoading(true);
            if (!(ids == null ? void 0 : ids.length)) return message.error("请先选择歌手");
            const proArr = ids.map(async (id) => {
              const res = await getCDNConfig(id);
              return res.data;
            });
            let allConfig = await Promise.all(proArr);
            allConfig = allConfig.flat();
            const allConfigMap = Object.fromEntries(
              allConfig.map((item) => [item.id, item])
            );
            console.log("allConfig", allConfig);
            const allInfo = await getSongInfoList(allConfig.map((item) => item.id));
            const songList22 = [];
            allInfo.map(({ privileges, songs: songs2 }) => {
              privileges.forEach((p2) => {
                var _a;
                const otherInfo = allConfigMap[p2.id];
                const defaultItem = {
                  ...otherInfo,
                  id: p2.id,
                  name: "未知",
                  album: "未知",
                  albumid: 0,
                  artists: "未知",
                  tns: "",
                  //翻译
                  dt: formatDuration(0),
                  filename: "未知." + (otherInfo == null ? void 0 : otherInfo.ext),
                  picUrl: "http://p4.music.126.net/UeTuwE7pvjBpypWLudqukA==/3132508627578625.jpg",
                  isNoCopyright: p2.st < 0,
                  isVIP: false,
                  isPay: false,
                  uploaded: p2.cs,
                  needMatch: otherInfo.name == void 0
                };
                const songsMap = Object.fromEntries(songs2.map((s) => [s.id, s]));
                const song2 = songsMap[p2.id];
                if (song2) {
                  Object.assign(defaultItem, song2, {
                    album: getAlbumTextInSongDetail(song2),
                    artists: getArtistTextInSongDetail(song2),
                    dt: formatDuration(song2.dt),
                    filename: `${getArtistTextInSongDetail(song2)} - ${song2.name}.${otherInfo.ext}`,
                    picUrl: ((_a = song2.al) == null ? void 0 : _a.picUrl) || "http://p4.music.126.net/UeTuwE7pvjBpypWLudqukA==/3132508627578625.jpg",
                    isVIP: song2.fee === 1,
                    isPay: song2.fee === 4
                  });
                }
                if (otherInfo.name) {
                  defaultItem.name = otherInfo.name;
                  defaultItem.album = otherInfo.al;
                  defaultItem.artists = otherInfo.ar;
                  defaultItem.filename = `${defaultItem.artists} - ${defaultItem.name}.${otherInfo.ext}`;
                }
                songList22.push(defaultItem);
              });
            });
            setSongList(songList22);
            setFilteredSongList(songList22);
          } catch (error) {
            console.log("error", error);
            message.error("获取歌曲信息失败", error.message);
          } finally {
            setLoading(false);
          }
        };
        useEffect(() => {
          getSongList(singerList);
        }, [singerList]);
        const [filteredSongList, setFilteredSongList] = useState([]);
        const handleSearch = (values) => {
          const { name: name2, artists, album } = values;
          const filtered = songList2.filter((song2) => {
            const nameMatch = !(name2 == null ? void 0 : name2.length) || name2.some((n2) => song2.name.toLowerCase().includes(n2.toLowerCase()));
            const artistMatch = !(artists == null ? void 0 : artists.length) || artists.some(
              (a) => song2.artists.toLowerCase().includes(a.toLowerCase())
            );
            const albumMatch = !(album == null ? void 0 : album.length) || album.some((a) => song2.album.toLowerCase().includes(a.toLowerCase()));
            return nameMatch && artistMatch && albumMatch;
          });
          setFilteredSongList(filtered);
        };
        const [selectedRows, setSelectedRows] = useState([]);
        const rowSelection = {
          type: "checkbox",
          fixed: true,
          getCheckboxProps: (record) => ({
            disabled: record.uploaded
          }),
          onChange: (selectedRowKeys, selectedRows2) => {
            setSelectedRows(selectedRows2);
          }
        };
        const handleUpload = async (record) => {
          try {
            setFilteredSongList((songList22) => {
              return songList22.map((song2) => {
                if (song2.id === record.id) song2.uploading = true;
                return song2;
              });
            });
            const res = await uploadSong(record);
            msgSuccess("上传成功");
            getSongList(singerList);
          } catch (error) {
            console.log("error", error);
          } finally {
            setFilteredSongList((songList22) => {
              return songList22.map((song2) => {
                if (song2.id === record.id) song2.uploading = false;
                return song2;
              });
            });
          }
        };
        const columns = [
          // 上传状态
          {
            title: "上传状态",
            dataIndex: "uploaded",
            key: "uploaded",
            width: 140,
            align: "center",
            filters: [
              { text: "已上传", value: true },
              { text: "未上传", value: false }
            ],
            onFilter: (value2, record) => record.uploaded === value2,
            defaultFilterValue: [false],
            render: (_, record) => {
              if (record.uploaded) return /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "success", children: "已上传" });
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  size: "small",
                  onClick: () => handleUpload(record),
                  loading: record.uploading,
                  children: "上传"
                }
              );
            }
          },
          {
            title: "歌曲",
            dataIndex: "name",
            key: "name",
            width: 200,
            sorter: (a, b) => {
              var _a;
              return (_a = a.name) == null ? void 0 : _a.localeCompare(b.name);
            },
            sortDirections: ["ascend", "descend"],
            render: (text2, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  src: record.picUrl,
                  alt: text2,
                  style: { width: "40px", height: "40px", borderRadius: "4px" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: text2 }),
                record.tns && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#666", fontSize: "12px" }, children: record.tns })
              ] })
            ] })
          },
          {
            title: "艺术家",
            dataIndex: "artists",
            key: "artists",
            width: 180,
            sorter: (a, b) => {
              var _a;
              return (_a = a.artists) == null ? void 0 : _a.localeCompare(b.artists);
            },
            sortDirections: ["ascend", "descend"],
            ellipsis: true
          },
          {
            title: "专辑",
            dataIndex: "album",
            key: "album",
            width: 160,
            sorter: (a, b) => {
              var _a;
              return (_a = a.album) == null ? void 0 : _a.localeCompare(b.album);
            },
            sortDirections: ["ascend", "descend"],
            defaultSortOrder: "descend",
            ellipsis: true
          },
          {
            title: "时长",
            dataIndex: "dt",
            key: "dt",
            width: 80,
            sorter: (a, b) => {
              var _a;
              return (_a = a.dt) == null ? void 0 : _a.localeCompare(b.dt);
            },
            sortDirections: ["ascend", "descend"]
          },
          {
            title: "音质",
            key: "quality",
            width: 100,
            render: (_, record) => {
              var _a;
              const quality = [];
              if (record.sq) quality.push("无损");
              if (((_a = record.h) == null ? void 0 : _a.br) >= 32e4) quality.push("320K");
              return quality.join(" / ") || "标准";
            }
          },
          {
            title: "备注",
            key: "status",
            width: 120,
            render: (_, record) => {
              if (record.isNoCopyright) return /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "error", children: "无版权" });
              if (record.isVIP) return /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "warning", children: "VIP" });
              if (record.isPay) return /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "success", children: "付费" });
              if (record.uploaded) return /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "processing", children: "已上传" });
            }
          },
          // 歌曲大小
          {
            title: "歌曲大小",
            dataIndex: "size",
            key: "size",
            width: 120,
            render: (size2) => formatFileSize(size2)
          },
          // 歌曲后缀
          {
            title: "歌曲后缀",
            dataIndex: "ext",
            key: "ext",
            width: 100,
            render: (ext) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: "blue", children: ext })
          }
        ];
        const handleTableChange = (pagination, filters, sorter) => {
          setFilteredSongList((songList22) => {
            return songList22.sort((a, b) => {
              var _a;
              const order = sorter.order === "ascend" ? 1 : -1;
              return order * ((_a = a[sorter.columnKey]) == null ? void 0 : _a.localeCompare(b[sorter.columnKey]));
            });
          });
        };
        const uploadProgressRef = useRef(null);
        const [uploadedSongList, setUploadedSongList] = useState([]);
        const [uploadFailedSongList, setUploadFailedSongList] = useState([]);
        const [toUploadingSongList, setToUploadingSongList] = useState([]);
        const [uploading, setUploading] = useState(false);
        const resetData = () => {
          setUploadedSongList([]);
          setToUploadingSongList([]);
          setUploadFailedSongList([]);
        };
        const handleBatchUpload = async (songs2) => {
          var _a;
          try {
            if (uploading) return;
            resetData();
            setUploading(true);
            console.log("将要批量上传的选中的歌曲", songs2);
            const uploadSongList = filteredSongList.filter((song2) => !song2.uploaded);
            console.log("uploadSongList", uploadSongList);
            setToUploadingSongList(uploadSongList);
            await UploadConfirm({
              total: songs2.length,
              uploaded: 0,
              toUpload: uploadSongList
            });
            if (!uploadSongList.length) return msgError("没有可上传的歌曲");
            (_a = uploadProgressRef.current) == null ? void 0 : _a.open();
            const tasks = uploadSongList.map((song2) => async () => {
              try {
                const res = await uploadSong(song2);
                song2.uploaded = true;
                setUploadedSongList((list) => [...list, song2]);
                return res;
              } catch (error) {
                song2.uploaded = true;
                setUploadFailedSongList((list) => [...list, song2]);
                return error;
              }
            });
            const results = await promiseLimit(tasks);
            getSongList(singerList);
            const successCount = results.filter((r) => !(r instanceof Error)).length;
            const failedCount = results.length - successCount;
            msgSuccess(`上传完成: 成功${successCount}首，失败${failedCount}首`);
          } catch (error) {
            console.log("error", error);
          } finally {
            setUploading(false);
          }
        };
        const handleUploadAll = async () => {
          handleBatchUpload(filteredSongList);
        };
        const handleUploadSelected = async () => {
          handleBatchUpload(selectedRows);
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          (singerList == null ? void 0 : singerList.length) ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["upload-list"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SearchForm$1, { onSearch: handleSearch, songList: songList2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Table,
              {
                rowSelection,
                dataSource: filteredSongList,
                columns,
                scroll: { y: 400, x: 1e3 },
                size: "small",
                loading,
                rowKey: ({ artists, id, name: name2 }) => name2 + artists + id,
                onChange: handleTableChange
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["upload-footer"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                UploadStats,
                {
                  selectedRows,
                  filteredSongList
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  onClick: () => handleUploadSelected(),
                  disabled: !selectedRows.length,
                  loading: uploading,
                  children: "批量上传"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  onClick: () => handleUploadAll(),
                  loading: uploading,
                  children: "全部上传"
                }
              )
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Empty,
            {
              description: "请先选择歌手",
              style: {
                height: 400,
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            UploadProgress,
            {
              ref: uploadProgressRef,
              total: toUploadingSongList.length,
              uploadedList: uploadedSongList,
              uploadFailedSongList
            }
          )
        ] });
      }
      const UploadConfirm = ({ total, uploaded, toUpload }) => {
        return confirm(
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["upload-confirm"], children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["confirm-item"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.label, children: "总计歌曲：" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.value, children: [
                total,
                " 首"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["confirm-item"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.label, children: "已上传：" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.value, children: [
                uploaded,
                " 首"
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["confirm-item"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$5.label, children: "待上传：" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.value, children: [
                toUpload.length,
                " 首",
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$5.size, children: [
                  "（",
                  formatFileSize(toUpload.reduce((acc, cur) => acc + cur.size, 0)),
                  "）"
                ] })
              ] })
            ] })
          ] }),
          "上传歌曲"
        );
      };
      const { TabPane } = Tabs;
      function QuickUpload(props, ref) {
        const [visible, setVisible] = useState(false);
        const open = () => {
          reset();
          getSingerList();
          setVisible(true);
        };
        const close = () => setVisible(false);
        const reset = () => {
          setSingerList([]);
        };
        const [currentTab, setCurrentTab] = useState("1");
        const [singerList, setSingerList] = useState([]);
        const [loading, setLoading] = useState(false);
        const getSingerList = async () => {
          try {
            setLoading(true);
            const res = await getArtists();
            const res2 = await getArtists2();
            console.log("res2", res2);
            const list = [...new Map([...res2, ...res].map((item) => [item.id, item])).values()];
            console.log("list", list);
            setSingerList(list);
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        const [chooseList, setChooseList] = useState([]);
        const handleChoose = (value2) => {
          console.log(value2);
          setChooseList(value2);
          setCurrentTab("2");
        };
        useImperativeHandle(ref, () => ({
          open,
          close,
          reset
        }));
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            title: "云盘快速上传",
            width: 900,
            centered: true,
            open: visible,
            footer: null,
            onCancel: close,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Tabs,
              {
                defaultActiveKey: "1",
                activeKey: currentTab,
                className: styles$5["quick-upload-tabs"],
                onChange: (key) => setCurrentTab(key),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabPane,
                    {
                      tab: "歌曲选择",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        SingerChoose,
                        {
                          singerList,
                          loading,
                          onChoose: handleChoose
                        }
                      )
                    },
                    "1"
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TabPane,
                    {
                      tab: "上传列表",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(UploadList, { singerList: chooseList })
                    },
                    "2"
                  )
                ]
              }
            )
          }
        );
      }
      const QuickUpload$1 = forwardRef(QuickUpload);
      const QualityUpgrade = forwardRef((props, ref) => {
        const [visible, setVisible] = useState(false);
        const open = () => setVisible(true);
        const close = () => setVisible(false);
        const reset = () => {
        };
        useImperativeHandle(ref, () => ({
          open,
          close,
          reset
        }));
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            title: "云盘音质提升",
            open: visible,
            onCancel: close,
            width: 800,
            footer: null
          }
        );
      });
      const dragger = "_dragger_ad6cg_12";
      const divider$1 = "_divider_ad6cg_56";
      const styles$4 = {
        "local-upload": "_local-upload_ad6cg_1",
        "upload-section": "_upload-section_ad6cg_6",
        dragger,
        "upload-icon": "_upload-icon_ad6cg_26",
        "upload-text": "_upload-text_ad6cg_30",
        "upload-hint": "_upload-hint_ad6cg_34",
        "file-list": "_file-list_ad6cg_39",
        "upload-stats": "_upload-stats_ad6cg_49",
        "size-text": "_size-text_ad6cg_53",
        divider: divider$1
      };
      const { Dragger } = Upload;
      const LocalUpload = forwardRef((props, ref) => {
        const [visible, setVisible] = useState(false);
        const [fileList, setFileList] = useState([]);
        const open = () => setVisible(true);
        const close = () => setVisible(false);
        const reset = () => setFileList([]);
        useImperativeHandle(ref, () => ({
          open,
          close,
          reset
        }));
        const [loading, setLoading] = useState(false);
        const handleUpload = async () => {
          try {
            setLoading(true);
            const uploadPromises = fileList.map((file) => async () => {
              if (file.status === "done") {
                return;
              }
              file.status = "uploading";
              const res2 = await uploadLocalSong(file);
              file.status = "done";
              setFileList((prev) => [...prev]);
              return res2;
            });
            const res = await promiseLimit(uploadPromises, 5);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        const columns = [
          {
            title: "文件名",
            dataIndex: "name",
            key: "name"
          },
          {
            title: "大小",
            dataIndex: "size",
            key: "size",
            render: (size2) => `${(size2 / 1024 / 1024).toFixed(2)} MB`
          },
          {
            title: "状态",
            dataIndex: "status",
            key: "status",
            render: (status, record) => {
              if (status === "done") {
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Progress,
                  {
                    percent: 100,
                    size: "small",
                    status: "success"
                  }
                );
              }
              if (status === "error") {
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Progress,
                  {
                    percent: record.progress || 0,
                    size: "small",
                    status: "exception"
                  }
                );
              }
              if (status === "uploading") {
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Progress,
                  {
                    percent: record.progress || 0,
                    size: "small",
                    status: "active"
                  }
                );
              }
              return /* @__PURE__ */ jsxRuntimeExports.jsx(
                Progress,
                {
                  percent: 0,
                  size: "small"
                }
              );
            }
          }
        ];
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            title: "云盘本地上传",
            open: visible,
            onCancel: close,
            onOk: handleUpload,
            confirmLoading: loading,
            centered: true,
            width: 1e3,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$4["local-upload"], children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4["upload-section"], children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Dragger,
                {
                  className: styles$4.dragger,
                  multiple: true,
                  fileList,
                  beforeUpload: (file) => {
                    setFileList((prev) => [...prev, file]);
                    return false;
                  },
                  showUploadList: false,
                  accept: ".mp3,.flac,.wav,.m4a",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$4["upload-icon"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(InboxOutlined, {}) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$4["upload-text"], children: "点击或拖拽文件到此区域上传" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$4["upload-hint"], children: "支持 mp3, flac, wav, m4a 格式的音频文件" })
                  ]
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$4["file-list"], children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Table,
                  {
                    columns,
                    dataSource: fileList,
                    rowKey: (file) => file.uid || file.name,
                    scroll: { y: 300 },
                    pagination: false
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$4["upload-stats"], children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                    "共 ",
                    fileList.length,
                    " 个文件"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$4.divider, children: "|" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$4["size-text"], children: [
                    "总大小：",
                    (fileList.reduce((acc, file) => acc + file.size, 0) / 1024 / 1024).toFixed(2),
                    " MB"
                  ] })
                ] })
              ] })
            ] })
          }
        );
      });
      const VipSongA = forwardRef((props, ref) => {
        const [visible, setVisible] = useState(false);
        const open = () => setVisible(true);
        const close = () => setVisible(false);
        const reset = () => {
        };
        useImperativeHandle(ref, () => ({
          open,
          close,
          reset
        }));
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            title: "网页VIP歌曲A",
            open: visible,
            onCancel: close,
            width: 800,
            footer: null
          }
        );
      });
      const VipSongB = forwardRef((props, ref) => {
        const [visible, setVisible] = useState(false);
        const open = () => setVisible(true);
        const close = () => setVisible(false);
        const reset = () => {
        };
        useImperativeHandle(ref, () => ({
          open,
          close,
          reset
        }));
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            title: "网页VIP歌曲B",
            open: visible,
            onCancel: close,
            width: 800,
            footer: null
          }
        );
      });
      const CloudExport = forwardRef((props, ref) => {
        const [visible, setVisible] = useState(false);
        const open = () => setVisible(true);
        const close = () => setVisible(false);
        const reset = () => {
        };
        useImperativeHandle(ref, () => ({
          open,
          close,
          reset
        }));
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            title: "云盘导出",
            open: visible,
            onCancel: close,
            footer: null,
            centered: true
          }
        );
      });
      const CloudImport = forwardRef((props, ref) => {
        const [visible, setVisible] = useState(false);
        const open = () => setVisible(true);
        const close = () => setVisible(false);
        const reset = () => {
        };
        useImperativeHandle(ref, () => ({
          open,
          close,
          reset
        }));
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            title: "云盘导入",
            open: visible,
            onCancel: close,
            footer: null
          }
        );
      });
      const TestModal = forwardRef((props, ref) => {
        const [visible, setVisible] = useState(false);
        const open = () => setVisible(true);
        const close = () => setVisible(false);
        const reset = () => {
        };
        useImperativeHandle(ref, () => ({
          open,
          close,
          reset
        }));
        const [pageData, setPageData] = useState({
          limit: 500,
          offset: 0
        });
        const handleGetCloudData = async () => {
          console.log("获取云盘数据");
          try {
            const res = await getCloudData(pageData.limit, pageData.offset);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [songListName, setSongListName] = useState("");
        const handleCreateSongList = async () => {
          console.log("新建歌单");
          try {
            const res = await createPlaylist(songListName);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [addInfo, setAddInfo] = useState({
          songId: "185620",
          playlistId: "12999288729"
        });
        const handleAddSong = async () => {
          console.log("添加歌曲");
          try {
            const res = await addSongToPlaylist(addInfo.playlistId, [addInfo.songId]);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [userId, setUserId] = useState("12999288729");
        const handleGetPlaylistList = async () => {
          console.log("获取歌单列表");
          try {
            const res = await getPlaylistList(userId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [songId2, setSongId] = useState("2608471890");
        const handleGetSongUrl = async () => {
          console.log("获取歌曲URL");
          try {
            const res = await getSongUrl([songId2]);
            console.log("res", res);
            if (res.code === 200) {
              const url = res.data[0].url;
              await navigator.clipboard.writeText(url);
              msgSuccess("获取成功,已复制到剪切板");
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleDeleteCloudSong = async () => {
          console.log("删除云盘歌曲");
          try {
            const res = await deleteCloudSong([songId2]);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [albumId, setAlbumId] = useState("242274622");
        const handleGetAlbumSongList = async () => {
          console.log("获取专辑歌曲列表");
          try {
            const res = await getAlbumSongList(albumId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const [artistId, setArtistId] = useState("3684");
        const handleGetArtistTopSongList = async () => {
          console.log("获取歌手歌曲列表");
          try {
            const res = await getArtistTopSongList(artistId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetArtistAlbum = async () => {
          console.log("获取歌手专辑");
          try {
            const res = await getArtistAlbumList(artistId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleGetArtistAllSongList = async () => {
          console.log("获取歌手全部歌曲");
          try {
            const res = await getArtistAllSongList(artistId);
            console.log("res", res);
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleQrLogin = async () => {
          console.log("二维码登录");
          try {
            const keyRes = await getQrKey();
            if (keyRes.code !== 200) return msgError("获取二维码key失败");
            const key = keyRes.unikey;
            console.log("key", key);
            const qrcode2 = await getQrCode(key);
            const qrImg = document.createElement("img");
            qrImg.src = qrcode2;
            qrImg.style.width = "200px";
            qrImg.style.height = "200px";
            document.getElementById("qrcode-container").innerHTML = "";
            document.getElementById("qrcode-container").appendChild(qrImg);
            const timeOutTime = Date.now() + 2 * 60 * 1e3;
            while (Date.now() < timeOutTime) {
              const qrStatusRes = await getQrStatus(key);
              console.log("qrStatus", qrStatusRes);
              const { code } = qrStatusRes.response;
              if (code === 801) {
                console.log("等待扫码");
              } else if (code === 802) {
                console.log("授权中");
              } else if (code === 803) {
                console.log("授权成功");
                console.log("qrStatusRes", qrStatusRes);
                break;
              } else if (code === 800) {
                console.log("不存在或失效");
                break;
              }
              await sleep(1e3);
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        const [fileList, setFileList] = useState([]);
        const handleUploadLocalSong = async () => {
          try {
            console.log("fileList", fileList);
            if (!fileList.length) return msgError("请选择文件");
            for (let i = 0; i < fileList.length; i++) {
              const file = fileList[i];
              await uploadLocalSong(file);
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: "测试Modal",
            open: visible,
            onCancel: close,
            width: 800,
            footer: null,
            centered: true,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取云盘数据", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "limit",
                      style: { width: 100 }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "offset",
                      style: { width: 100 }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      onClick: handleGetCloudData,
                      children: "获取云盘数据"
                    }
                  )
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "新建歌单", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入歌单名称",
                      value: songListName,
                      onChange: (e) => setSongListName(e.target.value)
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      onClick: handleCreateSongList,
                      children: "新建歌单"
                    }
                  )
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "添加歌曲", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入歌单id",
                      value: addInfo.playlistId,
                      onChange: (e) => setAddInfo({ ...addInfo, playlistId: e.target.value })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入歌曲id",
                      value: addInfo.songId,
                      onChange: (e) => setAddInfo({ ...addInfo, songId: e.target.value })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      onClick: handleAddSong,
                      children: "添加歌曲"
                    }
                  )
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌单列表", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入用户id",
                      value: userId,
                      onChange: (e) => setUserId(e.target.value)
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      onClick: handleGetPlaylistList,
                      children: "获取歌单列表"
                    }
                  )
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌曲URL", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入歌曲id",
                      value: songId2,
                      onChange: (e) => setSongId(e.target.value)
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      onClick: handleGetSongUrl,
                      children: "获取歌曲URL"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      onClick: handleDeleteCloudSong,
                      children: "删除云盘歌曲"
                    }
                  )
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取专辑歌曲列表", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入专辑id",
                      value: albumId,
                      onChange: (e) => setAlbumId(e.target.value)
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      onClick: handleGetAlbumSongList,
                      children: "获取专辑歌曲列表"
                    }
                  )
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "获取歌手歌曲列表", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Input,
                    {
                      placeholder: "请输入歌手id",
                      value: artistId,
                      onChange: (e) => setArtistId(e.target.value)
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      onClick: handleGetArtistTopSongList,
                      children: "获取歌手热门歌曲列表"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      onClick: handleGetArtistAlbum,
                      children: "获取歌手专辑"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      onClick: handleGetArtistAllSongList,
                      children: "获取歌手全部歌曲"
                    }
                  )
                ] }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Form.Item, { label: "二维码登录", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "qrcode-container" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "primary",
                    onClick: handleQrLogin,
                    children: "二维码登录"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { label: "上传本地歌曲到云盘", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Upload,
                  {
                    fileList,
                    accept: ".flac,.mp3,.wav,.aac,.m4a,.ogg,.wma",
                    beforeUpload: (file) => {
                      setFileList([...fileList, file]);
                      return false;
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UploadOutlined, {}), children: "Select File" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "primary",
                    onClick: handleUploadLocalSong,
                    children: "上传本地歌曲到云盘"
                  }
                )
              ] }) })
            ]
          }
        );
      });
      const songInfoColumn = "_songInfoColumn_19jjf_1";
      const songCover = "_songCover_19jjf_6";
      const songInfo = "_songInfo_19jjf_1";
      const songName = "_songName_19jjf_15";
      const songId = "_songId_19jjf_24";
      const footer = "_footer_19jjf_29";
      const actions = "_actions_19jjf_37";
      const stats = "_stats_19jjf_42";
      const size = "_size_19jjf_47";
      const divider = "_divider_19jjf_50";
      const playlist = "_playlist_19jjf_58";
      const autoAddContent = "_autoAddContent_19jjf_62";
      const title = "_title_19jjf_62";
      const statsWrapper = "_statsWrapper_19jjf_66";
      const statsContent = "_statsContent_19jjf_69";
      const label = "_label_19jjf_76";
      const value = "_value_19jjf_79";
      const listHeader = "_listHeader_19jjf_84";
      const listWrapper = "_listWrapper_19jjf_90";
      const listItem = "_listItem_19jjf_111";
      const itemName = "_itemName_19jjf_127";
      const itemCount = "_itemCount_19jjf_133";
      const deleteConfirmation = "_deleteConfirmation_19jjf_138";
      const count = "_count_19jjf_146";
      const songs = "_songs_19jjf_149";
      const songItem = "_songItem_19jjf_160";
      const warning = "_warning_19jjf_171";
      const text = "_text_19jjf_178";
      const icon = "_icon_19jjf_185";
      const styles$3 = {
        songInfoColumn,
        songCover,
        songInfo,
        songName,
        songId,
        footer,
        actions,
        stats,
        size,
        divider,
        playlist,
        autoAddContent,
        title,
        statsWrapper,
        statsContent,
        label,
        value,
        listHeader,
        listWrapper,
        listItem,
        itemName,
        itemCount,
        deleteConfirmation,
        count,
        songs,
        songItem,
        warning,
        text,
        icon
      };
      const PlayList = (props, ref) => {
        const [visible, setVisible] = useState(false);
        const [mode2, setMode] = useState("edit");
        const isSelect = mode2 === "select";
        const open = (mode22) => {
          reset();
          if (mode22) {
            setMode(mode22);
          }
          setVisible(true);
          handleGetPlayList();
        };
        const close = () => {
          setVisible(false);
          setPlayList([]);
        };
        const reset = () => {
          setPlayList([]);
          res.current = null;
          setMode("add");
          setSelectedRows([]);
          setName("");
          setCreateModalVisible(false);
        };
        const res = useRef(null);
        const submit = () => {
          return new Promise((resolve, reject) => {
            res.current = resolve;
          });
        };
        useImperativeHandle(ref, () => ({
          open,
          close,
          submit
        }));
        const [loading, setLoading] = useState(false);
        const [playList, setPlayList] = useState([]);
        const handleGetPlayList = async () => {
          setLoading(true);
          try {
            const user = getGUser();
            if (!user) return message.error("请先登录");
            const res2 = await getPlaylistList(user.userId);
            console.log("res", res2);
            if (res2.code === 200) {
              setPlayList((list) => [...list, ...res2.playlist]);
            }
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        const columns = [
          {
            title: "歌单",
            dataIndex: "name",
            key: "name",
            width: 220,
            ellipsis: true,
            render: (text2, record) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: "8px" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Image,
                {
                  src: record.coverImgUrl,
                  width: 40,
                  height: 40,
                  style: { borderRadius: "4px" },
                  preview: false
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    fontWeight: 500,
                    flex: 1,
                    minWidth: 0,
                    overflow: "hidden",
                    textOverflow: "ellipsis",
                    whiteSpace: "nowrap"
                  },
                  children: text2
                }
              )
            ] })
          },
          {
            title: "歌曲数",
            dataIndex: "trackCount",
            key: "trackCount",
            width: 100,
            align: "right",
            sorter: (a, b) => a.trackCount - b.trackCount,
            sortDirections: ["descend", "ascend"],
            render: (text2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "span",
              {
                style: {
                  color: "#666",
                  fontSize: "13px"
                },
                children: [
                  text2,
                  " 首"
                ]
              }
            )
          },
          {
            title: "创建者",
            dataIndex: ["creator", "nickname"],
            key: "creator",
            width: 150,
            ellipsis: true
          },
          {
            title: "更新时间",
            dataIndex: "updateTime",
            key: "updateTime",
            width: 200,
            render: (text2) => new Date(text2).toLocaleString(),
            sorter: (a, b) => a.updateTime - b.updateTime,
            sortDirections: ["descend", "ascend"]
          },
          {
            title: "播放量",
            dataIndex: "playCount",
            key: "playCount",
            width: 100,
            render: (text2) => {
              const count2 = text2 > 1e4 ? `${(text2 / 1e4).toFixed(1)}万` : text2;
              return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: count2 });
            },
            sorter: (a, b) => a.playCount - b.playCount,
            sortDirections: ["descend", "ascend"]
          }
        ];
        const [selectedRows, setSelectedRows] = useState([]);
        const rowSelection = {
          type: isSelect ? "radio" : "checkbox",
          selectedRowKeys: selectedRows.map((item) => item.id),
          onSelectAll: () => {
            setTimeout(() => {
              setSelectedRows(playList);
            }, 0);
          },
          onChange: (_, selectedRows2) => {
            setSelectedRows(selectedRows2);
          }
        };
        const handleConfirm = () => {
          var _a;
          if (!selectedRows.length) {
            msgWarning("请选择歌单");
            return;
          }
          if (selectedRows.length !== 1) return msgWarning("只能选择一个歌单");
          (_a = res.current) == null ? void 0 : _a.call(res, selectedRows[0]);
          close();
        };
        const [name2, setName] = useState("");
        const [createModalVisible, setCreateModalVisible] = useState(false);
        const handleCreate = async () => {
          if (!name2.trim()) {
            msgWarning("请输入歌单名称");
            return;
          }
          try {
            const res2 = await createPlaylist(name2.trim());
            if (res2.code === 200) {
              msgSuccess("新建成功");
              handleGetPlayList();
              setName("");
              setCreateModalVisible(false);
            } else {
              msgError("新建失败");
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleDelete = async () => {
          if (!selectedRows.length) {
            msgWarning("请选择要删除的歌单");
            return;
          }
          try {
            await confirm(
              /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteConfirmContent, { playlists: selectedRows }),
              "删除歌单"
            );
            const proArr = selectedRows.map((item) => deletePlaylist(item.id));
            const res2 = await Promise.all(proArr);
            console.log("res", res2);
            msgSuccess("删除成功");
            handleGetPlayList();
            setSelectedRows([]);
          } catch (error) {
            console.log("error", error);
            msgError("删除失败");
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Modal,
            {
              title: "歌单列表",
              open: visible,
              onCancel: close,
              footer: null,
              centered: true,
              width: 800,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Table,
                  {
                    dataSource: playList,
                    columns,
                    rowKey: "id",
                    size: "small",
                    loading,
                    scroll: { y: 400 },
                    rowSelection
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.footer, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                    "已选择 ",
                    selectedRows.length,
                    " 个歌单"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setCreateModalVisible(true), children: "新建歌单" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        danger: true,
                        disabled: !selectedRows.length,
                        onClick: handleDelete,
                        children: "删除歌单"
                      }
                    ),
                    isSelect && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      Button,
                      {
                        type: "primary",
                        onClick: handleConfirm,
                        disabled: selectedRows.length !== 1,
                        children: [
                          "选择(",
                          selectedRows.length,
                          ")"
                        ]
                      }
                    )
                  ] })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Modal,
            {
              title: "新建歌单",
              open: createModalVisible,
              onCancel: () => {
                setCreateModalVisible(false);
                setName("");
              },
              onOk: handleCreate,
              okText: "确定",
              cancelText: "取消",
              centered: true,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  placeholder: "请输入歌单名称",
                  value: name2,
                  onChange: (e) => setName(e.target.value),
                  onPressEnter: handleCreate,
                  autoFocus: true
                }
              )
            }
          )
        ] });
      };
      const DeleteConfirmContent = ({ playlists }) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.autoAddContent, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.statsWrapper, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.title, children: "总计：" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.statsContent, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.label, children: "删除数量：" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.value, children: playlists.length }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.label, children: " 个歌单" })
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.listHeader, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.title, children: "即将删除的歌单：" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: styles$3.listWrapper, children: playlists.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles$3.listItem, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.itemName, children: item.name }),
              item.trackCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.itemCount, children: [
                item.trackCount,
                "首"
              ] })
            ] }, item.id)) })
          ] })
        ] });
      };
      const PlayList$1 = forwardRef(PlayList);
      const SearchForm = ({ onSearch, songList: songList2 }) => {
        const [form] = Form.useForm();
        const getUniqueOptions = (key) => {
          const uniqueList = uniqueArrayByKey(
            songList2.map((item) => ({
              ...item,
              name: item.simpleSong.name,
              singer: item.simpleSong.singer
            })),
            key
          );
          return uniqueList.map((item) => ({
            label: item[key],
            value: item[key]
          }));
        };
        const handleSearch = () => {
          const values = form.getFieldsValue();
          onSearch(values);
        };
        const handleReset = () => {
          form.resetFields();
          onSearch({});
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { form, style: { marginBottom: 16 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Space, { wrap: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { name: "name", style: { marginBottom: 0, minWidth: 200 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Select,
            {
              mode: "multiple",
              allowClear: true,
              showSearch: true,
              placeholder: "歌名",
              maxTagCount: "responsive",
              options: getUniqueOptions("name"),
              filterOption: (input, option) => ((option == null ? void 0 : option.label) ?? "").toLowerCase().includes(input.toLowerCase())
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { name: "artist", style: { marginBottom: 0, minWidth: 200 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Select,
            {
              mode: "multiple",
              allowClear: true,
              showSearch: true,
              placeholder: "歌手",
              maxTagCount: "responsive",
              options: getUniqueOptions("artist"),
              filterOption: (input, option) => ((option == null ? void 0 : option.label) ?? "").toLowerCase().includes(input.toLowerCase())
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form.Item, { name: "album", style: { marginBottom: 0, minWidth: 200 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Select,
            {
              mode: "multiple",
              allowClear: true,
              showSearch: true,
              placeholder: "专辑",
              maxTagCount: "responsive",
              options: getUniqueOptions("album"),
              filterOption: (input, option) => ((option == null ? void 0 : option.label) ?? "").toLowerCase().includes(input.toLowerCase())
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "primary", onClick: handleSearch, children: "搜索" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleReset, children: "重置" })
        ] }) });
      };
      const Stats = memo(({ selectedRows = [], filteredSongList = [] }) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.stats, children: [
          "已选择 ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Tag, { color: "blue", children: [
            selectedRows.length,
            " 首"
          ] }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.size, children: selectedRows.length > 0 && `${(selectedRows.reduce((acc, cur) => acc + cur.fileSize, 0) / 1024 / 1024).toFixed(2)}MB` }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.divider, children: "/" }),
          "共",
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Tag, { color: "green", children: [
            filteredSongList.length,
            " 首"
          ] }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.size, children: filteredSongList.length > 0 && `${(filteredSongList.reduce((acc, cur) => acc + cur.fileSize, 0) / 1024 / 1024).toFixed(2)}MB` })
        ] });
      });
      Stats.displayName = "Stats";
      const CloudMusicManager = forwardRef((props, ref) => {
        const [visible, setVisible] = useState(false);
        const open = () => setVisible(true);
        const close = () => setVisible(false);
        const reset = () => {
        };
        useImperativeHandle(ref, () => ({
          open,
          close,
          reset
        }));
        const [songList2, setSongList] = useState([]);
        const [loading, setLoading] = useState(false);
        const getCloudDataList = async () => {
          try {
            setLoading(true);
            const res = await getCloudData(1e4, 0);
            if (res.code === 200) {
              console.log("songList", res.data);
              setSongList(res.data);
              setFilteredSongList(res.data);
            }
          } catch (error) {
            console.log("error", error);
          } finally {
            setLoading(false);
          }
        };
        useEffect(() => {
          if (!visible) return;
          getCloudDataList();
        }, [visible]);
        const [filteredSongList, setFilteredSongList] = useState([]);
        const handleSearch = (values) => {
          console.log("values", values);
          const { name: name2, artist: artist2, album } = values;
          const filtered = songList2.filter((song2) => {
            const nameMatch = !(name2 == null ? void 0 : name2.length) || name2.some(
              (n2) => {
                var _a;
                return (_a = song2.simpleSong.name) == null ? void 0 : _a.toLowerCase().includes(n2.toLowerCase());
              }
            );
            const artistMatch = !(artist2 == null ? void 0 : artist2.length) || artist2.some(
              (a) => song2.artist.toLowerCase().includes(a.toLowerCase())
            );
            const albumMatch = !(album == null ? void 0 : album.length) || album.some((a) => song2.album.toLowerCase().includes(a.toLowerCase()));
            const legacy = song2.simpleSong.al && song2.simpleSong.ar;
            const match = nameMatch && artistMatch && albumMatch && legacy;
            if (!match) {
              console.log("song", song2);
              console.log("nameMatch", nameMatch);
              console.log("artistMatch", artistMatch);
              console.log("albumMatch", albumMatch);
              console.log("legacy", legacy);
            }
            return match;
          });
          setFilteredSongList(filtered);
        };
        const [selectedRows, setSelectedRows] = useState([]);
        const selectedRowKeys = useMemo(
          () => selectedRows.map((item) => item.songId),
          [selectedRows]
        );
        const rowSelection = {
          type: "checkbox",
          fixed: true,
          selectedRowKeys,
          getCheckboxProps: (record) => ({
            disabled: record.uploaded
          }),
          onSelectAll: () => {
            setTimeout(() => {
              setSelectedRows(filteredSongList);
            }, 0);
          },
          onChange: (selectedRowKeys2, selectedRows2) => {
            setSelectedRows(selectedRows2);
          }
        };
        const handleTableChange = (pagination, filters, sorter) => {
          setFilteredSongList((songList22) => {
            return songList22.sort((a, b) => {
              var _a;
              const order = sorter.order === "ascend" ? 1 : -1;
              return order * ((_a = a[sorter.columnKey]) == null ? void 0 : _a.localeCompare(b[sorter.columnKey]));
            });
          });
        };
        const columns = [
          {
            title: "歌名",
            dataIndex: "simpleSong",
            key: "name",
            width: 250,
            sorter: (a, b) => {
              var _a;
              return (_a = a.simpleSong.name) == null ? void 0 : _a.localeCompare(b.simpleSong.name);
            },
            sortDirections: ["ascend", "descend"],
            render: (record) => {
              var _a;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.songInfoColumn, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: (_a = record.al) == null ? void 0 : _a.picUrl,
                    alt: record.name,
                    className: styles$3.songCover
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.songInfo, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.songName, children: record.name }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.songId, children: record.id })
                ] })
              ] });
            }
          },
          {
            title: "歌手",
            dataIndex: "simpleSong",
            key: "artists",
            width: 200,
            sorter: (a, b) => {
              var _a, _b;
              const aArtists = (_a = a.simpleSong.ar) == null ? void 0 : _a.map((a2) => a2.name).join(",");
              const bArtists = (_b = b.simpleSong.ar) == null ? void 0 : _b.map((a2) => a2.name).join(",");
              return aArtists == null ? void 0 : aArtists.localeCompare(bArtists);
            },
            sortDirections: ["ascend", "descend"],
            ellipsis: true,
            render: (record) => {
              var _a;
              return (_a = record.ar) == null ? void 0 : _a.map((a) => a.name).join(",");
            }
          },
          {
            title: "专辑",
            dataIndex: "simpleSong",
            key: "album",
            width: 300,
            sorter: (a, b) => {
              var _a, _b, _c;
              return (_c = (_a = a.simpleSong.al) == null ? void 0 : _a.name) == null ? void 0 : _c.localeCompare((_b = b.simpleSong.al) == null ? void 0 : _b.name);
            },
            sortDirections: ["ascend", "descend"],
            defaultSortOrder: "ascend",
            ellipsis: true,
            render: (record) => {
              var _a;
              return (_a = record.al) == null ? void 0 : _a.name;
            }
          },
          {
            title: "大小",
            dataIndex: "fileSize",
            key: "fileSize",
            width: 100,
            sorter: (a, b) => a.fileSize - b.fileSize,
            sortDirections: ["ascend", "descend"],
            render: (size2) => `${(size2 / 1024 / 1024).toFixed(2)}MB`
          },
          {
            title: "比特率",
            dataIndex: "bitrate",
            key: "bitrate",
            width: 100,
            sorter: (a, b) => a.bitrate - b.bitrate,
            sortDirections: ["ascend", "descend"],
            render: (bitrate) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Tag, { color: "blue", children: [
              bitrate,
              "kbps"
            ] })
          },
          {
            title: "上传时间",
            dataIndex: "addTime",
            key: "addTime",
            width: 150,
            sorter: (a, b) => a.addTime - b.addTime,
            sortDirections: ["ascend", "descend"],
            render: (time) => new Date(time).toLocaleString()
          }
        ];
        const [addToPlayListByAlbumLoading, setAddToPlayListByAlbumLoading] = useState(false);
        const handleAddToPlaylistByAlbum = async () => {
          var _a;
          try {
            setAddToPlayListByAlbumLoading(true);
            console.log("自动按专辑添加");
            const albumMap = /* @__PURE__ */ new Map();
            filteredSongList.forEach((song2) => {
              var _a2, _b, _c;
              const { simpleSong } = song2;
              const album = `${((_b = (_a2 = simpleSong.ar) == null ? void 0 : _a2[0]) == null ? void 0 : _b.name) || ""}-${(_c = simpleSong.al) == null ? void 0 : _c.name}`;
              if (!albumMap.has(album)) {
                albumMap.set(album, []);
              }
              albumMap.get(album).push(song2);
            });
            const totalSongs = filteredSongList.length;
            const albums = Array.from(albumMap.entries()).sort(
              ([, songsA], [, songsB]) => songsB.length - songsA.length
            );
            await confirm(
              /* @__PURE__ */ jsxRuntimeExports.jsx(AutoAddContent, { totalSongs, albums }),
              "自动按专辑添加",
              {
                width: "auto"
              }
            );
            const res = await getPlaylistList();
            console.log("res", res);
            if (res.code !== 200) return msgError("获取歌单失败");
            const playlist2 = res.playlist;
            for (const [album, songs2] of albums) {
              try {
                const playlistName = album;
                console.log("playlistName", playlistName, "songs", songs2);
                let playlistId = (_a = playlist2.find((p2) => p2.name === playlistName)) == null ? void 0 : _a.id;
                if (!playlistId) {
                  const truncatedName = truncateString(playlistName, 40);
                  const res3 = await createPlaylist(truncatedName);
                  if (res3.code === 200) {
                    playlistId = res3.id;
                  } else {
                    console.log("res", res3);
                    debugger;
                  }
                  await sleep(1e3);
                }
                const songIds = songs2.map((song2) => song2.songId);
                const res2 = await addSongToPlaylist(playlistId, songIds);
                console.log("res", res2);
                if (res2.code !== 200) {
                  console.log("添加歌曲失败", res2.message || res2.msg);
                }
                await sleep(500);
              } catch (error) {
                console.log("error", error);
              }
            }
            setSelectedRows([]);
            msgSuccess("添加成功");
          } catch (error) {
            console.log("error", error);
          } finally {
            setAddToPlayListByAlbumLoading(false);
          }
        };
        const playListRef = useRef(null);
        const handleAddToPlaylist = async () => {
          try {
            console.log("添加到歌单");
            playListRef.current.open("select");
            const playlist2 = await playListRef.current.submit();
            if (!playlist2) return;
            const songIds = selectedRows.map((item) => item.songId);
            const res = await addSongToPlaylist(playlist2.id, songIds);
            console.log("res", res);
            if (res.code === 200) {
              setSelectedRows([]);
              msgSuccess("添加成功");
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        const handleCreatePlaylist = () => {
          console.log("新建歌单");
          playListRef.current.open();
        };
        const handleDeleteSong = async () => {
          try {
            const confirmContent = /* @__PURE__ */ jsxRuntimeExports.jsx(
              DeleteConfirmation,
              {
                selectedCount: selectedRows.length,
                songNames: selectedRows.map((item) => item.simpleSong.name)
              }
            );
            await confirm(confirmContent, "删除确认");
            const songIds = selectedRows.map((item) => item.songId);
            const res = await deleteCloudSong(songIds);
            console.log("res", res);
            if (res.code === 200) {
              msgSuccess("删除成功");
              reset();
              getCloudDataList();
            }
          } catch (error) {
            console.log("error", error);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Modal,
          {
            title: "云盘音乐管理",
            open: visible,
            onCancel: close,
            footer: null,
            centered: true,
            width: 900,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SearchForm, { onSearch: handleSearch, songList: songList2 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Table,
                {
                  rowSelection,
                  dataSource: filteredSongList,
                  columns,
                  scroll: { y: 400, x: 1e3 },
                  size: "small",
                  loading,
                  rowKey: ({ songId: songId2 }) => songId2,
                  onChange: handleTableChange
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.footer, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Stats,
                  {
                    selectedRows,
                    filteredSongList
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.actions, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: () => setSelectedRows(filteredSongList), children: "全部选择" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      onClick: handleAddToPlaylistByAlbum,
                      loading: addToPlayListByAlbumLoading,
                      children: "自动按专辑添加"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      disabled: !selectedRows.length,
                      onClick: handleAddToPlaylist,
                      children: "添加到歌单"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleCreatePlaylist, children: "新建歌单" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Button,
                    {
                      type: "primary",
                      danger: true,
                      disabled: !selectedRows.length,
                      onClick: handleDeleteSong,
                      children: "删除歌曲"
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(PlayList$1, { ref: playListRef })
            ]
          }
        );
      });
      const AutoAddContent = ({ totalSongs, albums }) => {
        const handleCopy = () => {
          const text2 = albums.map(([name2, songs2]) => `${name2}（${songs2.length}首）`).join("\n");
          navigator.clipboard.writeText(text2).then(() => {
            message.success("复制成功");
          });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.autoAddContent, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.statsWrapper, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.title, children: "总计：" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.statsContent, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.label, children: "歌曲数：" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.value, children: totalSongs }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.label, children: " 首" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.label, children: "歌单数：" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.value, children: albums.length }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.label, children: " 个" })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.listHeader, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.title, children: "即将创建的歌单：" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "link",
                  size: "small",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyrightOutlined, {}),
                  onClick: handleCopy,
                  children: "复制列表"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: styles$3.listWrapper, children: albums.map(([name2, songs2]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles$3.listItem, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.itemName, children: name2 }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$3.itemCount, children: [
                songs2.length,
                "首"
              ] })
            ] }, name2)) })
          ] })
        ] });
      };
      const DeleteConfirmation = ({ selectedCount, songNames }) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$3.deleteConfirmation, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$3.title, children: [
            "您确定要删除以下 ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.count, children: selectedCount }),
            " 首歌曲吗？"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.songs, children: songNames.map((name2, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.songItem, children: name2 }, index)) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$3.warning, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$3.text, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$3.icon, children: "!" }),
            "注意：此操作不可恢复，删除后歌曲将从您的网易云音乐云盘中永久移除。"
          ] }) })
        ] });
      };
      const container = "_container_18cxg_1";
      const styles$2 = {
        container
      };
      const uploadArea = "_uploadArea_62myb_1";
      const uploadContent = "_uploadContent_62myb_14";
      const uploadIcon = "_uploadIcon_62myb_22";
      const uploadText = "_uploadText_62myb_27";
      const uploadTip = "_uploadTip_62myb_34";
      const styles$1 = {
        uploadArea,
        uploadContent,
        uploadIcon,
        uploadText,
        uploadTip
      };
      const UploadArea = ({ onUpload }) => {
        const handleDragOver = (e) => {
          e.preventDefault();
          e.stopPropagation();
        };
        const handleDrop = (e) => {
          e.preventDefault();
          e.stopPropagation();
          const files = e.dataTransfer.files;
          onUpload == null ? void 0 : onUpload(files);
        };
        const handleFileSelect = (e) => {
          const files = e.target.files;
          onUpload == null ? void 0 : onUpload(files);
          e.target.value = null;
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: styles$1.uploadArea,
            onDragOver: handleDragOver,
            onDrop: handleDrop,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "file",
                  multiple: true,
                  accept: ".ncm,.qmc,.mflac,.mgg,.kgm,.xm,.kwm",
                  onChange: handleFileSelect,
                  style: { display: "none" },
                  id: "file-input"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "label",
                {
                  htmlFor: "file-input",
                  className: styles$1.uploadContent,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(CloudUploadOutlined, { className: styles$1.uploadIcon }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.uploadText, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "点击或拖拽文件到此处" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$1.uploadTip, children: "支持格式：网易云音乐(ncm), QQ音乐(qmc, mflac, mgg), 酷狗音乐(kgm), 虾米音乐(xm), 酷我音乐(.kwm)" })
                    ] })
                  ]
                }
              )
            ]
          }
        );
      };
      const unlockList = "_unlockList_gel3y_1";
      const styles = {
        unlockList
      };
      const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      let nanoid = (size2 = 21) => {
        let id = "";
        let bytes = crypto.getRandomValues(new Uint8Array(size2 |= 0));
        while (size2--) {
          id += urlAlphabet[bytes[size2] & 63];
        }
        return id;
      };
      let wasm;
      const cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
        throw Error("TextDecoder not available");
      } };
      if (typeof TextDecoder !== "undefined") {
        cachedTextDecoder.decode();
      }
      let cachedUint8ArrayMemory0 = null;
      function getUint8ArrayMemory0() {
        if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
          cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
        }
        return cachedUint8ArrayMemory0;
      }
      function getStringFromWasm0(ptr, len) {
        ptr = ptr >>> 0;
        return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
      }
      let WASM_VECTOR_LEN = 0;
      const cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
        throw Error("TextEncoder not available");
      } };
      const encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
        return cachedTextEncoder.encodeInto(arg, view);
      } : function(arg, view) {
        const buf = cachedTextEncoder.encode(arg);
        view.set(buf);
        return {
          read: arg.length,
          written: buf.length
        };
      };
      function passStringToWasm0(arg, malloc, realloc) {
        if (realloc === void 0) {
          const buf = cachedTextEncoder.encode(arg);
          const ptr2 = malloc(buf.length, 1) >>> 0;
          getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
          WASM_VECTOR_LEN = buf.length;
          return ptr2;
        }
        let len = arg.length;
        let ptr = malloc(len, 1) >>> 0;
        const mem = getUint8ArrayMemory0();
        let offset = 0;
        for (; offset < len; offset++) {
          const code = arg.charCodeAt(offset);
          if (code > 127) break;
          mem[ptr + offset] = code;
        }
        if (offset !== len) {
          if (offset !== 0) {
            arg = arg.slice(offset);
          }
          ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
          const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
          const ret = encodeString(arg, view);
          offset += ret.written;
          ptr = realloc(ptr, len, offset, 1) >>> 0;
        }
        WASM_VECTOR_LEN = offset;
        return ptr;
      }
      let cachedDataViewMemory0 = null;
      function getDataViewMemory0() {
        if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
          cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
        }
        return cachedDataViewMemory0;
      }
      function getArrayU8FromWasm0(ptr, len) {
        ptr = ptr >>> 0;
        return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
      }
      function takeFromExternrefTable0(idx) {
        const value2 = wasm.__wbindgen_export_3.get(idx);
        wasm.__externref_table_dealloc(idx);
        return value2;
      }
      function passArray8ToWasm0(arg, malloc) {
        const ptr = malloc(arg.length * 1, 1) >>> 0;
        getUint8ArrayMemory0().set(arg, ptr / 1);
        WASM_VECTOR_LEN = arg.length;
        return ptr;
      }
      function decryptX2MHeader(buffer) {
        var ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.decryptX2MHeader(ptr0, len0, buffer);
        if (ret[1]) {
          throw takeFromExternrefTable0(ret[0]);
        }
      }
      function decryptX3MHeader(buffer) {
        var ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        const ret = wasm.decryptX3MHeader(ptr0, len0, buffer);
        if (ret[1]) {
          throw takeFromExternrefTable0(ret[0]);
        }
      }
      function _assertClass(instance, klass) {
        if (!(instance instanceof klass)) {
          throw new Error(`expected instance of ${klass.name}`);
        }
      }
      function isLikeNone(x) {
        return x === void 0 || x === null;
      }
      function decryptQMC1(buffer, offset) {
        var ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.decryptQMC1(ptr0, len0, buffer, offset);
      }
      function initPanicHook() {
        wasm.initPanicHook();
      }
      function detectAudioType(buffer) {
        const ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.detectAudioType(ptr0, len0);
        if (ret[2]) {
          throw takeFromExternrefTable0(ret[1]);
        }
        return AudioTypeResult.__wrap(ret[0]);
      }
      const AudioTypeResultFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_audiotyperesult_free(ptr >>> 0, 1));
      class AudioTypeResult {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(AudioTypeResult.prototype);
          obj.__wbg_ptr = ptr;
          AudioTypeResultFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          AudioTypeResultFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_audiotyperesult_free(ptr, 0);
        }
        /**
         * When this field is not zero, it means we need to feed this amount of bytes to the detector.
         * @returns {number}
         */
        get needMore() {
          const ret = wasm.__wbg_get_audiotyperesult_needMore(this.__wbg_ptr);
          return ret >>> 0;
        }
        /**
         * When this field is not zero, it means we need to feed this amount of bytes to the detector.
         * @param {number} arg0
         */
        set needMore(arg0) {
          wasm.__wbg_set_audiotyperesult_needMore(this.__wbg_ptr, arg0);
        }
        /**
         * Audio extension, without "."
         * When is unknown, it will return "bin".
         * @returns {string}
         */
        get audioType() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.__wbg_get_audiotyperesult_audioType(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * Audio extension, without "."
         * When is unknown, it will return "bin".
         * @param {string} arg0
         */
        set audioType(arg0) {
          const ptr0 = passStringToWasm0(arg0, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len0 = WASM_VECTOR_LEN;
          wasm.__wbg_set_audiotyperesult_audioType(this.__wbg_ptr, ptr0, len0);
        }
      }
      typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_jooxfile_free(ptr >>> 0, 1));
      const KWMDecipherFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_kwmdecipher_free(ptr >>> 0, 1));
      class KWMDecipher {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          KWMDecipherFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_kwmdecipher_free(ptr, 0);
        }
        /**
         * Create an instance of cipher (decipher) for decryption
         * @param {KuwoHeader} header
         * @param {string | undefined} [ekey]
         */
        constructor(header, ekey) {
          _assertClass(header, KuwoHeader);
          var ptr0 = isLikeNone(ekey) ? 0 : passStringToWasm0(ekey, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          var len0 = WASM_VECTOR_LEN;
          const ret = wasm.kwmdecipher_make_decipher(header.__wbg_ptr, ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          this.__wbg_ptr = ret[0] >>> 0;
          KWMDecipherFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
         * Decrypt buffer at given offset.
         * @param {Uint8Array} buffer
         * @param {number} offset
         */
        decrypt(buffer, offset) {
          var ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
          var len0 = WASM_VECTOR_LEN;
          wasm.kwmdecipher_decrypt(this.__wbg_ptr, ptr0, len0, buffer, offset);
        }
      }
      typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_kwmdecipherv1_free(ptr >>> 0, 1));
      const KuGouFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_kugou_free(ptr >>> 0, 1));
      class KuGou {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(KuGou.prototype);
          obj.__wbg_ptr = ptr;
          KuGouFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          KuGouFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_kugou_free(ptr, 0);
        }
        /**
         * Parse the KuGou header (0x400 bytes recommended).
         * @param {Uint8Array} header
         * @returns {KuGou}
         */
        static from_header(header) {
          const ptr0 = passArray8ToWasm0(header, wasm.__wbindgen_malloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.kugou_from_header(ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return KuGou.__wrap(ret[0]);
        }
        /**
         * Parse the KuGou header (0x400 bytes recommended).
         * @param {KuGouHeader} header
         * @param {string | undefined} [ekey]
         * @returns {KuGou}
         */
        static fromHeaderV5(header, ekey) {
          _assertClass(header, KuGouHeader);
          var ptr0 = isLikeNone(ekey) ? 0 : passStringToWasm0(ekey, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          var len0 = WASM_VECTOR_LEN;
          const ret = wasm.kugou_fromHeaderV5(header.__wbg_ptr, ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return KuGou.__wrap(ret[0]);
        }
        /**
         * Decrypt a buffer.
         * @param {Uint8Array} buffer
         * @param {number} offset
         */
        decrypt(buffer, offset) {
          var ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
          var len0 = WASM_VECTOR_LEN;
          wasm.kugou_decrypt(this.__wbg_ptr, ptr0, len0, buffer, offset);
        }
        /**
         * Decrypt Kugou PC client db.
         * @param {Uint8Array} database
         */
        static decryptDatabase(database) {
          var ptr0 = passArray8ToWasm0(database, wasm.__wbindgen_malloc);
          var len0 = WASM_VECTOR_LEN;
          const ret = wasm.kugou_decryptDatabase(ptr0, len0, database);
          if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
          }
        }
      }
      const KuGouHeaderFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_kugouheader_free(ptr >>> 0, 1));
      class KuGouHeader {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          KuGouHeaderFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_kugouheader_free(ptr, 0);
        }
        /**
         * Parse the KuGou header (0x400 bytes recommended).
         * @param {Uint8Array} header
         */
        constructor(header) {
          const ptr0 = passArray8ToWasm0(header, wasm.__wbindgen_malloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.kugouheader_new(ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          this.__wbg_ptr = ret[0] >>> 0;
          KuGouHeaderFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
         * Get the audio hash (kgm v5).
         * @returns {string}
         */
        get audioHash() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.kugouheader_audioHash(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * Get version
         * @returns {number}
         */
        get version() {
          const ret = wasm.kugouheader_version(this.__wbg_ptr);
          return ret >>> 0;
        }
        /**
         * Get offset to encrypted data
         * @returns {number}
         */
        get offsetToData() {
          const ret = wasm.kugouheader_offsetToData(this.__wbg_ptr);
          return ret >>> 0;
        }
      }
      const KuwoHeaderFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_kuwoheader_free(ptr >>> 0, 1));
      class KuwoHeader {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(KuwoHeader.prototype);
          obj.__wbg_ptr = ptr;
          KuwoHeaderFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          KuwoHeaderFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_kuwoheader_free(ptr, 0);
        }
        /**
         * Parse the KuWo header (0x400 bytes)
         * @param {Uint8Array} header
         * @returns {KuwoHeader}
         */
        static parse(header) {
          const ptr0 = passArray8ToWasm0(header, wasm.__wbindgen_malloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.kuwoheader_parse(ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return KuwoHeader.__wrap(ret[0]);
        }
        /**
         * Get quality id (used for Android Kuwo APP),
         *   that can be then used to extract ekey from mmkv db.
         * @returns {number}
         */
        get qualityId() {
          const ret = wasm.kuwoheader_qualityId(this.__wbg_ptr);
          return ret >>> 0;
        }
        /**
         * Get resource id
         * @returns {number}
         */
        get resourceId() {
          const ret = wasm.kuwoheader_resourceId(this.__wbg_ptr);
          return ret >>> 0;
        }
      }
      const Migu3DFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_migu3d_free(ptr >>> 0, 1));
      class Migu3D {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Migu3D.prototype);
          obj.__wbg_ptr = ptr;
          Migu3DFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          Migu3DFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_migu3d_free(ptr, 0);
        }
        /**
         * Create a new decipher and guess its key from first 0x100 bytes.
         * @param {Uint8Array} header
         * @returns {Migu3D}
         */
        static fromHeader(header) {
          const ptr0 = passArray8ToWasm0(header, wasm.__wbindgen_malloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.migu3d_fromHeader(ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return Migu3D.__wrap(ret[0]);
        }
        /**
         * Create a new decipher from file_key
         * @param {string} file_key
         * @returns {Migu3D}
         */
        static fromFileKey(file_key) {
          const ptr0 = passStringToWasm0(file_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.migu3d_fromFileKey(ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return Migu3D.__wrap(ret[0]);
        }
        /**
         * Decrypt encrypted buffer part.
         * @param {Uint8Array} buffer
         * @param {number} offset
         */
        decrypt(buffer, offset) {
          var ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
          var len0 = WASM_VECTOR_LEN;
          wasm.migu3d_decrypt(this.__wbg_ptr, ptr0, len0, buffer, offset);
        }
      }
      const NCMFileFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_ncmfile_free(ptr >>> 0, 1));
      class NCMFile {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          NCMFileFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_ncmfile_free(ptr, 0);
        }
        /**
         * Create a NCMFile instance
         */
        constructor() {
          const ret = wasm.ncmfile_new();
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          this.__wbg_ptr = ret[0] >>> 0;
          NCMFileFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
         * Open NCM file.
         * If everything is ok, return `0`.
         * If it needs more header bytes, return positive integer.
         * If it was not a valid NCM file, return -1.
         *
         * # Arguments
         *
         * * `header`: Header bytes of NCM file.
         *
         * returns: Result<i32, JsError>
         *
         * If it needs more bytes, the new header size will be returned.
         * If the header was large enough, it will return 0.
         * @param {Uint8Array} header
         * @returns {number}
         */
        open(header) {
          const ptr0 = passArray8ToWasm0(header, wasm.__wbindgen_malloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.ncmfile_open(this.__wbg_ptr, ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return ret[0];
        }
        /**
         * Decrypt buffer.
         *
         * # Arguments
         *
         * * `buffer`: Buffer to decrypt.
         * * `offset`: Offset (start from 0, of encrypted binary data)
         *
         * returns: Result<(), JsError>
         * @param {Uint8Array} buffer
         * @param {number} offset
         */
        decrypt(buffer, offset) {
          var ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
          var len0 = WASM_VECTOR_LEN;
          const ret = wasm.ncmfile_decrypt(this.__wbg_ptr, ptr0, len0, buffer, offset);
          if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
          }
        }
        /**
         * Get audio data offset.
         * @returns {number}
         */
        get audioOffset() {
          const ret = wasm.ncmfile_audioOffset(this.__wbg_ptr);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return ret[0] >>> 0;
        }
      }
      const QMC2Finalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_qmc2_free(ptr >>> 0, 1));
      class QMC2 {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(QMC2.prototype);
          obj.__wbg_ptr = ptr;
          QMC2Finalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          QMC2Finalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_qmc2_free(ptr, 0);
        }
        /**
         * Create a new QMC2 (mgg/mflac) cipher instance.
         * @param {string} ekey
         */
        constructor(ekey) {
          const ptr0 = passStringToWasm0(ekey, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.qmc2_new(ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          this.__wbg_ptr = ret[0] >>> 0;
          QMC2Finalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
         * Decrypt buffer at given offset.
         * @param {Uint8Array} buffer
         * @param {number} offset
         */
        decrypt(buffer, offset) {
          var ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
          var len0 = WASM_VECTOR_LEN;
          wasm.qmc2_decrypt(this.__wbg_ptr, ptr0, len0, buffer, offset);
        }
      }
      const QMCFooterFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_qmcfooter_free(ptr >>> 0, 1));
      class QMCFooter {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(QMCFooter.prototype);
          obj.__wbg_ptr = ptr;
          QMCFooterFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          QMCFooterFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_qmcfooter_free(ptr, 0);
        }
        /**
         * Parse QMC Footer from byte slice.
         *   Recommended to slice the last 1024 bytes of the file.
         * @param {Uint8Array} footer
         * @returns {QMCFooter | undefined}
         */
        static parse(footer2) {
          const ptr0 = passArray8ToWasm0(footer2, wasm.__wbindgen_malloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.qmcfooter_parse(ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return ret[0] === 0 ? void 0 : QMCFooter.__wrap(ret[0]);
        }
        /**
         * Get eKey (if embedded)
         * @returns {string | undefined}
         */
        get ekey() {
          const ret = wasm.qmcfooter_ekey(this.__wbg_ptr);
          let v1;
          if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
          }
          return v1;
        }
        /**
         * Get size of footer
         * @returns {number}
         */
        get size() {
          const ret = wasm.qmcfooter_size(this.__wbg_ptr);
          return ret >>> 0;
        }
        /**
         * Get media name (MusicEx)
         * @returns {string | undefined}
         */
        get mediaName() {
          const ret = wasm.qmcfooter_mediaName(this.__wbg_ptr);
          let v1;
          if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
          }
          return v1;
        }
      }
      const QingTingFMFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_qingtingfm_free(ptr >>> 0, 1));
      class QingTingFM {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          QingTingFMFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_qingtingfm_free(ptr, 0);
        }
        /**
         * @param {string} product
         * @param {string} device
         * @param {string} manufacturer
         * @param {string} brand
         * @param {string} board
         * @param {string} model
         * @returns {Uint8Array}
         */
        static getDeviceKey(product, device, manufacturer, brand, board, model) {
          const ptr0 = passStringToWasm0(product, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len0 = WASM_VECTOR_LEN;
          const ptr1 = passStringToWasm0(device, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len1 = WASM_VECTOR_LEN;
          const ptr2 = passStringToWasm0(manufacturer, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len2 = WASM_VECTOR_LEN;
          const ptr3 = passStringToWasm0(brand, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len3 = WASM_VECTOR_LEN;
          const ptr4 = passStringToWasm0(board, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len4 = WASM_VECTOR_LEN;
          const ptr5 = passStringToWasm0(model, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len5 = WASM_VECTOR_LEN;
          const ret = wasm.qingtingfm_getDeviceKey(ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4, ptr5, len5);
          var v7 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
          wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
          return v7;
        }
        /**
         * @param {string} file_name
         * @returns {Uint8Array}
         */
        static getFileIV(file_name) {
          const ptr0 = passStringToWasm0(file_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.qingtingfm_getFileIV(ptr0, len0);
          if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
          }
          var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
          wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
          return v2;
        }
        /**
         * @param {Uint8Array} device_key
         * @param {Uint8Array} file_iv
         */
        constructor(device_key, file_iv) {
          const ptr0 = passArray8ToWasm0(device_key, wasm.__wbindgen_malloc);
          const len0 = WASM_VECTOR_LEN;
          const ptr1 = passArray8ToWasm0(file_iv, wasm.__wbindgen_malloc);
          const len1 = WASM_VECTOR_LEN;
          const ret = wasm.qingtingfm_new(ptr0, len0, ptr1, len1);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          this.__wbg_ptr = ret[0] >>> 0;
          QingTingFMFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
         * Decrypt encrypted buffer part.
         * @param {Uint8Array} buffer
         * @param {number} offset
         */
        decrypt(buffer, offset) {
          var ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
          var len0 = WASM_VECTOR_LEN;
          wasm.qingtingfm_decrypt(this.__wbg_ptr, ptr0, len0, buffer, offset);
        }
      }
      const XiamiFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_xiami_free(ptr >>> 0, 1));
      class Xiami {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Xiami.prototype);
          obj.__wbg_ptr = ptr;
          XiamiFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          XiamiFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_xiami_free(ptr, 0);
        }
        /**
         * Parse the Xiami header (0x400 bytes)
         * @param {Uint8Array} header
         * @returns {Xiami}
         */
        static from_header(header) {
          const ptr0 = passArray8ToWasm0(header, wasm.__wbindgen_malloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.xiami_from_header(ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return Xiami.__wrap(ret[0]);
        }
        /**
         * Decrypt encrypted buffer part.
         * @param {Uint8Array} buffer
         */
        decrypt(buffer) {
          var ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
          var len0 = WASM_VECTOR_LEN;
          wasm.xiami_decrypt(this.__wbg_ptr, ptr0, len0, buffer);
        }
        /**
         * After header (0x10 bytes), the number of bytes should be copied without decryption.
         * @returns {number}
         */
        get copyPlainLength() {
          const ret = wasm.xiami_copyPlainLength(this.__wbg_ptr);
          return ret >>> 0;
        }
      }
      const XmlyPCFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_xmlypc_free(ptr >>> 0, 1));
      class XmlyPC {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          XmlyPCFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_xmlypc_free(ptr, 0);
        }
        /**
         * Get required bytes for the header, or throw error if not valid XM file.
         * @param {Uint8Array} buffer
         * @returns {number}
         */
        static getHeaderSize(buffer) {
          const ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.xmlypc_getHeaderSize(ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return ret[0] >>> 0;
        }
        /**
         * Create a new XmlyPC decipher
         * @param {Uint8Array} header
         */
        constructor(header) {
          const ptr0 = passArray8ToWasm0(header, wasm.__wbindgen_malloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.xmlypc_new(ptr0, len0);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          this.__wbg_ptr = ret[0] >>> 0;
          XmlyPCFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
         * Get the first few bytes of the header.
         * @returns {Uint8Array}
         */
        get audioHeader() {
          const ret = wasm.xmlypc_audioHeader(this.__wbg_ptr);
          var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
          wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
          return v1;
        }
        /**
         * Get the offset where the encrypted header is
         * @returns {number}
         */
        get encryptedHeaderOffset() {
          const ret = wasm.xmlypc_encryptedHeaderOffset(this.__wbg_ptr);
          return ret >>> 0;
        }
        /**
         * Get the size of encrypted header
         * @returns {number}
         */
        get encryptedHeaderSize() {
          const ret = wasm.xmlypc_encryptedHeaderSize(this.__wbg_ptr);
          return ret >>> 0;
        }
        /**
         * Decrypt encrypted header
         * @param {Uint8Array} buffer
         * @returns {number}
         */
        decrypt(buffer) {
          var ptr0 = passArray8ToWasm0(buffer, wasm.__wbindgen_malloc);
          var len0 = WASM_VECTOR_LEN;
          const ret = wasm.xmlypc_decrypt(this.__wbg_ptr, ptr0, len0, buffer);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return ret[0] >>> 0;
        }
      }
      async function __wbg_load(module, imports) {
        if (typeof Response === "function" && module instanceof Response) {
          if (typeof WebAssembly.instantiateStreaming === "function") {
            try {
              return await WebAssembly.instantiateStreaming(module, imports);
            } catch (e) {
              if (module.headers.get("Content-Type") != "application/wasm") {
                console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
              } else {
                throw e;
              }
            }
          }
          const bytes = await module.arrayBuffer();
          return await WebAssembly.instantiate(bytes, imports);
        } else {
          const instance = await WebAssembly.instantiate(module, imports);
          if (instance instanceof WebAssembly.Instance) {
            return { instance, module };
          } else {
            return instance;
          }
        }
      }
      function __wbg_get_imports() {
        const imports = {};
        imports.wbg = {};
        imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
          let deferred0_0;
          let deferred0_1;
          try {
            deferred0_0 = arg0;
            deferred0_1 = arg1;
            console.error(getStringFromWasm0(arg0, arg1));
          } finally {
            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
          }
        };
        imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {
          const ret = new Error();
          return ret;
        };
        imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
          const ret = arg1.stack;
          const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len1 = WASM_VECTOR_LEN;
          getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
          getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
        };
        imports.wbg.__wbindgen_copy_to_typed_array = function(arg0, arg1, arg2) {
          new Uint8Array(arg2.buffer, arg2.byteOffset, arg2.byteLength).set(getArrayU8FromWasm0(arg0, arg1));
        };
        imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
          const ret = new Error(getStringFromWasm0(arg0, arg1));
          return ret;
        };
        imports.wbg.__wbindgen_init_externref_table = function() {
          const table = wasm.__wbindgen_export_3;
          const offset = table.grow(4);
          table.set(0, void 0);
          table.set(offset + 0, void 0);
          table.set(offset + 1, null);
          table.set(offset + 2, true);
          table.set(offset + 3, false);
        };
        imports.wbg.__wbindgen_throw = function(arg0, arg1) {
          throw new Error(getStringFromWasm0(arg0, arg1));
        };
        return imports;
      }
      function __wbg_finalize_init(instance, module) {
        wasm = instance.exports;
        __wbg_init.__wbindgen_wasm_module = module;
        cachedDataViewMemory0 = null;
        cachedUint8ArrayMemory0 = null;
        wasm.__wbindgen_start();
        return wasm;
      }
      async function __wbg_init(module_or_path) {
        if (wasm !== void 0) return wasm;
        if (typeof module_or_path !== "undefined") {
          if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
            ({ module_or_path } = module_or_path);
          } else {
            console.warn("using deprecated parameters for the initialization function; pass a single object instead");
          }
        }
        if (typeof module_or_path === "undefined") {
          module_or_path = new URL("data:application/wasm;base64,AGFzbQEAAAABtgIqYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AGADf39/AGABfwF/YAADf39/YAACf39gAn9/A39/f2AEf39/fwBgA39+fgBgAABgBX9/f39/AGAFf39/b38AYAAEf39/f2ABfwJ/f2ADf35+AX9gB39/f39/f38Bf2AGf39/f39/AGAAAX9gBX9/f39/AX9gBH9/f38Bf2ADf39/A39/f2ADf39vAn9/YAd/f39/f39/AGAEf39/bwN/f39gBH9/f38Df39/YAJ/fwR/f39/YAN/f28AYAJ/fwFvYAABb2ACf28AYAZ/f39/f38Bf2ADfn9/AX5gA39+fwBgAn9+AX9gDH9/f39/f39/f39/fwJ/f2ADf39vBH9/f39gBX9/f29/An9/YAF/A39/f2AEf39vfwBgBH9/f28AAuUBBwN3YmceX193YmluZGdlbl9jb3B5X3RvX3R5cGVkX2FycmF5ABwDd2JnFF9fd2JpbmRnZW5fZXJyb3JfbmV3AB0Dd2JnGl9fd2JnX25ld184YTZmMjM4YTZlY2U4NmVhAB4Dd2JnHF9fd2JnX3N0YWNrXzBlZDc1ZDY4NTc1YjBmM2MAHwN3YmccX193YmdfZXJyb3JfNzUzNGI4ZTlhMzZmMWFiNAABA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUACwPtA+sDBAUBBBgBBAQEAAQEAAwRAAUEDAUFEgEECQQMAAIFAgEgBQQEAwIBBAMDAwMECQQFAgIEAAIBAAEDAQERARgSAQQJBQIEBRMAAQEEABIUASEBEQQBAAAAAAAJBAQAAAAAAAAAAAIBFAQACQAAAAEEBAQBAQEDBAQiBAQAAwMJBAIBAAUABAQABAUEASMABQEVDAABBQMDAAIDAAkAEwQEBQUBAQEAAAkDAQAEAQUAAAADAwABAwoDAwoKCgwEAwkDAQEDAAABBAEDBAUDCgIBAQQBAQMBAQECBQMEBAEBAAQBAQEDCwMCCwICAgAJBQMDBAECAgIBAgMDBAIBJAAAAwMUBQUFAwMDAwMDAwMBAAUFAAUFBQUFBQUAAAAAAAMDAwAlAwUFBRkaGRsaGwMDAwMDEwUFFiYWFgEICAgICAgICAgICAgICQEnFxcXBRUABgEPDw8PDwAAAwMDAwoKCgMAEBAQEBAAAwUAAwQNDQ0NDQ0AKCkBAQEBFQEBAQEEAgMAAAAMAQEAAQEBAQEBAwEBAQEBAAUBAQEBAQEBAQEAAQEAAAEAAAAABAQEAAQDAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAABCwsAAAABAAAAAAAAAQACBAEAAAELBQQECwJwAZ8CnwJvAIABBQMBABEGCQF/AUGAgMAACwfBDU0GbWVtb3J5AgASX193YmdfbmNtZmlsZV9mcmVlAM4BC25jbWZpbGVfbmV3ANcCDG5jbWZpbGVfb3BlbgC8Ag9uY21maWxlX2RlY3J5cHQAvQITbmNtZmlsZV9hdWRpb09mZnNldADQAhBkZWNyeXB0WDJNSGVhZGVyANECEGRlY3J5cHRYM01IZWFkZXIA0gIRX193YmdfeG1seXBjX2ZyZWUAxwEUeG1seXBjX2dldEhlYWRlclNpemUAwQIKeG1seXBjX25ldwDCAhJ4bWx5cGNfYXVkaW9IZWFkZXIA2QIceG1seXBjX2VuY3J5cHRlZEhlYWRlck9mZnNldACWAhp4bWx5cGNfZW5jcnlwdGVkSGVhZGVyU2l6ZQCXAg54bWx5cGNfZGVjcnlwdACuAhNfX3diZ19qb294ZmlsZV9mcmVlANsBDmpvb3hmaWxlX3BhcnNlAK8CFWpvb3hmaWxlX2J1ZmZlckxlbmd0aACZAhBqb294ZmlsZV9kZWNyeXB0ALACFl9fd2JnX2t1Z291aGVhZGVyX2ZyZWUAyAEPa3Vnb3VoZWFkZXJfbmV3AMMCFWt1Z291aGVhZGVyX2F1ZGlvSGFzaADaAhNrdWdvdWhlYWRlcl92ZXJzaW9uAJoCGGt1Z291aGVhZGVyX29mZnNldFRvRGF0YQCbAhBfX3diZ19rdWdvdV9mcmVlAKgBEWt1Z291X2Zyb21faGVhZGVyAMQCEmt1Z291X2Zyb21IZWFkZXJWNQC+Ag1rdWdvdV9kZWNyeXB0APQCFWt1Z291X2RlY3J5cHREYXRhYmFzZQDTAgtkZWNyeXB0UU1DMQD7Ag9fX3diZ19xbWMyX2ZyZWUAsgEIcW1jMl9uZXcAxQIMcW1jMl9kZWNyeXB0APUCFF9fd2JnX3FtY2Zvb3Rlcl9mcmVlAJkBD3FtY2Zvb3Rlcl9wYXJzZQDGAg5xbWNmb290ZXJfZWtleQDbAg5xbWNmb290ZXJfc2l6ZQCcAhNxbWNmb290ZXJfbWVkaWFOYW1lANwCFV9fd2JnX3Fpbmd0aW5nZm1fZnJlZQDnARdxaW5ndGluZ2ZtX2dldERldmljZUtleQCDAhRxaW5ndGluZ2ZtX2dldEZpbGVJVgCxAg5xaW5ndGluZ2ZtX25ldwCyAhJxaW5ndGluZ2ZtX2RlY3J5cHQA9gINaW5pdFBhbmljSG9vawDvAxVfX3diZ19rdXdvaGVhZGVyX2ZyZWUA3AEQa3V3b2hlYWRlcl9wYXJzZQDHAhRrdXdvaGVhZGVyX3F1YWxpdHlJZACdAhVrdXdvaGVhZGVyX3Jlc291cmNlSWQAngIXa3V3b0JvZGlhbkNpcGhlckZhY3RvcnkAyAIYX193Ymdfa3dtZGVjaXBoZXJ2MV9mcmVlAOgBFWt3bWRlY2lwaGVydjFfZGVjcnlwdAD3AhNrdXdvVjJDaXBoZXJGYWN0b3J5AMkCFl9fd2JnX2t3bWRlY2lwaGVyX2ZyZWUAqQEZa3dtZGVjaXBoZXJfbWFrZV9kZWNpcGhlcgC/AhNrd21kZWNpcGhlcl9kZWNyeXB0APgCDmRlY3J5cHRRUkNGaWxlAKkCEWRlY3J5cHRRUkNOZXR3b3JrALMCEF9fd2JnX3hpYW1pX2ZyZWUA3QEReGlhbWlfZnJvbV9oZWFkZXIAygINeGlhbWlfZGVjcnlwdAD8AhV4aWFtaV9jb3B5UGxhaW5MZW5ndGgAnwIaX193YmdfYXVkaW90eXBlcmVzdWx0X2ZyZWUAzAEiX193YmdfZ2V0X2F1ZGlvdHlwZXJlc3VsdF9uZWVkTW9yZQDUAiJfX3diZ19zZXRfYXVkaW90eXBlcmVzdWx0X25lZWRNb3JlANgCI19fd2JnX2dldF9hdWRpb3R5cGVyZXN1bHRfYXVkaW9UeXBlAN0CI19fd2JnX3NldF9hdWRpb3R5cGVyZXN1bHRfYXVkaW9UeXBlAKUBD2RldGVjdEF1ZGlvVHlwZQDLAhFfX3diZ19taWd1M2RfZnJlZQDpARFtaWd1M2RfZnJvbUhlYWRlcgDMAhJtaWd1M2RfZnJvbUZpbGVLZXkAzQIObWlndTNkX2RlY3J5cHQA+QIPX193YmluZGdlbl9mcmVlAIYDEV9f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CwJAIABBACAAa0EDcSIGaiIFIABNDQAgACEDIAEhBCAGBEAgBiEHA0AgAyAELQAAOgAAIARBAWohBCADQQFqIQMgB0EBayIHDQALCyAGQQFrQQdJDQADQCADIAQtAAA6AAAgA0EBaiAEQQFqLQAAOgAAIANBAmogBEECai0AADoAACADQQNqIARBA2otAAA6AAAgA0EEaiAEQQRqLQAAOgAAIANBBWogBEEFai0AADoAACADQQZqIARBBmotAAA6AAAgA0EHaiAEQQdqLQAAOgAAIARBCGohBCADQQhqIgMgBUcNAAsLIAUgAiAGayIHQXxxIghqIQMCQCABIAZqIgRBA3FFBEAgAyAFTQ0BIAQhAQNAIAUgASgCADYCACABQQRqIQEgBUEEaiIFIANJDQALDAELIAMgBU0NACAEQQN0IgJBGHEhBiAEQXxxIglBBGohAUEAIAJrQRhxIQogCSgCACECA0AgBSACIAZ2IAEoAgAiAiAKdHI2AgAgAUEEaiEBIAVBBGoiBSADSQ0ACwsgB0EDcSECIAQgCGohAQsCQCADIAIgA2oiBk8NACACQQdxIgQEQANAIAMgAS0AADoAACABQQFqIQEgA0EBaiEDIARBAWsiBA0ACwsgAkEBa0EHSQ0AA0AgAyABLQAAOgAAIANBAWogAUEBai0AADoAACADQQJqIAFBAmotAAA6AAAgA0EDaiABQQNqLQAAOgAAIANBBGogAUEEai0AADoAACADQQVqIAFBBWotAAA6AAAgA0EGaiABQQZqLQAAOgAAIANBB2ogAUEHai0AADoAACABQQhqIQEgA0EIaiIDIAZHDQALCyAAC7MGAQR/IwBBIGsiAiQAAkACQAJAAkACQAJAAkACQAJAAkAgAQ4oAAcHBwcHBwcHAQMHBwIHBwcHBwcHBwcHBwcHBwcHBwcHBwQHBwcHBQYLIABBgAQ7AQogAEIANwECIABB3OAAOwEADAgLIABBgAQ7AQogAEIANwECIABB3OgBOwEADAcLIABBgAQ7AQogAEIANwECIABB3OQBOwEADAYLIABBgAQ7AQogAEIANwECIABB3NwBOwEADAULIABBgAQ7AQogAEIANwECIABB3MQAOwEADAQLIABBgAQ7AQogAEIANwECIABB3M4AOwEADAMLIAFB3ABGDQELAkAgAUH/BU0NACABEExF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IANB0ABqELoCIQEgAEGAgICAeDYCACAAIAE2AgQMBAtBAUEIQdiqwQAQ8wIACyAAIARBARAeQQghAQsgBCABQQEQsQMLIAdFDQAgBSAHQQEQsQMLIANB4ABqJAALngUCBn4Hf0GAgICAeCEOAkACQAJAAkACQCADQQdxDQBBhICAgHghDiADQQhJDQADQCADQQhrIQMgAkEIakEAIQ0gAikAAEHst8AAQcAAEFYhBgNAIAZCIIgiCCAGQoCAgIBwg4QhByABIA1BA3RqKQMAIQlCACEEQWghCkG4vsAAIQtCACEFA0AgCkGEvcAAai0AACIPQcAATw0EIApBnL3AAGotAAAhDCAPQQN0Qbi+wABqKQMAIAeDUEUEQCALKQMAIAWEIQULIAxBwABPDQUgDEEDdEG4vsAAaikDACAHg1BFBEAgCykDACAEhCEECyALQQhqIQsgCkEBaiIKDQALIAVC/////w+DIARCIIaEIAmFIgSnIgpBGnZB7LjAAGoxAABCCIYgCkEUdkE/cUGsucAAajEAAEIEhoQgCkEOdkE/cUHsucAAajEAAIRCCIYgCkEIdkE/cUGsusAAajEAAEIEhoQgBEI6iKdB7LrAAGoxAACEQgiGIARCNIinQT9xQay7wABqMQAAQgSGhCAEQi6Ip0E/cUHsu8AAajEAAIRCBIZC8P///w+DIARCKIinQT9xQay8wABqMQAAhCEFQgAhBEEAIQpBuL7AACELA0AgCkGcvcAAai0AACIMQcAATw0GIAxBA3RBuL7AAGopAwAgBYNQRQRAIApBwAFxDQggCykDACAEhCEECyALQQhqIQsgCkEBaiIKQSBHDQALIAQgBoVCIIYgCIQhBiANQQFqIg1BEEcNAAsgAiAGQiCJQay4wABBwAAQVjcAACECIANBB0sNAAsLIAAgDjYCAA8LIA9BwABB2MLAABDQAQALIAxBwABB2MLAABDQAQALIAxBwABB2MLAABDQAQALIApBwABB2MLAABDQAQALxRYCDH4TfyMAQRBrIh4kACABKAIEIg8gASkDGCIDIAKtQv8BgyIKhULzytHLp4zZsvUAhSIEQhCJIAQgASkDECIGQuHklfPW7Nm87ACFfCIEhSILIANC7d6R85bM3LfkAIUiAyAGQvXKzYPXrNu38wCFfCIGQiCJfCINIApCgICAgICAgIAB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ASgCACADQQxqIAFBBGooAgARAAANAiAAQQhqIQAgCyAIQSBqIghHDQALCyAHIAIoAgRPDQEgAygCKCACKAIAIAdBA3RqIgAoAgAgACgCBCADKAIsKAIMEQIARQ0BC0EBDAELQQALIANBMGokAAvKBAEGfyMAQTBrIgMkACADIAI2AgggAyABNgIEIANBIGogA0EEahBAAkACQCADKAIgIgZFBEBBACEBQQEhBgwBCyADKAIkIQEgAygCLEUNAAJAIAJBAEgNAAJAIAJFBEBBASEFDAELQdGywgAtAAAaQQEhBCACQQEQnAMiBUUNAQtBACEEIANBADYCFCADIAU2AhAgAyACNgIMIAEgAksEQCADQQxqQQAgARCOASADKAIQIQUgAygCFCEEIAMoAgwhAgsgBCAFaiAGIAEQLBogAyABIARqIgE2AhQgAiABa0ECTQRAIANBDGogAUEDEI4BIAMoAhAhBSADKAIUIQELIAEgBWoiAkHUjsIALwAAIgU7AAAgAkECakHWjsIALQAAIgc6AAAgAyABQQNqIgI2AhQgAyADKQIENwIYIANBIGogA0EYahBAIAMoAiAiBgRAA0AgAygCLCADKAIkIgEgAygCDCACa0sEQCADQQxqIAIgARCOASADKAIUIQILIAMoAhAiBCACaiAGIAEQLBogAyABIAJqIgI2AhQEQCADKAIMIAJrQQJNBEAgA0EMaiACQQMQjgEgAygCECEEIAMoAhQhAgsgAiAEaiIBIAU7AAAgAUECaiAHOgAAIAMgAkEDaiICNgIUCyADQSBqIANBGGoQQCADKAIgIgYNAAsLIAAgAykCDDcCACAAQQhqIANBFGooAgA2AgAMAgsgBCACQYiNwgAQ8wIACyAAIAE2AgggACAGNgIEIABBgICAgHg2AgALIANBMGokAAuWBAEEfyMAQYABayIEJAACQAJAAkAgASgCFCICQRBxRQRAIAJBIHENAUEBIQIgACgCAEEBIAEQa0UNAgwDCyAAKAIAIQIDQCADIARqQf8AaiACQQ9xIgVBMHIgBUHXAGogBUEKSRs6AAAgA0EBayEDIAJBEEkgAkEEdiECRQ0AC0EBIQIgAUEBQdeRwgBBAiADIARqQYABakEAIANrECdFDQEMAgsgACgCACECA0AgAyAEakH/AGogAkEPcSIFQTByIAVBN2ogBUEK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BSgCDCIIIA1CJYinaiAFKAIIIgsgCUEEdGogCUHwyKHkAWtzc2siBkEEdGogBkHwyKHkAWtzIAUoAgQiCSAGQQV2anNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0HXw4CqBGpzc2siBkEEdCAKaiAGQdfDgKoEanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0Hir93HBWtzc2siBkEEdCAKaiAGQeKv3ccFa3MgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0Hl3MTGAGpzc2siBkEEdCAKaiAGQeXcxMYAanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0Gs6ebUBmpzc2siBkEEdCAKaiAGQazp5tQGanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0GNivecA2tzc2siBkEEdCAKaiAGQY2K95wDa3MgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0G6gqvxAmpzc2siBkEEdCAKaiAGQbqCq/ECanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0H/8LKAB2tzc2siBkEEdCAKaiAGQf/wsoAHa3MgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0G45JDyAGtzc2siBkEEdCAKaiAGQbjkkPIAa3MgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0GPqJGcBWpzc2siBkEEdCAKaiAGQY+okZwFanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0Gqy8zVBGtzc2siBkEEdCAKaiAGQarLzNUEa3MgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0GdwdW4AWpzc2siBkEEdCAKaiAGQZ3B1bgBanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0HkzffGB2pzc2siBkEEdCAKaiAGQeTN98YHanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0HVpeaqAmtzc2siBkEEdCAKaiAGQdWl5qoCa3MgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0Hy5rvjA2pzc2siBkEEdCAKaiAGQfLmu+MDanMg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IAJBADYCDAJ/IAFBgBBPBEAgAUGAgARPBEAgAkEMakEDciEEIAIgAUESdkHwAXI6AAwgAiABQQZ2QT9xQYABcjoADiACIAFBDHZBP3FBgAFyOgANQQQMAgsgAkEMakECciEEIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAELIAJBDGpBAXIhBCACIAFBBnZBwAFyOgAMQQILIQMgBCABQT9xQYABcjoAACADIAAoAgAgACgCCCIBa0sEQCAAIAEgAxB3IAAoAgghAQsgACgCBCABaiACQQxqIAMQLBogACABIANqNgIIDAELIAAoAggiAyAAKAIARgRAIABB3MnBABCRAQsgACgCBCADaiABOgAAIAAgA0EBajYCCAsgAkEQaiQAQQALxQIBA38jAEEQayICJAACQCABQYABTwRAIAJBADYCDAJ/IAFBgBBPBEAgAUGAgARPBEAgAkEMakEDciEEIAIgAUESdkHwAXI6AAwgAiABQQZ2QT9xQYABcjoADiACIAFBDHZBP3FBgAFyOgANQQQMAgsgAkEMakECciEEIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAELIAJBDGpBAXIhBCACIAFBBnZBwAFyOgAMQQILIQMgBCABQT9xQYABcjoAACADIAAoAgAgACgCCCIBa0sEQCAAIAEgAxB3IAAoAgghAQsgACgCBCABaiACQQxqIAMQLBogACABIANqNgIIDAELIAAoAggiAyAAKAIARgRAIABBpMzBABCRAQsgACgCBCADaiABOgAAIAAgA0EBajYCCAsgAkEQaiQAQQAL7wIBAX8jAEEwayICJAACfwJAAkACQAJAIAAtAABBAWsOAwECAwALIAIgACgCBDYCACACIAAtAAE6AAcgAkEDNgIMIAJBiNXBADYCCCACQgI3AhQgAiACrUKAgICAwAyENwMoIAIgAkEHaq1CgICAgIAchDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQOAwDCyACIAAoAgQ2AgAgAkEBNgIMIAJBuNXBADYCCCACQgE3AhQgAiACrUKAgICAwAyENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahA4DAILIAIgACgCBDYCACACIAAtAAE6AAcgAkEDNgIMIAJB1NXBADYCCCACQgI3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SyAAQQR2IQANAAsgAUEBQdeRwgBBAiACIARqQYABakEAIAJrECcMAQsgACgCACEAQQAhAgNAIAIgBGpB/wBqIABBD3EiA0EwciADQTdqIANBCkkbOgAAIAJBAWshAiAAQQ9LIABBBHYhAA0ACyABQQFB15HCAEECIAIgBGpBgAFqQQAgAmsQJwsgBEGAAWokAAvLAQIFfwF+IwBBIGsiAiQAAkACQCABIAFBAWoiA0sNAEEIIAAoAgAiAUEBdCIEIAMgAyAESRsiAyADQQhJGyIErSIHQiCIUEUNACAHpyIFQf////8HSw0AIAIgAQR/IAIgATYCHCACIAAoAgQ2AhRBAQVBAAs2AhggAkEIakEBIAUgAkEUahChASACKAIIQQFHDQEgAigCECEDIAIoAgwhBgsgBiADQdzmwAAQ8wIACyACKAIMIQEgACAENgIAIAAgATYCBCACQSBqJAALywECBH8BfiMAQSBrIgMkAAJAAkAgASABIAJqIgJLDQBBCCAAKAIAIgFBAXQiBCACIAIgBEkbIgIgAkEISRsiBK0iB0IgiFBFDQAgB6ciBUH/////B0sNACADIAEEfyADIAE2AhwgAyAAKAIENgIUQQEFQQALNgIYIANBCGpBASAFIANBFGoQoQEgAygCCEEBRw0BIAMoAhAhAiADKAIMIQYLIAYgAkH4gcEAEPMCAAsgAygCDCEBIAAgBDYCACAAIAE2AgQgA0EgaiQAC8sBAgR/AX4jAEEgayIDJAACQAJAIAEgASACaiICSw0AQQggACgCACIBQQF0IgQgAiACIARJGyICIAJBCEkbIgStIgdCIIhQRQ0AIAenIgVB/////wdLDQAgAyABBH8gAyABNgIcIAMgACgCBDYCFEEBBUEACzYCGCADQQhqQQEgBSADQRRqEKEBIAMoAghBAUcNASADKAIQIQIgAygCDCEGCyAGIAJBrKTBABDzAgALIAMoAgwhASAAIAQ2AgAgACABNgIEIANBIGokAAvLAQIEfwF+IwBBIGsiAyQAAkACQCABIAEgAmoiAksNAEEIIAAoAgAiAUEBdCIEIAIgAiAESRsiAiACQQhJGyIErSIHQiCIUEUNACAHpyIFQf////8HSw0AIAMgAQR/IAMgATYCHCADIAAoAgQ2AhRBAQVBAAs2AhggA0EIakEBIAUgA0EUahChASADKAIIQQFHDQEgAygCECECIAMoAgwhBgsgBiACQbjKwQAQ8wIACyADKAIMIQEgACAENgIAIAAgATYCBCADQSBqJAALqgICA38BfiMAQUBqIgIkACABKAIAQYCAgIB4RgRAIAEoAgwhAyACQSRqIgRBADYCACACQoCAgIAQNwIcIAJBMGogAygCACIDQQhqKQIANwMAIAJBOGogA0EQaikCADcDACACIAMpAgA3AyggAkEcakGU4cEAIAJBKGoQOBogAkEYaiAEKAIAIgM2AgAgAiACKQIcIgU3AxAgAUEIaiADNgIAIAEgBTcCAAsgASkCACEFIAFCgICAgBA3AgAgAkEIaiIDIAFBCGoiASgCADYCACABQQA2AgBB0bLCAC0AABogAiAFNwMAQQxBBBCcAyIBRQRAQQRBDBDnAwALIAEgAikDADcCACABQQhqIAMoAgA2AgAgAEGo7sEANgIEIAAgATYCACACQUBrJAALrQMBCX8jAEGABGsiAiQAIAEoAgQhBgJAIAEoAggiA0UEQBC5AiEDIABBAjoAACAAIAM2AgQMAQsCQCAAAn8gA0GsAk0EQCACQfwCaiEFIwBBgAFrIggkAAJAIANFBEAQuQIhAyAFQQE6AAAgBSADNgIEDAELIAhBAEGAARBKIQkDQCAEIAlqIAYgBCAEbEGurARqIANwIgdqLQAAIgogB0EHcUEEcyIHdCAKIAd2cjoAACAEQQFqIgRBgAFHDQALIAVBAWogCUGAARAsGiAFQQA6AAALIAhBgAFqJAAgAi0A/AINAiACQYIBaiACLQD/AjoAACACIAIvAP0COwGAASACKAKAAyEDIAJBgAJqIgQgAkGEA2pB+QAQLBogAkGEAWoiBSAEQfkAECwaIAIgBUH5ABAsGkEADAELIAIgBiADECpBAQs6AAAgACACLwGAATsAASAAIAM2AgQgAEEDaiACQYIBai0AADoAACAAQQhqIAJB+QAQLBoMAQsgAigCgAMhAyAAQQI6AAAgACADNgIECyABKAIAIgAEQCAGIABBARCxAwsgAkGABGokAAv2AQEIfyABKAIIIgIgASgCBCIDIAIgA0sbIQggASgCACEFQX8hByACIQQCQAJAA0AgBCAIRg0BIAEgBEEBaiIGNgIIIAdBAWohByAEIAVqIAYhBC0AACIGQTBrQf8BcUEKSSAGQeEA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ACADKAIIIAMoAgQiAhshBEEJIAMoAgwgAhsLIQIgBCACIAEQngECQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCxAwwBCyAALQAEQQNHDQAgACgCCCIAKAIAIQEgAEEEaigCACICKAIAIgUEQCABIAURAwALIAIoAgQiBQRAIAEgBSACKAIIELEDCyAAQQxBBBCxAwsgA0EQaiQAC98BAgF+A38CQCABKAIYIgVFDQACQCABKQMAIgJQBEAgASgCECEEIAEoAgghAwNAIARBQGohBCADKQMAIANBCGohA0KAgYKEiJCgwIB/gyICQoCBgoSIkKDAgH9RDQALIAEgBDYCECABIAM2AgggASAFQQFrNgIYIAEgAkKAgYKEiJCgwIB/hSICQgF9IAKDNwMADAELIAEgBUEBazYCGCABIAJCAX0gAoM3AwAgASgCECIEDQAMAQsgBCACeqdB+ABxayIBQQRrIQQgAUEIayEDCyAAIAQ2AgQgACADNgIAC90BAQF/IwBBMGsiAiQAAn8CQAJAAkAgACgCAEEBaw4CAQIACyABQfirwQBBIBCHAwwCCyACIABBBGo2AgwgAkEBNgIUIAJBuKzBADYCECACQgE3AhwgAiACQQxqrUKAgICAoBWENwMoIAIgAkEoajYCGCABKAIcIAEoAiAgAkEQahA4DAELIAIgAEEEajYCDCACQQE2AhQgAkHgrMEANgIQIAJCATcCHCACIAJBDGqtQoCAgICgFYQ3AyggAiACQShqNgIYIAEoAhwgASgCICACQRBqEDgLIAJBMGokAAuUCAEEfyMAQUBqIgMkACADQQA2AhQgA0KAgICAEDcCDCADQbSxwAA2AjggA0EDOgAwIANCIDcCKCADQQA2AiAgA0EANgIYIAMgA0EMajYCNCADQRhqIQIjAEEwayIBJAACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAQQogACgCAEGAgICAeHMiBCAEQQ1PG0EBaw4MAQIDBAUGBwgJCgsMAAsgASAAQQRqNgIMIAFBAjYCFCABQayawQA2AhAgAUIBNwIcIAEgAUEMaq1CgICAgIARhDcDKCABIAFBKGo2AhggAigCHCACKAIgIAFBEGoQOAwMCyABIABBBGo2AgwgAUEBNgIUIAFB1JrBADYCECABQgE3AhwgASABQQxq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BiAGLwD8AjsB/AEgBigA/wIhAyAGQYACaiIJIAZBgwNqQfkAECwaIAsgCUH5ABAsGiAGQYABaiALQfkAECwaQQAMAQsgBkGAAWogASASECpBAQshCSAGKQOAASEgIAZBCGogBkGIAWpB8QAQLBogEQRAIAEgEUEBELEDCyAOIAk6AAAgDiAGLwH8ATsAASAOICA3AwggDiADNgIEIA5BA2ogBkH+AWotAAA6AAAgDkEQaiAGQQhqQfgAECwaDAILIAEhAwsgBiADNgKAASAGQQA2AogCIAZCgICAgBA3AoACIAZByJ3BADYCnAMgBkEDOgCUAyAGQiA3AowDIAZBADYChAMgBkEANgL8AiAGIAZBgAJqNgKYAyAGQYABaiIDIAZB/AJqENUDDQEgBigCgAIhASAGKQKEAiEgIAMQiAMgDiAgNwMIIA4gATYCBCAOQQI6AAALIAZBgARqJAAMAQtB8J3BAEE3IAZB/wNqQeCdwQBB9J7BABDCAQALIAQtALgBIglBAkcEQCAEIAQpALkBNwOQASAEIARBwAFqKQAANwCXASAEQRhqIARByAFqQfgAECwaIARBEGogBCkAlwE3AAAgBCAJOgAIIAQgBCkDkAE3AAkgEARAIAcgEEEBELEDCyAJQQJrIQNBACELDAMLIARBmwFqIARBxAFqKAIAIgE2AAAgBCAEKQK8ASIgNwCTASAKQQxqIAE2AAAgCiAgNwAEIApBBDoAACAQRQ0EIAcgEEEBELEDDAQLIApBBDoAACAKQYOAgIB4NgIEC0EBIQsMAQsgBEGYAWogD0EwaikAADcDACAEIA8pACg3A5ABAkACQAJAAkBBAiADIANBAk8bQQFrDgIBAgALIARBkAFqIgcgBEEIakEBciIBLQAAIgwgBy0AAHM6AAAgByAMIActAARzOgAEIAcgAUEBai0AACIJIActAAFzOgABIAcgAUECai0AACIDIActAAJzOgACIAcgAUEDai0AACIBIActAANzOgADIAcgCSAHLQAFczoABSAHIAMgBy0ABnM6AAYgByABIActAAdzOgAHIAcgDCAHLQAIczoACCAHIAkgBy0ACXM6AAkgByADIActAApzOgAKIAcgASAHLQALczoACyAHIAwgBy0ADHM6AAwgByAJIActAA1zOgANIAcgAyAHLQAOczoADiAHIAEgBy0AD3M6AA8MAgtBACEDA0AgBEGQAWogA2oiCSAEQQhqIANqIgFBAWotAAAgA0EQdiADQQh2cyADQRh2cyADc3MgCS0AACABQRFqLQAAcyIBQQR0cyABczoAACADQQFqIgNBEEcNAAsMAQsgCUEBcUUEQCAEQZABaiIDIARBCGpBAXIiAS0AACADLQAAczoAACADIAFBAWotAAAgAy0AAXM6AAEgAyABQQJqLQAAIAMtAAJzOgACIAMgAUEDai0AACADLQADczoAAyADIAFBBGotAAAgAy0ABHM6AAQgAyABQQVqLQAAIAMtAAVzOgAFIAMgAUEGai0AACADLQAGczoABiADIAFBB2otAAAgAy0AB3M6AAcgAyABQQhqLQAAIAMtAAhzOgAIIAMgAUEJai0AACADLQAJczoACSADIAFBCmotAAAgAy0ACnM6AAogAyABQQtqLQAAIAMtAAtzOgALIAMgAUEMai0AACADLQAMczoADCADIAFBDWotAAAgAy0ADXM6AA0gAyABQQ5qLQAAIAMtAA5zOgAOIAMgAUEPai0AACADLQAPczoADwwBCyAEQRBqIgEgBEGQAWpBEEEAEIQBIAEgBEGgAWpBAEEQEEgLIARBwAFqIA9B0ABqKQAANwMAIAQgDykASDcDuAECQCAEQZABaiAEQbgBakEQEO0BRQRAIAogBEEIakGIARAsGiALIAIoAgAiAUGAgICAeEdxDQEMAwsgCkEEOgAAIApBhYCAgHg2AgQgBC0ACCIBQQFLIAFFcg0BIAQoAhQiAQRAIAQoAhAgAUEBELEDCyAEKAIgQYAsQQEQsQMMAQsgAUUNASACKAIEIAFBARCxAwwBCyALRQ0AIAIoAgAiAUGAgICAeEYgAUVyDQAgAigCBCABQQEQsQMLIARBwAJqJAACQCANLQAIIgJBBEcEQCAAIA0vAAk7AAEgAEEDaiANLQALOgAAIA0oAgwhASAAQQhqIA1BEGpBgAEQLBoMAQsgDUGYAWogDUEUaigCADYCACANIA0pAgw3A5ABIA1BkAFqEIkBIQELIAAgAjoAACAAIAE2AgQgDUGgAWokAAuaAQECfyMAQSBrIgMkAAJAIAAEQCADIAI2AhwgAyABNgIYIAMgAjYCFCADQQhqIANBFGpBrJ7AABDNASAAKAIADQEgAygCDCEBIAMoAgghAiAAQX82AgAgACgCBCIEBEAgACgCCCAEQQEQsQMLIAAgAjYCCCAAQQA2AgAgACABNgIMIAAgATYCBCADQSBqJAAPCxDbAwALENwDAAvFAwEDfyMAQUBqIgEkACABQQA2AhQgAUKAgICAEDcCDCABQbSxwAA2AjggAUEDOgAwIAFCIDcCKCABQQA2AiAgAUEANgIYIAEgAUEMajYCNCABQRhqIQIjAEEwayIDJAACfwJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCAEEBaw4KAQIDBAUGBwgJCgALIAJBgOrAAEEVEIcDDAoLIAMgAEEEajYCDCADQQI2AhQgA0G86sAANgIQIANCATcCHCADIANBDGqtQoCAgICAC4Q3AyggAyADQShqNgIYIAIoAhwgAigCICADQRBqEDgMCQsgAkHM6sAAQS4QhwMMCAsgAkH66sAAQSEQhwMMBwsgAkGb68AAQSgQhwMMBgsgAkHD68AAQR4QhwMMBQsgAkHh68AAQSMQhwMMBAsgAkGE7MAAQSYQhwMMAwsgAkGq7MAAQSAQhwMMAgsgAkHK7MAAQSMQhwMMAQsgAkHt7MAAQSYQhwMLIANBMGokAEUEQCABKAIMIQAgASgCECICIAEoAhQQ+gIgAARAIAIgAEEBELEDCyABQUBrJAAPC0HcscAAQTcgAUE/akHMscAAQeCywAAQwgEAC4cHAQN/IwBBQGoiAyQAIANBADYCFCADQoCAgIAQNwIMIANBtLHAADYCOCADQQM6ADAgA0IgNwIoIANBADYCICADQQA2AhggAyADQQxqNgI0IANBGGohAiMAQdAAayIBJAACfwJAAkACQAJAAkACQAJAIAAtAABBAWsOBgECAwQFBgALIAEgAEEEajYCKCABQQI2AjQgAUH018EANgIwIAFCATcCPCABIAFBKGqtQoCAgICQHIQ3AxAgASABQRBqNgI4IAIoAhwgAigCICABQTBqEDgMBgsgASAAQQRqNgIoIAFBAjYCNCABQaTYwQA2AjAgAUIBNwI8IAEgAUEoaq1CgICAgJAchDcDECABIAFBEGo2AjggAigCHCACKAIgIAFBMGoQOAwFCyABIABBBGo2AiggAUECNgI0IAFB1NjBADYCMCABQgE3AjwgASABQShqrUKAgICAkByENwMQIAEgAUEQajYCOCACKAIcIAIoAiAgAUEwahA4DAQLIAEgAEEBajYCDCABIAFBDGqtQoCAgICgHIQ3AyggAUEBNgIkIAFBATYCFCABQYDZwQA2AhAgAUEBNgIcIAFBAzoATCABQRA2AkggAUIgNwJAIAFCgICAgCA3AjggAUECNgIwIAEgAUEwajYCICABIAFBKGo2AhggAigCHCACKAIgIAFBEGoQOAwDCyABIABBAWo2AgwgASABQQxqrUKAgICAsByENwMoIAFBATYCJCABQQE2AhQgAUGk2cEANgIQIAFBATYCHCABQQM6AEwgAUEANgJIIAFCIDcCQCABQoCAgIAgNwI4IAFBAjYCMCABIAFBMGo2AiAgASABQShqNgIYIAIoAhwgAigCICABQRBqEDgMAgsgASAAQQFqNgIoIAFBATYCNCABQcjZwQA2AjAgAUIBNwI8IAEgAUEoaq1CgICAgMAchDcDECABIAFBEGo2AjggAigCHCACKAIgIAFBMGoQOAwBCyABIABBAWo2AiggAUEBNgI0IAFB6NnBADYCMCABQgE3AjwgASABQShqrUKAgICA0ByENwMQIAEgAUEQajYCOCACKAIcIAIoAiAgAUEwahA4CyABQdAAaiQARQRAIAMoAgwhACADKAIQIgEgAygCFBD6AiAABEAgASAAQQEQsQMLIANBQGskAA8LQdyxwABBNyADQT9qQcyxwABB4LLAABDCAQALlwIBA38jAEGQAWsiAiQAAkACQCABRQRAIAJBCGohBCMAQZABayIDJAACQAJAIAAEQCAAQQhrIgEoAgBBAUcNASADIABBkAEQLCEDIAFBADYCAAJAIAFBf0YNACAAQQRrIgAgACgCAEEBayIANgIAIAANACABQZgBQQgQsQMLIAQgA0EIakGIARAsGiADQZABaiQADAILENsDAAtB7orAAEE/ENoDAAsgAi0ACCIAQQFLIABFcg0BIAIoAhQiAARAIAIoAhAgAEEBELEDCyACKAIgQYAsQQEQsQMMAQsgAEUNASACIABBCGsiADYCCCAAIAAoAgBBAWsiADYCACAADQAgAkEIahD+AQsgAkGQAWokAA8LENsDAAuXAgEDfyMAQZABayICJAACQAJAIAFFBEAgAkEIaiEEIwBBkAFrIgMkAAJAAkAgAARAIABBCGsiASgCAEEBRw0BIAMgAEGQARAsIQMgAUEANgIAAkAgAUF/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KAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIcIAEoAiAgAkEIahA4CyACQSBqJAALhwECAX8BfiMAQRBrIgIkACACQQA2AgQgAkEIaiABIAJBBGpBBBDzAQJAAkACfyACLQAIQQRGBEAgAigCBAwBCyACKQMIIgNC/wGDQgRSDQEgA0IgiKcLIQEgAEGNgICAeDYCACAAIAE2AgQMAQsgACADNwIEIABBi4CAgHg2AgALIAJBEGokAAuOAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGUosEANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakH4osEAEMACAAsgAEEIahCCASAAKAIIIgJFDQAgACgCDCACQQxsQQQQsQMLIABBHEEEELEDIAFBIGokAAuOAQECfyMAQSBrIgMkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GUosEANgIEIANCADcCECADIANBHGo2AgwgA0EEakH4osEAEMACAAsgAEEIahCCASAAKAIIIgRFDQAgACgCDCAEQQxsQQQQsQMLIABBHEEEELEDIANBIGokAAuOAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUH8usEANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakHgu8EAEMACAAsgAEEIahCDASAAKAIIIgJFDQAgACgCDCACQQxsQQQQsQMLIABBLEEEELEDIAFBIGokAAuOAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUH8usEANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakHgu8EAEMACAAsgAEEIahCDASAAKAIIIgJFDQAgACgCDCACQQxsQQQQsQMLIABBJEEEELEDIAFBIGokAAuOAQECfyMAQSBrIgMkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0H8usEANgIEIANCADcCECADIANBHGo2AgwgA0EEakHgu8EAEMACAAsgAEEIahCDASAAKAIIIgRFDQAgACgCDCAEQQxs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ayIDJAACQAJAAkAgAC0AEEEBaw4CAgABCyADQQE2AgggA0HkocAANgIEIANCADcCECADIANBHGo2AgwgA0EEakHIosAAEMACAAsgACgCCCIFBEAgACgCBCEEA0AgBCgCCCIGBEAgBCgCBEEkaiEBA0AgAUEEaygCACICQYCAgIB4RiACRXJFBEAgASgCACACQQEQsQMLAkAgAUEUaygCACIHQQJGDQAgAUEQayECIAdFBEAgAigCACICRQ0BIAFBDGsoAgAgAkEBELEDDAELIAIoAgAiAkUNACABQQxrKAIAIAJBAXRBAhCxAwsgAUEsaiEBIAZBAWsiBg0ACwsgBCgCACIBBEAgBEEEaigCACABQSxsQQQQsQMLIARBDGohBCAFQQFrIgUNAAsLIAAoAgAiAUUNACAAKAIEIAFBDGxBBBCxAwsgA0EgaiQAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQeSPwgA2AgggA0ICNwIUIANCgICAgMAMIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhDAAgALbQEBfyAALQAEIQEgAC0ABQRAIAACf0EBIAFBAXENABogACgCACIBLQAUQQRxRQRAIAEoAhxBz5HCAEECIAEoAiAoAgwRAgAMAQsgASgCHEHOkcIAQQEgASgCICgCDBECAAsiAToABAsgAUEBcQt0AQF/IwBBIGsiASQAAkAgACgCBEECRw0AAkACQCAALQAYQQFrDgICAAELIAFBATYCCCABQYyFwQA2AgQgAUIANwIQIAEgAUEcajYCDCABQQRqQfCFwQAQwAIACyAAQQhqEHsLIABBMEEEELEDIAFBIGokAAt0AQF/IwBBIGsiAyQAAkAgACgCBEECRw0AAkACQCAALQAYQQFrDgICAAELIANBATYCCCADQYyFwQA2AgQgA0IANwIQIAMgA0EcajYCDCADQQRqQfCFwQAQwAIACyAAQQhqEHsLIABBMEEEELEDIANBIGokAAtkAQF/IwBBEGsiACQAAn8gAigCAARAQfDswQAhA0EJDAELIABBBGogAigCBCACKAIIEC5B8OzBACAAKAIIIAAoAgQiAhshA0EJIAAoAgwgAhsLIQIgAyACIAEQngEgAEEQaiQAC2cAIwBBMGsiACQAQdCywgAtAAAEQCAAQQI2AgwgAEGg7cEANgIIIABCATcCFCAAIAE2AiwgACAAQSxqrUKAgICAwAyENwMgIAAgAEEgajYCECAAQQhqQcjtwQAQwAIACyAAQTBqJAALawEDfwJAIAEoAggiAkEATgRAIAEoAgQhBCACRQRAQQEhAQwCC0HRssIALQAAGkEBIQMgAkEBEJwDIgENAQsgAyACQcSOwgAQ8wIACyABIAQgAhAsIQEgACACNgIIIAAgATYCBCAAIAI2AgALaQEBfwJ/IAIoAgQEQCACKAIIIgNFBEBB0bLCAC0AABogAUEBEJwDDAILIAIoAgAgA0EBIAEQgQMMAQtB0bLCAC0AABogAUEBEJwDCyECIAAgATYCCCAAIAJBASACGzYCBCAAIAJFNgIAC18BAn8CQAJAIAEEQCABQQhrIgMgAygCAEEBaiICNgIAIAJFDQEgASgCACICQX9GDQIgACADNgIIIAAgATYCBCAAIAFBBGo2AgAgASACQQFqNgIADwsQ2wMLAAsQ3AMAC18BAn8CQAJAIAEEQCABQQhrIgMgAygCAEEBaiICNgIAIAJFDQEgASgCACICQX9GDQIgACADNgIIIAAgATYCBCAAIAFBCGo2AgAgASACQQFqNgIADwsQ2wMLAAsQ3AMAC3IBAn8CQCAAKAIAIgJBBEYNACAAKAIgIgFBgICAgHhGIAFFckUEQCAAKAIkIAFBARCxAwsCQAJAIAJBAWsOAwACAQILIAAoAgQiAUUNACAAKAIIIAFBARCxAwsgACgCECIBRQ0AIAAoAhQgAUEBELEDCwvfAQEDfyMAQYADayICJAACQAJAIAFFBEAgAkEIaiEEIwBBgANrIgMkAAJAIAAEQCAAQQhrIgEoAgBBAUcNASADIABBgAMQLCEDIAFBADYCAAJAIAFBf0YNACAAQQRrIgAgACgCAEEBayIANgIAIAANACABQYgDQQgQsQMLIAQgA0EIakH4AhAsGiADQYADaiQADAMLENsDAAtB7orAAEE/ENoDAAsgAEUNASACIABBCGsiADYCCCAAIAAoAgBBAWsiADYCACAADQAgAkEIahC1AgsgAkGAA2okAA8LENsDAAu9AQECfyMAQUBqIgIkAAJAAkAgAUUEQCACQQRqIQMgAARAIABBCGsiASgCAEEBRgRAIAMgAEEEakE8ECwaIAFBADYCAAJAIAFBf0YNACAAQQRrIgAgACgCAEEBayIANgIAIAANACABQcgAQQQQsQMLDAMLQYCdwABBPxDaAwALENsDAAsgAEUNASACIABBCGsiADYCBCAAIAAoAgBBAWsiADYCACAADQAgAkEEahC3AgsgAkFAayQADwsQ2wMAC8oBAQJ/IwBBEGsiAiQAAkACQCABRQRAIAJBBGohAyAABEAgAEEIayIBKAIAQQFGBEAgAyAAKQIENwIAIANBCGogAEEMaigCADYCACABQQA2AgACQCABQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgAUEYQQQQsQMLDAMLQYCdwABBPxDaAwALENsDAAsgAEUNASACIABBCGsiADYCBCAAIAAoAgBBAWsiADYCACAADQAgAkEEahC2AgsgAkEQaiQADwsQ2wMAC2MBAX5B0bLCAC0AABogACkCACEDQSRBBBCcAyIABEAgACABNgIAIAAgAzcCHCAAIAIpAgA3AgQgAEEMaiACQQhqKQIANwIAIABBFGogAkEQaikCADcCACAADwtBBEEkEOcDAAtrAQJ/IAAoAgAhASAAQYCAxAA2AgACQCABQYCAxABHDQBBgIDEACEBIAAoAgQiAiAAKAIIRg0AIAAgAkEBajYCBCAAIAAoAgwiACACLQAAIgFBD3FqLQAANgIAIAAgAUEEdmotAAAhAQsgAQtrAQF/IwBBIGsiASQAAkAgACgCBEECRw0AAkACQCAALQAYQQFrDgICAAELIAFBATYCCCABQYyFwQA2AgQgAUIANwIQIAEgAUEcajYCDCABQQRqQfCFwQAQwAIACyAAQQhqEHsLIAFBIGokAAtfAQJ/AkAgAkEATgRAIAJFBEBBASEEDAILQdGywgAtAAAaQQEhAyACQQEQnAMiBA0BCyADIAJBsJDAABDzAgALIAQgASACECwhASAAIAI2AgggACABNgIEIAAgAjYCAAtfAQJ/AkAgAkEATgRAIAJFBEBBASEEDAILQdGywgAtAAAaQQEhAyACQQEQnAMiBA0BCyADIAJBjLjBABDzAgALIAQgASACECwhASAAIAI2AgggACABNgIEIAAgAjYCAAtYAQJ/IwBBEGsiAiQAIAEtAABBA0cEf0EABSACQQhqIAEoAgQiASgCACABKAIEKAIkEQEAIAIoAgwhAyAC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IABFDQEgAiAAQQhrIgA2AgAgACAAKAIAQQFrIgA2AgAgAA0AIAIQuAILIAJBkANqJAAPCxDbAwALrQICBX8BfiMAQSBrIgIkAAJAAkAgAUUEQCMAQSBrIgEkACAABEAgAEEIayIDKAIAQQFGBEAgAUEYaiIEIABBHGopAgA3AwAgAUEQaiIFIABBFGopAgA3AwAgAUEIaiIGIABBDGopAgA3AwAgACkCBCEHIANBADYCACABIAc3AwACQCADQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgA0EsQQQQsQMLIAIgASkDADcAACACQRhqIAQpAwA3AAAgAkEQaiAFKQMANwAAIAJBCGogBikDADcAACABQSBqJAAMAwtBgJ3AAEE/ENoDAAsQ2wMACyAARQ0BIAIgAEEIayIANgIAIAAgACgCAEEBayIANgIAIAANACACELQCCyACQSBqJAAPCxDbAwALrQICBX8BfiMAQSBrIgIkAAJAAkAgAUUEQCMAQSBrIgEkACAABEAgAEEIayIDKAIAQQFGBEAgAUEYaiIEIABBHGopAgA3AwAgAUEQaiIFIABBFGopAgA3AwAgAUEIaiIGIABBDGopAgA3AwAgACkCBCEHIANBADYCACABIAc3AwACQCADQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgA0EsQQQQsQMLIAIgASkDADcAACACQRhqIAQpAwA3AAAgAkEQaiAFKQMANwAAIAJBCGogBikDADcAACABQSBqJAAMAwtBqLPAAEE/ENoDAAsQ2wMACyAARQ0BIAIgAEEIayIANgIAIAAgACgCAEEBayIANgIAIAANACACELQCCyACQSBqJAAPCxDbAwALZAICfwF+IwBBEGsiAiQAQQBByILBACgCABEFACIBBEAgACABKQMINwMIIAAgASkDACIDNwMAIAEgA0IBfDcDACACQRBqJAAPC0Hg/sAAQcYAIAJBD2pB0P7AAEH4/8AAEMIBAAtxAQN/QfjywgAtAABB+PLCAEEBOgAAQYDzwgAoAgAhAkGA88IAQQQ2AgBBhPPCAEEANgIAQYjzwgBBADYCAEGM88IAQQA2AgBB/PLCACgCACEAQfzywgBBADYCAEUgAEVyRQRAIAIgAEECdEEEELEDCwtQAQN/IAAtAABBA0YEQCAAKAIEIgAo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NgIYIAFBATYCDCABQeSVwgA2AgggAUIENwIQIAFBCGogABDAAgALNwEBfyMAQSBrIgEkACABQQA2AhggAUEBNgIMIAFBuKjCADYCCCABQgQ3AhAgAUEIaiAAEMACAAssAQF/IwBBEGsiACQAIABBCGoiAiABQdTiwQBBCxDOAiACENEBIABBEGokAAv2AwEGfyMAQRBrIgQkABBNIgYgAiYBIAEhAyMAQUBqIgEkACABIAM2AjggASAANgI0IAEgAzYCMCABQQhqIAFBMGoiCEGMm8AAEM0BIAEgBjYCHCABIAEoAgwiADYCGCABIAEoAggiAzYCFCABQSBqIQYCQAJAIABBC08EQCADQaDDwABBCxDtAUUNAQsgBkGDgICAeDYCAAwBCwJAIABBC2siAEEASA0AAkAgAEUEQEEBIQcMAQtB0bLCAC0AABpBASEFIABBARCcAyIHRQ0BCyAHIANBC2ogABAsIgMgAEELEIABIAYgAyAAECAgAARAIAMgAEEBELEDCwwBCyAFIABB3LfAABDzAgALIAQCfwJAAkAgASgCIEGEgICAeEcEQCABQThqIAFBKGopAgA3AwAgASABKQIgNwMwIAgQlAEhACABQRRqEIYCDAELIAEoAiQhAyABKAIsIQUgASgCKCEAIAFBFGoQhgIgA0GAgICAeEcNAQtBACEDQQAhBUEBDAELIAEgBTYCOCABIAA2AjQgASADNgIwIAEgAUEwakGcm8AAEM0BIAEoAgQhBSABKAIAIQNBACEAQQALNgIMIAQgADYCCCAEIAU2AgQgBCADNgIAIAFBQGskACAEKAIAIAQoAgQgBCgCCCAEKAIMIARBEGokAAsvAQF/IAAtAAAEQCAAKAIMIgEEQCAAKAIIIAFBARCxAwsgACgCGEGALEEBELEDCwugAQEDfyMAQSBrIgMkACADQQhqIgIQrgECf0HRssIALQAAGkEwQQQQnAMiAQRAIAFBoK3AADYCACABIAIpAgA3AgQgASAAKQIANwIcIAFBDGogAkEIaikCADcCACABQRRqIAJBEGopAgA3AgAgAUEkaiAAQQhqKQIANwIAIAFBLGogAEEQaigCADYCACABDAELQQRBMBDnAwALIANBIGokAAsqAQJ/IwBBIGsiASQAIAFBCGoiAhCuASAAQbitwAAgAhDeASABQSBqJAALOAEBf0EBIQEgAC0ABEUEQCAAKAIAIgEoAhxB1pHCAEEBIAEoAiAoAgwRAgAhAQsgACABOgAEIAELxmcCLn8DfiMAQRBrIiokABBNIgYgAyYBIAIhCUEAIQIjAEFAaiIYJAAgGEEcaiIxIAAQ2AEgGCgCHCEdIBggCTYCPCAYIAE2AjggGCAJNgI0IBhBEGogGEE0akHAgcAAEM0BIBggBjYCMCAYIBgoAhQiIjYCLCAYIBgoAhAiADYCKCAYQQhqITAjAEEQayIoJAAgKEEEaiEpIwBB0AprIgkkACAJQZAEakHo5cAAKQAANwMAIAlBiARqQeDlwAApAAA3AwAgCUGABGpB2OXAACkAADcDACAJQdDlwAApAAA3A/gDIAlBCGohHiMAQeADayIBJAAgAUFAa0EAQaADEEoaIAEgCUH4A2oiBigADCIFQQF2IAVzQdWq1aoFcSIPIAVzIgcgBigACCIIQQF2IAhzQdWq1aoFcSIQIAhzIhNBAnZzQbPmzJkDcSIRIAdzIgwgBigABCIHQQF2IAdzQdWq1aoFcSISIAdzIgsgBigAACINQQF2IA1zQdWq1aoFcSIUIA1zIhVBAnZzQbPmzJkDcSIWIAtzIhdBBHZzQY+evPgAcSIfIAxzNgIcIAEgBigAHCIMQQF2IAxzQdWq1aoFcSIjIAxzIg4gBigAGCILQQF2IAtzQdWq1aoFcSIgIAtzIhlBAnZzQbPmzJkDcSIkIA5zIiUgBigAFCIOQQF2IA5zQdWq1aoFcSIaIA5zIiEgBigAECIGQQF2IAZzQdWq1aoFcSImIAZzIhtBAnZzQbPmzJkDcSInICFzIiFBBHZzQY+evPgAcSIcICVzNgI8IAEgBSAPQQF0cyIFIAggEEEBdHMiCEECdnNBs+bMmQNxIg8gBXMiBSAHIBJBAXRzIgcgDSAUQQF0cyINQQJ2c0Gz5syZA3EiECAHcyIHQQR2c0GPnrz4AHEiEiAFczYCGCABIBFBAnQgE3MiBSAWQQJ0IBVzIhNBBHZzQY+evPgAcSIRIAVzNgIUIAEgH0EEdCAXczYCDCABIAwgI0EBdHMiBSALICBBAXRzIgxBAnZzQbPmzJkDcSILIAVzIgUgDiAaQQF0cyIOIAYgJkEBdHMiBkECdnNBs+bMmQNxIhQgDnMiDkEEdnNBj568+ABxIhUgBXM2AjggASAkQQJ0IBlzIgUgJ0ECdCAbcyIWQQR2c0GPnrz4AHEiFyAFczYCNCABIBxBBHQgIXM2AiwgASAPQQJ0IAhzIgUgEEECdCANcyIIQQR2c0GPnrz4AHEiDSAFczYCECABIBJBBHQgB3M2AgggASARQQR0IBNzNgIEIAEgC0ECdCAMcyIFIBRBAnQgBnMiBkEEdnNBj568+ABxIgcgBXM2AjAgASAVQQR0IA5zNgIoIAEgF0EEdCAWczYCJCABIA1BBHQgCHM2AgAgASAHQQR0IAZzNgIgQcAAIQVBCCEIA0AgAUH4ACAIEEcgASAEaiIGQUBrIgcQMCAHIAcoAgBBf3M2AgAgBkHEAGoiByAHKAIAQX9zNgIAIAZB1ABqIgcgBygCAEF/czYCACAGQdgAaiIHIAcoAgBBf3M2AgAgASAFaiIHIAcoAgBBgIADczYCACABQfgAIAhBCGoiCEEQQQ4QISAEQYADRgRAQQAhBANAIAEgBGoiBkFAayIFIAUoAgAiBUEEdiAFc0GAnoD4AHFBEWwgBXM2AgAgBkEgaiIFIAUoAgAiBUEEdiAFc0GAmLwYcUERbCAFcyIFQQJ2IAVzQYDmgJgDcUEFbCAFczYCACAGQSRqIgUgBSgCACIFQQR2IAVzQYCYvBhxQRFsIAVzIgVBAnYgBXNBgOaAmANxQQVsIAVzNgIAIAZBKGoiBSAFKAIAIgVBBHYgBXNBgJi8GHFBEWwgBXMiBUECdiAFc0GA5oCYA3FBBWwgBXM2AgAgBkEsaiIFIAUoAgAiBUEEdiAFc0GAmLwYcUERbCAFcyIFQQJ2IAVzQYDmgJgDcUEFbCAFczYCACAGQTBqIgUgBSgCACIFQQR2IAVzQYCYvBhxQRFsIAVzIgVBAnYgBXNBgOaAmANxQQVsIAVzNgIAIAZBNGoiBSAFKAIAIgVBBHYgBXNBgJi8GHFBEWwgBXMiBUECdiAFc0GA5oCYA3FBBWwgBXM2AgAgBkE4aiIFIAUoAgAiBUEEdiAFc0GAmLwYcUERbCAFcyIFQQJ2IAVzQYDmgJgDcUEFbCAFczYCACAGQTxqIgUgBSgCACIFQQR2IAVzQYCYvBhxQRFsIAVzIgVBAnYgBXNBgOaAmANxQQVsIAVzNgIAIAZBxABqIgUgBSgCACIFQQR2IAVzQYCegPgAcUERbCAFczYCACAGQcgAaiIFIAUoAgAiBUEEdiAFc0GAnoD4AHFBEWwgBXM2AgAgBkHMAGoiBSAFKAIAIgVBBHYgBXNBgJ6A+ABxQRFsIAVzNgIAIAZB0ABqIgUgBSgCACIFQQR2IAVzQYCegPgAcUERbCAFczYCACAGQdQAaiIFIAUoAgAiBUEEdiAFc0GAnoD4AHFBEWwgBXM2AgAgBkHYAGoiBSAFKAIAIgVBBHYgBXNBgJ6A+ABxQRFsIAVzNgIAIAZB3ABqIgUgBSgCACIFQQR2IAVzQYCegPgAcUERbCAFczYCACAGQeAAaiIFIAUoAgAiBUEEdiAFc0GAhrzgAHFBEWwgBXMiBUECdiAFc0GA5oCYA3FBBWwgBXM2AgAgBkHkAGoiBSAFKAIAIgVBBHYgBXNBgIa84ABxQRFsIAVzIgVBAnYgBXNBgOaAmANxQQVsIAVzNgIAIAZB6ABqIgUgBSgCACIFQQR2IAVzQYCGvOAAcUERbCAFcyIFQQJ2IAVzQYDmgJgDcUEFbCAFczYCACAGQewAaiIFIAUoAgAiBUEEdiAFc0GAhrzgAHFBEWwgBXMiBUECdiAFc0GA5oCYA3FBBWwgBXM2AgAgBkHwAGoiBSAFKAIAIgVBBHYgBXNBgIa84ABxQRFsIAVzIgVBAnYgBXNBgOaAmANxQQVsIAVzNgIAIAZB9ABqIgUgBSgCACIFQQR2IAVzQYCGvOAAcUERbCAFcyIFQQJ2IAVzQYDmgJgDcUEFbCAFczYCACAGQfgAaiIFIAUoAgAiBUEEdiAFc0GAhrzgAHFBEWwgBXMiBUECdiAFc0GA5oCYA3FBBWwgBXM2AgAgBkH8AGoiBiAGKAIAIgZBBHYgBnNBgIa84ABxQRFsIAZzIgZBAnYgBnNBgOaAmANxQQVsIAZzNgIAIARBgAFqIgRBgANHDQALIAEgASgCIEF/czYCICABIAEoAiRBf3M2AiQgASABKAI0QX9zNgI0IAEgASgCqAMiBkEEdiAGc0GAmLwYcUERbCAGcyIGQQJ2IAZzQYDmgJgDcUEFbCAGczYCqAMgASABKAKsAyIGQQR2IAZzQYCYvBhxQRFsIAZzIgZBAnYgBnNBgOaAmANxQQVsIAZzNgKsAyABIAEoArADIgZBBHYgBnNBgJi8GHFBEWwgBnMiBkECdiAGc0GA5oCYA3FBBWwgBnM2ArADIAEgASgCvAMiBkEEdiAGc0GAmLwYcUERbCAGcyIGQQJ2IAZzQYDmgJgDcUEFbCAGczYCvAMgASgCoAMhBiABKAKkAyEEIAEoArQDIQUgASgCuAMhCCABIAEoAjhBf3M2AjggASABKAJAQX9zNgJAIAEgASgCREF/czYCRCABIAEoAlRBf3M2AlQgASABKAJYQX9zNgJYIAEgASgCYEF/czYCYCABIAEoAmRBf3M2AmQgASABKAJ0QX9zNgJ0IAEgASgCeEF/czYCeCABIAEoAoABQX9zNgKAASABIAEoAoQBQX9zNgKEASABIAEoApQBQX9zNgKUASABIAEoApgBQX9zNgKYASABIAEoAqABQX9zNgKgASABIAEoAqQBQX9zNgKkASABIAEoArQBQX9zNgK0ASABIAEoArgBQX9zNgK4ASABIAEoAsABQX9zNgLAASABIAEoAsQBQX9zNgLEASABIAEoAtQBQX9zNgLUASABIAEoAtgBQX9zNgLYASABIAEoAuABQX9zNgLgASABIAEoAuQBQX9zNgLkASABIAEoAvQBQX9zNgL0ASABIAEoAvgBQX9zNgL4ASABIAEoAoACQX9zNgKAAiABIAEoAoQCQX9zNgKEAiABIAEoApQCQX9zNgKUAiABIAEoApgCQX9zNgKYAiABIAEoAqACQX9zNgKgAiABIAEoAqQCQX9zNgKkAiABIAEoArQCQX9zNgK0AiABIAEoArgCQX9zNgK4AiABIAEoAsACQX9zNgLAAiABIAEoAsQCQX9zNgLEAiABIAEoAtQCQX9zNgLUAiABIAEoAtgCQX9zNgLYAiABIAEoAuACQX9zNgLgAiABIAEoAuQCQX9zNgLkAiABIAEoAvQCQX9zNgL0AiABIAEoAvgCQX9zNgL4AiABIAEoAoADQX9zNgKAAyABIAEoAoQDQX9zNgKEAyABIAEoApQDQX9zNgKUAyABKAKYAyEHIAEgCCAIIAhBBHZzQYCYvBhxQRFscyIIQQJ2IAhzQYDmgJgDcUEFbCAIc0F/czYCuAMgASAFIAUgBUEEdnNBgJi8GHFBEWxzIgVBAnYgBXNBgOaAmANxQQVsIAVzQX9zNgK0AyABIAQgBCAEQQR2c0GAmLwYcUERbHMiBEECdiAEc0GA5oCYA3FBBWwgBHNBf3M2AqQDIAEgBiAGIAZBBHZzQYCYvBhxQRFscyIGQQJ2IAZzQYDmgJgDcUEFbCAGc0F/czYCoAMgASAHQX9zNgKYAyABIAEoAsADQX9zNgLAAyABIAEoAsQDQX9zNgLEAyABIAEoAtQDQX9zNgLUAyABIAEoAtgDQX9zNgLYAyAeIAFB4AMQLBogAUHgA2okAAUgAUH4ACAIEEcgBkHgAGoiBxAwIAcgBygCAEF/czYCACAGQeQAaiIHIAcoAgBBf3M2AgAgBkH0AGoiByAHKAIAQX9zNgIAIAZB+ABqIgYgBigCAEF/czYCACABQfgAIAhBCGoiCEEQQQYQISAFQcQAaiEFIARBQGshBAwBCwsgCUHwA2ogHUEcaikCADcCACAJIB0pAhQ3AugDAkACQAJAAkACQAJ/AkACQCAiQQ9xDQAgCSAANgKkByAJIAA2AqAHIAkgCUHoA2o2ApwHIAkgIkEEdiIONgKoB0EAIQUjAEHQAGsiASQAIAlBnAdqIgYoAgwiC0EBcSAGKAIIIQ8gBigCBCEQIAYoAgAhBiALQQJPBEAgC0EBdiEHIAFBQGshCANAIAUgEGoiBEEPai0AACERIARBDmotAAAhEiAEQQ1qLQAAIRQgBEEMai0AACEVIARBC2otAAAhFiAEQQpqLQAAIRcgBEEJai0AACEfIARBCGoiDS0AACEjIARBB2otAAAhICAEQQZqLQAAIRkgBEEFai0AACEkIARBBGotAAAhJSAEQQNqLQAAIRogBEECai0AACEhIARBAWotAAAhJiAELQAAIRsgAUEoaiInIARBGGoiDCkAADcDACABIARBEGoiHCkAADcDICAIIBwpAAA3AAAgCEEIaiAMKQAANwAAIAQpAAAhMiABQQhqIgQgDSkAADcDACABQRBqIg0gCCkDADcDACABQRhqIgwgAUHIAGoiHCkDADcDACABIDI3AwAgAUEwaiAeIAEQDyAMIBwpAAA3AwAgDSAIKQAANwMAIAQgAUE4aikAADcDACABIAEpADAiMjcDACABIAYtAAAgMqdzOgAAIAEgAS0AASAGLQABczoAASABIAEtAAIgBi0AAnM6AAIgASABLQADIAYtAANzOgADIAEgAS0ABCAGLQAEczoABCABIAEtAAUgBi0ABXM6AAUgASABLQAGIAYtAAZzOgAGIAEgAS0AByAGLQAHczoAByAEIAQtAAAgBkEIaiIcLQAAczoAACABIAEtAAkgBi0ACXM6AAkgASABLQAKIAYtAApzOgAKIAEgAS0ACyAGLQALczoACyABIAEtAAwgBi0ADHM6AAwgASABLQANIAYtAA1zOgANIAEgAS0ADiAGLQAOczoADiABIAEtAA8gBi0AD3M6AA8gDSAbIA0tAABzOgAAIAEgJiABLQARczoAESABICEgAS0AEnM6ABIgASAaIAEtABNzOgATIAEgJSABLQAUczoAFCABICQgAS0AFXM6ABUgASAZIAEtABZzOgAWIAEgICABLQAXczoAFyAMICMgDC0AAHM6AAAgASAfIAEtABlzOgAZIAEgFyABLQAaczoAGiABIBYgAS0AG3M6ABsgASAVIAEtABxzOgAcIAEgFCABLQAdczoAHSABIBIgAS0AHnM6AB4gASARIAEtAB9zOgAfIAQpAwAhMiANKQMAITMgASkDACE0IAUgD2oiBEEYaiAMKQMANwAAIARBEGogMzcAACAEQQhqIDI3AAAgBCA0NwAAIBwgJykDADcAACAGIAEpAyA3AAAgBUEgaiEFIAdBAWsiBw0ACwsEQCABQShqIgUgECALQf7///8AcUEEdCIEaiIIQQhqKQAAIjI3AwAgASAIKQAAIjM3AyAgAUEYakIANwAAIAFCADcAECABIDI3AAggASAzNwAAIAFBMGogHiABEA8gAS0AMCEIIAEtADEhByABLQAyIQ0gAS0AMyEMIAEtADQhHiABLQA1IQsgAS0ANiEQIAEtADchEyABLQA4IREgAS0AOSESIAEtADohFCABLQA7IRUgAS0APCEWIAEtAD0hFyABLQA+IR8gBkEIaiIjLQAAISAgBi0AACEZIAYtAAEhJCAGLQACISUgBi0AAyEaIAYtAAQhISAGLQAFISYgBi0ABiEbIAYtAAchJyAGLQAJIRwgBi0ACiErIAYtAAshLCAGLQAMIS0gBi0ADSEuIAYtAA4hLyAEIA9qIgQgAS0APyAGLQAPczoADyAEIB8gL3M6AA4gBCAXIC5zOgANIAQgFiAtczoADCAEIBUgLHM6AAsgBCAUICtzOgAKIAQgEiAcczoACSAEIBEgIHM6AAggBCATICdzOgAHIAQgECAbczoABiAEIAsgJnM6AAUgBCAeICFzOgAEIAQgDCAaczoAAyAEIA0gJXM6AAIgBCAHICRzOgABIAQgCCAZczoA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LQAGIAItAAZzOgAGIAAgAC0AByACLQAHczoAByAGIAYtAAAgAkEIaiIbLQAAczoAACAAIAAtAAkgAi0ACXM6AAkgACAALQAKIAItAApzOgAKIAAgAC0ACyACLQALczoACyAAIAAtAAwgAi0ADHM6AAwgACAALQANIAItAA1zOgANIAAgAC0ADiACLQAOczoADiAAIAAtAA8gAi0AD3M6AA8gByAhIActAABzOgAAIAAgGiAALQARczoAESAAICUgAC0AEnM6ABIgACAkIAAtABNzOgATIAAgGSAALQAUczoAFCAAICAgAC0AFXM6ABUgACAjIAAtABZzOgAWIAAgHyAALQAXczoAFyAdIBcgHS0AAHM6AAAgACAWIAAtABlzOgAZIAAgFSAALQAaczoAGiAAIBQgAC0AG3M6ABsgACASIAAtABxzOgAcIAAgESAALQAdczoAHSAAIBMgAC0AHnM6AB4gACAQIAAtAB9zOgAfIAYpAwAhMiAHKQMAITMgACkDACE0IAQgC2oiBkEYaiAdKQMANwAAIAZBEGogMzcAACAGQQhqIDI3AAAgBiA0NwAAIBsgJikDADcAACACIAApAyA3AAAgBEEgaiEEIApBAWsiCg0ACwsEQCAAQShqIgQgDiAMQf7///8AcUEEdCIGaiIKQQhqKQAAIjI3AwAgACAKKQAAIjM3AyAgAEEYakIANwAAIABCADcAECAAIDI3AAggACAzNwAAIABBMGogHiAAEBEgAC0AMCEKIAAtADEhCCAALQAyIQcgAC0AMyEdIAAtADQhDCAALQA1IR4gAC0ANiEOIAAtADchDyAALQA4IRAgAC0AOSETIAAtADohESAALQA7IRIgAC0APCEUIAAtAD0hFSAALQA+IRYgAkEIaiIXLQAAIR8gAi0AACEjIAItAAEhICACLQACIRkgAi0AAyEkIAItAAQhJSACLQAFIRogAi0ABiEhIAItAAchJiACLQAJIRsgAi0ACiEnIAItAAshHCACLQAMISsgAi0ADSEsIAItAA4hLSAGIAtqIgYgAC0APyACLQAPczoADyAGIBYgLXM6AA4gBiAVICxzOgANIAYgFCArczoADCAGIBIgHHM6AAsgBiARICdzOgAKIAYgEyAbczoACSAGIBAgH3M6AAggBiAPICZzOgAHIAYgDiAhczoABiAGIBogHnM6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aiAGQThqKAIANgIAIAYgBikCJCIcNwMIIAYgBikCMDcCFCADQRBqIAZBGGopAwA3AgAgA0EIaiACKQMANwIAIAMgHDcCACADIBc6ALUCIAMgGDoAtAIgAyANNgKwAiADIBtCIIg+AiwgAyAANgIoIAMgDjYCJCADIBpCIIg+AiAgAyABNgIcIAMgEjYCGAwVCyAGQccAaiAGQcgCaikCACIaNwAAIAYgBikCwAIiGzcAPyADQQxqIBo3AAAgAyAbNwAEIANBgICAgHg2AgAgDkGAgICAeHJBgICAgHhHBEAgACAOQQEQsQMLIBJBgICAgHhyQYCAgIB4RwRAIAEgEkEBELEDCyAGKAIwIgAEQCAGKAI0IABBARCxAwsgBigCJCIARQ0UIAYoAiggAEEBELEDDBQLIANBDjYCCCADQQA6AAQgA0GAgICAeDYCAAwTC0EOIABB/JDAABC1AwALIAAgBUH8kMAAELMDAAsgACAJQYyRwAAQtQMACyADIAk2AgggA0EAOgAEIANBgICAgHg2AgAMDwsgCSAAQZyRwAAQtQMACyAAIAVBnJHAABCzAwALIAAgDUGskcAAELUDAAsgDSAFQayRwAAQswMACyADIAc2AgggA0EAOgAEIANBgICAgHg2AgAMCgsgAyABNgIMIAMgAjYCCCADQQQ6AAQgA0GAgICAeDYCAAwJCyANIAVB2JnAABDQAQALIAEgB0HomcAAELUDAAsgAyABOgAFIANBBToABCADQYCAgIB4NgIADAYLIAcgAEH4mcAAELUDAAsgACAFQfiZwAAQswMACyADIA02AgggA0EAOgAEIANBgICAgHg2AgAMAwsgACAHQYiawAAQtQMACyAHIAVBiJrAABCzAwALIAAgDUGYmsAAELUDAAsgBkHABGokAAJ/AkAgAygCAEGAgICAeEcEQCATEMQBIBMgA0G4AhAsGkEAIQAMAQsgA0EEaiEBQX8hAAJAAkACQCADLQAEDgQAAgIBAgsgAygCCCEACyABEJwBDAELIANBwAJqIAFBCGopAgA3AwAgAyABKQIANwO4AiADQQA2AtQCIANCgICAgBA3AswCIANB4IHAADYC+AIgA0EDOgDwAiADQiA3AugCIANBADYC4AIgA0EANgLYAiADIANBzAJqNgL0AiADQdgCaiEBIwBB8ABrIgAkAAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgA0G4AmoiAi0AAEEBaw4MAQIDBAUGBwgJCgsMAAsgACACQQRqNgIgIABBAjYCMCAAQbz4wAA2AiwgAEIBNwI4IAAgAEEgaq1CgICAgMALhDcDCCAAIABBCGo2AjQgASgCHCABKAIgIABBLGoQOAwMCyAAIAJBBGo2AiAgAEEBNgIwIABB3PjAADYCLCAAQgE3AjggACAAQSBqrUKAgICA0AuENwMIIAAgAEEIajYCNCABKAIcIAEoAiAgAEEsahA4DAsLIAFB5PjAAEEcEIcDDAoLIAFBgPnAAEEOEIcDDAkLIAAgAkEEajYCbCAAIABB7ABqrUKAgICA4AuENwMgIABBAjYCHCAAQQI2AgwgAEG4+cAANgIIIABBATYCFCAAQQM6AGggAEEINgJkIABCIDcCXCAAQoCAgICAATcCVCAAQQI2AkwgAEEDOgBIIABBCDYCRCAAQiA3AjwgAEKAgICAgAE3AjQgAEECNgIsIAAgAEEsajYCGCAAIABBIGo2AhAgASgCHCABKAIgIABBCGoQOAwICyAAIAJBAWo2AiAgAEEBNgIwIABB7PnAADYCLCAAQgE3AjggACAAQSBqrUKAgICA8AuENwMIIAAgAEEIajYCNCABKAIcIAEoAiAgAEEsahA4DAcLIAAgAkEEajYCbCAAIAJBCGo2AiAgAEECNgIwIABBvPrAADYCLCAAQgI3AjggACAAQSBqrUKAgICAwAuENwMQIAAgAEHsAGqtQoCAgIDAC4Q3AwggACAAQQhqNgI0IAEoAhwgASgCICAAQSxqEDgMBgsgAUHM+sAAQSMQhwMMBQsgACACQQRqNgIgIABBATYCMCAAQZD7wAA2AiwgAEIBNwI4IAAgAEEgaq1CgICAgIAMhDcDCCAAIABBCGo2AjQgASgCHCABKAIgIABBLGoQOAwECyAAIAJBBGo2AiAgAEEBNgIwIABBxPvAADYCLCAAQgE3AjggACAAQSBqrUKAgICAgAyENwMIIAAgAEEIajYCNCABKAIcIAEoAiAgAEEsahA4DAMLIAFBzPvAAEEhEIcDDAILIAAgAkEEajYCICAAQQE2AjAgAEGQ/MAANgIsIABCATcCOCAAIABBIGqtQoCAgICQDIQ3AwggACAAQQhqNgI0IAEoAhwgASgCICAAQSxqEDgMAQsgACACQQRqNgIgIABBATYCMCAAQcD8wAA2AiwgAEIBNwI4IAAgAEEgaq1CgICAgIAMhDcDCCAAIABBCGo2AjQgASgCHCABKAIgIABBLGoQOAsgAEHwAGokAEUEQCADKALMAiEBIAMoAtACIgIgAygC1AIQ+gIhACABBEAgAiABQQEQsQMLIANBuAJqEJwBQQEMAgtBiILAAEE3IANB/wJqQfiBwABBjIPAABDCAQALQQALIQEgFCAANgIEIBQgATYCACADQYADaiQAIAooAgwhACAKKAIIIQEgFQRAIBYgFUEBELEDCyAKKAIcQQA2AgAgCigCICICIAIoAgBBAWsiAjYCACACRQRAIApBIGoQnwELIBEgATYCCCARIABBACABQQFxIgEbNgIEIBFBACAAIAEbNgIAIApBMGokACARKAIAIBEoAgQgESgCCCARQRBqJAALvgIBBX8jAEEQayIFJAAQTSIHIAMmASACIQYjAEFAaiICJAAgAkEcaiIJIAAQ2AEgAigCHCEIIAIgBjYCPCACIAE2AjggAiAGNgI0IAJBEGogAkE0akHAgcAAEM0BIAIgBzYCMCACIAIoAhQiATYCLCACIAIoAhAiADYCKCACQQhqIQZBACEHAkAgCCgCAEGAgICAeEcEQCABRQ0BIAhBMGohCANAIAAgAC0AACAIIARB/wFxai0AAHM6AAAgBEEBaiEEIABBAWohACABQQFrIgENAAsMAQtBASEHQfODwABBGBD6AiEACyAGIAA2AgQgBiAHNgIAIAIoAgwhASACKAIIIQAgAkEoahCGAiAJEI0CIAUgADYCBCAFIAFBACAAQQFxGzYCACACQUBrJAAgBSgCACAFKAIEIAVBEGokAAuYAgEDfyMAQRBrIgQkACMAQcACayIDJAAgA0EQaiAAENgBIAMoAhAhBQJAIAFFBEBBgICAgHghAAwBCyADIAI2ArgBIAMgATYCtAEgAyACNgKwASADQQhqIANBsAFqQfCEwAAQzQEgAyADKAIMIgA2AiQgAyADKAIINgIgCyADIAA2AhwgA0EoaiIAIAUgA0EcahCkASADQRBqEI8CIAQCfyADLQAoQQRHBEAgA0EANgKwASADQbgBaiAAQYgBECwaIANBsAFqEIoCQQhqIQBBAAwBCyADKAIsIQBBAQsiATYCCCAEIABBACABGzYCBCAEQQAgACABGzYCACADQcACaiQAIAQoAgAgBCgCBCAEKAIIIARBEGokAAvTEwEofyMAQRBrIg0kACMAQcACayIGJAAgBkEQaiAAENgBIAYoAhAhAwJAIAFFBEBBgICAgHghAAwBCyAGIAI2ArgBIAYgATYCtAEgBiACNgKwASAGQQhqIAZBsAFqQYybwAAQzQEgBiAGKAIMIgA2AiQgBiAGKAIINgIgCyAGIAA2AhwgBkEoaiEOIwBBkAFrIgskACALQQhqIQQgBkEcaiEIIwBBoAJrIgAkAAJAAkACQAJAAkAgAygCECIBQQFrDgIAAQILIABBGGohAiADKAIYIQEjAEFAaiIFJAAgBSABNgIIIAVBADYCFCAFQoCAgIAQNwIMIAVB6I7BADYCOCAFQQM6ADAgBUIgNwIoIAVBADYCICAFQQA2AhggBSAFQQxqNgI0AkAgBUEIaiAFQRhqELQDRQRAIAUoAhAhASAFKAIMISoCfyAFKAIUIgNFBEBB1AAhA0H2ACEHQccAIQlB9wAhD0HkACEQQTYhCkHuACERQTAhEkHFACETQTEhFEHpACEVQTchFkHMACEXQTUhGEH0ACEZQTIhGkHJACEbQc8AIQxB7wAhHEHOACEdQesAIR5B7wAhH0HFACEgQTIhIUHOACEiQckAISNB6QAhJEHPACElQfQAISZBzwAhJ0HvACEoQc0ADAELIAEgASABIAEgASABIAEgASABIAEgASABIAEgASABIAEgASABIAEgASABIAEgASABIAEgASABIAEgASABIAEgA0EBR2oiKEEBaiIHIAcgASADaiIDRhsiJ0EBaiIHIAMgB0YbIiZBAWoiByADIAdGGyIlQQFqIgcgAyAHRhsiJEEBaiIHIAMgB0YbIilBAWoiByADIAdGGyIHQQFqIgkgAyAJRhsiI0EBaiIJIAMgCUYbIiJBAWoiCSADIAlGGyIJQQFqIg8gAyAPRhsiD0EBaiIQIAMgEEYbIhBBAWoiCiADIApGGyIhQQFqIgogAyAKRhsiIEEBaiIKIAMgCkYbIgpBAWoiESADIBFGGyIRQQFqIhIgAyASRhsiEkEBaiITIAMgE0YbIhNBAWoiFCADIBRGGyIUQQFqIhUgAyAVRhsiFUEBaiIWIAMgFkYbIhZBAWoiFyADIBdGGyIXQQFqIhggAyAYRhsiGEEBaiIZIAMgGUYbIhlBAWoiGiADIBpGGyIaQQFqIhsgAyAbRhsiG0EBaiIMIAMgDEYbIh9BAWoiDCADIAxGGyIMQQFqIhwgAyAcRhsiHEEBaiIdIAMgHUYbIh1BAWoiHiADIB5GGy0AAEHrAHMhHiAdLQAAQc4AcyEdIBwtAABB7wBzIRwgDC0AAEHPAHMhDCAfLQAAQe8AcyEfIBstAABByQBzIRsgGi0AAEEycyEaIBktAABB9ABzIRkgGC0AAEE1cyEYIBctAABBzABzIRcgFi0AAEE3cyEWIBUtAABB6QBzIRUgFC0AAEExcyEUIBMtAABBxQBzIRMgEi0AAEEwcyESIBEtAABB7gBzIREgCi0AAEE2cyEKICAtAABBxQBzISAgIS0AAEEycyEhIBAtAABB5ABzIRAgDy0AAEH3AHMhDyAJLQAAQccAcyEJICItAABBzgBzISIgIy0AAEHJAHMhIyAHLQAAQfYAcyEHICktAABB1ABzIQMgJC0AAEHpAHMhJCAlLQAAQc8AcyElICYtAABB9ABzISYgJy0AAEHPAHMhJyAoLQAAQe8AcyEoIAEtAABBzQBzCyEpIAIgHjoAHyACIB06AB4gAiAcOgAdIAIgDDoAHCACIB86ABsgAiAbOgAaIAIgGjoAGSACIBk6ABggAiAYOgAXIAIgFzoAFiACIBY6ABUgAiAVOgAUIAIgFDoAEyACIBM6ABIgAiASOgARIAIgEToAECACIAo6AA8gAiAgOgAOIAIgIToADSACIBA6AAwgAiAPOgALIAIgCToACiACICI6AAkgAiAjOgAIIAIgBzoAByACIAM6AAYgAiAkOgAFIAIgJToABCACICY6AAMgAiAnOgACIAIgKDoAASACICk6AAAgKgRAIAEgKkEBELEDCyAFQUBrJAAMAQtBkI/BAEE3IAVBP2pBgI/BAEGUkMEAEMIBAAsgAEEGaiAAQRpqLQAAIgE6AAAgBCAAKQAfNwAIIARBEGogAEEnaikAADcAACAEQRhqIABBL2opAAA3AAAgBEEgaiAAQTdqLQAAOgAAIAAgAC8AGCICOwEEIAAoABshAyAEQQI6AAAgBCACOwABIARBA2ogAToAACAEIAM2AgQgCCgCACIBQYCAgIB4RiABRXINAyAIKAIEIAFBARCxAwwDCyAIKAIAQYCAgIB4Rg0BIABBEGogCEEIaigCADYCACAAIAgpAgA3AwgjAEEgayIBJAAgAUEIaiEDIABBCGoiBSgCBCECAkACQCAFKAIIIghBGE8EQCACQbCFwABBGBDtAUUNAQsgAyACIAgQHgwBCyADIAJBGGogCEEYaxAzCyAFKAIAIgMEQCACIANBARCxAwsgAEEYaiECIAEoAgwhAwJAIAEoAggiBUGAgICAeEcEQCABIAEoAhA2AhwgASADNgIYIAEgBTYCFCACIAFBFGoQeQwBCyACQQI6AAAgAiADNgIECyABQSBqJAAgAC0AGCIBQQJHBEAgAEEGaiICIAAtABs6AAAgACAALwAZOwEEIAAoAhwhAyAAQaABaiAAQSBqQYABECwaIARBIWogAEG5AWpB5wAQLBogBCABOgAAIAQgAzYCBCAEIAAvAQQ7AAEgBEEDaiACLQAAOgAAIAQgACkDoAE3AwggBEEQaiAAQagBaikDADcDACAEQRhqIABBsAFqKQMANwMAIARBIGogAEG4AWotAAA6AAAMAwsgACgCHCEBIARBAzoAACAEIAE2AgQMAgsgACABNgIcIABBAzoAGCAAQRhqEKsCIQEgBEEDOgAAIAQgATYCBCAIKAIAIgFBgICAgHhGIAFFcg0BIAgoAgQgAUEBELEDDAELIABBAjoAGCAAQRhqEKsCIQEgBEEDOgAAIAQgATYCBAsgAEGgAmokAAJAIAstAAgiAEEDRwRAIA4gCy8ACTsAASAOQQNqIAstAAs6AAAgCygCDCECIA5BCGogC0EQakGAARAsGgwBCyALKAIMEJoBIQILIA4gADoAACAOIAI2AgQgC0GQAWokACAGQRBqEJMCIA0CfyAGLQAoQQNHBEAgBkEANgKwASAGQbgBaiAOQYgBECwaIAZBsAFqEIoCQQhqIQJBAAwBCyAGKAIsIQJBAQsiADYCCCANIAJBACAAGzYCBCANQQAgAiAAGzYCACAGQcACaiQAIA0oAgAgDSgCBCANKAIIIA1BEGokAAv8AQICfwF+IwBBEGsiAiQAIAJBATsBDCACIAE2AgggAiAANgIEIwBBEGsiASQAIAJBBGoiACkCACEEIAEgADYCDCABIAQ3AgQjAEEQayIAJAAgAUEEaiIBKAIAIgIoAgwhAwJAAkACQAJAIAIoAgQOAgABAgsgAw0BQQEhAkEAIQMMAgsgAw0AIAIoAgAiAigCBCEDIAIoAgAhAgwBCyAAQYCAgIB4NgIAIAAgATYCDCAAQeTuwQAgASgCBCABKAIIIgAtAAggAC0ACRCXAQALIAAgAzYCBCAAIAI2AgAgAEHI7sEAIAEoAgQgASgCCCIALQAIIAAtAAkQlwEAC8wCAQV/IwBBEGsiBCQAIwBBIGsiAiQAIAIgATYCHCACIAA2AhggAiABNgIUIAJBCGogAkEUakHAgcAAEM0BIAIoAggiBiEDIAIoAgwhASMAQdAAayIAJAAgAEEEaiADIAEQEgJAAkAgACgCBCIFQYCAgIB4RwRAIAAoAhAhAyAFRQ0BIAAoAgggBUEBELEDDAELQQEhBSAAKAIIQQFHBEAgAEHIAGogAEEIaiIDQQhqKAIANgIAIAAgAykCADcDQCAAQUBrEKYBIQMMAgsgACgCDCEDC0EAIQULIAIgAzYCBCACIAU2AgAgAEHQAGokACACKAIEIQAgAigCACEDIAEEQCAGIAFBARCxAwsgBCADNgIIIAQgAEEAIANBAXEiARs2AgQgBEEAIAAgARs2AgAgAkEgaiQAIAQoAgAgBCgCBCAEKAIIIARBEGokAAuHAwEGfyMAQRBrIgMkACMAQZABayICJAAgAiABNgJYIAIgADYCVCACIAE2AlAgAkEIaiACQdAAakHAgcAAEM0BIAJBFGohASACKAIIIgYhBCACKAIMIQUjAEHQAGsiACQAIABBEGogBCAFEBIgAEEIaiIEIABBHGooAgA2AgAgACAAKQIUNwMAAkAgACgCECIHQYCAgIB4RwRAIAFBEGogAEEgakEsECwaIAFBDGogBCgCADYCACABIAApAwA3AgQMAQsgAEEYaiAEKAIANgIAIAAgACkDADcDECABIABBEGoQpgE2AgQLIAEgBzYCACAAQdAAaiQAIAUEQCAGIAVBARCxAwsCfyACKAIUQYCAgIB4RwRAQQAhACACQQA2AlAgAkHUAGogAkEUakE8ECwaIAJB0ABqEIkCQQhqDAELQQEhACACKAIYCyEBIAMgADYCCCADIAFBACAAGzYCBCADQQAgASAAGzYCACACQZABaiQAIAMoAgAgAygCBCADKAIIIANBEGokAAuYAgECfyMAQRBrIgMkACMAQcABayICJAAgAiABNgJsIAIgADYCaCACIAE2AmQgAiACQeQAakHwhMAAEM0BIAJBDGogAigCACIBIAIoAgQiABCxASAABEAgASAAQQEQsQMLAn8gAigCDEGAgICAeEcEQEEAIQAgAkEANgJkIAJB6ABqIAJBDGpB2AAQLBpB0bLCAC0AABpB5ABBBBCcAyIBRQRAQQRB5AAQ5wMACyABQoGAgIAQNwIAIAFBCGoiASACQeQAakHcABAsGiABDAELQQEhACACKAIQCyEBIAMgADYCCCADIAFBACAAGzYCBCADQQAgASAAGzYCACACQcABaiQAIAMoAgAgAygCBCADKAIIIANBEGokAAv0AgEHfyMAQRBrIgMkACMAQaACayICJAAgAiABNgKYASACIAA2ApQBIAIgATYCkAEgAiACQZABakHwhMAAEM0BIAJBCGohASACKAIAIgchBCACKAIEIgYhBSMAQbABayIAJAAgAEHYAGoiCCAEIAUQsQEgACgCXCEEAkAgACgCWCIFQYCAgIB4RwRAIABBCGogAEHgAGpB0AAQLBogACAENgIEIAAgBTYCACAAQYCAgIB4NgJYIAEgACAIEKQBIAVFDQEgBCAFQQEQsQMMAQsgAUEEOgAAIAEgBDYCBAsgAEGwAWokACAGBEAgByAGQQEQsQMLAn8gAi0ACEEERwRAQQAhACACQQA2ApABIAJBmAFqIAJBCGpBiAEQLBogAkGQAWoQigJBCGoMAQtBASEAIAIoAgwLIQEgAyAANgIIIAMgAUEAIAAbNgIEIANBACABIAAbNgIAIAJBoAJqJAAgAygCACADKAIEIAMoAgggA0EQaiQAC+QBAQJ/IwBBEGsiAyQAIwBBoAJrIgIkACACIAE2ApgBIAIgADYClAEgAiABNgKQASACIAJBkAFqQfyMwAAQzQEgAkEIaiACKAIAIgEgAigCBCIAEMMBIAAEQCABIABBARCxAwsCfyACLQAIQQJHBEBBACEAIAJBADYCkAEgAkGYAWogAkEIakGIARAsGiACQZABahCKAkEIagwBC0EBIQAgAigCDAshASADIAA2AgggAyABQQAgABs2AgQgA0EAIAEgABs2AgAgAkGgAmokACADKAIAIAMoAgQgAygCCCADQRBqJAALijMCE38CfiMAQRBrIhAkACMAQfAAayIKJAAgCiABNgJAIAogADYCPCAKIAE2AjggCiAKQThqQfyMwAAQzQEgCkEIaiES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KQJkNwMQIAIoAmAiAUEFRg0BIAJBOGoiBSACQYwBaigCADYCAEEQIQAgAkEwaiIEIAJBhAFqKQIANwMAIAJBKGoiCCACQfwAaikCADcDACACIAIpAnQ3AyAgAUEERwRAIAcgAikDEDcCBCAHIAIpAyA3AhQgB0EMaiADKQMANwIAIAdBHGogCCkDADcCACAHQSRqIAQpAwA3AgAgB0EsaiAFKAIANgIAIAcgATYCAAwECwJAAkAgDUEQSQR/QQAFQQQhACAMIA1qQQhrKQAAQu3qzcu2rJk8Ug0CIAwgDUEMayIBaigAACIAQQFGDQFBAwshASACIAA2AmggAiABNgJkDAQLIAJB4ABqIQMjAEHwAmsiACQAAkAgAUEDSwRAAkAgDCABQQRrIgVqKAAAIgRBwAFGBEAgAUG0AWshASAFQbABTwRAIABB2AFqIAEgDGoiAUEYaikAADcDACAAQeABaiABQSBqKQAANwMAIABB6AFqIAFBKGopAAA3AwAgAEHwAWogAUEwaikAADcDACAAQfgBaiABQThqKQAANwMAIABBgAJqIAFBQGspAAA3AwAgACABKQAQNwPQASABKQAAIRUgASkACCEWIABBiAJqIAFByABqQeQAECwaIAEoAKwBIQEgAEEYaiAAQdABakGcARAsGiAAIAE2ArQBIAAgFjcCECAAIBU3AgggAEG4AWogAEEUakE8EH8gAEHEAWogAEHQAGpB5AAQfyADQQE2AgAgA0HAATYCLCADQYCAgIB4NgIgIAMgACkCuAE3AgQgA0EMaiAAQcABaikCADcCACADQRRqIABByAFqKQIANwIADAILIAEgBUHIucEAELIDAAsgAyAENgIIIANChYCAgMAANwMACyAAQfACaiQADAELIABBADYCGCAAQQE2AgwgAEGIucEANgIIIABCBDcCECAAQQhqQbi5wQAQwAIACyACKAJgIgBBBUYNAwsgAkHYAGoiCSACQewAaiIRKQIAIhU3AwAgAkE8aiACQfwAaikCADcCACACQcQAaiACQYQBaikCADcCACACQcwAaiACQYwBaigCADYCACACQSxqIBU3AgAgAiACKQJkIhU3A1AgAiACKQJ0NwI0IAIgFTcCJCACIAA2AiAgAEEERwRAIAcgAikDIDcDACAHQShqIAJByABqKQMANwMAIAdBIGogAkFA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GCADKAIcIAMoAiAgAEEQahA4DAYLIAAgAUEEajYCDCAAQQE2AhQgAEG8wcEANgIQIABCATcCHCAAIABBDGqtQoCAgICQGoQ3AyggACAAQShqNgIYIAMoAhwgAygCICAAQRBqEDgMBQsgACABQQRqNgIMIABBATYCFCAAQejBwQA2AhAgAEIBNwIcIAAgAEEMaq1CgICAgJAahDcDKCAAIABBKGo2AhggAygCHCADKAIgIABBEGoQOAwECyAAIAFBBGo2AgwgAEEBNgIUIABBkMLBADYCECAAQgE3AhwgACAAQQxqrUKAgICAkBqENwMoIAAgAEEoajYCGCADKAIcIAMoAiAgAEEQahA4DAMLIAAgAUEEajYCDCAAQQE2AhQgAEG4wsEANgIQIABCATcCHCAAIABBDGqtQoCAgICQGoQ3AyggACAAQShqNgIYIAMoAhwgAygCICAAQRBqEDgMAgsgACABQQRqNgIMIABBATYCFCAAQeTCwQA2AhAgAEIBNwIcIAAgAEEMaq1CgICAgJAahDcDKCAAIABBKGo2AhggAygCHCADKAIgIABBEGoQOAwBCyAAIAFBBGo2AgwgAEECNgIUIABBmMPBADYCECAAQgE3AhwgACAAQQxqrUKAgICAkBqENwMoIAAgAEEoajYCGCADKAIcIAMoAiAgAEEQahA4CyAAQTBqJABFBEAgBSgCDCEAIAUoAhAiAyAFKAIUEPoCIAAEQCADIABBARCxAwsCQAJAAkACQAJAAkACQAJAAkAgASgCAA4MCAgICAgBAgMEBQYHAAsgASgCBCIARQ0HIAEoAgggAEEBELEDDAcLIAFBBGoQiAMMBgsgASgCBCIARQ0FIAEoAgggAEEBELEDDAULIAEoAgQiAEUNBCABKAIIIABBARCxAwwECyABKAIEIgBFDQMgASgCCCAAQQEQsQMMAwsgASgCBCIARQ0CIAEoAgggAEEBELEDDAILIAEoAgQiAEUNASABKAIIIABBARCxAwwBCyABKAIEIgBFDQAgASgCCCAAQQEQsQMLIAVBQGskAAwBC0HcscAAQTcgBUE/akHMscAAQeCywAAQwgEACyEAIBJBBTYCACASIAA2AgQMAQsgEkEENgIACyAHQUBrJAAgDQRAIAwgDUEBELEDC0EAIQFBACEAAkACQAJAIAooAggiA0EEaw4CAgEA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Rg0IIAlB7QBHDQYMCAsgBEE0Rg0BDAcLIARB8ABHIANBNEdyDQZBBiECDAELQQQhAgJAIANBwQBrDgIBAAYLQQUhAgsgAiEADAQLQQggCUGc3cEAELMDAAtBDCAJQazdwQAQswMAC0EAIQAMAQsgA0EgaiEACyAFIAA2AgQgBSAINgIADAELQQogAEGo3MEAELMDAAsgBUEAIAUoAgQiAyAFKAIAIggbNgIIIAVBADYCFCAFQoCAgIAQNwIMIAVBzJ7AADYCOCAFQQM6ADAgBUIgNwIoIAVBADYCICAFQQA2AhggBSAFQQxqNgI0IAVBGGohAiMAQTBrIgAkACAAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBUEIaigCACIEDgkNAQIDBAUGBwgACwJAIARB/v///wdqDgQKCwAMCQsACyAAQcjcwQA2AigMDAsgAEHL3MEANgIoDAsLIABBztzBADYCKAwKCyAAQdHcwQA2AigMCQsgAEHU3MEANgIoDAgLIABB19zBADYCKAwHCyAAQdrcwQA2AigMBgsgAEHd3MEANgIoDAULIABB4NzBADYCKEEEDAULIABB5NzBADYCKAwDCyAAQefcwQA2AigMAgsgAEHq3MEANgIoDAELIABB7dzBADYCKAtBAws2AiwgAEEBNgIMIABB8NzBADYCCCAAQgE3AhQgACAAQShqrUKAgICA8ByENwMgIAAgAEEgajYCECACKAIcIAIoAiAgAEEIahA4IABBMGokAARAQfSewABBNyAFQT9qQeSewABB+J/AABDCAQALIAdBDGoiACAFKQIMNwIAIABBCGogBUEUaigCADYCACAAIANBACAIGzYCDCAFQUBrJAAgAQRAIAYgAUEBELEDCwJ/IAcoAgxBgICAgHhHBEAgB0EoaiAHQRRqKQIANwIAQQAhASAHQQA2AhwgByAHKQIMNwIgQdGywgAtAAAaQRxBBBCcAyIARQRAQQRBHBDnAwALIABCgYCAgBA3AgAgACAHQRxqIgIpAgA3AgggAEEQaiACQQhqKQIANwIAIABBGGogAkEQaigCADYCACAAQQhqDAELQQEhASAHKAIQCyEAIAogATYCCCAKIABBACABGzYCBCAKQQAgACABGzYCACAHQTBqJAAgCigCACAKKAIEIAooAgggCkEQaiQAC6Yo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AEGw/sAAKQMANwMAIABB5IDBACkAADcDGAJAIApBIE8EQCAIIAFBGGopAAA3AwAgAyABQRBqKQAANwMAIAUgAUEIaikAADcDACAAQgE3AxAgACABKQAANwM4IAAgAEEYaiIFQQEQCiABQSBqIgggCkEgayIBQUBxaiEMIAFBP3EhAyABQcAATwRAIAAgACkDECABQQZ2IgGtfDcDECAAIAggARAKCyAFIAwgAxAsGgwBCyAAQThqIAEgChAsGiAKQSByIQMLIAAgAzoAWCAAQeAAaiAAQeAAECwaIAApA3AhDSAALQC4ASEBIABByAFqIABBCGopAwA3AwAgASAAQfgAaiIFaiIDQYABOgAAIAAgACkDADcDwAEgAa1CA4YgDUIJhoQhDQJAAkAgAUE/RwRAIANBAWpBACABQT9zEEoaIAFBOHNBB0sNAQsgAEHAAWoiASAFQQEQCiAAQYACakIANwMAIABB+AFqQgA3AwAgAEHwAWpCADcDACAAQegBakIANwMAIABB4AFqQgA3AwAgAEHYAWpCADcDACAAQgA3A9ABIAAgDTcDiAIgASAAQdABakEBEAoMAQsgACANNwOwASAAQcABaiAFQQEQCgsgAEHYAWogAEHIAWopAwAiDTcDACAAIAApA8ABIg43A9ABIAZBCGogDTcAACAGIA43AAAgAEGQAmokACACQQA2AiQgAkKAgICAEDcCHCACQcD+wAA2AjQgAiACQRxqIgU2AjAgAkGAgMQANgIoIAIgBjYCLCACQThqIgBBATYCBCAAIAJBKGoiASgCCCABKAIEa0EBdCABKAIAQYCAxABHciIBNgIIIAAgATYCACACKAI4IgAEQCAFQQAgABB1CyACQUBrIAJBMGopAgA3AwAgAiACKQIoNwM4IAJBOGoQ3wEiA0GAgMQARwRAIAJBzABqIgBBA3IhASAAQQJyIQYgAEEBciEFA0ACQCADQYABTwRAIAJBADYCTAJ/IANBgBBPBEAgA0GAgARPBEAgAiADQRJ2QfABcjoATCACIANBBnZBP3FBgAFyOgBOIAIgA0EMdkE/cUGAAXI6AE0gASEAQQQMAgsgAiADQQx2QeABcjoATCACIANBBnZBP3FBgAFyOgBNIAYhAEEDDAELIAIgA0EGdkHAAXI6AEwgBSEAQQILIQggACADQT9xQYABcjoAACAIIAIoAhwgAigCJCIAa0sEfyACQRxqIAAgCBB1IAIoAiQFIAALIAIoAiBqIAJBzABqIAgQLBogAiACKAIkIAhqNgIkDAELIAIoAiQiACACKAIcRgRAIAJBHGpB1IDBABCRAQsgAigCICAAaiADOgAAIAIgAEEBajYCJAsgAkE4ahDfASIDQYCAxABHDQALCyAHQQ9qIQEgAigCHCEFIAIoAiAhBgJAAkAgAigCJEEgRgRAIAEgBikAATcAAiABQQpqIAZBCWopAAA3AAAgAUESaiAGQRFqKQAANwAAIAFBGWogBkEYaikAADcAACAGLQAAIQBBACEDIAUNAQwCC0EBIQBBASEDIAVFDQELIAYgBUEBELEDCyABIAM6AAAgASAAOgABIAJB0ABqJAAgBy0AECEBIARBCGoiAAJ/IActAA9FBEAgACAHKQARNwACIABBGWogB0EoaikAADcAACAAQRJqIAdBIWopAAA3AAAgAEEKaiAHQRlqKQAANwAAIAAgAToAAUEADAELIAACfyMAQUBqIgAkACAAIAFBAXE6AAsgAEEANgIUIABCgICAgBA3AgwgAEG0scAANgI4IABBAzoAMCAAQiA3AiggAEEANgIgIABBADYCGCAAIABBDGo2AjQCfyAAQRhqIQEgAEELai0AAEUEQCABQYSBwQBBDxCHAwwBCyABQZOBwQBBGRCHAwtFBEAgACgCDCEBIAAoAhAiBiAAKAIUEPoCIAEEQCAGIAFBARCxAwsgAEFAayQADAELQdyxwABBNyAAQT9qQcyxwABB4LLAABDCAQALNgIEQQELOgAAIAdBMGokACAKBEAgCyAKQQEQsQMLAn8gBC0ACEUEQCAEQcgAaiAEQSFqKQAANwIAIARBQGsgBEEZaikAADcCACAEQThqIARBEWopAAA3AgAgBCAEKQAJNwIwQQAhACAEQQA2AiwgBEEsahCLAkEIagwBC0EBIQAgBCgCDAshASAJIAA2AgggCSABQQAgABs2AgQgCUEAIAEgABs2AgAgBEHQAGokACAJKAIAIAkoAgQgCSgCCCAJQRBqJAALLQAgASgCHCACIAMgASgCICgCDBECACECIABBADoABSAAIAI6AAQgACABNgIACzIBAX8gASgCHEGEj8IAQQEgASgCICgCDBECACECIABBADoABSAAIAI6AAQgACABNgIA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IgEkACABQQhqIgYgABDYASABQRRqIQQCQCABKAIIIgUoAggiAEEATgRAIAUoAgQhByAARQRAQQEhBQwCC0HRssIALQAAGkEBIQMgAEEBEJwDIgUNAQsgAyAAQbjnwAAQ8wIACyAFIAcgABAsIQMgBCAANgIIIAQgAzYCBCAEIAA2AgAgBhCOAiABIARB0IHAABDNASABKAIEIQAgAiABKAIANgIAIAIgADYCBCABQSBqJAAgAigCACACKAIEIAJBEGokAAtkAQN/IwBBEGsiAiQAIwBBIGsiASQAIAFBCGoiAyAAENgBIAFBFGoiACABKAIIENYBIAMQjwIgASAAQYCFwAAQzQEgAiABKQMANwMAIAFBIGokACACKAIAIAIoAgQgAkEQaiQAC88BAQR/IwBBEGsiAiQAIwBBMGsiASQAIAFBIGoiAyAAENkBIAICfyABKAIgIgAoAiBBgICAgHhGBEAgAxCRAkEAIQBBAAwBCyABQRRqIABBIGoQ1gEgASgCFCEDIAFBIGoiBBCRAkEAIQBBACADQYCAgIB4Rg0AGiABQShqIAFBHGooAgA2AgAgASABKQIUNwMgIAFBCGogBEGMjcAAEM0BIAEoAgghACABKAIMCzYCBCACIAA2AgAgAUEwaiQAIAIoAgAgAigCBCACQRBqJAALywEBBH8jAEEQayICJAAjAEEwayIBJAAgAUEgaiIDIAAQ2QEgAgJ/IAEoAiAiACgCAEEBRwRAIAMQkQJBACEAQQAMAQsgAUEUaiAAQRBqENYBIAEoAhQhAyABQSBqIgQQkQJBACEAQQAgA0GAgICAeEYNABogAUEoaiABQRxqKAIANgIAIAEgASkCFDcDICABQQhqIARBjI3AABDNASABKAIIIQAgASgCDAs2AgQgAiAANgIAIAFBMGokACACKAIAIAIoAgQgAkEQaiQAC5wBAQN/IwBBEGsiASQAIwBBIGsiAiQAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAJBFGoiAyAAQQRqENYBIAAgACgCAEEBazYCACACQQhqIANBvJ7AABDNASACKAIMIQAgASACKAIINgIAIAEgADYCBCACQSBqJAAMAgsQ2wMACxDcAwALIAEoAgAgASgCBCABQRBqJAALKAAgASAAKAIALQAAQQJ0IgBBwInCAGooAgAgAEGs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QoCA/AeDQhiGIAVCgICA+A+DQgiGhIQgBUIIiEKAgID4D4MgBUIYiEKAgPwHg4QgBUIoiEKA/gODIAVCOIiEhIQ3A6AGIAJBmANqIA4gAkGIBmoQDSACLQCYAyEEIAItAJkDIQwgAi0AmgMhCyACLQCbAyENIAItAJwDIRAgAi0AnQMhESACLQCeAyEPIAItAJ8DIRIgAi0AoAMhEyACLQChAyEUIAItAKIDIRUgAi0AowMhFiACLQCkAyEXIAItAKUDIRggAi0ApgMhGSACLQCnAyEaIAItAKgDIRsgAi0AqQMhHCACLQCqAyEdIAItAKsDIR4gAi0ArAMhHyACLQCtAyEgIAItAK4DISEgAi0ArwMhIiACLQCwAyEjIAItALEDISQgAi0AsgMhJSACLQCzAyEmIAItALQDIScgAi0AtQMhKCACLQC2AyEpIABBAWoiKi0AACErIABBAmoiLC0AACEtIABBA2oiLi0AACEvIABBBGoiMC0AACExIABBBWoiMi0AACEzIABBBmoiNC0AACE1IABBB2oiNi0AACE3IABBCGoiOC0AACE5IABBCWoiOi0AACE7IABBCmoiPC0AACE9IABBC2oiPi0AACE/IABBDGoiQC0AACFBIABBDWoiQi0AACFDIABBDmoiRC0AACFFIABBD2oiRi0AACFHIABBEGoiSC0AACFJIABBEWoiSi0AACFLIABBEmoiTC0AACFNIABBE2oiTi0AACFPIABBFGoiUC0AACFRIABBFWoiUi0AACFTIABBFmoiVC0AACFVIABBF2oiVi0AACFXIABBGGoiWC0AACFZIABBGWoiWi0AACFbIABBGmoiXC0AACFdIABBG2oiXi0AACFfIABBHGoiYC0AACFhIABBHWoiYi0AACFjIABBHmoiZC0AACFlIAAtAAAhZiAAQR9qImcgZy0AACACLQC3A3M6AAAgZCApIGVzOgAAIGIgKCBjczoAACBgICcgYXM6AAAgXiAmIF9zOgAAIFwgJSBdczoAACBaICQgW3M6AAAgWCAjIFlzOgAAIFYgIiBXczoAACBUICEgVXM6AAAgUiAgIFNzOgAAIFAgHyBRczoAACBOIB4gT3M6AAAgTCAdIE1zOgAAIEogHCBLczoAACBIIBsgSXM6AAAgRiAaIEdzOgAAIEQgGSBFczoAACBCIBggQ3M6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2ZHCAGovAAA7AAALAkAgAkEKTwRAIABBAmsiACADQQxqaiACQQF0QdmRwgBqLwAAOwAADAELIABBAWsiACADQQxqaiACQTByOgAACyABQQFBAUEAIANBDGogAGpBFCAAaxAnIANBIGokAAsMACAAIAEgAiUBEAALDgAgAUGcg8AAQQUQhwMLDQAgAEHMnsAAIAEQOAsOACABQZigwABBBRCHAwsOACABQcCnwABBEBCHAwsOACABQfCywABBBRCHAwuPAQECfwJ/QZzdwAAhAkEWIQMCQAJAAkACQAJAAkACQCAAKAIALQAMIgBB/AFrDgQGAQIDAAsgAEEBaw4CBQQDCyABQbLdwABBGhCHAwwFCyABQczdwABBGRCHAwwECyABQeXdwABBEhCHAwwDCyABQQFBABCHAwwCC0H33cAAIQJBKCEDCyABIAIgAxCHAwsL5gEBAn8gACgCACECIwBBMGsiACQAAn8CQAJAAkAgAigCACIDQf//wwBrQQAgA0H+//8AcUGAgMQARhtBAWsOAgECAAsgACADNgIAIAAgAigCBDYCBCAAQQI2AgwgAEGog8EANgIIIABCAjcCFCAAIABBBGqtQoCAgIDADIQ3AyggACAArUKAgICA0AyENwMgIAAgAEEgajYCECABKAIcIAEoAiAgAEEIahA4DAILIAEoAhxBuIPBAEEUIAEoAiAoAgwRAgAMAQsgASgCHEHMg8EAQRUgASgCICgCDBECAAsgAEEwaiQACw0AIABBjODAACABEDgLDgAgAUHI4cAAQQUQhwMLDAAgACgCACABELQDCw4AIAFBs/fAAEEREIcDCwwAIAAoAgAgARCYAQsLACAAKAIAIAEQXwsLACAAKAIAIAEQUgsMACAAKAIAIAEQtQEL/gIBAn8gACgCACEDIwBBEGsiACQAIABBBGoiAiABEM8CIAAgAzYCDCACIABBDGoiAUHkg8EAEG4gACADQQFqNgIMIAIgAUHkg8EAEG4gACADQQJqNgIMIAIgAUHkg8EAEG4gACADQQNqNgIMIAIgAUHkg8EAEG4gACADQQRqNgIMIAIgAUHkg8EAEG4gACADQQVqNgIMIAIgAUHkg8EAEG4gACADQQZqNgIMIAIgAUHkg8EAEG4gACADQQdqNgIMIAIgAUHkg8EAEG4gACADQQhqNgIMIAIgAUHkg8EA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AAAAAgAAAAMAAAAEAEGAgsAAC+EcAQAAAAUAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAAA/ARAASwAAAI4KAAAOAAAARXJyb3IAAAA/ARAASwAAAI0FAAAbAAAAYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkTkNNRmlsZSBub3QgaW5pdGlhbGl6ZWQuL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjk5L3NyYy9jb252ZXJ0L3NsaWNlcy5ycwALAhAAZAAAAOgAAAABAAAACwIQAGQAAAAkAQAADgAAAAAAAAAEAAAABAAAAAYAAABIZWFkZXJNYWdpY0J5dGVzVVZGTmRYTnBZeUJGYm1OV01peExaWGs2eWVlbGlvbi1rdXdvLXRtZXllZWxpb24ta3V3bwAAAAABAABBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1f////////////////////////////////////////////////////////////Pv//NDU2Nzg5Ojs8Pf////////8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGf////8//xobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIz/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wEAAEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky//////////////////////////////////////////////////////////Pv///z80NTY3ODk6Ozw9/////////wABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZ////////GhscHR4fICEiIyQlJicoKSorLC0uLzAxMjP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////YXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkAAAAAQAAAAAAAAAvd29ya3NwYWNlL3VtL2xpYl91bV9jcnlwdG9fcnVzdC91bV9jcnlwdG8vcXRmbS9zcmMvc2VjcmV0LnJzAAAAuAUQAD0AAAAfAAAADwAAACYrKxIREhQKCAAIChQSERIvaF9fXy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3dhc20tYmluZGdlbi0wLjIuOTkvc3JjL2NvbnZlcnQvc2xpY2VzLnJzGAYQAGQAAADoAAAAAQAAABgGEABkAAAAJAEAAA4AAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAnAYQAEoAAAChAAAAGQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL2JveGVkLnJzAAD4BhAASgAAAJwCAAASAAAAL3dvcmtzcGFjZS91bS9saWJfdW1fY3J5cHRvX3J1c3QvdW1fY3J5cHRvL2t1d28vc3JjL2Rlcy9tb2QucnMAAFQHEAA+AAAAIwAAAA8AAABhdHRlbXB0ZWQgdG8gdGFrZSBvd25lcnNoaXAgb2YgUnVzdCB2YWx1ZSB3aGlsZSBpdCB3YXMgYm9ycm93ZWQvcnVzdGMvNGQ5MWRlNGU0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NWI1NTdmL3dhc20tYmluZGdlbi0wLjIuOTkvc3JjL2NvbnZlcnQvc2xpY2VzLnJzAMcOEABkAAAA6AAAAAEAAADHDhAAZAAAACQBAAAOAAAACQAAAAwAAAAEAAAACgAAAAsAAAAEAEHsnsAAC90KAQAAAAwAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAACrDxAASwAAAI4KAAAOAAAAAAAAAAQAAAAEAAAADQAAAEVycm9yAAAAqw8QAEsAAACNBQAAGwAAAFNRTGl0ZSBmb3JtYXQgMwAvd29ya3NwYWNlL3VtL2xpYl91bV9jcnlwdG9fcnVzdC91bV9jcnlwdG8va2dtL3NyYy9wY19kYl9kZWNyeXB0L21vZC5ycwBAEBAARwAAACYAAAAfAAAAQBAQAEcAAAAqAAAAJAAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGU6IGludmFsaWQgT25jZSBzdGF0ZagQEAA8AAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL29uY2Uvbm9fdGhyZWFkcy5ycwDsEBAAWwAAADUAAAASAAAALnAhYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkbWlkID4gbGVuAJoREAAJAAAAZmFpbGVkIHRvIGZpbGwgd2hvbGUgYnVmZmVyAKwREAAbAAAAJQAAAAAAAAACAAAAyBEQAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvc3RkL3NyYy9pby9jdXJzb3IucnPgERAATAAAAOwAAAAPAAAApAvINNaV8xMjI0MjVGOD8wAAAAAAAAAAAQAAAA4AAAAPAAAAEAAAAE9uY2UgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAZBIQACoAAABvbmUtdGltZSBpbml0aWFsaXphdGlvbiBtYXkgbm90IGJlIHBlcmZvcm1lZCByZWN1cnNpdmVseZgSEAA4AAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9zdGQvc3JjL3N5bmMvcG9pc29uL29uY2UucnMA2BIQAFMAAACeAAAAMgAAAGRlc2NyaXB0aW9uKCkgaXMgZGVwcmVjYXRlZDsgdXNlIERpc3BsYXkvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAZBMQAEoAAAChAAAAGQAAAFFNQ1YyTWFwS2V5RW1wdHkAAAAABAAAAAQAAAARAAAASW52YWxpZERlc0RhdGFTaXplAAAAAAAABAAAAAQAAAASAAAASW52YWxpZEhlYWRlck1hZ2ljVjJFS2V5UmVxdWlyZWRVbnN1cHBvcnRlZFZlcnNpb24AAAAAAAAEAAAABAAAABMAAAAAAAAABAAAAAQAAAANAAAASW52YWxpZEJ5dGVJbnZhbGlkTGVuZ3RoSW52YWxpZExhc3RTeW1ib2xJbnZhbGlkUGFkZGluZwAUAAAACAAAAAQAAAAVAAAAFAAAAAgAAAAEAAAAFgAAABUAAACQFBAAFwAAABgAAAAZAAAAGgAAABsAQdSpwAALBQEAAAAcAEHkqcAAC+UHAQAAAB0AAAAcAAAAzBQQAB4AAAAfAAAAIAAAACEAAAAiAAAAAAAAAAgAAAAEAAAAIwAAAAAAAAAIAAAABAAAACQAAAAjAAAACBUQACUAAAAmAAAAJwAAACUAAAAbAAAAAAAAABQAAAAEAAAAKAAAAAAAAAAUAAAABAAAACkAAAAoAAAARBUQACUAAAAqAAAAJwAAACsAAAAbAAAALAAAACQAAAAEAAAALQAAACwAAAAkAAAABAAAAC4AAAAtAAAAgBUQAC8AAAAwAAAAMQAAAC8AAAAyAAAAMwAAADAAAAAEAAAALQAAADMAAAAwAAAABAAAAC4AAAAtAAAAvBUQAC8AAAA0AAAAMQAAAC8AAAAyAAAANQAAACQAAAAEAAAALQAAADUAAAAkAAAABAAAAC4AAAAtAAAA+BUQAC8AAAA2AAAAMQAAAC8AAAAyAAAANwAAABwAAAAEAAAALQAAADcAAAAcAAAABAAAAC4AAAAtAAAANBYQAC8AAAA4AAAAMQAAAC8AAAAyAAAAOQAAADoAAAA7AAAAPAAAAD0AAAA+AAAAPwAAAEAAAABBAAAAQgAAAEMAAAA+AAAARAAAAEUAAABGAAAARwAAAEgAAAA+AAAASQAAAEoAAABLAAAATAAAAD0AAAA+AAAAOIXtknlf+EyzA2FBFqAdRx1aBTQMQY1CnIOSbK4W/lYvd29ya3NwYWNlL3VtL2xpYl91bV9jcnlwdG9fcnVzdC91bV9jcnlwdG8va2dtL3NyYy9oZWFkZXIucnPwFhAAPAAAAD8AAAAoAAAAL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjk5L3NyYy9jb252ZXJ0L3NsaWNlcy5yczwXEABkAAAA6AAAAAEAAAAvaF9fXy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2NvbnNvbGVfZXJyb3JfcGFuaWNfaG9vay0wLjEuNy9zcmMvbGliLnJzsBcQAGQAAACVAAAADgAAAGZhaWxlZCB0byBmaWxsIHdob2xlIGJ1ZmZlcgAkGBAAGwAAACUAAAAAAAAAAgAAAEAYEAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L3N0ZC9zcmMvaW8vbW9kLnJzAAAAWBgQAEkAAAA+AgAAHwAAAE0AAAAMAAAABAAAAE4AAABPAAAABABB1LHAAAvdDgEAAABQAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseS9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAExkQAEsAAACOCgAADgAAAEVycm9yAAAAExkQAEsAAACNBQAAGwAAAGNvdWxkIG5vdCBjb252ZXJ0IHNsaWNlIHRvIGFycmF5YXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkZmFpbGVkIHRvIGd1ZXNzIGtleS9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvY29yZS9zcmMvaXRlci90cmFpdHMvaXRlcmF0b3IucnMAAPoZEABYAAAAswcAAAkAAAAvaF9fXy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2hleC0wLjQuMy9zcmMvbGliLnJzAGQaEABPAAAAxwAAACUAAABkGhAATwAAAMcAAABBAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc9QaEABMAAAAKAIAABEAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL2l0ZXIucnMAADAbEABOAAAA9gUAABUAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAkBsQAEoAAAChAAAAGQAAADkxKSEZEQkBOzMrIxsTCwM9NS0lHRUNBT83LycfFw8HODAoIBgQCAA6MioiGhIKAjw0LCQcFAwEPjYuJh4WDgYnBy8PNxc/HyYGLg42Fj4eJQUtDTUVPR0kBCwMNBQ8HCMDKwszEzsbIgIqCjISOhohASkJMRE5GSAAKAgwEDgYDgAEDw0HAQQCDg8CCw0IAQMKCgYGDAwLBQkJBQADBwgEDwEMDggIAg0EBgkCAQsHDwUMCwkDBw4DCgoABQYADQ8DAQ0IBA4HBg8LAgMIBA8JDAcAAgENCgwGAAkFCwoFAA0OCAcKCwEKAwQPDQQBAgULCAYMBwYMCQADBQIODwkKDQAHCQAOCQYDAwQPBgUKAQINCAwFBw4LDAQLAg8IAQ0BBgoEDQkA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YW1JbnZhbGlkIG91dHB1dCBidWZmZXIgc2l6ZUFkbGVyMzIgY2hlY2tzdW0gbWlzbWF0Y2hJbnZhbGlkIGlucHV0IGRhdGFPdXRwdXQgc2l6ZSBleGNlZWRlZCB0aGUgc3BlY2lmaWVkIGxpbWl0L2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9taW5pel9veGlkZS0wLjguMC9zcmMvaW5mbGF0ZS9tb2QucnMAAB8vEABfAAAAvwAAABwAAABkZXN0IGlzIG91dCBvZiBib3VuZHMAAACQLxAAFQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnOwLxAATAAAACgCAAARAAAAUwAAAAwAAAAEAAAAVAAAAFUAAABWAEGs4MAAC8kWAQAAAFcAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAABrMBAASwAAAI4KAAAOAAAARXJyb3IAAABrMBAASwAAAI0FAAAbAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc+AwEABMAAAAKAIAABEAAAAKClN0YWNrOgoKL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjk5L3NyYy9jb252ZXJ0L3NsaWNlcy5ycwAARjEQAGQAAAAkAQAADgAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAAC8MRAASgAAAKEAAAAZAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5ycxgyEABYAAAAswcAAAkAAAB1bV9jcnlwdG8veG1seS9zcmMvcGMucnOAMhAAGAAAAFEAAAAfAAAAMTIzNDU2NzgxMjM0NTY3ODEyMzQ1Njc4gDIQABgAAABsAAAAGAAAAHhpbWFsYXlheGltYWxheWF4aW1hbGF5YXhpbWFsYXlhgDIQABgAAACHAAAALQAAAIAyEAAYAAAAkwAAAC0AAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzEDMQAEwAAAAoAgAAEQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAABsMxAASgAAAKEAAAAZAAAAL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9oZXgtMC40LjMvc3JjL2xpYi5ycwDIMxAATwAAAMcAAAAlAAAAyDMQAE8AAADHAAAAQQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvY29yZS9zcmMvaXRlci90cmFpdHMvaXRlcmF0b3IucnM4NBAAWAAAALMHAAAJAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pdGVyLnJzAACgNBAATgAAAPYFAAAVAAAARXhwZWN0ZWQgSUQzIG1ldGFkYXRhSUQzIE1ldGFkYXRhIHRvbyBzbWFsbCAocmVxdWlyZSAgYnl0ZXMpFTUQACAAAAA1NRAABwAAAEZhaWxlZCB0byBleHRyYWN0IGVuY3J5cHRlZCBhdWRpbyBzZWdtZW50IHNpemVGYWlsZWQgdG8gZXh0cmFjdCBTdGFnZSAxIElWIGRhdGFGYWlsZWQgdG8gZXh0cmFjdCBTdGFnZSAyIGRlY3J5cHRpb24ga2V5RmFpbGVkIHRvIGV4dHJhY3QgYXVkaW8gaGVhZGVyRGVjcnlwdGlvbiBzdGFnZSAxIGZhaWxlZCAocGFkZGluZylEZWNyeXB0aW9uIHN0YWdlIDEgZmFpbGVkIChiNjQgZGVjb2RlKURlY3J5cHRpb24gc3RhZ2UgMiBmYWlsZWQgKGluaXQpRGVjcnlwdGlvbiBzdGFnZSAyIGZhaWxlZCAocGFkZGluZylEZWNyeXB0aW9uIHN0YWdlIDIgZmFpbGVkIChiNjQgZGVjb2RlKU9uY2UgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAAJM2EAAqAAAAb25lLXRpbWUgaW5pdGlhbGl6YXRpb24gbWF5IG5vdCBiZSBwZXJmb3JtZWQgcmVjdXJzaXZlbHnINhAAOAAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvc3RkL3NyYy9zeW5jL3BvaXNvbi9vbmNlLnJzAAg3EABTAAAAngAAADIAAAAvaF9fXy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2Jhc2U2NC0wLjIyLjEvc3JjL2VuZ2luZS9tb2QucnMAAGw3EABaAAAA+gAAAB4AAABWZWMgaXMgc2l6ZWQgY29uc2VydmF0aXZlbHkA2DcQABsAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiAAAPw3EAAqAAAAbDcQAFoAAAABAQAAGQAAAC93b3Jrc3BhY2UvdW0vbGliX3VtX2NyeXB0b19ydXN0L3VtX2NyeXB0by91dGlscy9zcmMvYmFzZTY0LnJzAABAOBAAPgAAACcAAAAJAAAAAQAAQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL/////////////////////////////////////////////////////////8+////PzQ1Njc4OTo7PD3/////////AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBn///////8aGxwdHh8gISIjJCUmJygpKissLS4vMDEyM/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9jb3VsZCBub3QgZmluZCBpdGVtdW1fY3J5cHRvL3htbHkvc3JjL2FuZHJvaWQucnMA5jkQAB0AAAAXAAAADgAAAHhtbHl4bWx5eG1seXhtbHl4bWx5eG1seXhtbHl4bWx5Mzk4OWQxMTFhYWQ1NjEzOTQwZjRmYzQ0YjYzOWIyOTLmORAAHQAAADIAAAAQAAAAL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9sYXp5X3N0YXRpYy0xLjUuMC9zcmMvaW5saW5lX2xhenkucnMAZDoQAF8AAAAeAAAAEAAAAGhlYWRlciB0b28gc21hbGwsIHJlcXVpcmUgYXQgbGVhc3QgIGJ5dGVzAAAA1DoQACMAAAD3OhAABgAAAG5vdCBhIHhpYW1pIGZpbGUvaF9fXy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2NpcGhlci0wLjQuNC9zcmMvc3RyZWFtLnJzAEGA98AAC9sLAQAAAFsAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlU3RyZWFtQ2lwaGVyRXJyb3IgOxAAVQAAAHgAAAAnAAAARmFpbGVkIHRvIGRlY29kZSBmaWxlIG5hbWUuRmlsZSBuYW1lIGRvZXMgbm90IHN0YXJ0IHdpdGgga25vd24gcHJlZml4LkhlYWRlciBuZWVkIGF0IGxlYXN0ICBtb3JlIGJ5dGVzAAAaPBAAFQAAAC88EAALAAAARmlsZSBJL08gRXJyb3I6IEw8EAAQAAAARmlsZSBJL08gRXJyb3I6IFJlYWQgMCBieXRlc05vdCBhIE5DTSBmaWxlSW52YWxpZCBOQ00gY2hlY2tzdW0uIEV4cGVjdGVkICwgYWN0dWFsOiAAjjwQAB8AAACtPBAACgAAAFVuc3VwcG9ydGVkIGNvdmVyIGltYWdlIHZlcnNpb246IAAAAMg8EAAhAAAAQ292ZXIgaW1hZ2U6IEZyYW1lIHNpemUgaXMgbGVzcyB0aGFuIGltYWdlIDEuIGZyYW1lX3NpemU6LCBpbWFnZTFfc2l6ZToA9DwQADkAAAAtPRAADgAAAENvbnRlbnRLZXk6IEFFUyBQS0NTIzcgRGVjb2RlIEVycm9yQ29udGVudEtleTogSW52YWxpZCBrZXkgcHJlZml4OiAAbz0QACAAAABNZXRhZGF0YTogSW52YWxpZCBwcmVmaXggd2hpbGUgZGVjb2Rpbmc6IAAAAJg9EAApAAAATWV0YWRhdGE6IEFFUyBQS0NTIzcgRGVjb2RlIEVycm9yTWV0YWRhdGE6IERlY29kZSBtZXRhZGF0YSBmYWlsZWQ6IADtPRAAIgAAAE1ldGFkYXRhOiBJbnZhbGlkIHByZWZpeCBvbiBmaW5hbCBqc29uOiAYPhAAKAAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAABIPhAASgAAAKEAAAAZAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5yc6Q+EABYAAAAswcAAAkAAABoekhSQW1zbzVrSW5iYXhXbmV0ZWFzZWNsb3VkbXVzaWMAAAABI0VniavN7/7cuph2VDIQMDEyMzQ1Njc4OUFCQ0RFRgAAAAAAAAAAAQAAAGIAAABjYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9zdGQvc3JjL3RocmVhZC9sb2NhbC5ycwAAAKY/EABPAAAAEAEAABoAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMACEAQAEsAAACNBQAAGwAAAEFDODlFQzQ3QTcwQjc2RjMwN0NCMzlBMEQ3NEJDQ0IwSW52YWxpZCBGaWxlS2V5Q29udmVydCBoYXNoIHRvIGtleSBlcnJvci9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnOsQBAATAAAACgCAAARAAAAdW1fY3J5cHRvL21nM2Qvc3JjL2d1ZXNzX200YS5ycwAAAAAAZnR5cE00QSAAAAAATTRBIG1wNDJpc29tAAAAAGMAAAAAAAAA//////////9QQRAAQeiCwQALlQwIQRAAHwAAADoAAABAAAAACEEQAB8AAAA8AAAAQAAAAEludmFsaWQgY2hhcmFjdGVyICBhdCBwb3NpdGlvbiAAiEEQABIAAACaQRAADQAAAE9kZCBudW1iZXIgb2YgZGlnaXRzSW52YWxpZCBzdHJpbmcgbGVuZ3RoAAAAAAAAAAQAAAAEAAAAaQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnP0QRAATAAAACgCAAARAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogaW52YWxpZCBPbmNlIHN0YXRlUEIQADwAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L3N0ZC9zcmMvc3lzL3N5bmMvb25jZS9ub190aHJlYWRzLnJzAJRCEABbAAAANQAAABIAAAAgAAAAAQAAAAAAAAAAQxAAAQAAAAAAAAAEAAAABAAAAGoAAABIZWFkZXJNYWdpY0J5dGVzSW52YWxpZCBERVMgZGF0YSBzaXplIChleHBlY3RlZDogIG1vZCA4ID09IDApAAAANEMQACEAAABVQxAADAAAAEludmFsaWQgS1dNIGhlYWRlciBtYWdpYyBieXRlczogdEMQACAAAABLV012MjogRUtleSByZXF1aXJlZEtXTTogVW5zdXBwb3J0ZWQgdmVyc2lvbiAAAACwQxAA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bGlkUU1DMkVLZXlFcnJvcjogYU4QAA8AAABQYXJzZSBLR00gaGVhZGVyIHdpdGggaS9vIGVycm9yOiAAAAB4ThAAIQAAAEludmFsaWQgYXVkaW8gaGFzaCBzaXplOiAAAACkThAAGQAAAJIAAAAMAAAABAAAAJMAAACUAAAAkQBB6J3BAAvVAgEAAACVAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseS9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAJ08QAEsAAACOCgAADgAAAEVycm9yAAAAJ08QAEsAAACNBQAAGwAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnOcTxAATAAAACgCAAARAAAAZGVzY3JpcHRpb24oKSBpcyBkZXByZWNhdGVkOyB1c2UgRGlzcGxheVFNQ1YyTWFwS2V5RW1wdHkAAAAAAAAAAAEAAAAcAEHIoMEAC60qAQAAAJYAAAAcAAAAMFAQAJcAAACYAAAAmQAAAJoAAACbAAAAnAAAABwAAAAEAAAAnQAAAJwAAAAcAAAABAAAAJ4AAACdAAAAbFAQAJ8AAACgAAAAoQAAAJ8AAACiAAAAowAAAKQAAAClAAAApgAAAKcAAACoAAAAVVZGTmRYTnBZeUJGYm1OV01peExaWGs2aW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogaW52YWxpZCBPbmNlIHN0YXRl2FAQADwAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L3N0ZC9zcmMvc3lzL3N5bmMvb25jZS9ub190aHJlYWRzLnJzABxREABbAAAANQAAABIAAAB1bV9jcnlwdG8va2dtL3NyYy9wY19kYl9kZWNyeXB0L21vZC5ycwAAiFEQACYAAAALAAAAIwAAAIhREAAmAAAADAAAACMAAABTUUxpdGUgZm9ybWF0IDMAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc+BREABMAAAAKAIAABEAAABjYXBhY2l0eSBvdmVyZmxvdwAAADxSEAARAAAAdW1fY3J5cHRvL3FtYy9zcmMvZm9vdGVyL3V0aWxzLnJzAAAAWFIQACEAAAANAAAAHQAAAFhSEAAhAAAADQAAAEUAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAnFIQAEoAAAChAAAAGQAAAAAAAAAEAAAABAAAAKsAAABLZXlUb29TaG9ydEludmFsaWREYXRhU2l6ZQAAAAAAAAQAAAAEAAAArAAAAERlY3J5cHRCdWZmZXJUb29TbWFsbEVuY3J5cHRCdWZmZXJUb29TbWFsbEludmFsaWRQYWRkaW5nU2xpY2VFcnJvcgAAnFIQAEoAAAAIAwAAGgAAAC9oX19fLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5naW5lL21vZC5ycwAAiFMQAFoAAAD6AAAAHgAAAFZlYyBpcyBzaXplZCBjb25zZXJ2YXRpdmVseQD0UxAAGwAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGU6IAAAGFQQACoAAACIUxAAWgAAAAEBAAAZAAAAL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi90Y190ZWEtMC4yLjEvc3JjL2xpYi5ycwAAXFQQAFIAAAB0AAAAFQAAAG1pZCA+IGxlbgAAAMBUEAAJAAAAdW1fY3J5cHRvL3FtYy9zcmMvZWtleS5ycwAAANRUEAAZAAAAMwAAACEAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2NvcmUvc3JjL2l0ZXIvdHJhaXRzL2l0ZXJhdG9yLnJzAFUQAFgAAACzBwAACQAAADM4NlpKWSFAIyokJV4mKSgqKiMhKCMkJSZeYTFjWixUL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9sYXp5X3N0YXRpYy0xLjUuMC9zcmMvaW5saW5lX2xhenkucnMAiFUQAF8AAAAeAAAAEAAAAEVLZXkgaXMgdG9vIHNob3J0IGZvciBkZWNyeXB0aW9uRXJyb3Igd2hlbiBkZWNyeXB0aW5nIGVrZXkgdjE6IAAYVhAAHwAAAEVycm9yIHdoZW4gZGVjcnlwdGluZyBla2V5IHYyOiAAQFYQAB8AAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9ib3hlZC9jb252ZXJ0LnJzAABoVhAAUgAAAFIAAAATAAAAdW1fY3J5cHRvL3FtYy9zcmMvdjJfcmM0L2NpcGhlci5ycwAAzFYQACIAAAAiAAAAPwAAAMxWEAAiAAAAJAAAABcAAADMVhAAIgAAAC4AAAAdAAAAT25jZSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkAAAgVxAAKgAAAG9uZS10aW1lIGluaXRpYWxpemF0aW9uIG1heSBub3QgYmUgcGVyZm9ybWVkIHJlY3Vyc2l2ZWx5VFcQADgAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L3N0ZC9zcmMvc3luYy9wb2lzb24vb25jZS5ycwCUVxAAUwAAAJ4AAAAyAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9zdHIvcGF0dGVybi5ycwD4VxAATwAAAM0BAAA3AAAAw0rWypBn91LYoWZin1sJAMNelSOfExF+2JI/vJC7dA7DR3Q9kKo/Udj0EYSf3pUdw8YJ1Z/6ZvnY8PegkKHW88Pz1qGQoPfw2Plm+p/VCcbDHZXen4QR9NhRP6qQPXRHww50u5C8P5LYfhETnyOVXsMACVufYmah2FL3Z5DK1kp1bV9jcnlwdG8vcW1jL3NyYy92Ml9yYzQvcmM0LnJzANhYEAAfAAAAEQAAAA8AAADYWBAAHwAAACIAAAApAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5ycxhZEABYAAAAswcAAAkAAABkZXNjcmlwdGlvbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBEaXNwbGF5L3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAAKhZEABKAAAAoQAAABkAAAAAAAAABAAAAAQAAACtAAAAAAAAAAQAAAAEAAAArgAAAEludmFsaWRCeXRlAAAAAAAEAAAABAAAAKsAAABJbnZhbGlkTGVuZ3RoSW52YWxpZExhc3RTeW1ib2xJbnZhbGlkUGFkZGluZwAAAAAQAAAABAAAAK8AAAAAAAAAEAAAAAQAAACwAAAArwAAAGxaEACxAAAAsgAAALMAAAC0AAAAtQAAAAAAAAAIAAAABAAAACMAAAAAAAAACAAAAAQAAAC2AAAAIwAAAKhaEACxAAAAtwAAALMAAAC4AAAAtQAAALkAAAAkAAAABAAAALoAAAC5AAAAJAAAAAQAAAC7AAAAugAAAORaEAC8AAAAvQAAAL4AAAC8AAAAvwAAAMAAAAAsAAAABAAAALoAAADAAAAALAAAAAQAAAC7AAAAugAAACBbEAC8AAAAwQAAAL4AAAC8AAAAvwAAAMIAAADDAAAAxAAAAMUAAADGAAAAxwAAAMgAAADJAAAAygAAAMsAAADMAAAAxwAAAEVLZXlUb29TaG9ydAAAAAAEAAAABAAAAM0AAABGYWlsRGVjcnlwdFYxRmFpbERlY3J5cHRWMi9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzwlsQAEoAAAChAAAAGQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMAHFwQAE8AAADNAQAANwAAAG1pZCA+IGxlbgAAAHxcEAAJAAAAdW1fY3J5cHRvL3FtYy9zcmMvZm9vdGVyL211c2ljZXhfdjEucnMAAJBcEAAmAAAAOAAAACkAAACQXBAAJgAAAEAAAAAbAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5yc9hcEABYAAAAswcAAAkAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiBpbnZhbGlkIE9uY2Ugc3RhdGVAXRAAPAAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvc3RkL3NyYy9zeXMvc3luYy9vbmNlL25vX3RocmVhZHMucnMAhF0QAFsAAAA1AAAAEgAAAAEAAEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky//////////////////////////////////////////////////////////Pv///z80NTY3ODk6Ozw9/////////wABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZ////////GhscHR4fICEiIyQlJicoKSorLC0uLzAxMjP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Rm9vdGVyOiBCdWZmZXIgdG9vIHNtYWxsLCByZXF1aXJlIGF0IGxlYXN0ICBieXRlczNfEAArAAAAXl8QAAYAAABQQ3YxL0VLZXk6IEJ1ZmZlciB0b28gbGFyZ2UsIG1pZ2h0IG5vdCBiZSB2YWxpZCBFS2V5IChsZW49KQB0XxAAOgAAAK5fEAABAAAAUEN2MS9FS2V5OiBGb3VuZCBpbnZhbGlkIEVLZXkgY2hhclBDdjIvTXVzaWNFeDogSW52YWxpZCBtZXRhZGF0YSB2ZXJzaW9uIAAAAOJfEAAnAAAAUEN2Mi9NdXNpY0V4OiBJbnZhbGlkIGBNdXNpY0V4YCBzaXplOiAAABRgEAAmAAAAUEN2Mi9NdXNpY0V4OiBJbnZhbGlkIGBNdXNpY0V4YCBkYXRhOiAAAERgEAAmAAAAQW5kcm9pZC9TVGFnOiBJbnZhbGlkIElEIGZpZWxkOiB0YBAAIAAAAEFuZHJvaWQvU1RhZzogSW52YWxpZCBWZXJzaW9uOiAAnGAQAB8AAABBbmRyb2lkL1NUYWc6IEludmFsaWQgQ1NWIG1ldGFkYXRhOiDEYBAAJAAAAEFuZHJvaWQvUVRhZzogSW52YWxpZCBJRCBmaWVsZDog8GAQACAAAABBbmRyb2lkL1FUYWc6IEludmFsaWQgVmVyc2lvbjogABhhEAAfAAAAQW5kcm9pZC9RVGFnOiBJbnZhbGlkIEVLZXkgZmllbGQ6IAAAQGEQACIAAABQYXJzZTogRmFpbGVkIHRvIHBhcnNlIHN0cmluZyAnJyBhcyBpbnRlZ2VyAGxhEAAfAAAAi2EQAAwAAABRTUMgVjIvTWFwIENpcGhlcjogS2V5IGlzIGVtcHR5L2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi90Y190ZWEtMC4yLjEvc3JjL2NiYy5ycwAAAMdhEABSAAAAjwAAAA4AAABLZXkgc2l6ZSBtaXNtYXRjaC4gUmVxdWlyZWQgMTYgYnl0ZXMsIGdvdCAgYnl0ZXMsYhAAKgAAAFZiEAAGAAAAQ2lwaGVyIHRleHQgc2l6ZSBpbnZhbGlkLiAgbW9kIDggIT0gMC4AAGxiEAAaAAAAhmIQAAwAAABEZWNyeXB0IGJ1ZmZlciBzaXplIHRvbyBzbWFsbCwgaXQgc2hvdWxkIGJlIGF0IGxlYXN0ICBieXRlcyAoYWN0dWFsPSBieXRlcykupGIQADUAAADZYhAADwAAAOhiEAAIAAAARW5jcnlwdCBidWZmZXIgc2l6ZSB0b28gc21hbGwsIGl0IHNob3VsZCBiZSBhdCBsZWFzdCAAAAAIYxAANQAAANliEAAPAAAA6GIQAAgAAABJbnZhbGlkIGRhdGEgcGFkZGluZ1NsaWNlIGVycm9yLi9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvY29yZS9zcmMvcHRyL21vZC5ycwB4YxAASwAAAAsCAAABAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwDUYxAATwAAAEwDAAA0AAAA1GMQAE8AAABTAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAG5kEABLAAAAxAcAAB0AAABuZBAASwAAAMwHAAAdAAAAbmQQAEsAAACNBQAAGwAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnPsZBAATAAAACgCAAARAAAA0wAAAAwAAAAEAAAA1AAAANUAAADWAAAA2QAAAAwAAAAEAAAA2gAAANsAAADWAEGAy8EAC403AQAAANwAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAAC/ZRAASwAAAI4KAAAOAAAARXJyb3IAAAC/ZRAASwAAAI0FAAAbAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5pc19jaGFyX2JvdW5kYXJ5KG5ld19sZW4pv2UQAEsAAADABQAADQAAAAAAAAAQAAAABAAAAN0AAADeAAAA3wAAAGJhY2t0cmFjZSBjYXB0dXJlIGZhaWxlZC9oX19fLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYW55aG93LTEuMC45NC9zcmMvZXJyb3IucnMAAACkZhAA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VEFHSUQzdW1fYXVkaW8vc3JjL21ldGFkYXRhLnJzAAAObhAAGAAAADEAAAA5AAAADm4QABgAAAAhAAAAGQAAAG9nZ2FhY21wM200YW00Ym1wNHdtYW1rYWZsYWNkZmZ3YXZhcGViaW4BAAAAAAAAAHVtX2F1ZGlvL3NyYy9saWIucnMAeG4QABMAAABeAAAAIgAAAHhuEAATAAAAcQAAAA8AAAB4bhAAEwAAAHMAAAAmAAAAeG4QABMAAABcAAAAGQAAAG51bGwgcG9pbnRlciBwYXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3RsaWJyYXJ5L3N0ZC9zcmMvcGFuaWNraW5nLnJzAAAAAAAABAAAAAQAAADuAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAAGRvEABKAAAAoQAAABkAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAwG8QAEsAAACNBQAAGwAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnMccBAATAAAACgCAAARAAAAOgAAAAEAAAAAAAAAeHAQAAEAAAB4cBAAAQAAAO8AAAAMAAAABAAAAPAAAADxAAAA8gAAAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjcvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZACscBAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAArHAQACkAAACuBAAADQAAAEFjY2Vzc0Vycm9ybGlicmFyeS9zdGQvc3JjL2JhY2t0cmFjZS5yc29wZXJhdGlvbiBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgcGxhdGZvcm0Ae3EQACgAAAAkAAAAAgAAAKRxEAB1bnN1cHBvcnRlZCBiYWNrdHJhY2VkaXNhYmxlZCBiYWNrdHJhY2UAX3EQABwAAACKAQAAHQAAAPMAAAAQAAAABAAAAPQAAAD1AAAAAQAAAAAAAABlbnRpdHkgbm90IGZvdW5kcGVybWlzc2lvbiBkZW5pZWRjb25uZWN0aW9uIHJlZnVzZWRjb25uZWN0aW9uIHJlc2V0aG9zdCB1bnJlYWNoYWJsZW5ldHdvcmsgdW5yZWFjaGFibGVjb25uZWN0aW9uIGFib3J0ZWRub3QgY29ubmVjdGVkYWRkcmVzcyBpbiB1c2VhZGRyZXNzIG5vdCBhdmFpbGFibGVuZXR3b3JrIGRvd25icm9rZW4gcGlwZWVudGl0eSBhbHJlYWR5IGV4aXN0c29wZXJhdGlvbiB3b3VsZCBibG9ja25vdCBhIGRpcmVjdG9yeWlzIGEgZGlyZWN0b3J5ZGlyZWN0b3J5IG5vdCBlbXB0eXJlYWQtb25seSBmaWxlc3lzdGVtIG9yIHN0b3JhZ2UgbWVkaXVtZmlsZXN5c3RlbSBsb29wIG9yIGluZGlyZWN0aW9uIGxpbWl0IChlLmcuIHN5bWxpbmsgbG9vcClzdGFsZSBuZXR3b3JrIGZpbGUgaGFuZGxlaW52YWxpZCBpbnB1dCBwYXJhbWV0ZXJpbnZhbGlkIGRhdGF0aW1lZCBvdXR3cml0ZSB6ZXJvbm8gc3RvcmFnZSBzcGFjZXNlZWsgb24gdW5zZWVrYWJsZSBmaWxlcXVvdGEgZXhjZWVkZWRmaWxlIHRvbyBsYXJnZXJlc291cmNlIGJ1c3lleGVjdXRhYmxlIGZpbGUgYnVzeWRlYWRsb2NrY3Jvc3MtZGV2aWNlIGxpbmsgb3IgcmVuYW1ldG9vIG1hbnkgbGlua3NpbnZhbGlkIGZpbGVuYW1lYXJndW1lbnQgbGlzdCB0b28gbG9uZ29wZXJhdGlvbiBpbnRlcnJ1cHRlZHVuc3VwcG9ydGVkdW5leHBlY3RlZCBlbmQgb2YgZmlsZW91dCBvZiBtZW1vcnlpbiBwcm9ncmVzc290aGVyIGVycm9ydW5jYXRlZ29yaXplZCBlcnJvck9zAAAAAAAEAAAABAAAAPYAAABjb2RlAAAAAAEAAAABAAAA9wAAAGtpbmTvAAAADAAAAAQAAAD4AAAAbWVzc2FnZUtpbmRFcnJvcgAAAAAIAAAABAAAAPkAAAAAAAAABAAAAAQAAAD6AAAAQ3VzdG9tZXJyb3IgKG9zIGVycm9yICkAAQAAAAAAAABvdRAACwAAAHp1EAABAAAAOiBwYW5pY2tlZCBhdCA6CmNhbm5vdCByZWN1cnNpdmVseSBhY3F1aXJlIG11dGV4pHUQACAAAABsaWJyYXJ5L3N0ZC9zcmMvc3lzL3N5bmMvbXV0ZXgvbm9fdGhyZWFkcy5yc8x1EAAsAAAAEwAAAAkAAABsaWJyYXJ5L3N0ZC9zcmMvc3luYy9wb2lzb24vb25jZS5ycwAIdhAAIwAAAJ4AAAAyAAAAbGlicmFyeS9zdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzAAAAPHYQACEAAADRAAAAEwAAADx1bmtub3duPu+/vW1lbW9yeSBhbGxvY2F0aW9uIG9mICBieXRlcyBmYWlsZWQAAHx2EAAVAAAAkXYQAA0AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnOwdhAAGAAAAGMBAAAJAAAAY2Fubm90IG1vZGlmeSB0aGUgcGFuaWMgaG9vayBmcm9tIGEgcGFuaWNraW5nIHRocmVhZNh2EAA0AAAANm8QABwAAACOAAAACQAAAAoAAADvAAAADAAAAAQAAAD7AAAAAAAAAAgAAAAEAAAA/AAAAAAAAAAIAAAABAAAAP0AAAD+AAAA/wAAAAABAAABAQAAEAAAAAQAAAACAQAAAwEAAAQBAAAFAQAAbGlicmFyeS9zdGQvc3JjLy4uLy4uL2JhY2t0cmFjZS9zcmMvc3ltYm9saXplL21vZC5yc4B3EAA0AAAAZwEAADAAAAABAAAAAAAAAJR1EAACAAAAIC0gAAEAAAAAAAAA1HcQAAMAAAAgICAgICAgICAgICAgICAgICAgYXQgAAB4cBAAAQAAAE5vdEZvdW5kUGVybWlzc2lvbkRlbmllZENvbm5lY3Rpb25SZWZ1c2VkQ29ubmVjdGlvblJlc2V0SG9zdFVucmVhY2hhYmxlTmV0d29ya1VucmVhY2hhYmxlQ29ubmVjdGlvbkFib3J0ZWROb3RDb25uZWN0ZWRBZGRySW5Vc2VBZGRyTm90QXZhaWxhYmxlTmV0d29ya0Rvd25Ccm9rZW5QaXBlQWxyZWFkeUV4aXN0c1dvdWxkQmxvY2tOb3RBRGlyZWN0b3J5SXNBRGlyZWN0b3J5RGlyZWN0b3J5Tm90RW1wdHlSZWFkT25seUZpbGVzeXN0ZW1GaWxlc3lzdGVtTG9vcFN0YWxlTmV0d29ya0ZpbGVIYW5kbGVJbnZhbGlkSW5wdXRJbnZhbGlkRGF0YVRpbWVkT3V0V3JpdGVaZXJvU3RvcmFnZUZ1bGxOb3RTZWVrYWJsZVF1b3RhRXhjZWVkZWRGaWxlVG9vTGFyZ2VSZXNvdXJjZUJ1c3lFeGVjdXRhYmxlRmlsZUJ1c3lEZWFkbG9ja0Nyb3NzZXNEZXZpY2VzVG9vTWFueUxpbmtzSW52YWxpZEZpbGVuYW1lQXJndW1lbnRMaXN0VG9vTG9uZ0ludGVycnVwdGVkVW5zdXBwb3J0ZWRVbmV4cGVjdGVkRW9mT3V0T2ZNZW1vcnlJblByb2dyZXNzT3RoZXJVbmNhdGVnb3JpemVkb3BlcmF0aW9uIHN1Y2Nlc3NmdWxPbmNlIGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQ6ehAAKgAAAG9uZS10aW1lIGluaXRpYWxpemF0aW9uIG1heSBub3QgYmUgcGVyZm9ybWVkIHJlY3Vyc2l2ZWx5bHoQADgAAAAQAAAAEQAAABIAAAAQAAAAEAAAABMAAAASAAAADQAAAA4AAAAVAAAADAAAAAsAAAAVAAAAFQAAAA8AAAAOAAAAEwAAACYAAAA4AAAAGQAAABcAAAAMAAAACQAAAAoAAAAQAAAAFwAAAA4AAAAOAAAADQAAABQAAAAIAAAAGwAAAA4AAAAQAAAAFgAAABUAAAALAAAAFgAAAA0AAAALAAAACwAAABMAAAAMchAAHHIQAC1yEAA/chAAT3IQAF9yEABychAAhHIQAJFyEACfchAAtHIQAMByEADLchAA4HIQAPVyEAAEcxAAEnMQACVzEABLcxAAg3MQAJxzEACzcxAAv3MQAMhzEADScxAA4nMQAPlzEAAHdBAAFXQQACJ0EAA2dBAAPnQQAFl0EABndBAAd3QQAI10EACidBAArXQQAMN0EADQdBAA23QQAOZ0EAAIAAAAEAAAABEAAAAPAAAADwAAABIAAAARAAAA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YSBmb3JtYXR0aW5nIHRyYWl0IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgc3RyZWFtIGRpZCBub3RsaWJyYXJ5L2FsbG9jL3NyYy9mbXQucnMAAP6GEAAYAAAAigIAAA4AAABsaWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAKIcQABoAAAChAAAAGQAAAO+/vQBshhAAGwAAAI0FAAAbAAAAACkuLjAxMjM0NTY3ODlhYmNkZWYBAAAAAAAAAFtjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyAAALCHEAAgAAAA0IcQABIAAAAAAAAABAAAAAQAAAAbAQAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAD4gQABAAAAAfiBAAFwAAADaIEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAAA+IEAAQAAAAWIgQABAAAABoiBAACQAAADaIEAAJAAAAOiAAAAEAAAAAAAAAlIgQAAIAAAAAAAAADAAAAAQAAAAcAQAAHQEAAB4BAAAgICAgIHsgLCAgewosCn0gfSgoCiwKXTB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTlsaWJyYXJ5L2NvcmUvc3JjL2ZtdC9tb2QucnNmYWxzZXRydWUAAAChiRAAGwAAAKAKAAAmAAAAoYkQABsAAACpCgAAGgAAAHVzZXItcHJvdmlkZWQgY29tcGFyaXNvbiBmdW5jdGlvbiBkb2VzIG5vdCBjb3JyZWN0bHkgaW1wbGVtZW50IGEgdG90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KjCgK2+mYCwCqOAsHvvgLQD+IDae/2A2/QHhNgEKITckDeE3qw5hOS8Y4TkwHOFK8x7hTkA0oVIeYeFT8GphVE9v4VSdvGFVAM9hVmXRoVYA2iFXAOChWK7iIVrs5OFb0OhhXCAA7lzwAX9dAHAABwAtAQEBAgECAQFICzAVEAFlBwIGAgIBBCMBHhtbCzoJCQEYBAEJAQMBBSsDOwkqGAEgNwEBAQQIBAEDBwoCHQE6AQEBAgQIAQkBCgIaAQICOQEEAgQCAgMDAR4CAwELAjkBBAUBAgQBFAIWBgEBOgEBAgEECAEHAwoCHgE7AQEBDAEJASgBAwE3AQEDBQMBBAcCCwIdAToBAgIBAQMDAQQHAgsCHAI5AgEBAgQIAQkBCgIdAUgBBAECAwEBCAFRAQIHDAhiAQIJCwdJAhsBAQEBATcOAQUBAgULASQJAWYEAQYBAgICGQIEAxAEDQECAgYBDwEAAwAEHAMdAh4CQAIBBwgBAgsJAS0DAQF1AiIBdgMEAgkBBgPbAgIBOgEBBwEBAQECCAYKAgEwHzEEMAoEAyYJDAIgBAIGOAEBAgMBAQU4CAICmAMBDQEHBAEGAQMCxkAAAcMhAAONAWAgAAZpAgAEAQogAlACAAEDAQQBGQIFAZcCGhINASYIGQsBASwDMAECBAICAgEkAUMGAgICAgwBCAEvATMBAQMCAgUCAQEqAggB7gECAQQBAAEAEBAQAAIAAeIBlQUAAwECBQQoAwQBpQIABEEFAAJPBEYLMQR7ATYPKQECAgoDMQQCAgcBPQMkBQEIPgEMAjQJAQEIBAIBXwMCBAYBAgGdAQMIFQI5AgEBAQEMAQkBDgcDBUMBAgYBAQIBAQMEAwEBDgJVCAIDAQEXAVEBAgYBAQIBAQIBAusBAgQGAgECGwJVCAIBAQJqAQEBAghlAQEBAgQBBQAJAQL1AQoEBAGQBAICBAEgCigGAgQIAQkGAgMuDQECAAcBBgEBUhYCBwECAQJ6BgMBAQIBBwEBSAIDAQEBAAILAjQFBQMXAQABBg8ADAMDAAU7BwABPwRRAQsCAAIALgIXAAUDBggIAgceBJQDADcEMggBDgEWBQEPAAcBEQIHAQIBBWQBoAcAAT0EAAT+AgAHbQcAYIDwAAICAgICAgICAgMDAQEBAEHvsMIACxABAAAAAAAAAAICAAAAAAACAEGuscIACwECAEHUscIACwEBAEHvscIACwEBAHsJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjg1LjAgKDRkOTFkZTRlNCAyMDI1LTAyLTE3KQZ3YWxydXMGMC4yMy4yDHdhc20tYmluZGdlbhIwLjIuOTkgKDA0Y2E2ZjM0YSkASQ90YXJnZXRfZmVhdHVyZXMEKw9tdXRhYmxlLWdsb2JhbHMrCHNpZ24tZXh0Kw9yZWZlcmVuY2UtdHlwZXMrCm11bHRpdmFsdWU=", module.meta.url);
        }
        const imports = __wbg_get_imports();
        if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
          module_or_path = fetch(module_or_path);
        }
        const { instance, module: module$1 } = await __wbg_load(await module_or_path, imports);
        return __wbg_finalize_init(instance, module$1);
      }
      function loader() {
        {
          const url = new URL("data:application/wasm;base64,AGFzbQEAAAABtgIqYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AGADf39/AGABfwF/YAADf39/YAACf39gAn9/A39/f2AEf39/fwBgA39+fgBgAABgBX9/f39/AGAFf39/b38AYAAEf39/f2ABfwJ/f2ADf35+AX9gB39/f39/f38Bf2AGf39/f39/AGAAAX9gBX9/f39/AX9gBH9/f38Bf2ADf39/A39/f2ADf39vAn9/YAd/f39/f39/AGAEf39/bwN/f39gBH9/f38Df39/YAJ/fwR/f39/YAN/f28AYAJ/fwFvYAABb2ACf28AYAZ/f39/f38Bf2ADfn9/AX5gA39+fwBgAn9+AX9gDH9/f39/f39/f39/fwJ/f2ADf39vBH9/f39gBX9/f29/An9/YAF/A39/f2AEf39vfwBgBH9/f28AAuUBBwN3YmceX193YmluZGdlbl9jb3B5X3RvX3R5cGVkX2FycmF5ABwDd2JnFF9fd2JpbmRnZW5fZXJyb3JfbmV3AB0Dd2JnGl9fd2JnX25ld184YTZmMjM4YTZlY2U4NmVhAB4Dd2JnHF9fd2JnX3N0YWNrXzBlZDc1ZDY4NTc1YjBmM2MAHwN3YmccX193YmdfZXJyb3JfNzUzNGI4ZTlhMzZmMWFiNAABA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUACwPtA+sDBAUBBBgBBAQEAAQEAAwRAAUEDAUFEgEECQQMAAIFAgEgBQQEAwIBBAMDAwMECQQFAgIEAAIBAAEDAQERARgSAQQJBQIEBRMAAQEEABIUASEBEQQBAAAAAAAJBAQAAAAAAAAAAAIBFAQACQAAAAEEBAQBAQEDBAQiBAQAAwMJBAIBAAUABAQABAUEASMABQEVDAABBQMDAAIDAAkAEwQEBQUBAQEAAAkDAQAEAQUAAAADAwABAwoDAwoKCgwEAwkDAQEDAAABBAEDBAUDCgIBAQQBAQMBAQECBQMEBAEBAAQBAQEDCwMCCwICAgAJBQMDBAECAgIBAgMDBAIBJAAAAwMUBQUFAwMDAwMDAwMBAAUFAAUFBQUFBQUAAAAAAAMDAwAlAwUFBRkaGRsaGwMDAwMDEwUFFiYWFgEICAgICAgICAgICAgICQEnFxcXBRUABgEPDw8PDwAAAwMDAwoKCgMAEBAQEBAAAwUAAwQNDQ0NDQ0AKCkBAQEBFQEBAQEEAgMAAAAMAQEAAQEBAQEBAwEBAQEBAAUBAQEBAQEBAQEAAQEAAAEAAAAABAQEAAQDAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAABCwsAAAABAAAAAAAAAQACBAEAAAELBQQECwJwAZ8CnwJvAIABBQMBABEGCQF/AUGAgMAACwfBDU0GbWVtb3J5AgASX193YmdfbmNtZmlsZV9mcmVlAM4BC25jbWZpbGVfbmV3ANcCDG5jbWZpbGVfb3BlbgC8Ag9uY21maWxlX2RlY3J5cHQAvQITbmNtZmlsZV9hdWRpb09mZnNldADQAhBkZWNyeXB0WDJNSGVhZGVyANECEGRlY3J5cHRYM01IZWFkZXIA0gIRX193YmdfeG1seXBjX2ZyZWUAxwEUeG1seXBjX2dldEhlYWRlclNpemUAwQIKeG1seXBjX25ldwDCAhJ4bWx5cGNfYXVkaW9IZWFkZXIA2QIceG1seXBjX2VuY3J5cHRlZEhlYWRlck9mZnNldACWAhp4bWx5cGNfZW5jcnlwdGVkSGVhZGVyU2l6ZQCXAg54bWx5cGNfZGVjcnlwdACuAhNfX3diZ19qb294ZmlsZV9mcmVlANsBDmpvb3hmaWxlX3BhcnNlAK8CFWpvb3hmaWxlX2J1ZmZlckxlbmd0aACZAhBqb294ZmlsZV9kZWNyeXB0ALACFl9fd2JnX2t1Z291aGVhZGVyX2ZyZWUAyAEPa3Vnb3VoZWFkZXJfbmV3AMMCFWt1Z291aGVhZGVyX2F1ZGlvSGFzaADaAhNrdWdvdWhlYWRlcl92ZXJzaW9uAJoCGGt1Z291aGVhZGVyX29mZnNldFRvRGF0YQCbAhBfX3diZ19rdWdvdV9mcmVlAKgBEWt1Z291X2Zyb21faGVhZGVyAMQCEmt1Z291X2Zyb21IZWFkZXJWNQC+Ag1rdWdvdV9kZWNyeXB0APQCFWt1Z291X2RlY3J5cHREYXRhYmFzZQDTAgtkZWNyeXB0UU1DMQD7Ag9fX3diZ19xbWMyX2ZyZWUAsgEIcW1jMl9uZXcAxQIMcW1jMl9kZWNyeXB0APUCFF9fd2JnX3FtY2Zvb3Rlcl9mcmVlAJkBD3FtY2Zvb3Rlcl9wYXJzZQDGAg5xbWNmb290ZXJfZWtleQDbAg5xbWNmb290ZXJfc2l6ZQCcAhNxbWNmb290ZXJfbWVkaWFOYW1lANwCFV9fd2JnX3Fpbmd0aW5nZm1fZnJlZQDnARdxaW5ndGluZ2ZtX2dldERldmljZUtleQCDAhRxaW5ndGluZ2ZtX2dldEZpbGVJVgCxAg5xaW5ndGluZ2ZtX25ldwCyAhJxaW5ndGluZ2ZtX2RlY3J5cHQA9gINaW5pdFBhbmljSG9vawDvAxVfX3diZ19rdXdvaGVhZGVyX2ZyZWUA3AEQa3V3b2hlYWRlcl9wYXJzZQDHAhRrdXdvaGVhZGVyX3F1YWxpdHlJZACdAhVrdXdvaGVhZGVyX3Jlc291cmNlSWQAngIXa3V3b0JvZGlhbkNpcGhlckZhY3RvcnkAyAIYX193Ymdfa3dtZGVjaXBoZXJ2MV9mcmVlAOgBFWt3bWRlY2lwaGVydjFfZGVjcnlwdAD3AhNrdXdvVjJDaXBoZXJGYWN0b3J5AMkCFl9fd2JnX2t3bWRlY2lwaGVyX2ZyZWUAqQEZa3dtZGVjaXBoZXJfbWFrZV9kZWNpcGhlcgC/AhNrd21kZWNpcGhlcl9kZWNyeXB0APgCDmRlY3J5cHRRUkNGaWxlAKkCEWRlY3J5cHRRUkNOZXR3b3JrALMCEF9fd2JnX3hpYW1pX2ZyZWUA3QEReGlhbWlfZnJvbV9oZWFkZXIAygINeGlhbWlfZGVjcnlwdAD8AhV4aWFtaV9jb3B5UGxhaW5MZW5ndGgAnwIaX193YmdfYXVkaW90eXBlcmVzdWx0X2ZyZWUAzAEiX193YmdfZ2V0X2F1ZGlvdHlwZXJlc3VsdF9uZWVkTW9yZQDUAiJfX3diZ19zZXRfYXVkaW90eXBlcmVzdWx0X25lZWRNb3JlANgCI19fd2JnX2dldF9hdWRpb3R5cGVyZXN1bHRfYXVkaW9UeXBlAN0CI19fd2JnX3NldF9hdWRpb3R5cGVyZXN1bHRfYXVkaW9UeXBlAKUBD2RldGVjdEF1ZGlvVHlwZQDLAhFfX3diZ19taWd1M2RfZnJlZQDpARFtaWd1M2RfZnJvbUhlYWRlcgDMAhJtaWd1M2RfZnJvbUZpbGVLZXkAzQIObWlndTNkX2RlY3J5cHQA+QIPX193YmluZGdlbl9mcmVlAIYDEV9f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CwJAIABBACAAa0EDcSIGaiIFIABNDQAgACEDIAEhBCAGBEAgBiEHA0AgAyAELQAAOgAAIARBAWohBCADQQFqIQMgB0EBayIHDQALCyAGQQFrQQdJDQADQCADIAQtAAA6AAAgA0EBaiAEQQFqLQAAOgAAIANBAmogBEECai0AADoAACADQQNqIARBA2otAAA6AAAgA0EEaiAEQQRqLQAAOgAAIANBBWogBEEFai0AADoAACADQQZqIARBBmotAAA6AAAgA0EHaiAEQQdqLQAAOgAAIARBCGohBCADQQhqIgMgBUcNAAsLIAUgAiAGayIHQXxxIghqIQMCQCABIAZqIgRBA3FFBEAgAyAFTQ0BIAQhAQNAIAUgASgCADYCACABQQRqIQEgBUEEaiIFIANJDQALDAELIAMgBU0NACAEQQN0IgJBGHEhBiAEQXxxIglBBGohAUEAIAJrQRhxIQogCSgCACECA0AgBSACIAZ2IAEoAgAiAiAKdHI2AgAgAUEEaiEBIAVBBGoiBSADSQ0ACwsgB0EDcSECIAQgCGohAQsCQCADIAIgA2oiBk8NACACQQdxIgQEQANAIAMgAS0AADoAACABQQFqIQEgA0EBaiEDIARBAWsiBA0ACwsgAkEBa0EHSQ0AA0AgAyABLQAAOgAAIANBAWogAUEBai0AADoAACADQQJqIAFBAmotAAA6AAAgA0EDaiABQQNqLQAAOgAAIANBBGogAUEEai0AADoAACADQQVqIAFBBWotAAA6AAAgA0EGaiABQQZqLQAAOgAAIANBB2ogAUEHai0AADoAACABQQhqIQEgA0EIaiIDIAZHDQALCyAAC7MGAQR/IwBBIGsiAiQAAkACQAJAAkACQAJAAkACQAJAAkAgAQ4oAAcHBwcHBwcHAQMHBwIHBwcHBwcHBwcHBwcHBwcHBwcHBwQHBwcHBQYLIABBgAQ7AQogAEIANwECIABB3OAAOwEADAgLIABBgAQ7AQogAEIANwECIABB3OgBOwEADAcLIABBgAQ7AQogAEIANwECIABB3OQBOwEADAYLIABBgAQ7AQogAEIANwECIABB3NwBOwEADAULIABBgAQ7AQogAEIANwECIABB3MQAOwEADAQLIABBgAQ7AQogAEIANwECIABB3M4AOwEADAMLIAFB3ABGDQELAkAgAUH/BU0NACABEExF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IANB0ABqELoCIQEgAEGAgICAeDYCACAAIAE2AgQMBAtBAUEIQdiqwQAQ8wIACyAAIARBARAeQQghAQsgBCABQQEQsQMLIAdFDQAgBSAHQQEQsQMLIANB4ABqJAALngUCBn4Hf0GAgICAeCEOAkACQAJAAkACQCADQQdxDQBBhICAgHghDiADQQhJDQADQCADQQhrIQMgAkEIakEAIQ0gAikAAEHst8AAQcAAEFYhBgNAIAZCIIgiCCAGQoCAgIBwg4QhByABIA1BA3RqKQMAIQlCACEEQWghCkG4vsAAIQtCACEFA0AgCkGEvcAAai0AACIPQcAATw0EIApBnL3AAGotAAAhDCAPQQN0Qbi+wABqKQMAIAeDUEUEQCALKQMAIAWEIQULIAxBwABPDQUgDEEDdEG4vsAAaikDACAHg1BFBEAgCykDACAEhCEECyALQQhqIQsgCkEBaiIKDQALIAVC/////w+DIARCIIaEIAmFIgSnIgpBGnZB7LjAAGoxAABCCIYgCkEUdkE/cUGsucAAajEAAEIEhoQgCkEOdkE/cUHsucAAajEAAIRCCIYgCkEIdkE/cUGsusAAajEAAEIEhoQgBEI6iKdB7LrAAGoxAACEQgiGIARCNIinQT9xQay7wABqMQAAQgSGhCAEQi6Ip0E/cUHsu8AAajEAAIRCBIZC8P///w+DIARCKIinQT9xQay8wABqMQAAhCEFQgAhBEEAIQpBuL7AACELA0AgCkGcvcAAai0AACIMQcAATw0GIAxBA3RBuL7AAGopAwAgBYNQRQRAIApBwAFxDQggCykDACAEhCEECyALQQhqIQsgCkEBaiIKQSBHDQALIAQgBoVCIIYgCIQhBiANQQFqIg1BEEcNAAsgAiAGQiCJQay4wABBwAAQVjcAACECIANBB0sNAAsLIAAgDjYCAA8LIA9BwABB2MLAABDQAQALIAxBwABB2MLAABDQAQALIAxBwABB2MLAABDQAQALIApBwABB2MLAABDQAQALxRYCDH4TfyMAQRBrIh4kACABKAIEIg8gASkDGCIDIAKtQv8BgyIKhULzytHLp4zZsvUAhSIEQhCJIAQgASkDECIGQuHklfPW7Nm87ACFfCIEhSILIANC7d6R85bM3LfkAIUiAyAGQvXKzYPXrNu38wCFfCIGQiCJfCINIApCgICAgICAgIAB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ASgCACADQQxqIAFBBGooAgARAAANAiAAQQhqIQAgCyAIQSBqIghHDQALCyAHIAIoAgRPDQEgAygCKCACKAIAIAdBA3RqIgAoAgAgACgCBCADKAIsKAIMEQIARQ0BC0EBDAELQQALIANBMGokAAvKBAEGfyMAQTBrIgMkACADIAI2AgggAyABNgIEIANBIGogA0EEahBAAkACQCADKAIgIgZFBEBBACEBQQEhBgwBCyADKAIkIQEgAygCLEUNAAJAIAJBAEgNAAJAIAJFBEBBASEFDAELQdGywgAtAAAaQQEhBCACQQEQnAMiBUUNAQtBACEEIANBADYCFCADIAU2AhAgAyACNgIMIAEgAksEQCADQQxqQQAgARCOASADKAIQIQUgAygCFCEEIAMoAgwhAgsgBCAFaiAGIAEQLBogAyABIARqIgE2AhQgAiABa0ECTQRAIANBDGogAUEDEI4BIAMoAhAhBSADKAIUIQELIAEgBWoiAkHUjsIALwAAIgU7AAAgAkECakHWjsIALQAAIgc6AAAgAyABQQNqIgI2AhQgAyADKQIENwIYIANBIGogA0EYahBAIAMoAiAiBgRAA0AgAygCLCADKAIkIgEgAygCDCACa0sEQCADQQxqIAIgARCOASADKAIUIQILIAMoAhAiBCACaiAGIAEQLBogAyABIAJqIgI2AhQEQCADKAIMIAJrQQJNBEAgA0EMaiACQQMQjgEgAygCECEEIAMoAhQhAgsgAiAEaiIBIAU7AAAgAUECaiAHOgAAIAMgAkEDaiICNgIUCyADQSBqIANBGGoQQCADKAIgIgYNAAsLIAAgAykCDDcCACAAQQhqIANBFGooAgA2AgAMAgsgBCACQYiNwgAQ8wIACyAAIAE2AgggACAGNgIEIABBgICAgHg2AgALIANBMGokAAuWBAEEfyMAQYABayIEJAACQAJAAkAgASgCFCICQRBxRQRAIAJBIHENAUEBIQIgACgCAEEBIAEQa0UNAgwDCyAAKAIAIQIDQCADIARqQf8AaiACQQ9xIgVBMHIgBUHXAGogBUEKSRs6AAAgA0EBayEDIAJBEEkgAkEEdiECRQ0AC0EBIQIgAUEBQdeRwgBBAiADIARqQYABakEAIANrECdFDQEMAgsgACgCACECA0AgAyAEakH/AGogAkEPcSIFQTByIAVBN2ogBUEK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BSgCDCIIIA1CJYinaiAFKAIIIgsgCUEEdGogCUHwyKHkAWtzc2siBkEEdGogBkHwyKHkAWtzIAUoAgQiCSAGQQV2anNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0HXw4CqBGpzc2siBkEEdCAKaiAGQdfDgKoEanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0Hir93HBWtzc2siBkEEdCAKaiAGQeKv3ccFa3MgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0Hl3MTGAGpzc2siBkEEdCAKaiAGQeXcxMYAanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0Gs6ebUBmpzc2siBkEEdCAKaiAGQazp5tQGanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0GNivecA2tzc2siBkEEdCAKaiAGQY2K95wDa3MgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0G6gqvxAmpzc2siBkEEdCAKaiAGQbqCq/ECanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0H/8LKAB2tzc2siBkEEdCAKaiAGQf/wsoAHa3MgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0G45JDyAGtzc2siBkEEdCAKaiAGQbjkkPIAa3MgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0GPqJGcBWpzc2siBkEEdCAKaiAGQY+okZwFanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0Gqy8zVBGtzc2siBkEEdCAKaiAGQarLzNUEa3MgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0GdwdW4AWpzc2siBkEEdCAKaiAGQZ3B1bgBanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0HkzffGB2pzc2siBkEEdCAKaiAGQeTN98YHanMgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0HVpeaqAmtzc2siBkEEdCAKaiAGQdWl5qoCa3MgBkEFdiAJanNrIgcgBiAHQQV2IAhqIAdBBHQgC2ogB0Hy5rvjA2pzc2siBkEEdCAKaiAGQfLmu+MDanMgBkEFdiAJanNrIgcgCiAGIAdBBXYgCGogB0EEdCALaiAHQceMoo4Ga3NzayIIQQR0aiAIQceMoo4Ga3MgCEEFdiAJanNrrUIghiAIrYQiD4UiDUI4hiANQoD+A4NCKIaEIA1CgID8B4NCGIYgDUKAgID4D4NCCIaEhCANQgiIQoCAgPgPgyANQhiIQoCA/AeDhCANQiiIQoD+A4MgDUI4iISEhDcAACACQQhqIQIgDEEBayIMDQALIAEgBEEHayIDaiICLQABIAItAAByIAItAAJyIAItAANyIAItAARyIAItAAVyIAItAAZyRQRAIAMgAS0AAEEHcUEDaiICSQ0CIABBBjYCACAAIAMgAms2AgggACABIAJqNgIEDwsgAUEAIAQQShogAEEENgIADwsgACACNgIIIAAgBDYCBCAAQQI2AgAPCyACIANBnMTBABC1AwAL+QMBAn8gACABaiECAkACQCAAKAIEIgNBAXENACADQQJxRQ0BIAAoAgAiAyABaiEBIAAgA2siAEHQ9sIAKAIARgRAIAIoAgRBA3FBA0cNAUHI9sIAIAE2AgAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCACIAE2AgAMAgsgACADEFoLAkACQAJAIAIoAgQiA0ECcUUEQCACQdT2wgAoAgBGDQIgAkHQ9sIAKAIARg0DIAIgA0F4cSICEFogACABIAJqIgFBAXI2AgQgACABaiABNgIAIABB0PbCACgCAEcNAUHI9sIAIAE2AgAPCyACIANBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsgAUGAAk8EQCAAIAEQbA8LIAFB+AFxQbj0wgBqIQICf0HA9sIAKAIAIgNBASABQQN2dCIBcUUEQEHA9sIAIAEgA3I2AgAgAgwBCyACKAIICyEBIAIgADYCCCABIAA2AgwgACACNgIMIAAgATYCCA8LQdT2wgAgADYCAEHM9sIAQcz2wgAoAgAgAWoiATYCACAAIAFBAXI2AgQgAEHQ9sIAKAIARw0BQcj2wgBBADYCAEHQ9sIAQQA2AgAPC0HQ9sIAIAA2AgBByPbCAEHI9sIAKAIAIAFqIgE2AgAgACABQQFyNgIEIAAgAWogATYCAAsLmQMBAn8CQAJAAkACQCACQQdqIgQgAU8NACACQQ9qIgMgAU8NAiAAIANBAnRqIAAgBEECdGooAgA2AgAgAkEGaiIEIAFPDQAgAkEOaiIDIAFPDQIgACADQQJ0aiAAIARBAnRqKAIANgIAIAJBBWoiBCABTw0AIAJBDWoiAyABTw0CIAAgA0ECdGogACAEQQJ0aigCADYCACACQQRqIgQgAU8NACACQQxqIgMgAU8NAiAAIANBAnRqIAAgBEECdGooAgA2AgAgAkEDaiIEIAFPDQAgAkELaiIDIAFPDQIgACADQQJ0aiAAIARBAnRqKAIANgIAIAJBAmoiBCABTw0AIAJBCmoiAyABTw0CIAAgA0ECdGogACAEQQJ0aigCADYCACACQQFqIgQgAU8NACACQQlqIgMgAU8NAiAAIANBAnRqIAAgBEECdGooAgA2AgAgASACSw0BIAIhBAsgBCABQazbwQAQ0AEACyACQQhqIgMgAUkNAQsgAyABQbzbwQAQ0AEACyAAIANBAnRqIAAgAkECdGooAgA2AgALowMDCH8BfAF+IAAoAgQiBgRAIAMgA0GAKG4iBEGAKGwiCWshBQJAIAJBgCwgBSAAKAIAIAQgBnBqMQAAIg1QBH9BAAVCfwJ+IAArAwggDSAEQQFqrX66o0QAAAAAAABZQKIiDEQAAAAAAADwQ2MgDEQAAAAAAAAAAGYiBHEEQCAMsQwBC0IAC0IAIAQbIAxE////////70NkG6dB/wNxCyIGaiIFayIEIAIgBEkbIgJFDQAgACgCECEIQQAhBCACQQRPBEAgBSAIaiEKIAJB/D9xIQsDQCABIARqIgAgAC0AACAEIApqIgUtAABzOgAAIABBAWoiByAHLQAAIAVBAWotAABzOgAAIABBAmoiByAHLQAAIAVBAmotAABzOgAAIABBA2oiACAALQAAIAVBA2otAABzOgAAIAsgBEEEaiIERw0ACwsgAkEDcSIARQ0AQQAgAGshAiABIARqIQAgCCAEIAZqIANqIAlraiEEA0AgACAALQAAIAQtAABzOgAAIABBAWohACAEQQFqIQQgAkEBaiICDQALCw8LQZCuwQAQpwIAC6ADAgd/An4jAEEQayIEJAACfwJAIAAoAgAiA0UNACAAKAIIIgIgACgCBCIFTw0AIAIgA2oiAS0AAEHMAEYEQCAAIAJBAWoiATYCCCAAAn4CQCABIAVJBEAgASADai0AAEHfAEYNAQsgASAFIAEgBUsbIQcCQAJAA0ACQCABIAVJBEAgASADai0AAEHfAEYNAQsgASAHRg0CAkAgASADai0AACICQTBrIgZB/wFxQQpJDQAgAkHhAGtB/wFxQRpPBEAgAkHBAGtB/wFxQRpPDQQgAkEdayEGDAELIAJB1wBrIQYLIAAgAUEBaiIBNgIIIAQgCEI+EMEBIAQpAwhCAFINAiAEKQMAIgkgBq1C/wGDfCIIIAlaDQEMAgsLIAAgAUEBajYCCCAIQn9SDQELIAAoAhAiAwRAQQFBpIbCAEEQIAMQ6QMNBhoLIABBADoABCAAQQA2AgBBAAwFCyAIQgF8DAELIAAgAkECajYCCEIACxCSAQwCCyABLQAAQcsARw0AIAAgAkEBajYCCCAAQQAQEwwBCyAAEBoLIARBEGokAAuUAwEEfwJAIAJBEEkEQCAAIQMMAQsCQCAAQQAgAGtBA3EiBWoiBCAATQ0AIAAhAyAFBEAgBSEGA0AgAyABOgAAIANBAWohAyAGQQFrIgYNAAsLIAVBAWtBB0kNAANAIAMgAToAACADQQdqIAE6AAAgA0EGaiABOgAAIANBBWogAToAACADQQRqIAE6AAAgA0EDaiABOgAAIANBAmogAToAACADQQFqIAE6AAAgA0EIaiIDIARHDQALCyAEIAIgBWsiAkF8cWoiAyAESwRAIAFB/wFxQYGChAhsIQUDQCAEIAU2AgAgBEEEaiIEIANJDQALCyACQQNxIQILAkAgAyACIANqIgVPDQAgAkEHcSIEBEADQCADIAE6AAAgA0EBaiEDIARBAWsiBA0ACwsgAkEBa0EHSQ0AA0AgAyABOgAAIANBB2ogAToAACADQQZqIAE6AAAgA0EFaiABOgAAIANBBGogAToAACADQQNqIAE6AAAgA0ECaiABOgAAIANBAWogAToAACADQQhqIgMgBUcNAAsLIAALuQMCBn8BfiMAQUBqIgMkACADQSxqIAJBEBB9IANBMGohAgJAAkACQCADKAIsRQRAIANBEGogAkEIaikCADcDACADIAIpAgA3AwggASgCCCICQQBIDQEgASgCBCEEAkAgAkUEQEEBIQYMAQtB0bLCAC0AABpBASEFIAIQ9AEiBkUNAgsgA0EsaiAGIAIgBCACIANBCGoQRSADKAI0IQQgAygCMCEFIAMoAiwiB0EGRgRAQQAhByAEQQBIDQMCQCAERQRAQQEhCAwBC0HRssIALQAAGkEBIQcgBEEBEJwDIghFDQQLIAggBSAEECwhBSAAIAQ2AgwgACAFNgIIIAAgBDYCBCAAQQA2AgAgAkUNBCAGIAJBARCxAwwECyAAIAQ2AgwgACAFNgIIIAAgBzYCBCAAQQE2AgAgAkUNAyAGIAJBARCxAwwDCyADQSBqIAJBCGooAgAiBDYCACADIAIpAgAiCTcDGCAAQQxqIAQ2AgAgACAJNwIEIABBATYCAAwCCyAFIAJBsKnBABDzAgALIAcgBEHopcEAEPMCAAsgASgCACIABEAgASgCBCAAQQEQsQMLIANBQGskAAucAwEFfwJAQRFBACAAQa+wBE8bIgEgAUEIciIBIABBC3QiAiABQQJ0QdipwgBqKAIAQQt0SRsiASABQQRyIgEgAUECdEHYqcIAaigCAEELdCACSxsiASABQQJyIgEgAUECdEHYqcIAaigCAEELdCACSxsiASABQQFqIgEgAUECdEHYqcIAaigCAEELdCACSxsiASABQQFqIgEgAUECdEHYqcIAaigCAEELdCACSxsiA0ECdEHYqcIAaigCAEELdCIBIAJGIAEgAklqIANqIgJBIU0EQCACQQJ0QdipwgBqIgEoAgBBFXYhA0HvBSEEAn8CQCACQSFGDQAgASgCBEEVdiEEIAINAEEADAELIAFBBGsoAgBB////AHELIQECQCAEIANBf3NqRQ0AIAAgAWshAkHvBSADIANB7wVNGyEFIARBAWshAUEAIQADQCADIAVGDQMgACADQeCqwgBqLQAAaiIAIAJLDQEgASADQQFqIgNHDQALIAEhAwsgA0EBcQ8LIAJBIkG4p8IAENABAAsgBUHvBUHIp8IAENABAAvDAwEJfyMAQSBrIgEkAEH48sIALQAARQRAEOsBC0GA88IAKAIAIQVBgPPCAEEENgIAQfzywgAoAgAhAEH88sIAQQA2AgBBhPPCACgCACECQYTzwgBBADYCAEGI88IAKAIAIQdBiPPCAEEANgIAQYzzwgAoAgAhBkGM88IAQQA2AgACQCACIAdGBEACQCAAIAJGBEDQb0GAASAAIABBgAFNGyIE/A8BIgNBf0YNAwJAIAZFBEAgAyEGDAELIAAgBmogA0cNBAsgACAEaiIEQf////8BSw0DIAEgAAR/IAEgBTYCFCABIABBAnQ2AhxBBAVBAAs2AhggAUEIakEEIARBAnQgAUEUahChASABKAIIQQFGDQMgASgCDCEFIAAhAyAEIQAMAQsgAiEDIAAgAk0NAgsgBSADQQJ0aiACQQFqNgIAIANBAWohAgsgAiAHTQ0AIAUgB0ECdGooAgAhBEH88sIAKAIAIQhB/PLCACAANgIAQYDzwgAoAgAhA0GA88IAIAU2AgBBhPPCACACNgIAQYjzwgAgBDYCAEGM88IAIAY2AgAgCARAIAMgCEECdEEEELEDCyABQSBqJAAgBiAHag8LAAvnAgEFfwJAQc3/e0EQIAAgAEEQTRsiAGsgAU0NACAAQRAgAUELakF4cSABQQtJGyIEakEMahAIIgJFDQAgAkEIayEBAkAgAEEBayIDIAJxRQRAIAEhAAwBCyACQQRrIgUoAgAiBkF4cSACIANqQQAgAGtxQQhrIgIgAEEAIAIgAWtBEE0baiIAIAFrIgJrIQMgBkEDcQRAIAAgAyAAKAIEQQFxckECcjYCBCAAIANqIgMgAygCBEEBcjYCBCAFIAIgBSgCAEEBcXJBAnI2AgAgASACaiIDIAMoAgRBAXI2AgQgASACEEYMAQsgASgCACEBIAAgAzYCBCAAIAEgAmo2AgALAkAgACgCBCIBQQNxRQ0AIAFBeHEiAiAEQRBqTQ0AIAAgBCABQQFxckECcjYCBCAAIARqIgEgAiAEayIEQQNyNgIEIAAgAmoiAiACKAIEQQFyNgIEIAEgBBBGCyAAQQhqIQMLIAML5w4CCX8BfCMAQbAIayIFJAACQAJAIABFBEBB1LLCACEEIAVB1LLCADYCrAhB1NLCAC0AAEEDRwRAIAUgBUGsCGo2AgggBUEIaiEAIwBBsOABayICJAACQAJAAkACQAJAAkBB1NLCAC0AAEEBaw4DAgQBAAtB1NLCAEECOgAAIAAoAgAhBCAAQQA2AgAgBEUNAiAEKAIAIAJBCGpBAEGAIBBKGiACQYggakEAQYDAABBKGkRE+YIWErDjPyELA0AgAkGIIGoiBCAGaiIAIAs5AwAgAEEIaiALRGxblNkgsw5AokQAAAAAAADwPyALoaIiCzkDACAAQRBqIAtEbFuU2SCzDkCiRAAAAAAAAPA/IAuhoiILOQMAIABBGGogC0RsW5TZILMOQKJEAAAAAAAA8D8gC6GiIgs5AwAgC0RsW5TZILMOQKJEAAAAAAAA8D8gC6GiIQsgBkEgaiIGQYDAAEcNAAsgAkGI4ABqIgAgBEGAwAAQLBogAiACQa/gAWo2AoigASAAIAJBiKABahBDIAJBkKABaiAEQYDAABAsIQlBACEEQQAhAANAIAQiA0EBaiEEIAAiBkEEaiEAIAkgA0EDdGorAwAhCyAGIAJBCGpqQYBAIQZBACEDAkACQAJAAkADQCALIAJBiOAAaiAGaiIHQYBAaysDAGENBCALIAdBiMAAaisDAGENAyALIAdBkMAAaisDAGENAiALIAdBmMAAaisDAGENASADQQRqIQMgBkEgaiIGDQALQdPzwABBE0GE9MAAEOYBAAsgA0EDaiEDDAILIANBAmohAwwBCyADQQFqIQMLIAM2AgAgAkGI4ABqIANBA3RqQoCAgICAgIB8NwMAIABBgCBHDQALIAJBiKABaiIAIAJBCGpBgCAQLBogAEGAIBAsGkHU0sIAQQM6AAALIAJBsOABaiQADAMLIAJBADYCmKABIAJBATYCjKABIAJBwO3AADYCiKABDAYLQdzuwAAQtgMACyACQQA2ApigASACQQE2AoygASACQYDuwAA2AoigAQwECyAFKAKsCCEECyAFQZAIakGc9MAAKQAANwMAIAVBmAhqQaT0wAApAAA3AwAgBUGgCGpBrPTAACkAADcDACAFQZT0wAApAAA3A4gIDAELQdjSwgAhBCAFQdjSwgA2AqwIQdjywgAtAABBA0cEQCAFIAVBrAhqNgIIIAVBCGohACMAQbDgAWsiAiQAAkACQAJAAkACQAJAQdjywgAtAABBAWsOAwIEAQALQdjywgBBAjoAACAAKAIAIQQgAEEANgIAIARFDQIgBCgCACACQQhqQQBBgCAQShogAkGIIGpBAEGAwAAQShpEezNqvko+5z8hCwNAIAJBiCBqIgQgBmoiACALOQMAIABBCGogC0T6KY4Dr5YPQKJEAAAAAAAA8D8gC6GiIgs5AwAgAEEQaiALRPopjgOvlg9AokQAAAAAAADwPyALoaIiCzkDACAAQRhqIAtE+imOA6+WD0CiRAAAAAAAAPA/IAuhoiILOQMAIAtE+imOA6+WD0CiRAAAAAAAAPA/IAuhoiELIAZBIGoiBkGAwABHDQALIAJBiOAAaiIAIARBgMAAECwaIAIgAkGv4AFqNgKIoAEgACACQYigAWoQQyACQZCgAWogBEGAwAAQLCEJQQAhBEEAIQADQCAEIgNBAWohBCAAIgZBBGohACAJIANBA3RqKwMAIQsgBiACQQhqakGAQCEGQQAhAwJAAkACQAJAA0AgCyACQYjgAGogBmoiB0GAQGsrAwBhDQQgCyAHQYjAAGorAwBhDQMgCyAHQZDAAGorAwBhDQIgCyAHQZjAAGorAwBhDQEgA0EEaiEDIAZBIGoiBg0AC0HT88AAQRNBhPTAABDmAQALIANBA2ohAwwCCyADQQJqIQMMAQsgA0EBaiEDCyADNgIAIAJBiOAAaiADQQN0akKAgICAgICAfDcDACAAQYAgRw0ACyACQYigAWoiACACQQhqQYAgECwaIABBgCAQLBpB2PLCAEEDOgAACyACQbDgAWokAAwDCyACQQA2ApigASACQQE2AoygASACQcDtwAA2AoigAQwFC0Hc7sAAELYDAAsgAkEANgKYoAEgAkEBNgKMoAEgAkGA7sAANgKIoAEMAwsgBSgCrAghBAsgBUGQCGpBvPTAACkAADcDACAFQZgIakHE9MAAKQAANwMAIAVBoAhqQcz0wAApAAA3AwAgBUG09MAAKQAANwOICAsgBUEIaiABQYAIECwaIARBBGohBkEAIQACQANAIAQgAEH+B3FBAnRqKAIAIgNBgAhPDQEgACABaiICIAVBiAhqIgcgAEEecWotAAAgBUEIaiADai0AAHM6AAAgBigCACIDQf8HSw0BIAJBAWogAEEBakEfcSAHai0AACAFQQhqIANqLQAAczoAACAGQQhqIQYgAEECaiIAQYAIRw0ACyAFQbAIaiQADwsgA0GACEHU9MAAENABAAsgAkIENwKQoAEgAkGIoAFqQcT1wAAQwAIAC/QCAgZ/An4jAEEQayIEJAAgAAJ/AkACQCABKAIIIgMgASgCBCIFSQRAIAEoAgAiBiADai0AAEHzAEYNAQsgAEIANwMIDAELIAEgA0EBaiICNgIIAkACQAJAIAIgBU8NACACIAZqLQAAQd8ARw0AIAEgA0ECajYCCAwBCwJAAkADQAJAIAIgBUkEQCACIAZqLQAAQd8ARg0BCyACIAVGDQICQCACIAZqLQAAIgNBMGsiB0H/AXFBCkkNACADQeEAa0H/AXFBGk8EQCADQcEAa0H/AXFBGk8NBCADQR1rIQcMAQsgA0HXAGshBwsgASACQQFqIgI2AgggBCAIQj4QwQEgBCkDCEIAUg0CIAQpAwAiCSAHrUL/AYN8IgggCVoNAQwCCwsgASACQQFqNgIIIAhCf1INAQsgAEEAOgABQQEMBAsgCEIBfCIIQn9RDQELIAAgCEIBfDcDCAwBCyAAQQA6AAFBAQwBC0EACzoAACAEQRBqJAAL2QICBH8BfiMAQdAAayIEJAAgBCABIAJBm4PCAEEBEBQDQCAEQcQAaiAEEB0gBCgCRCIDRQ0ACwJAIAAgAgJ/IANBAkcEQCAEKAJIDAELIAILIgNrQRBNBH4gAiADRwRAIAEgAmohBiABIANqIQMDQAJ/IAMsAAAiAUEATgRAIAFB/wFxIQIgA0EBagwBCyADLQABQT9xIQUgAUEfcSECIAFBX00EQCACQQZ0IAVyIQIgA0ECagwBCyADLQACQT9xIAVBBnRyIQUgAUFwSQRAIAUgAkEMdHIhAiADQQNqDAELIAJBEnRBgIDwAHEgAy0AA0E/cSAFQQZ0cnIhAiADQQRqCyEDIAJBwQBrQV9xQQpqIAJBMGsgAkE5SxsiAUEQTw0DIAGtIAdCBIaEIQcgAyAGRw0ACwsgACAHNwMIQgEFIAcLNwMAIARB0ABqJAAPC0Gcg8IAELYDAAu/AwEBfyMAQUBqIgIkAAJAAkACQAJAAkACQCAALQAAQQFrDgMBAgMACyACIAAoAgQ2AgRB0bLCAC0AABpBFEEBEJwDIgBFDQQgAEEQakG29MEAKAAANgAAIABBCGpBrvTBACkAADcAACAAQab0wQApAAA3AAAgAkEUNgIQIAIgADYCDCACQRQ2AgggAkEDNgIsIAJB/OrBADYCKCACQgI3AjQgAiACQQRqrUKAgICAsB2ENwMgIAIgAkEIaq1CgICAgMAdhDcDGCACIAJBGGo2AjAgASgCHCABKAIgIAJBKGoQOCEAIAIoAggiAUUNAyACKAIMIAFBARCxAwwDCyAALQABIQAgAkEBNgIsIAJBhOTBADYCKCACQgE3AjQgAiACQRhqrUKAgICAkB2ENwMIIAIgAEECdCIAQaz1wQBqKAIANgIcIAIgAEHU9sEAaigCADYCGCACIAJBCGo2AjAgASgCHCABKAIgIAJBKGoQOCEADAILIAAoAgQiACgCACAAKAIEIAEQ6QMhAAwBCyAAKAIEIgAoAgAgASAAKAIEKAIQEQAAIQALIAJBQGskACAADwtBAUEUQbDfwQAQ8wIAC6sCAQF/IwBB8ABrIgYkACAGIAE2AgwgBiAANgIIIAYgAzYCFCAGIAI2AhAgBkGEkMIANgIYIAZBAjYCHAJAIAQoAgBFBEAgBkEDNgJcIAZBwJDCADYCWCAGQgM3AmQgBiAGQRBqrUKAgICA8CKENwNIIAYgBkEIaq1CgICAgPAihDcDQAwBCyAGQTBqIARBEGopAgA3AwAgBkEoaiAEQQhqKQIANwMAIAYgBCkCADcDICAGQQQ2AlwgBkH0kMIANgJYIAZCBDcCZCAGIAZBEGqtQoCAgIDwIoQ3A1AgBiAGQQhqrUKAgICA8CKENwNIIAYgBkEgaq1CgICAgJAjhDcDQAsgBiAGQRhqrUKAgICAgCOENwM4IAYgBkE4ajYCYCAGQdgAaiAFEMACAAuIAwIEfwF+IwBBQGoiBiQAQQEhBwJAIAAtAAQNACAALQAFIQggACgCACIFLQAUQQRxRQRAIAUoAhxBx5HCAEHEkcIAIAhBAXEiCBtBAkEDIAgbIAUoAiAoAgwRAgANASAFKAIcIAEgAiAFKAIgKAIMEQIADQEgBSgCHEGUkcIAQQIgBSgCICgCDBECAA0BIAMgBSAEKAIMEQAAIQcMAQsgCEEBcUUEQCAFKAIcQcmRwgBBAyAFKAIgKAIMEQIADQELIAZBAToAFyAGQSBqIAVBCGopAgA3AwAgBkEoaiAFQRBqKQIANwMAIAZBMGogBUEYaigCADYCACAGIAUpAhw3AgggBSkCACEJIAZBqJHCADYCOCAGIAk3AxggBiAGQRdqNgIQIAYgBkEIaiIFNgI0IAUgASACEDsNACAFQZSRwgBBAhA7DQAgAyAGQRhqIAQoAgwRAAANACAGKAI0QcyRwgBBAiAGKAI4KAIMEQIAIQcLIABBAToABSAAIAc6AAQgBkFAayQAIAAL6AIBB38CQCABKAIEIgRFBEAMAQsgASgCECEGIAEgBCAEIAEoAggiAyADIARLGyIFazYCBCABIAEoAgAiByAFajYCAAJ/AkACQAJAAkACfwJAAkACQCADBEAgASgCDCIIQQF0IQQgBy0AACICQcEAa0H/AXFBBkkNASACQeEAa0H/AXFBBkkNAiACQTBrIgNB/wFxQQpJDQMgBAwEC0EAQQBBtLXAABDQAQALIAJBN2shAwwBCyACQdcAayEDCyAFQQFGDQMgBy0AASICQcEAa0H/AXFBBkkNASACQeEAa0H/AXFBBkkNAiACQTBrIgVB/wFxQQpJDQQgBEEBcgshAyAGIAI2AgAgBiAEQYB+cSADQf8BcXI2AgRBAAwECyACQTdrIQUMAgsgAkHXAGshBQwBC0EBQQFBxLXAABDQAQALIAUgA0EEdHIhA0EBCyECIAEgCEEBajYCDAsgACADOgABIAAgAjoAAAuiAwIFfwJ+IwBBIGsiBCQAIAQgAkEBcSIDNgIEAn4CQAJAAkACQCADRQRAQgAgAkEBdiIDIAIgA2siAiACIANLGyIGRQ0FGiABIANqIQdBACECA0AgASACai0AACIFQcAATwRAIAVBwABB2MLAABDQAQALIAIgB2otAAAhAyAFQQN0Qbi+wABqKQMAIACDUEUEQCACQf8BcSIFQcAATw0DIAVBA3RBuL7AAGopAwAgCIQhCAsgA0HAAE8NAyADQQN0Qbi+wABqKQMAIACDUEUEQCACQf8BcSIDQcAATw0FIANBA3RBuL7AAGopAwAgCYQhCQsgAkEBaiICIAZHDQALDAQLIARCADcCFCAEQoGAgIDAADcCDCAEQYjDwAA2AggjAEEQayIBJAAgAUHowsAANgIMIAEgBEEEajYCCCABQQhqQfSPwgAgAUEMakH0j8IAIARBCGpBkMPAABBTAAsgBUHAAEHYwsAAENABAAsgA0HAAEHYwsAAENABAAsgA0HAAEHYwsAAENABAAsgCEL/////D4MgCUIghoQLIARBIGokAAvLAgIHfwJ+IwBBEGsiBCQAIAEoAgAhBgJAAkACQCABKAIIIgIgASgCBCIHSQRAIAIgBmotAABB3wBGDQELIAIgByACIAdLGyEIAkADQCACIAdJBEAgAiAGai0AAEHfAEYNAgsgAiAIRg0DAkAgAiAGai0AACIFQTBrIgNB/wFxQQpJDQAgBUHhAGtB/wFxQRpPBEAgBUHBAGtB/wFxQRpPDQUgBUEdayEDDAELIAVB1wBrIQMLIAEgAkEBaiICNgIIIAQgCUI+EMEBIAQpAwhCAFINAyAEKQMAIgogA61C/wGDfCIJIApaDQALDAILQQEhAyABIAJBAWo2AgggCUJ/UgRAIAAgCUIBfDcDCEEAIQMMAwsgAEEAOgABDAILIABCADcDCCABIAJBAWo2AggMAQsgAEEAOgABQQEhAwsgACADOgAAIARBEGokAAvSAgEHf0EBIQkCQAJAIAJFDQAgASACQQF0aiEKIABBgP4DcUEIdiELIABB/wFxIQ0DQCABQQJqIQwgByABLQABIgJqIQggCyABLQAAIgFHBEAgASALSw0CIAghByAMIgEgCkYNAgwBCwJAAkAgByAITQRAIAQgCEkNASADIAdqIQEDQCACRQ0DIAJBAWshAiABLQAAIAFBAWohASANRw0AC0EAIQkMBQsgByAIQdSbwgAQtQMACyAIIARB1JvCABCzAwALIAghByAMIgEgCkcNAAsLIAZFDQAgBSAGaiEDIABB//8DcSEBA0AgBUEBaiEAAkAgBSwAACICQQBOBEAgACEFDAELIAAgA0cEQCAFLQABIAJB/wBxQQh0ciECIAVBAmohBQwBC0HEm8IAELYDAAsgASACayIBQQBIDQEgCUEBcyEJIAMgBUcNAAsLIAlBAXEL5QIBBn8CQCABKAIEIgVFBEBBAiEDDAELIAEgBSAFIAEoAggiBCAEIAVLGyIGazYCBCABIAEoAgAiByAGajYCAAJ/AkACQAJAAkAgBARAIAEoAgwiCEEBdCEFIActAAAiA0HBAGtB/wFxQQZJDQEgA0HhAGtB/wFxQQZJDQIgA0EwayIEQf8BcUEKSQ0DIAUhBAwEC0EAQQBBmOjAABDQAQALIANBN2shBAwBCyADQdcAayEECwJAAkACQCAGQQFHBEAgBy0AASIDQcEAa0H/AXFBBkkNASADQeEAa0H/AXFBBkkNAiADQTBrIgZB/wFxQQpJDQMgBUEBciEEDAQLQQFBAUGo6MAAENABAAsgA0E3ayEGDAELIANB1wBrIQYLIAYgBEEEdHIhBEEBDAELIAIgAzYCACACIAVBgH5xIARB/wFxcjYCBEEACyEDIAEgCEEBajYCDAsgACAEOgABIAAgAzoAAAvxAgEEfyAAKAIMIQICQAJAIAFBgAJPBEAgACgCGCEDAkACQCAAIAJGBEAgAEEUQRAgACgCFCICG2ooAgAiAQ0BQQAhAgwCCyAAKAIIIgEgAjYCDCACIAE2AggMAQsgAEEUaiAAQRBqIAIbIQQDQCAEIQUgASICQRRqIAJBEGogAigCFCIBGyEEIAJBFEEQIAEbaigCACIBDQALIAVBADYCAAsgA0UNAiAAIAAoAhxBAnRBqPPCAGoiASgCAEcEQCADQRBBFCADKAIQIABGG2ogAjYCACACRQ0DDAILIAEgAjYCACACDQFBxPbCAEHE9sIAKAIAQX4gACgCHHdxNgIADAILIAAoAggiACACRwRAIAAgAjYCDCACIAA2AggPC0HA9sIAQcD2wgAoAgBBfiABQQN2d3E2AgAPCyACIAM2AhggACgCECIBBEAgAiABNgIQIAEgAjYCGAsgACgCFCIARQ0AIAIgADYCFCAAIAI2AhgLC8YCAQN/IwBBEGsiAiQAAkAgAUGAAU8EQCACQQA2AgwCfyABQYAQTwRAIAFBgIAETwRAIAJBDGpBA3IhBCACIAFBEnZB8AFyOgAMIAIgAUEGdkE/cUGAAXI6AA4gAiABQQx2QT9xQYABcjoADUEEDAILIAJBDGpBAnIhBCACIAFBDHZB4AFyOgAMIAIgAUEGdkE/cUGAAXI6AA1BAwwBCyACQQxqQQFyIQQgAiABQQZ2QcABcjoADEECCyEDIAQgAUE/cUGAAXI6AAAgAyAAKAIAIAAoAggiAWtLBEAgACABIAMQ9wEgACgCCCEBCyAAKAIEIAFqIAJBDGogAxAsGiAAIAEgA2o2AggMAQsgACgCCCIDIAAoAgBGBEAgAEGkg8AAEJEBCyAAKAIEIANqIAE6AAAgACADQQFqNgIICyACQRBqJABBAAvGAgEDfyMAQRBrIgIkAAJAIAFBgAFPBEAgAkEANgIMAn8gAUGAEE8EQCABQYCABE8EQCACQQxqQQNyIQQgAiABQRJ2QfABcjoADCACIAFBBnZBP3FBgAFyOgAOIAIgAUEMdkE/cUGAAXI6AA1BBAwCCyACQQxqQQJyIQQgAiABQQx2QeABcjoADCACIAFBBnZBP3FBgAFyOgANQQMMAQsgAkEMakEBciEEIAIgAUEGdkHAAXI6AAxBAgshAyAEIAFBP3FBgAFyOgAAIAMgACgCACAAKAIIIgFrSwRAIAAgASADEPcBIAAoAgghAQsgACgCBCABaiACQQxqIAMQLBogACABIANqNgIIDAELIAAoAggiAyAAKAIARgRAIABB+LLAABCRAQsgACgCBCADaiABOgAAIAAgA0EBajYCCAsgAkEQaiQAQQALxQIBA38jAEEQayICJAACQCABQYABTwRAIAJBADYCDAJ/IAFBgBBPBEAgAUGAgARPBEAgAkEMakEDciEEIAIgAUESdkHwAXI6AAwgAiABQQZ2QT9xQYABcjoADiACIAFBDHZBP3FBgAFyOgANQQQMAgsgAkEMakECciEEIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAELIAJBDGpBAXIhBCACIAFBBnZBwAFyOgAMQQILIQMgBCABQT9xQYABcjoAACADIAAoAgAgACgCCCIBa0sEQCAAIAEgAxB3IAAoAgghAQsgACgCBCABaiACQQxqIAMQLBogACABIANqNgIIDAELIAAoAggiAyAAKAIARgRAIABB3MnBABCRAQsgACgCBCADaiABOgAAIAAgA0EBajYCCAsgAkEQaiQAQQALxQIBA38jAEEQayICJAACQCABQYABTwRAIAJBADYCDAJ/IAFBgBBPBEAgAUGAgARPBEAgAkEMakEDciEEIAIgAUESdkHwAXI6AAwgAiABQQZ2QT9xQYABcjoADiACIAFBDHZBP3FBgAFyOgANQQQMAgsgAkEMakECciEEIAIgAUEMdkHgAXI6AAwgAiABQQZ2QT9xQYABcjoADUEDDAELIAJBDGpBAXIhBCACIAFBBnZBwAFyOgAMQQILIQMgBCABQT9xQYABcjoAACADIAAoAgAgACgCCCIBa0sEQCAAIAEgAxB3IAAoAgghAQsgACgCBCABaiACQQxqIAMQLBogACABIANqNgIIDAELIAAoAggiAyAAKAIARgRAIABBpMzBABCRAQsgACgCBCADaiABOgAAIAAgA0EBajYCCAsgAkEQaiQAQQAL7wIBAX8jAEEwayICJAACfwJAAkACQAJAIAAtAABBAWsOAwECAwALIAIgACgCBDYCACACIAAtAAE6AAcgAkEDNgIMIAJBiNXBADYCCCACQgI3AhQgAiACrUKAgICAwAyENwMoIAIgAkEHaq1CgICAgIAchDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQOAwDCyACIAAoAgQ2AgAgAkEBNgIMIAJBuNXBADYCCCACQgE3AhQgAiACrUKAgICAwAyENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahA4DAILIAIgACgCBDYCACACIAAtAAE6AAcgAkEDNgIMIAJB1NXBADYCCCACQgI3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SyAAQQR2IQANAAsgAUEBQdeRwgBBAiACIARqQYABakEAIAJrECcMAQsgACgCACEAQQAhAgNAIAIgBGpB/wBqIABBD3EiA0EwciADQTdqIANBCkkbOgAAIAJBAWshAiAAQQ9LIABBBHYhAA0ACyABQQFB15HCAEECIAIgBGpBgAFqQQAgAmsQJwsgBEGAAWokAAvLAQIFfwF+IwBBIGsiAiQAAkACQCABIAFBAWoiA0sNAEEIIAAoAgAiAUEBdCIEIAMgAyAESRsiAyADQQhJGyIErSIHQiCIUEUNACAHpyIFQf////8HSw0AIAIgAQR/IAIgATYCHCACIAAoAgQ2AhRBAQVBAAs2AhggAkEIakEBIAUgAkEUahChASACKAIIQQFHDQEgAigCECEDIAIoAgwhBgsgBiADQdzmwAAQ8wIACyACKAIMIQEgACAENgIAIAAgATYCBCACQSBqJAALywECBH8BfiMAQSBrIgMkAAJAAkAgASABIAJqIgJLDQBBCCAAKAIAIgFBAXQiBCACIAIgBEkbIgIgAkEISRsiBK0iB0IgiFBFDQAgB6ciBUH/////B0sNACADIAEEfyADIAE2AhwgAyAAKAIENgIUQQEFQQALNgIYIANBCGpBASAFIANBFGoQoQEgAygCCEEBRw0BIAMoAhAhAiADKAIMIQYLIAYgAkH4gcEAEPMCAAsgAygCDCEBIAAgBDYCACAAIAE2AgQgA0EgaiQAC8sBAgR/AX4jAEEgayIDJAACQAJAIAEgASACaiICSw0AQQggACgCACIBQQF0IgQgAiACIARJGyICIAJBCEkbIgStIgdCIIhQRQ0AIAenIgVB/////wdLDQAgAyABBH8gAyABNgIcIAMgACgCBDYCFEEBBUEACzYCGCADQQhqQQEgBSADQRRqEKEBIAMoAghBAUcNASADKAIQIQIgAygCDCEGCyAGIAJBrKTBABDzAgALIAMoAgwhASAAIAQ2AgAgACABNgIEIANBIGokAAvLAQIEfwF+IwBBIGsiAyQAAkACQCABIAEgAmoiAksNAEEIIAAoAgAiAUEBdCIEIAIgAiAESRsiAiACQQhJGyIErSIHQiCIUEUNACAHpyIFQf////8HSw0AIAMgAQR/IAMgATYCHCADIAAoAgQ2AhRBAQVBAAs2AhggA0EIakEBIAUgA0EUahChASADKAIIQQFHDQEgAygCECECIAMoAgwhBgsgBiACQbjKwQAQ8wIACyADKAIMIQEgACAENgIAIAAgATYCBCADQSBqJAALqgICA38BfiMAQUBqIgIkACABKAIAQYCAgIB4RgRAIAEoAgwhAyACQSRqIgRBADYCACACQoCAgIAQNwIcIAJBMGogAygCACIDQQhqKQIANwMAIAJBOGogA0EQaikCADcDACACIAMpAgA3AyggAkEcakGU4cEAIAJBKGoQOBogAkEYaiAEKAIAIgM2AgAgAiACKQIcIgU3AxAgAUEIaiADNgIAIAEgBTcCAAsgASkCACEFIAFCgICAgBA3AgAgAkEIaiIDIAFBCGoiASgCADYCACABQQA2AgBB0bLCAC0AABogAiAFNwMAQQxBBBCcAyIBRQRAQQRBDBDnAwALIAEgAikDADcCACABQQhqIAMoAgA2AgAgAEGo7sEANgIEIAAgATYCACACQUBrJAALrQMBCX8jAEGABGsiAiQAIAEoAgQhBgJAIAEoAggiA0UEQBC5AiEDIABBAjoAACAAIAM2AgQMAQsCQCAAAn8gA0GsAk0EQCACQfwCaiEFIwBBgAFrIggkAAJAIANFBEAQuQIhAyAFQQE6AAAgBSADNgIEDAELIAhBAEGAARBKIQkDQCAEIAlqIAYgBCAEbEGurARqIANwIgdqLQAAIgogB0EHcUEEcyIHdCAKIAd2cjoAACAEQQFqIgRBgAFHDQALIAVBAWogCUGAARAsGiAFQQA6AAALIAhBgAFqJAAgAi0A/AINAiACQYIBaiACLQD/AjoAACACIAIvAP0COwGAASACKAKAAyEDIAJBgAJqIgQgAkGEA2pB+QAQLBogAkGEAWoiBSAEQfkAECwaIAIgBUH5ABAsGkEADAELIAIgBiADECpBAQs6AAAgACACLwGAATsAASAAIAM2AgQgAEEDaiACQYIBai0AADoAACAAQQhqIAJB+QAQLBoMAQsgAigCgAMhAyAAQQI6AAAgACADNgIECyABKAIAIgAEQCAGIABBARCxAwsgAkGABGokAAv2AQEIfyABKAIIIgIgASgCBCIDIAIgA0sbIQggASgCACEFQX8hByACIQQCQAJAA0AgBCAIRg0BIAEgBEEBaiIGNgIIIAdBAWohByAEIAVqIAYhBC0AACIGQTBrQf8BcUEKSSAGQeEA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ACADKAIIIAMoAgQiAhshBEEJIAMoAgwgAhsLIQIgBCACIAEQngECQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCxAwwBCyAALQAEQQNHDQAgACgCCCIAKAIAIQEgAEEEaigCACICKAIAIgUEQCABIAURAwALIAIoAgQiBQRAIAEgBSACKAIIELEDCyAAQQxBBBCxAwsgA0EQaiQAC98BAgF+A38CQCABKAIYIgVFDQACQCABKQMAIgJQBEAgASgCECEEIAEoAgghAwNAIARBQGohBCADKQMAIANBCGohA0KAgYKEiJCgwIB/gyICQoCBgoSIkKDAgH9RDQALIAEgBDYCECABIAM2AgggASAFQQFrNgIYIAEgAkKAgYKEiJCgwIB/hSICQgF9IAKDNwMADAELIAEgBUEBazYCGCABIAJCAX0gAoM3AwAgASgCECIEDQAMAQsgBCACeqdB+ABxayIBQQRrIQQgAUEIayEDCyAAIAQ2AgQgACADNgIAC90BAQF/IwBBMGsiAiQAAn8CQAJAAkAgACgCAEEBaw4CAQIACyABQfirwQBBIBCHAwwCCyACIABBBGo2AgwgAkEBNgIUIAJBuKzBADYCECACQgE3AhwgAiACQQxqrUKAgICAoBWENwMoIAIgAkEoajYCGCABKAIcIAEoAiAgAkEQahA4DAELIAIgAEEEajYCDCACQQE2AhQgAkHgrMEANgIQIAJCATcCHCACIAJBDGqtQoCAgICgFYQ3AyggAiACQShqNgIYIAEoAhwgASgCICACQRBqEDgLIAJBMGokAAuUCAEEfyMAQUBqIgMkACADQQA2AhQgA0KAgICAEDcCDCADQbSxwAA2AjggA0EDOgAwIANCIDcCKCADQQA2AiAgA0EANgIYIAMgA0EMajYCNCADQRhqIQIjAEEwayIBJAACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAQQogACgCAEGAgICAeHMiBCAEQQ1PG0EBaw4MAQIDBAUGBwgJCgsMAAsgASAAQQRqNgIMIAFBAjYCFCABQayawQA2AhAgAUIBNwIcIAEgAUEMaq1CgICAgIARhDcDKCABIAFBKGo2AhggAigCHCACKAIgIAFBEGoQOAwMCyABIABBBGo2AgwgAUEBNgIUIAFB1JrBADYCECABQgE3AhwgASABQQxq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BiAGLwD8AjsB/AEgBigA/wIhAyAGQYACaiIJIAZBgwNqQfkAECwaIAsgCUH5ABAsGiAGQYABaiALQfkAECwaQQAMAQsgBkGAAWogASASECpBAQshCSAGKQOAASEgIAZBCGogBkGIAWpB8QAQLBogEQRAIAEgEUEBELEDCyAOIAk6AAAgDiAGLwH8ATsAASAOICA3AwggDiADNgIEIA5BA2ogBkH+AWotAAA6AAAgDkEQaiAGQQhqQfgAECwaDAILIAEhAwsgBiADNgKAASAGQQA2AogCIAZCgICAgBA3AoACIAZByJ3BADYCnAMgBkEDOgCUAyAGQiA3AowDIAZBADYChAMgBkEANgL8AiAGIAZBgAJqNgKYAyAGQYABaiIDIAZB/AJqENUDDQEgBigCgAIhASAGKQKEAiEgIAMQiAMgDiAgNwMIIA4gATYCBCAOQQI6AAALIAZBgARqJAAMAQtB8J3BAEE3IAZB/wNqQeCdwQBB9J7BABDCAQALIAQtALgBIglBAkcEQCAEIAQpALkBNwOQASAEIARBwAFqKQAANwCXASAEQRhqIARByAFqQfgAECwaIARBEGogBCkAlwE3AAAgBCAJOgAIIAQgBCkDkAE3AAkgEARAIAcgEEEBELEDCyAJQQJrIQNBACELDAMLIARBmwFqIARBxAFqKAIAIgE2AAAgBCAEKQK8ASIgNwCTASAKQQxqIAE2AAAgCiAgNwAEIApBBDoAACAQRQ0EIAcgEEEBELEDDAQLIApBBDoAACAKQYOAgIB4NgIEC0EBIQsMAQsgBEGYAWogD0EwaikAADcDACAEIA8pACg3A5ABAkACQAJAAkBBAiADIANBAk8bQQFrDgIBAgALIARBkAFqIgcgBEEIakEBciIBLQAAIgwgBy0AAHM6AAAgByAMIActAARzOgAEIAcgAUEBai0AACIJIActAAFzOgABIAcgAUECai0AACIDIActAAJzOgACIAcgAUEDai0AACIBIActAANzOgADIAcgCSAHLQAFczoABSAHIAMgBy0ABnM6AAYgByABIActAAdzOgAHIAcgDCAHLQAIczoACCAHIAkgBy0ACXM6AAkgByADIActAApzOgAKIAcgASAHLQALczoACyAHIAwgBy0ADHM6AAwgByAJIActAA1zOgANIAcgAyAHLQAOczoADiAHIAEgBy0AD3M6AA8MAgtBACEDA0AgBEGQAWogA2oiCSAEQQhqIANqIgFBAWotAAAgA0EQdiADQQh2cyADQRh2cyADc3MgCS0AACABQRFqLQAAcyIBQQR0cyABczoAACADQQFqIgNBEEcNAAsMAQsgCUEBcUUEQCAEQZABaiIDIARBCGpBAXIiAS0AACADLQAAczoAACADIAFBAWotAAAgAy0AAXM6AAEgAyABQQJqLQAAIAMtAAJzOgACIAMgAUEDai0AACADLQADczoAAyADIAFBBGotAAAgAy0ABHM6AAQgAyABQQVqLQAAIAMtAAVzOgAFIAMgAUEGai0AACADLQAGczoABiADIAFBB2otAAAgAy0AB3M6AAcgAyABQQhqLQAAIAMtAAhzOgAIIAMgAUEJai0AACADLQAJczoACSADIAFBCmotAAAgAy0ACnM6AAogAyABQQtqLQAAIAMtAAtzOgALIAMgAUEMai0AACADLQAMczoADCADIAFBDWotAAAgAy0ADXM6AA0gAyABQQ5qLQAAIAMtAA5zOgAOIAMgAUEPai0AACADLQAPczoADwwBCyAEQRBqIgEgBEGQAWpBEEEAEIQBIAEgBEGgAWpBAEEQEEgLIARBwAFqIA9B0ABqKQAANwMAIAQgDykASDcDuAECQCAEQZABaiAEQbgBakEQEO0BRQRAIAogBEEIakGIARAsGiALIAIoAgAiAUGAgICAeEdxDQEMAwsgCkEEOgAAIApBhYCAgHg2AgQgBC0ACCIBQQFLIAFFcg0BIAQoAhQiAQRAIAQoAhAgAUEBELEDCyAEKAIgQYAsQQEQsQMMAQsgAUUNASACKAIEIAFBARCxAwwBCyALRQ0AIAIoAgAiAUGAgICAeEYgAUVyDQAgAigCBCABQQEQsQMLIARBwAJqJAACQCANLQAIIgJBBEcEQCAAIA0vAAk7AAEgAEEDaiANLQALOgAAIA0oAgwhASAAQQhqIA1BEGpBgAEQLBoMAQsgDUGYAWogDUEUaigCADYCACANIA0pAgw3A5ABIA1BkAFqEIkBIQELIAAgAjoAACAAIAE2AgQgDUGgAWokAAuaAQECfyMAQSBrIgMkAAJAIAAEQCADIAI2AhwgAyABNgIYIAMgAjYCFCADQQhqIANBFGpBrJ7AABDNASAAKAIADQEgAygCDCEBIAMoAgghAiAAQX82AgAgACgCBCIEBEAgACgCCCAEQQEQsQMLIAAgAjYCCCAAQQA2AgAgACABNgIMIAAgATYCBCADQSBqJAAPCxDbAwALENwDAAvFAwEDfyMAQUBqIgEkACABQQA2AhQgAUKAgICAEDcCDCABQbSxwAA2AjggAUEDOgAwIAFCIDcCKCABQQA2AiAgAUEANgIYIAEgAUEMajYCNCABQRhqIQIjAEEwayIDJAACfwJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCAEEBaw4KAQIDBAUGBwgJCgALIAJBgOrAAEEVEIcDDAoLIAMgAEEEajYCDCADQQI2AhQgA0G86sAANgIQIANCATcCHCADIANBDGqtQoCAgICAC4Q3AyggAyADQShqNgIYIAIoAhwgAigCICADQRBqEDgMCQsgAkHM6sAAQS4QhwMMCAsgAkH66sAAQSEQhwMMBwsgAkGb68AAQSgQhwMMBgsgAkHD68AAQR4QhwMMBQsgAkHh68AAQSMQhwMMBAsgAkGE7MAAQSYQhwMMAwsgAkGq7MAAQSAQhwMMAgsgAkHK7MAAQSMQhwMMAQsgAkHt7MAAQSYQhwMLIANBMGokAEUEQCABKAIMIQAgASgCECICIAEoAhQQ+gIgAARAIAIgAEEBELEDCyABQUBrJAAPC0HcscAAQTcgAUE/akHMscAAQeCywAAQwgEAC4cHAQN/IwBBQGoiAyQAIANBADYCFCADQoCAgIAQNwIMIANBtLHAADYCOCADQQM6ADAgA0IgNwIoIANBADYCICADQQA2AhggAyADQQxqNgI0IANBGGohAiMAQdAAayIBJAACfwJAAkACQAJAAkACQAJAIAAtAABBAWsOBgECAwQFBgALIAEgAEEEajYCKCABQQI2AjQgAUH018EANgIwIAFCATcCPCABIAFBKGqtQoCAgICQHIQ3AxAgASABQRBqNgI4IAIoAhwgAigCICABQTBqEDgMBgsgASAAQQRqNgIoIAFBAjYCNCABQaTYwQA2AjAgAUIBNwI8IAEgAUEoaq1CgICAgJAchDcDECABIAFBEGo2AjggAigCHCACKAIgIAFBMGoQOAwFCyABIABBBGo2AiggAUECNgI0IAFB1NjBADYCMCABQgE3AjwgASABQShqrUKAgICAkByENwMQIAEgAUEQajYCOCACKAIcIAIoAiAgAUEwahA4DAQLIAEgAEEBajYCDCABIAFBDGqtQoCAgICgHIQ3AyggAUEBNgIkIAFBATYCFCABQYDZwQA2AhAgAUEBNgIcIAFBAzoATCABQRA2AkggAUIgNwJAIAFCgICAgCA3AjggAUECNgIwIAEgAUEwajYCICABIAFBKGo2AhggAigCHCACKAIgIAFBEGoQOAwDCyABIABBAWo2AgwgASABQQxqrUKAgICAsByENwMoIAFBATYCJCABQQE2AhQgAUGk2cEANgIQIAFBATYCHCABQQM6AEwgAUEANgJIIAFCIDcCQCABQoCAgIAgNwI4IAFBAjYCMCABIAFBMGo2AiAgASABQShqNgIYIAIoAhwgAigCICABQRBqEDgMAgsgASAAQQFqNgIoIAFBATYCNCABQcjZwQA2AjAgAUIBNwI8IAEgAUEoaq1CgICAgMAchDcDECABIAFBEGo2AjggAigCHCACKAIgIAFBMGoQOAwBCyABIABBAWo2AiggAUEBNgI0IAFB6NnBADYCMCABQgE3AjwgASABQShqrUKAgICA0ByENwMQIAEgAUEQajYCOCACKAIcIAIoAiAgAUEwahA4CyABQdAAaiQARQRAIAMoAgwhACADKAIQIgEgAygCFBD6AiAABEAgASAAQQEQsQMLIANBQGskAA8LQdyxwABBNyADQT9qQcyxwABB4LLAABDCAQALlwIBA38jAEGQAWsiAiQAAkACQCABRQRAIAJBCGohBCMAQZABayIDJAACQAJAIAAEQCAAQQhrIgEoAgBBAUcNASADIABBkAEQLCEDIAFBADYCAAJAIAFBf0YNACAAQQRrIgAgACgCAEEBayIANgIAIAANACABQZgBQQgQsQMLIAQgA0EIakGIARAsGiADQZABaiQADAILENsDAAtB7orAAEE/ENoDAAsgAi0ACCIAQQFLIABFcg0BIAIoAhQiAARAIAIoAhAgAEEBELEDCyACKAIgQYAsQQEQsQMMAQsgAEUNASACIABBCGsiADYCCCAAIAAoAgBBAWsiADYCACAADQAgAkEIahD+AQsgAkGQAWokAA8LENsDAAuXAgEDfyMAQZABayICJAACQAJAIAFFBEAgAkEIaiEEIwBBkAFrIgMkAAJAAkAgAARAIABBCGsiASgCAEEBRw0BIAMgAEGQARAsIQMgAUEANgIAAkAgAUF/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KAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIcIAEoAiAgAkEIahA4CyACQSBqJAALhwECAX8BfiMAQRBrIgIkACACQQA2AgQgAkEIaiABIAJBBGpBBBDzAQJAAkACfyACLQAIQQRGBEAgAigCBAwBCyACKQMIIgNC/wGDQgRSDQEgA0IgiKcLIQEgAEGNgICAeDYCACAAIAE2AgQMAQsgACADNwIEIABBi4CAgHg2AgALIAJBEGokAAuOAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGUosEANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakH4osEAEMACAAsgAEEIahCCASAAKAIIIgJFDQAgACgCDCACQQxsQQQQsQMLIABBHEEEELEDIAFBIGokAAuOAQECfyMAQSBrIgMkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GUosEANgIEIANCADcCECADIANBHGo2AgwgA0EEakH4osEAEMACAAsgAEEIahCCASAAKAIIIgRFDQAgACgCDCAEQQxsQQQQsQMLIABBHEEEELEDIANBIGokAAuOAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUH8usEANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakHgu8EAEMACAAsgAEEIahCDASAAKAIIIgJFDQAgACgCDCACQQxsQQQQsQMLIABBLEEEELEDIAFBIGokAAuOAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUH8usEANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakHgu8EAEMACAAsgAEEIahCDASAAKAIIIgJFDQAgACgCDCACQQxsQQQQsQMLIABBJEEEELEDIAFBIGokAAuOAQECfyMAQSBrIgMkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0H8usEANgIEIANCADcCECADIANBHGo2AgwgA0EEakHgu8EAEMACAAsgAEEIahCDASAAKAIIIgRFDQAgACgCDCAEQQxs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ayIDJAACQAJAAkAgAC0AEEEBaw4CAgABCyADQQE2AgggA0HkocAANgIEIANCADcCECADIANBHGo2AgwgA0EEakHIosAAEMACAAsgACgCCCIFBEAgACgCBCEEA0AgBCgCCCIGBEAgBCgCBEEkaiEBA0AgAUEEaygCACICQYCAgIB4RiACRXJFBEAgASgCACACQQEQsQMLAkAgAUEUaygCACIHQQJGDQAgAUEQayECIAdFBEAgAigCACICRQ0BIAFBDGsoAgAgAkEBELEDDAELIAIoAgAiAkUNACABQQxrKAIAIAJBAXRBAhCxAwsgAUEsaiEBIAZBAWsiBg0ACwsgBCgCACIBBEAgBEEEaigCACABQSxsQQQQsQMLIARBDGohBCAFQQFrIgUNAAsLIAAoAgAiAUUNACAAKAIEIAFBDGxBBBCxAwsgA0EgaiQAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQeSPwgA2AgggA0ICNwIUIANCgICAgMAMIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhDAAgALbQEBfyAALQAEIQEgAC0ABQRAIAACf0EBIAFBAXENABogACgCACIBLQAUQQRxRQRAIAEoAhxBz5HCAEECIAEoAiAoAgwRAgAMAQsgASgCHEHOkcIAQQEgASgCICgCDBECAAsiAToABAsgAUEBcQt0AQF/IwBBIGsiASQAAkAgACgCBEECRw0AAkACQCAALQAYQQFrDgICAAELIAFBATYCCCABQYyFwQA2AgQgAUIANwIQIAEgAUEcajYCDCABQQRqQfCFwQAQwAIACyAAQQhqEHsLIABBMEEEELEDIAFBIGokAAt0AQF/IwBBIGsiAyQAAkAgACgCBEECRw0AAkACQCAALQAYQQFrDgICAAELIANBATYCCCADQYyFwQA2AgQgA0IANwIQIAMgA0EcajYCDCADQQRqQfCFwQAQwAIACyAAQQhqEHsLIABBMEEEELEDIANBIGokAAtkAQF/IwBBEGsiACQAAn8gAigCAARAQfDswQAhA0EJDAELIABBBGogAigCBCACKAIIEC5B8OzBACAAKAIIIAAoAgQiAhshA0EJIAAoAgwgAhsLIQIgAyACIAEQngEgAEEQaiQAC2cAIwBBMGsiACQAQdCywgAtAAAEQCAAQQI2AgwgAEGg7cEANgIIIABCATcCFCAAIAE2AiwgACAAQSxqrUKAgICAwAyENwMgIAAgAEEgajYCECAAQQhqQcjtwQAQwAIACyAAQTBqJAALawEDfwJAIAEoAggiAkEATgRAIAEoAgQhBCACRQRAQQEhAQwCC0HRssIALQAAGkEBIQMgAkEBEJwDIgENAQsgAyACQcSOwgAQ8wIACyABIAQgAhAsIQEgACACNgIIIAAgATYCBCAAIAI2AgALaQEBfwJ/IAIoAgQEQCACKAIIIgNFBEBB0bLCAC0AABogAUEBEJwDDAILIAIoAgAgA0EBIAEQgQMMAQtB0bLCAC0AABogAUEBEJwDCyECIAAgATYCCCAAIAJBASACGzYCBCAAIAJFNgIAC18BAn8CQAJAIAEEQCABQQhrIgMgAygCAEEBaiICNgIAIAJFDQEgASgCACICQX9GDQIgACADNgIIIAAgATYCBCAAIAFBBGo2AgAgASACQQFqNgIADwsQ2wMLAAsQ3AMAC18BAn8CQAJAIAEEQCABQQhrIgMgAygCAEEBaiICNgIAIAJFDQEgASgCACICQX9GDQIgACADNgIIIAAgATYCBCAAIAFBCGo2AgAgASACQQFqNgIADwsQ2wMLAAsQ3AMAC3IBAn8CQCAAKAIAIgJBBEYNACAAKAIgIgFBgICAgHhGIAFFckUEQCAAKAIkIAFBARCxAwsCQAJAIAJBAWsOAwACAQILIAAoAgQiAUUNACAAKAIIIAFBARCxAwsgACgCECIBRQ0AIAAoAhQgAUEBELEDCwvfAQEDfyMAQYADayICJAACQAJAIAFFBEAgAkEIaiEEIwBBgANrIgMkAAJAIAAEQCAAQQhrIgEoAgBBAUcNASADIABBgAMQLCEDIAFBADYCAAJAIAFBf0YNACAAQQRrIgAgACgCAEEBayIANgIAIAANACABQYgDQQgQsQMLIAQgA0EIakH4AhAsGiADQYADaiQADAMLENsDAAtB7orAAEE/ENoDAAsgAEUNASACIABBCGsiADYCCCAAIAAoAgBBAWsiADYCACAADQAgAkEIahC1AgsgAkGAA2okAA8LENsDAAu9AQECfyMAQUBqIgIkAAJAAkAgAUUEQCACQQRqIQMgAARAIABBCGsiASgCAEEBRgRAIAMgAEEEakE8ECwaIAFBADYCAAJAIAFBf0YNACAAQQRrIgAgACgCAEEBayIANgIAIAANACABQcgAQQQQsQMLDAMLQYCdwABBPxDaAwALENsDAAsgAEUNASACIABBCGsiADYCBCAAIAAoAgBBAWsiADYCACAADQAgAkEEahC3AgsgAkFAayQADwsQ2wMAC8oBAQJ/IwBBEGsiAiQAAkACQCABRQRAIAJBBGohAyAABEAgAEEIayIBKAIAQQFGBEAgAyAAKQIENwIAIANBCGogAEEMaigCADYCACABQQA2AgACQCABQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgAUEYQQQQsQMLDAMLQYCdwABBPxDaAwALENsDAAsgAEUNASACIABBCGsiADYCBCAAIAAoAgBBAWsiADYCACAADQAgAkEEahC2AgsgAkEQaiQADwsQ2wMAC2MBAX5B0bLCAC0AABogACkCACEDQSRBBBCcAyIABEAgACABNgIAIAAgAzcCHCAAIAIpAgA3AgQgAEEMaiACQQhqKQIANwIAIABBFGogAkEQaikCADcCACAADwtBBEEkEOcDAAtrAQJ/IAAoAgAhASAAQYCAxAA2AgACQCABQYCAxABHDQBBgIDEACEBIAAoAgQiAiAAKAIIRg0AIAAgAkEBajYCBCAAIAAoAgwiACACLQAAIgFBD3FqLQAANgIAIAAgAUEEdmotAAAhAQsgAQtrAQF/IwBBIGsiASQAAkAgACgCBEECRw0AAkACQCAALQAYQQFrDgICAAELIAFBATYCCCABQYyFwQA2AgQgAUIANwIQIAEgAUEcajYCDCABQQRqQfCFwQAQwAIACyAAQQhqEHsLIAFBIGokAAtfAQJ/AkAgAkEATgRAIAJFBEBBASEEDAILQdGywgAtAAAaQQEhAyACQQEQnAMiBA0BCyADIAJBsJDAABDzAgALIAQgASACECwhASAAIAI2AgggACABNgIEIAAgAjYCAAtfAQJ/AkAgAkEATgRAIAJFBEBBASEEDAILQdGywgAtAAAaQQEhAyACQQEQnAMiBA0BCyADIAJBjLjBABDzAgALIAQgASACECwhASAAIAI2AgggACABNgIEIAAgAjYCAAtYAQJ/IwBBEGsiAiQAIAEtAABBA0cEf0EABSACQQhqIAEoAgQiASgCACABKAIEKAIkEQEAIAIoAgwhAyAC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IABFDQEgAiAAQQhrIgA2AgAgACAAKAIAQQFrIgA2AgAgAA0AIAIQuAILIAJBkANqJAAPCxDbAwALrQICBX8BfiMAQSBrIgIkAAJAAkAgAUUEQCMAQSBrIgEkACAABEAgAEEIayIDKAIAQQFGBEAgAUEYaiIEIABBHGopAgA3AwAgAUEQaiIFIABBFGopAgA3AwAgAUEIaiIGIABBDGopAgA3AwAgACkCBCEHIANBADYCACABIAc3AwACQCADQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgA0EsQQQQsQMLIAIgASkDADcAACACQRhqIAQpAwA3AAAgAkEQaiAFKQMANwAAIAJBCGogBikDADcAACABQSBqJAAMAwtBgJ3AAEE/ENoDAAsQ2wMACyAARQ0BIAIgAEEIayIANgIAIAAgACgCAEEBayIANgIAIAANACACELQCCyACQSBqJAAPCxDbAwALrQICBX8BfiMAQSBrIgIkAAJAAkAgAUUEQCMAQSBrIgEkACAABEAgAEEIayIDKAIAQQFGBEAgAUEYaiIEIABBHGopAgA3AwAgAUEQaiIFIABBFGopAgA3AwAgAUEIaiIGIABBDGopAgA3AwAgACkCBCEHIANBADYCACABIAc3AwACQCADQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgA0EsQQQQsQMLIAIgASkDADcAACACQRhqIAQpAwA3AAAgAkEQaiAFKQMANwAAIAJBCGogBikDADcAACABQSBqJAAMAwtBqLPAAEE/ENoDAAsQ2wMACyAARQ0BIAIgAEEIayIANgIAIAAgACgCAEEBayIANgIAIAANACACELQCCyACQSBqJAAPCxDbAwALZAICfwF+IwBBEGsiAiQAQQBByILBACgCABEFACIBBEAgACABKQMINwMIIAAgASkDACIDNwMAIAEgA0IBfDcDACACQRBqJAAPC0Hg/sAAQcYAIAJBD2pB0P7AAEH4/8AAEMIBAAtxAQN/QfjywgAtAABB+PLCAEEBOgAAQYDzwgAoAgAhAkGA88IAQQQ2AgBBhPPCAEEANgIAQYjzwgBBADYCAEGM88IAQQA2AgBB/PLCACgCACEAQfzywgBBADYCAEUgAEVyRQRAIAIgAEECdEEEELEDCwtQAQN/IAAtAABBA0YEQCAAKAIEIgAo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NgIYIAFBATYCDCABQeSVwgA2AgggAUIENwIQIAFBCGogABDAAgALNwEBfyMAQSBrIgEkACABQQA2AhggAUEBNgIMIAFBuKjCADYCCCABQgQ3AhAgAUEIaiAAEMACAAssAQF/IwBBEGsiACQAIABBCGoiAiABQdTiwQBBCxDOAiACENEBIABBEGokAAv2AwEGfyMAQRBrIgQkABBNIgYgAiYBIAEhAyMAQUBqIgEkACABIAM2AjggASAANgI0IAEgAzYCMCABQQhqIAFBMGoiCEGMm8AAEM0BIAEgBjYCHCABIAEoAgwiADYCGCABIAEoAggiAzYCFCABQSBqIQYCQAJAIABBC08EQCADQaDDwABBCxDtAUUNAQsgBkGDgICAeDYCAAwBCwJAIABBC2siAEEASA0AAkAgAEUEQEEBIQcMAQtB0bLCAC0AABpBASEFIABBARCcAyIHRQ0BCyAHIANBC2ogABAsIgMgAEELEIABIAYgAyAAECAgAARAIAMgAEEBELEDCwwBCyAFIABB3LfAABDzAgALIAQCfwJAAkAgASgCIEGEgICAeEcEQCABQThqIAFBKGopAgA3AwAgASABKQIgNwMwIAgQlAEhACABQRRqEIYCDAELIAEoAiQhAyABKAIsIQUgASgCKCEAIAFBFGoQhgIgA0GAgICAeEcNAQtBACEDQQAhBUEBDAELIAEgBTYCOCABIAA2AjQgASADNgIwIAEgAUEwakGcm8AAEM0BIAEoAgQhBSABKAIAIQNBACEAQQALNgIMIAQgADYCCCAEIAU2AgQgBCADNgIAIAFBQGskACAEKAIAIAQoAgQgBCgCCCAEKAIMIARBEGokAAsvAQF/IAAtAAAEQCAAKAIMIgEEQCAAKAIIIAFBARCxAwsgACgCGEGALEEBELEDCwugAQEDfyMAQSBrIgMkACADQQhqIgIQrgECf0HRssIALQAAGkEwQQQQnAMiAQRAIAFBoK3AADYCACABIAIpAgA3AgQgASAAKQIANwIcIAFBDGogAkEIaikCADcCACABQRRqIAJBEGopAgA3AgAgAUEkaiAAQQhqKQIANwIAIAFBLGogAEEQaigCADYCACABDAELQQRBMBDnAwALIANBIGokAAsqAQJ/IwBBIGsiASQAIAFBCGoiAhCuASAAQbitwAAgAhDeASABQSBqJAALOAEB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IAEtAAkgBi0ACXM6AAkgASABLQAKIAYtAApzOgAKIAEgAS0ACyAGLQALczoACyABIAEtAAwgBi0ADHM6AAwgASABLQANIAYtAA1zOgANIAEgAS0ADiAGLQAOczoADiABIAEtAA8gBi0AD3M6AA8gDSAbIA0tAABzOgAAIAEgJiABLQARczoAESABICEgAS0AEnM6ABIgASAaIAEtABNzOgATIAEgJSABLQAUczoAFCABICQgAS0AFXM6ABUgASAZIAEtABZzOgAWIAEgICABLQAXczoAFyAMICMgDC0AAHM6AAAgASAfIAEtABlzOgAZIAEgFyABLQAaczoAGiABIBYgAS0AG3M6ABsgASAVIAEtABxzOgAcIAEgFCABLQAdczoAHSABIBIgAS0AHnM6AB4gASARIAEtAB9zOgAfIAQpAwAhMiANKQMAITMgASkDACE0IAUgD2oiBEEYaiAMKQMANwAAIARBEGogMzcAACAEQQhqIDI3AAAgBCA0NwAAIBwgJykDADcAACAGIAEpAyA3AAAgBUEgaiEFIAdBAWsiBw0ACwsEQCABQShqIgUgECALQf7///8AcUEEdCIEaiIIQQhqKQAAIjI3AwAgASAIKQAAIjM3AyAgAUEYakIANwAAIAFCADcAECABIDI3AAggASAzNwAAIAFBMGogHiABEA8gAS0AMCEIIAEtADEhByABLQAyIQ0gAS0AMyEMIAEtADQhHiABLQA1IQsgAS0ANiEQIAEtADchEyABLQA4IREgAS0AOSESIAEtADohFCABLQA7IRUgAS0APCEWIAEtAD0hFyABLQA+IR8gBkEIaiIjLQAAISAgBi0AACEZIAYtAAEhJCAGLQACISUgBi0AAyEaIAYtAAQhISAGLQAFISYgBi0ABiEbIAYtAAchJyAGLQAJIRwgBi0ACiErIAYtAAshLCAGLQAMIS0gBi0ADSEuIAYtAA4hLyAEIA9qIgQgAS0APyAGLQAPczoADyAEIB8gL3M6AA4gBCAXIC5zOgANIAQgFiAtczoADCAEIBUgLHM6AAsgBCAUICtzOgAKIAQgEiAcczoACSAEIBEgIHM6AAggBCATICdzOgAHIAQgECAbczoABiAEIAsgJnM6AAUgBCAeICFzOgAEIAQgDCAaczoAAyAEIA0gJXM6AAIgBCAHICRzOgABIAQgCCAZczoA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LQAGIAItAAZzOgAGIAAgAC0AByACLQAHczoAByAGIAYtAAAgAkEIaiIbLQAAczoAACAAIAAtAAkgAi0ACXM6AAkgACAALQAKIAItAApzOgAKIAAgAC0ACyACLQALczoACyAAIAAtAAwgAi0ADHM6AAwgACAALQANIAItAA1zOgANIAAgAC0ADiACLQAOczoADiAAIAAtAA8gAi0AD3M6AA8gByAhIActAABzOgAAIAAgGiAALQARczoAESAAICUgAC0AEnM6ABIgACAkIAAtABNzOgATIAAgGSAALQAUczoAFCAAICAgAC0AFXM6ABUgACAjIAAtABZzOgAWIAAgHyAALQAXczoAFyAdIBcgHS0AAHM6AAAgACAWIAAtABlzOgAZIAAgFSAALQAaczoAGiAAIBQgAC0AG3M6ABsgACASIAAtABxzOgAcIAAgESAALQAdczoAHSAAIBMgAC0AHnM6AB4gACAQIAAtAB9zOgAfIAYpAwAhMiAHKQMAITMgACkDACE0IAQgC2oiBkEYaiAdKQMANwAAIAZBEGogMzcAACAGQQhqIDI3AAAgBiA0NwAAIBsgJikDADcAACACIAApAyA3AAAgBEEgaiEEIApBAWsiCg0ACwsEQCAAQShqIgQgDiAMQf7///8AcUEEdCIGaiIKQQhqKQAAIjI3AwAgACAKKQAAIjM3AyAgAEEYakIANwAAIABCADcAECAAIDI3AAggACAzNwAAIABBMGogHiAAEBEgAC0AMCEKIAAtADEhCCAALQAyIQcgAC0AMyEdIAAtADQhDCAALQA1IR4gAC0ANiEOIAAtADchDyAALQA4IRAgAC0AOSETIAAtADohESAALQA7IRIgAC0APCEUIAAtAD0hFSAALQA+IRYgAkEIaiIXLQAAIR8gAi0AACEjIAItAAEhICACLQACIRkgAi0AAyEkIAItAAQhJSACLQAFIRogAi0ABiEhIAItAAchJiACLQAJIRsgAi0ACiEnIAItAAshHCACLQAMISsgAi0ADSEsIAItAA4hLSAGIAtqIgYgAC0APyACLQAPczoADyAGIBYgLXM6AA4gBiAVICxzOgANIAYgFCArczoADCAGIBIgHHM6AAsgBiARICdzOgAKIAYgEyAbczoACSAGIBAgH3M6AAggBiAPICZzOgAHIAYgDiAhczoABiAGIBogHnM6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aiAGQThqKAIANgIAIAYgBikCJCIcNwMIIAYgBikCMDcCFCADQRBqIAZBGGopAwA3AgAgA0EIaiACKQMANwIAIAMgHDcCACADIBc6ALUCIAMgGDoAtAIgAyANNgKwAiADIBtCIIg+AiwgAyAANgIoIAMgDjYCJCADIBpCIIg+AiAgAyABNgIcIAMgEjYCGAwVCyAGQccAaiAGQcgCaikCACIaNwAAIAYgBikCwAIiGzcAPyADQQxqIBo3AAAgAyAbNwAEIANBgICAgHg2AgAgDkGAgICAeHJBgICAgHhHBEAgACAOQQEQsQMLIBJBgICAgHhyQYCAgIB4RwRAIAEgEkEBELEDCyAGKAIwIgAEQCAGKAI0IABBARCxAwsgBigCJCIARQ0UIAYoAiggAEEBELEDDBQLIANBDjYCCCADQQA6AAQgA0GAgICAeDYCAAwTC0EOIABB/JDAABC1AwALIAAgBUH8kMAAELMDAAsgACAJQYyRwAAQtQMACyADIAk2AgggA0EAOgAEIANBgICAgHg2AgAMDwsgCSAAQZyRwAAQtQMACyAAIAVBnJHAABCzAwALIAAgDUGskcAAELUDAAsgDSAFQayRwAAQswMACyADIAc2AgggA0EAOgAEIANBgICAgHg2AgAMCgsgAyABNgIMIAMgAjYCCCADQQQ6AAQgA0GAgICAeDYCAAwJCyANIAVB2JnAABDQAQALIAEgB0HomcAAELUDAAsgAyABOgAFIANBBToABCADQYCAgIB4NgIADAYLIAcgAEH4mcAAELUDAAsgACAFQfiZwAAQswMACyADIA02AgggA0EAOgAEIANBgICAgHg2AgAMAwsgACAHQYiawAAQtQMACyAHIAVBiJrAABCzAwALIAAgDUGYmsAAELUDAAsgBkHABGokAAJ/AkAgAygCAEGAgICAeEcEQCATEMQBIBMgA0G4AhAsGkEAIQAMAQsgA0EEaiEBQX8hAAJAAkACQCADLQAEDgQAAgIBAgsgAygCCCEACyABEJwBDAELIANBwAJqIAFBCGopAgA3AwAgAyABKQIANwO4AiADQQA2AtQCIANCgICAgBA3AswCIANB4IHAADYC+AIgA0EDOgDwAiADQiA3AugCIANBADYC4AIgA0EANgLYAiADIANBzAJqNgL0AiADQdgCaiEBIwBB8ABrIgAkAAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgA0G4AmoiAi0AAEEBaw4MAQIDBAUGBwgJCgsMAAsgACACQQRqNgIgIABBAjYCMCAAQbz4wAA2AiwgAEIBNwI4IAAgAEEgaq1CgICAgMALhDcDCCAAIABBCGo2AjQgASgCHCABKAIgIABBLGoQOAwMCyAAIAJBBGo2AiAgAEEBNgIwIABB3PjAADYCLCAAQgE3AjggACAAQSBqrUKAgICA0AuENwMIIAAgAEEIajYCNCABKAIcIAEoAiAgAEEsahA4DAsLIAFB5PjAAEEcEIcDDAoLIAFBgPnAAEEOEIcDDAkLIAAgAkEEajYCbCAAIABB7ABqrUKAgICA4AuENwMgIABBAjYCHCAAQQI2AgwgAEG4+cAANgIIIABBATYCFCAAQQM6AGggAEEINgJkIABCIDcCXCAAQoCAgICAATcCVCAAQQI2AkwgAEEDOgBIIABBCDYCRCAAQiA3AjwgAEKAgICAgAE3AjQgAEECNgIsIAAgAEEsajYCGCAAIABBIGo2AhAgASgCHCABKAIgIABBCGoQOAwICyAAIAJBAWo2AiAgAEEBNgIwIABB7PnAADYCLCAAQgE3AjggACAAQSBqrUKAgICA8AuENwMIIAAgAEEIajYCNCABKAIcIAEoAiAgAEEsahA4DAcLIAAgAkEEajYCbCAAIAJBCGo2AiAgAEECNgIwIABBvPrAADYCLCAAQgI3AjggACAAQSBqrUKAgICAwAuENwMQIAAgAEHsAGqtQoCAgIDAC4Q3AwggACAAQQhqNgI0IAEoAhwgASgCICAAQSxqEDgMBgsgAUHM+sAAQSMQhwMMBQsgACACQQRqNgIgIABBATYCMCAAQZD7wAA2AiwgAEIBNwI4IAAgAEEgaq1CgICAgIAMhDcDCCAAIABBCGo2AjQgASgCHCABKAIgIABBLGoQOAwECyAAIAJBBGo2AiAgAEEBNgIwIABBxPvAADYCLCAAQgE3AjggACAAQSBqrUKAgICAgAyENwMIIAAgAEEIajYCNCABKAIcIAEoAiAgAEEsahA4DAMLIAFBzPvAAEEhEIcDDAILIAAgAkEEajYCICAAQQE2AjAgAEGQ/MAANgIsIABCATcCOCAAIABBIGqtQoCAgICQDIQ3AwggACAAQQhqNgI0IAEoAhwgASgCICAAQSxqEDgMAQsgACACQQRqNgIgIABBATYCMCAAQcD8wAA2AiwgAEIBNwI4IAAgAEEgaq1CgICAgIAMhDcDCCAAIABBCGo2AjQgASgCHCABKAIgIABBLGoQOAsgAEHwAGokAEUEQCADKALMAiEBIAMoAtACIgIgAygC1AIQ+gIhACABBEAgAiABQQEQsQMLIANBuAJqEJwBQQEMAgtBiILAAEE3IANB/wJqQfiBwABBjIPAABDCAQALQQALIQEgFCAANgIEIBQgATYCACADQYADaiQAIAooAgwhACAKKAIIIQEgFQRAIBYgFUEBELEDCyAKKAIcQQA2AgAgCigCICICIAIoAgBBAWsiAjYCACACRQRAIApBIGoQnwELIBEgATYCCCARIABBACABQQFxIgEbNgIEIBFBACAAIAEbNgIAIApBMGokACARKAIAIBEoAgQgESgCCCARQRBqJAALvgIBBX8jAEEQayIFJAAQTSIHIAMmASACIQYjAEFAaiICJAAgAkEcaiIJIAAQ2AEgAigCHCEIIAIgBjYCPCACIAE2AjggAiAGNgI0IAJBEGogAkE0akHAgcAAEM0BIAIgBzYCMCACIAIoAhQiATYCLCACIAIoAhAiADYCKCACQQhqIQZBACEHAkAgCCgCAEGAgICAeEcEQCABRQ0BIAhBMGohCANAIAAgAC0AACAIIARB/wFxai0AAHM6AAAgBEEBaiEEIABBAWohACABQQFrIgENAAsMAQtBASEHQfODwABBGBD6AiEACyAGIAA2AgQgBiAHNgIAIAIoAgwhASACKAIIIQAgAkEoahCGAiAJEI0CIAUgADYCBCAFIAFBACAAQQFxGzYCACACQUBrJAAgBSgCACAFKAIEIAVBEGokAAuYAgEDfyMAQRBrIgQkACMAQcACayIDJAAgA0EQaiAAENgBIAMoAhAhBQJAIAFFBEBBgICAgHghAAwBCyADIAI2ArgBIAMgATYCtAEgAyACNgKwASADQQhqIANBsAFqQfCEwAAQzQEgAyADKAIMIgA2AiQgAyADKAIINgIgCyADIAA2AhwgA0EoaiIAIAUgA0EcahCkASADQRBqEI8CIAQCfyADLQAoQQRHBEAgA0EANgKwASADQbgBaiAAQYgBECwaIANBsAFqEIoCQQhqIQBBAAwBCyADKAIsIQBBAQsiATYCCCAEIABBACAB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hMAAEM0BIAJBDGogAigCACIBIAIoAgQiABCxASAABEAgASAAQQEQsQMLAn8gAigCDEGAgICAeEcEQEEAIQAgAkEANgJkIAJB6ABqIAJBDGpB2AAQLBpB0bLCAC0AABpB5ABBBBCcAyIBRQRAQQRB5AAQ5wMACyABQoGAgIAQNwIAIAFBCGoiASACQeQAakHcABAsGiABDAELQQEhACACKAIQCyEBIAMgADYCCCADIAFBACAAGzYCBCADQQAgASAAGzYCACACQcABaiQAIAMoAgAgAygCBCADKAIIIANBEGokAAv0AgEHfyMAQRBrIgMkACMAQaACayICJAAgAiABNgKYASACIAA2ApQBIAIgATYCkAEgAiACQZABakHwhMAAEM0BIAJBCGohASACKAIAIgchBCACKAIEIgYhBSMAQbABayIAJAAgAEHYAGoiCCAEIAUQsQEgACgCXCEEAkAgACgCWCIFQYCAgIB4RwRAIABBCGogAEHgAGpB0AAQLBogACAENgIEIAAgBTYCACAAQYCAgIB4NgJYIAEgACAIEKQBIAVFDQEgBCAFQQEQsQMMAQsgAUEEOgAAIAEgBDYCBAsgAEGwAWokACAGBEAgByAGQQEQsQMLAn8gAi0ACEEERwRAQQAhACACQQA2ApABIAJBmAFqIAJBCGpBiAEQLBogAkGQAWoQigJBCGoMAQtBASEAIAIoAgwLIQEgAyAANgIIIAMgAUEAIAAbNgIEIANBACABIAAbNgIAIAJBoAJqJAAgAygCACADKAIEIAMoAgggA0EQaiQAC+QBAQJ/IwBBEGsiAyQAIwBBoAJrIgIkACACIAE2ApgBIAIgADYClAEgAiABNgKQASACIAJBkAFqQfyMwAAQzQEgAkEIaiACKAIAIgEgAigCBCIAEMMBIAAEQCABIABBARCxAwsCfyACLQAIQQJHBEBBACEAIAJBADYCkAEgAkGYAWogAkEIakGIARAsGiACQZABahCKAkEIagwBC0EBIQAgAigCDAshASADIAA2AgggAyABQQAgABs2AgQgA0EAIAEgABs2AgAgAkGgAmokACADKAIAIAMoAgQgAygCCCADQRBqJAALijMCE38CfiMAQRBrIhAkACMAQfAAayIKJAAgCiABNgJAIAogADYCPCAKIAE2AjggCiAKQThqQfyMwAAQzQEgCkEIaiES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KQJkNwMQIAIoAmAiAUEFRg0BIAJBOGoiBSACQYwBaigCADYCAEEQIQAgAkEwaiIEIAJBhAFqKQIANwMAIAJBKGoiCCACQfwAaikCADcDACACIAIpAnQ3AyAgAUEERwRAIAcgAikDEDcCBCAHIAIpAyA3AhQgB0EMaiADKQMANwIAIAdBHGogCCkDADcCACAHQSRqIAQpAwA3AgAgB0EsaiAFKAIANgIAIAcgATYCAAwECwJAAkAgDUEQSQR/QQAFQQQhACAMIA1qQQhrKQAAQu3qzcu2rJk8Ug0CIAwgDUEMayIBaigAACIAQQFGDQFBAwshASACIAA2AmggAiABNgJkDAQLIAJB4ABqIQMjAEHwAmsiACQAAkAgAUEDSwRAAkAgDCABQQRrIgVqKAAAIgRBwAFGBEAgAUG0AWshASAFQbABTwRAIABB2AFqIAEgDGoiAUEYaikAADcDACAAQeABaiABQSBqKQAANwMAIABB6AFqIAFBKGopAAA3AwAgAEHwAWogAUEwaikAADcDACAAQfgBaiABQThqKQAANwMAIABBgAJqIAFBQGspAAA3AwAgACABKQAQNwPQASABKQAAIRUgASkACCEWIABBiAJqIAFByABqQeQAECwaIAEoAKwBIQEgAEEYaiAAQdABakGcARAsGiAAIAE2ArQBIAAgFjcCECAAIBU3AgggAEG4AWogAEEUakE8EH8gAEHEAWogAEHQAGpB5AAQfyADQQE2AgAgA0HAATYCLCADQYCAgIB4NgIgIAMgACkCuAE3AgQgA0EMaiAAQcABaikCADcCACADQRRqIABByAFqKQIANwIADAILIAEgBUHIucEAELIDAAsgAyAENgIIIANChYCAgMAANwMACyAAQfACaiQADAELIABBADYCGCAAQQE2AgwgAEGIucEANgIIIABCBDcCECAAQQhqQbi5wQAQwAIACyACKAJgIgBBBUYNAwsgAkHYAGoiCSACQewAaiIRKQIAIhU3AwAgAkE8aiACQfwAaikCADcCACACQcQAaiACQYQBaikCADcCACACQcwAaiACQYwBaigCADYCACACQSxqIBU3AgAgAiACKQJkIhU3A1AgAiACKQJ0NwI0IAIgFTcCJCACIAA2AiAgAEEERwRAIAcgAikDIDcDACAHQShqIAJByABqKQMANwMAIAdBIGogAkFA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GCADKAIcIAMoAiAgAEEQahA4DAYLIAAgAUEEajYCDCAAQQE2AhQgAEG8wcEANgIQIABCATcCHCAAIABBDGqtQoCAgICQGoQ3AyggACAAQShqNgIYIAMoAhwgAygCICAAQRBqEDgMBQsgACABQQRqNgIMIABBATYCFCAAQejBwQA2AhAgAEIBNwIcIAAgAEEMaq1CgICAgJAahDcDKCAAIABBKGo2AhggAygCHCADKAIgIABBEGoQOAwECyAAIAFBBGo2AgwgAEEBNgIUIABBkMLBADYCECAAQgE3AhwgACAAQQxqrUKAgICAkBqENwMoIAAgAEEoajYCGCADKAIcIAMoAiAgAEEQahA4DAMLIAAgAUEEajYCDCAAQQE2AhQgAEG4wsEANgIQIABCATcCHCAAIABBDGqtQoCAgICQGoQ3AyggACAAQShqNgIYIAMoAhwgAygCICAAQRBqEDgMAgsgACABQQRqNgIMIABBATYCFCAAQeTCwQA2AhAgAEIBNwIcIAAgAEEMaq1CgICAgJAahDcDKCAAIABBKGo2AhggAygCHCADKAIgIABBEGoQOAwBCyAAIAFBBGo2AgwgAEECNgIUIABBmMPBADYCECAAQgE3AhwgACAAQQxqrUKAgICAkBqENwMoIAAgAEEoajYCGCADKAIcIAMoAiAgAEEQahA4CyAAQTBqJABFBEAgBSgCDCEAIAUoAhAiAyAFKAIUEPoCIAAEQCADIABBARCxAwsCQAJAAkACQAJAAkACQAJAAkAgASgCAA4MCAgICAgBAgMEBQYHAAsgASgCBCIARQ0HIAEoAgggAEEBELEDDAcLIAFBBGoQiAMMBgsgASgCBCIARQ0FIAEoAgggAEEBELEDDAULIAEoAgQiAEUNBCABKAIIIABBARCxAwwECyABKAIEIgBFDQMgASgCCCAAQQEQsQMMAwsgASgCBCIARQ0CIAEoAgggAEEBELEDDAILIAEoAgQiAEUNASABKAIIIABBARCxAwwBCyABKAIEIgBFDQAgASgCCCAAQQEQsQMLIAVBQGskAAwBC0HcscAAQTcgBUE/akHMscAAQeCywAAQwgEACyEAIBJBBTYCACASIAA2AgQMAQsgEkEENgIACyAHQUBrJAAgDQRAIAwgDUEBELEDC0EAIQFBACEAAkACQAJAIAooAggiA0EEaw4CAgEACyAKIAM2AkAgCkEANgI4IApBxABqIApBCGpBBHJBLBAsGkHRssIALQAAGkHAAEEIEJwDIgFFBEBBCEHAABDnAwALIAFCgYCAgBA3AwAgAUEIaiIBIApBOGpBOBAsGgwBC0EBIQAgCigCDCEBCyAQIAA2AgggECABQQAgABs2AgQgEEEAIAEgABs2AgAgCkHwAGokACAQKAIAIBAoAgQgECgCCCAQQRBqJAAL2QkCCH8BfiMAQRBrIgQkACMAQZABayIDJAAgAyABNgJYIAMgADYCVCADIAE2AlAgA0EIaiADQdAAakGMm8AAEM0BIAMoAggiCSECIAMoAgwhBSMAQUBqIgEkACMAQeAAayIAJAAgAEIANwMIIAAgBTYCBCAAIAI2AgAgAEEYakIANwMAIABCADcDECAAQcgAaiICIAAgAEEQakEQEK0BAkACQAJAAkACQAJAIAAtAEhBBEYEQCAAQQA2AiAgAiAAIABBIGpBBBCtAQJAIAAtAEhBBEYEQCAAKAIgIQIMAQsgACkDSCIKQiCIpyECIApC/wGDQgRSDQILIABBADYCICAAQcgAaiAAIABBIGpBBBCtAQJAIAAtAEhBBEYEQCAAKAIgIQYMAQsgACkDSCIKQiCIpyEGIApC/wGDQgRSDQMLIABBADYCICAAQcgAaiAAIABBIGpBBBCtAQJAIAAtAEhBBEYEQCAAKAIgIQcMAQsgACkDSCIKQiCIpyEHIApC/wGDQgRSDQQLIABBMGpBADYCACAAQShqQgA3AwAgAEIANwMgIABByABqIgggACAAQSBqQRQQrQEgAC0ASEEERw0EIABBQGtBADYCACAAQgA3AzggCCAAIABBOGpBDBCtASAALQBIQQRHDQUCQCAAQRBqIghByIXAAEEQEO0BBEAgCEHYhcAAQRAQ7QENAQsgASAAKQMQNwAEIAEgACkDIDcAICABIAApAzg3ADQgASAHNgIcIAEgBjYCGCABIAI2AhQgAUEMaiAAQRhqKQMANwAAIAFBKGogAEEoaikDADcAACABQTBqIABBMGooAgA2AAAgAUE8aiAAQUBrKAIANgAAIAFBADYCAAwHCyAAQdEAaiAAQRhqKQMANwAAIAAgACkDEDcASSAAQQE6AEggAEHIAGoQqwIhAiABQQE2AgAgASACNgIEDAYLIAAgACkDSDcDSCAAQcgAahCsAiECIAFBATYCACABIAI2AgQMBQsgACACNgJMIAAgCjwASCAAIAqnIgJBGHY6AEsgACACQQh2OwBJIABByABqEKwCIQIgAUEBNgIAIAEgAjYCBAwECyAAIAY2AkwgACAKPABIIAAgCqciAkEYdjoASyAAIAJBCHY7AEkgAEHIAGoQrAIhAiABQQE2AgAgASACNgIEDAMLIAAgBzYCTCAAIAo8AEggACAKpyICQRh2OgBLIAAgAkEIdjsASSAAQcgAahCsAiECIAFBATYCACABIAI2AgQMAgsgACAAKQNINwNIIABByABqEKwCIQIgAUEBNgIAIAEgAjYCBAwBCyAAIAApA0g3A0ggAEHIAGoQrAIhAiABQQE2AgAgASACNgIECyAAQeAAaiQAIANBEGoiAAJ/IAEoAgBFBEAgASgCBCECIABBCGogAUEIakE4ECwaQQAMAQsgASgCBBCaASECQQELNgIAIAAgAjYCBCABQUBrJAAgBQRAIAkgBUEBELEDCwJ/IAMoAhBFBEAgA0HUAGogA0EUakE8ECwaQQAhACADQQA2AlAgA0HQAGoQiQJBCGoMAQtBASEAIAMoAhQLIQEgBCAANgIIIAQgAUEAIAAbNgIEIARBACABIAAbNgIAIANBkAFqJAAgBCgCACAEKAIEIAQoAgggBEEQaiQAC6gVAht/BH4jAEEQayIIJAAjAEGgAmsiBCQAIAQgATYCmAEgBCAANgKUASAEIAE2ApABIAQgBEGQAWpBjJvAABDNASAEQQhqIRIgBCgCACIZIQAgBCgCBCETIwBBEGsiDCQAIAxBBGohDSMAQRBrIg4kACAOQQRqIQkjAEGgAWsiBSQAIAVBEGoiFkGriMAAIAAgExBgIAUpAhQhHQJAAkAgBSgCECIQQYCAgIB4RwRAIAUoAhQhFyMAQdACayIBJABBv53AACkAACEfQUghAEGAisEAIQMDQCAAQfSQwQBqLQAAIgJBwABJBH4gAkEDdEGAisEAaikDAAVCAAsgH4NQRQRAIAMpAwAgHoQhHgsgA0EIaiEDIABBAWoiAA0ACyABQQhqIgZBAEGAARBKGiABQZwBakH8kMEAKQIANwIAIAFB9JDBACkCADcClAEgAUKAgICAgAI3AqQBIAFBuAFqQYiRwQBBgAEQLCEKIAFCgICAgIACNwO4AiABQZQBaiELIAFBiAFqIQIDQAJAIAIgBkYNACACQQhrIQIgASgCpAEiACABKAKoAUYNACABIABBAWo2AqQBIAEoArgCIgMgASgCvAJGDQAgACALai0AACEAIAEgA0EBajYCuAIgCiADQQN0aikDACIfIB6DQRwgAGtBP3GthiAeIB9Cf4WDIABBP3GtiIQhHkIAIR9BgIrBACEDQUAhAANAIABByJLBAGotAAAiB0HAAEkEfiAHQQN0QYCKwQBqKQMABUIACyAeg1BFBEAgAykDACAfhCEfCyADQQhqIQMgAEEBaiIADQALIAIgHzcDAAwBCwsgFiABQQhqQYABECwaIAFB0AJqJAACfyAdpyIaIQEjAEEgayIRJAACQAJ/IB1CIIinIhsiD0EHcUUEQCAPQQhPBEADQCAPQQhrIQ8gASkAACEdQUAhAkGAisEAIQBCACEeA0AgAkGYmMEAai0AACIDQcAASQR+IANBA3RBgIrBAGopAwAFQgALIB2DUEUEQCAAKQMAIB6EIR4LIABBCGohACACQQFqIgINAAsgAUEIakEAIRQDQCAeQiCIIR8gFiAUQQN0aikDACEgQgAhHUGAisEAIQBBQCECA0AgAkGIk8EAai0AACIDQcAASQR+IANBA3RBgIrBAGopAwAFQgALIB+DUEUEQCAAKQMAIB2EIR0LIABBCGohACACQQFqIgINAAsgHSAghSIdQjiIIiCnIQAgHUI4hiAdQoD+A4NCKIaEIB1CgID8B4NCGIYgHUKAgID4D4NCCIaEhCAdQgiIQoCAgPgPgyAdQhiIQoCA/AeDhCAdQiiIQoD+A4MgIISEhCIdQsABg1BFDQUgHaciBkEIdkH/AXEhAiAdQoCAA4NQRQRAIAIhAAwGCyAGQRB2Qf8BcSEDIB1CgICABoNQRQRAIAMhAAwGCyAGQRh2IQYgHUKAgICADINQRQRAIAYhAAwGCyAdQiCIp0H/AXEhCiAdQoCAgICAGINQRQRAIAohAAwGCyAdQiiIp0H/AXEhCyAdQoCAgICAgDCDUEUEQCALIQAMBgsgHUIwiKdB/wFxIQcgHUKAgICAgICA4ACDUEUEQCAHIQAMBgsgHUI4iKchGCAdQv//////////P1YEQCAYIQAMBgsgGEHIlsEAajEAACAHQYiWwQBqMQAAIApBiJXBAGoxAAAgA0GIlMEAajEAACAAQYiTwQBqMQAAQgiGIAJByJPBAGoxAABCBIaEhEIIhiAGQciUwQBqMQAAQgSGhIRCCIYgC0HIlcEAajEAAEIEhoSEQgSGQvD///8Pg4QhIEIAIR1BgIrBACEAQWAhAgNAIAJBqJfBAGotAAAiA0HAAEkEfiADQQN0QYCKwQBqKQMABUIACyAgg1BFBEAgACkDACAdhCEdCyAAQQhqIQAgAkEBaiICDQALIB0gHoVCIIYgH4QhHiAUQQFqIhRBEEcNAAsgHkIgiSEeQgAhHUGAisEAIQBBQCECA0AgAkHYmMEAai0AACIDQcAASQR+IANBA3RBgIrBAGopAwAFQgALIB6DUEUEQCAAKQMAIB2EIR0LIABBCGohACACQQFqIgINAAsgASAdNwAAIQEgD0EHSw0ACwtBAAwBCyARIA82AhAgEUEAOgAMIwBBIGsiAiQAIAJBCGoiARCuAQJ/QdGywgAtAAAaQTBBBBCcAyIABEAgAEHQicEANgIAIAAgASkCADcCBCAAIBFBDGoiAykCADcCHCAAQQxqIAFBCGopAgA3AgAgAEEUaiABQRBqKQIANwIAIABBJGogA0EIaikCADcCACAAQSxqIANBEGooAgA2AgAgAAwBC0EEQTAQ5wMACyACQSBqJAALIBFBIGokAAwBCyAAQcAAQciXwQAQ0AEACyIARQRAIAVBlAFqIBogGxA5QQAhCiAFQQhqIQsgBSgCmAEhAyAFKAKcASEAA0AgACIBBEAgACADaiIGQQFrIgAsAAAiAkEASARAIAJBP3ECfyAGQQJrIgAtAAAiAsAiB0FATgRAIAJBH3EMAQsgB0E/cQJ/IAZBA2siAC0AACICwCIHQUBOBEAgAkEPcQwBCyAHQT9xIAZBBGsiAC0AAEEHcUEGdHILQQZ0cgtBBnRyIQILIAAgA2shACACRQ0BCwsgCyABNgIEIAsgAzYCACAFKAIMIgFBAEgNAiAFKAIIIQICQCABRQRAQQEhAAwBC0HRssIALQAAGkEBIQogAUEBEJwDIgBFDQMLIAAgAiABECwhACAFKAKUASICQYCAgIB4ckGAgICAeEcEQCADIAJBARCxAwsgCSABNgIIIAkgADYCBCAJIAE2AgAgEEUNAyAXIBBBARCxAwwDCyAJQYCAgIB4NgIAIAkgADYCBCAQRQ0CIBcgEEEBELEDDAILIAUgHTcDECMAQSBrIgAkACAAQQhqIgEQrgEgBUEQakHwrMAAIAEQ3gEhASAAQSBqJAAgCUGAgICAeDYCACAJIAE2AgQMAQsgCiABQeiNwAAQ8wIACyAFQaABaiQAIA4oAgghAQJAAkACQAJAAkACQCAOKAIEIgNBgICAgHhHBEAgDigCDCIAQRBLDQEgAEEQRw0EQQEhAkEAIQAMAgsgDUGAgICAeDYCACANIAE2AgQMAgsgASwAEEG/f0wNAiAAQRBrIgBBAEgNA0HRssIALQAAGkEBIRUgAEEBEJwDIgJFDQMLIAIgAUEQaiAAECwhAiANIAA2AgggDSACNgIEIA0gADYCACADRQ0AIAEgA0EBELEDCyAOQRBqJAAMAgsgASAAQRAgAEGUj8AAEIwDAAsgFSAAQeiNwAAQ8wIACwJAIAwoAgQiAEGAgICAeEcEQCASIAwoAggiASAMKAIMEMMBIABFDQEgASAAQQEQsQMMAQsgDCgCCBCaASEAIBJBAjoAACASIAA2AgQLIAxBEGokACATBEAgGSATQQEQsQMLAn8gBC0ACEECRwRAIARBmAFqIARBCGpBiAEQLBpBACEAIARBADYCkAEgBEGQAWoQigJBCGoMAQtBASEAIAQoAgwLIQEgCCAANgIIIAggAUEAIAAbNgIEIAhBACABIAAbNgIAIARBoAJqJAAgCCgCACAIKAIEIAgoAgggCEEQaiQAC+QBAQJ/IwBBEGsiAyQAIwBBoAJrIgIkACACIAE2ApgBIAIgADYClAEgAiABNgKQASACIAJBkAFqQYybwAAQzQEgAkEIaiACKAIAIgEgAigCBCIAEMMBIAAEQCABIABBARCxAwsCfyACLQAIQQJHBEAgAkGYAWogAkEIakGIARAsGkEAIQAgAkEANgKQASACQZABahCKAkEIagwBC0EBIQAgAigCDAshASADIAA2AgggAyABQQAgABs2AgQgA0EAIAEgABs2AgAgAkGgAmokACADKAIAIAMoAgQgAygCCCADQRBqJAAL5gYBCH8jAEEQayIFJAAjAEEwayIDJAAgAyABNgIoIAMgADYCJCADIAE2AiAgA0EIaiADQSBqQYybwAAQzQEgAygCCCIJIQAgAygCDCIIIQIjAEEQayIBJAACQAJAIAJBEE8EQCAALQAAQekARw0BIAAtAAFB5gBHDQEgAC0AAkHtAEcNASAALQADQfQARw0BIAAtAAhB/gFHDQEgAC0ACUH+AUcNASAALQAKQf4BRw0BIAAtAAtB/gFHDQEgASAAKAAENgIIIAEgAC0AD0EBazoADCABIAAvAAwgAC0ADkEQdHI2AgQgAUEANgIADAILIAFCgICAgIACNwIEIAFBATYCAAwBCyABQQE2AgQgAUEBNgIACyABKAIIIQQgASgCBCECIANBEGoiBgJ/IAEoAgBFBEAgBiABKAIMNgIMIAYgBDYCCEEADAELAn8jAEFAaiIAJAAgACAENgIIIAAgAjYCBCAAQQA2AhQgAEKAgICAEDcCDCAAQbSxwAA2AjggAEEDOgAwIABCIDcCKCAAQQA2AiAgAEEANgIYIAAgAEEMajYCNCAAQRhqIQQjAEEwayICJAACfyAAQQRqIgcoAgBFBEAgAiAHQQRqNgIMIAJBAjYCFCACQYD2wAA2AhAgAkIBNwIcIAIgAkEMaq1CgICAgKALhDcDKCACIAJBKGo2AhggBCgCHCAEKAIgIAJBEGoQOAwBCyAEQZD2wABBEBCHAwsgAkEwaiQARQRAIAAoAgwhAiAAKAIQIgQgACgCFBD6AiACBEAgBCACQQEQsQMLIABBQGskAAwBC0HcscAAQTcgAEE/akHMscAAQeCywAAQwgEACyECQQELNgIAIAYgAjYCBCABQRBqJAAgCARAIAkgCEEBELEDCwJ/IAMoAhBFBEAgA0EsaiADQRRqIgBBCGooAgA2AgBBACECIANBADYCICADIAApAgA3AiRB0bLCAC0AABpBGEEEEJwDIgBFBEBBBEEYEOcDAAsgAEKBgICAEDcCACAAIANBIGoiASkCADcCCCAAQRBqIAFBCGopAgA3AgAgAEEIagwBC0EBIQIgAygCFAshACAFIAI2AgggBSAAQQAgAhs2AgQgBUEAIAAgAhs2AgAgA0EwaiQAIAUoAgAgBSgCBCAFKAIIIAVBEGokAAuiFgEKfyMAQRBrIgokACMAQTBrIgckACAHIAE2AiQgByAANgIgIAcgATYCHCAHIAdBHGpBrJ7AABDNASAHKAIAIQYgBygCBCEBIwBBQGoiBSQAQQohAEEBIQgCQAJAAkAgAUEKSQ0AAkACQAJAQYjcwQAgBkEDEO0BRQRAQYABIQMMAQtBi9zBACAGQQMQ7QEEQCABQSBJDQMgBikAAELBoJWilejRotgAUg0CIAYoAAxBIGoiA0UNAgwBCyAGKAAGIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyIgBBgIGChHhxBEBBCiEDDAELIABBAnZBgID/AHEgAEEDdkGAgID/AHEgAEH/AHEgAEEBdkGA/wBxcnJyQQpqIQMLIANBCmoiACABSw0CAkACQCABIANJDQACQAJAAkAgASADayIAQQNJDQBBiNzBACADIAZqIgRBAxDtAUUEQEGAASECDAILQYvcwQAgBEEDEO0BDQBBCiECIABBCkkNCCAEKAAGIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyIgBBgIGChHhxDQEgAEECdkGAgP8AcSAAQQN2QYCAgP8AcSAAQf8AcSAAQQF2QYD/AHFycnJBCmohAgwBCyABQSBJDQUgBikAAELBoJWilejRotgAUg0BIAYoAAxBIGoiAkUNAQsgAiADaiIDQQpqIgAgAUsNBSABIANJDQECQAJAIAEgA2siAEEDSQ0AQYjcwQAgAyAGaiIEQQMQ7QFFBEBBgAEhAgwCC0GL3MEAIARBAxDtAQ0AQQohAiAAQQpJDQggBCgABiIAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZyciIAQYCBgoR4cQ0BIABBAnZBgID/AHEgAEEDdkGAgID/AHEgAEH/AHEgAEEBdkGA/wBxcnJyQQpqIQIMAQsgAUEgSQ0FIAYpAABCwaCVopXo0aLYAFINASAGKAAMQSBqIgJFDQELIAIgA2oiA0EKaiIAIAFLDQUgASADSQ0BAkACQCABIANrIgBBA0kNAEGI3MEAIAMgBmoiBEEDEO0BRQRAQYABIQIMAgtBi9zBACAEQQMQ7QENAEEKIQIgAEEKSQ0IIAQoAAYiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnIiAEGAgYKEeHENASAAQQJ2QYCA/wBxIABBA3ZBgICA/wBxIABB/wBxIABBAXZBgP8AcXJyckEKaiECDAELIAFBIEkNBSAGKQAAQsGglaKV6NGi2ABSDQEgBigADEEgaiICRQ0BCyACIANqIgNBCmoiACABSw0FIAEgA0kNAQJAIAEgA2siAEEDSQ0AQYjcwQAgAyAGaiIEQQMQ7QFFBEAgA0GAAWohAgwFC0GL3MEAIARBAxDtAQ0AQQohAiAAQQpJDQcgBCgABiIAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZyciIAQYCBgoR4cQ0DIABBAnZBgID/AHEgAEEDdkGAgID/AHEgAEH/AHEgAEEBdkGA/wBxcnJyQQpqIQIMAwsgAUEgSQ0EIAYpAABCwaCVopXo0aLYAFINACAGKAAMQSBqIgINAgsgAyECDAILIAMgAUG43MEAELIDAAsgAiADaiECCyACQRBqIgAgAUsNAQJAAkACQAJAAkACQAJAAkACQAJAIAEgAk8EQCABIAJrIglBA00NCSACIAZqIgItAAMhACACLQACIQMgAi0AASEEIAItAAAiC0Ewaw43BQoKCgoKCgoKCgoKCgoKCgoKCgoKCgQKCgoKCgoGCgMKCggKCgoKCgoKCgoKCgoKCgoKCgoKAgELIAIgAUG83cEAELIDAAsgC0EaRg0FDAgLIARBzABHIANB4QBHciAAQcMAR3INB0EAIQhBgYCAgHghAAwJCyAEQecARyADQecAR3IgAEHTAEdyDQZBACEIQQEhAAwICyAEQdIARyADQc0AR3IgAEE4R3INBUEAIQhBgoCAgHghAAwHCyAEQSZHIANBsgFHciAAQfUAR3INBEEAIQhBByEADAYLIARBwQBHIANBwwBHciAAQSBHcg0DQQAhCEGFgICAeCEADAULIARBxQBHIANB3wFHciAAQaMBR3INAkEAIQhBCCEADAQLIARByQBHIANBxgBHciAAQcYAR3INAUEAIQhBg4CAgHghAAwDC0EEIAlBjN3BABCzAwALQQAhCCALQRh0IARBEHRyIANBEHRBCHYgAHJyIgBBgIBYcUGAgEBGBEBBAiEADAILIABB////fksEQEEDIQAMAgsCQAJAIAlBB0sEQCACKAAEQebo5YMHRwRAQQAhAAwFCyAJQQtNDQEgAi0ACyEJIAItAAohAyACLQAJIQRBACEAAkACQAJAAkACQAJAAkACQCACLQAIQc0Aaw4hAQIMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMDAwFDAsgBEHzAEcNCSADQe8ARg0CDAkLIARB0wBHIANBzgBHciAJQdYAR3INAkEGIQAMCgsgBEHEAEcgA0HBAEdyIAlB0wBHcg0HQQQhAAwJC0EGIQAgCUEyRg0IIAlB7QBHDQYMCAsgBEE0Rg0BDAcLIARB8ABHIANBNEdyDQZBBiECDAELQQQhAgJAIANBwQBrDgIBAAYLQQUhAgsgAiEADAQLQQggCUGc3cEAELMDAAtBDCAJQazdwQAQswMAC0EAIQAMAQsgA0EgaiEACyAFIAA2AgQgBSAINgIADAELQQogAEGo3MEAELMDAAsgBUEAIAUoAgQiAyAFKAIAIggbNgIIIAVBADYCFCAFQoCAgIAQNwIMIAVBzJ7AADYCOCAFQQM6ADAgBUIgNwIoIAVBADYCICAFQQA2AhggBSAFQQxqNgI0IAVBGGohAiMAQTBrIgAkACAAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBUEIaigCACIEDgkNAQIDBAUGBwgACwJAIARB/v///wdqDgQKCwAMCQsACyAAQcjcwQA2AigMDAsgAEHL3MEANgIoDAsLIABBztzBADYCKAwKCyAAQdHcwQA2AigMCQsgAEHU3MEANgIoDAgLIABB19zBADYCKAwHCyAAQdrcwQA2AigMBgsgAEHd3MEANgIoDAULIABB4NzBADYCKEEEDAULIABB5NzBADYCKAwDCyAAQefcwQA2AigMAgsgAEHq3MEANgIoDAELIABB7dzBADYCKAtBAws2AiwgAEEBNgIMIABB8NzBADYCCCAAQgE3AhQgACAAQShqrUKAgICA8ByENwMgIAAgAEEgajYCECACKAIcIAIoAiAgAEEIahA4IABBMGokAARAQfSewABBNyAFQT9qQeSewABB+J/AABDCAQALIAdBDGoiACAFKQIMNwIAIABBCGogBUEUaigCADYCACAAIANBACAIGzYCDCAFQUBrJAAgAQRAIAYgAUEBELEDCwJ/IAcoAgxBgICAgHhHBEAgB0EoaiAHQRRqKQIANwIAQQAhASAHQQA2AhwgByAHKQIMNwIgQdGywgAtAAAaQRxBBBCcAyIARQRAQQRBHBDnAwALIABCgYCAgBA3AgAgACAHQRxqIgIpAgA3AgggAEEQaiACQQhqKQIANwIAIABBGGogAkEQaigCADYCACAAQQhqDAELQQEhASAHKAIQCyEAIAogATYCCCAKIABBACABGzYCBCAKQQAgACABGzYCACAHQTBqJAAgCigCACAKKAIEIAooAgggCkEQaiQAC6Yo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AEGw/sAAKQMANwMAIABB5IDBACkAADcDGAJAIApBIE8EQCAIIAFBGGopAAA3AwAgAyABQRBqKQAANwMAIAUgAUEIaikAADcDACAAQgE3AxAgACABKQAANwM4IAAgAEEYaiIFQQEQCiABQSBqIgggCkEgayIBQUBxaiEMIAFBP3EhAyABQcAATwRAIAAgACkDECABQQZ2IgGtfDcDECAAIAggARAKCyAFIAwgAxAsGgwBCyAAQThqIAEgChAsGiAKQSByIQMLIAAgAzoAWCAAQeAAaiAAQeAAECwaIAApA3AhDSAALQC4ASEBIABByAFqIABBCGopAwA3AwAgASAAQfgAaiIFaiIDQYABOgAAIAAgACkDADcDwAEgAa1CA4YgDUIJhoQhDQJAAkAgAUE/RwRAIANBAWpBACABQT9zEEoaIAFBOHNBB0sNAQsgAEHAAWoiASAFQQEQCiAAQYACakIANwMAIABB+AFqQgA3AwAgAEHwAWpCADcDACAAQegBakIANwMAIABB4AFqQgA3AwAgAEHYAWpCADcDACAAQgA3A9ABIAAgDTcDiAIgASAAQdABakEBEAoMAQsgACANNwOwASAAQcABaiAFQQEQCgsgAEHYAWogAEHIAWopAwAiDTcDACAAIAApA8ABIg43A9ABIAZBCGogDTcAACAGIA43AAAgAEGQAmokACACQQA2AiQgAkKAgICAEDcCHCACQcD+wAA2AjQgAiACQRxqIgU2AjAgAkGAgMQANgIoIAIgBjYCLCACQThqIgBBATYCBCAAIAJBKGoiASgCCCABKAIEa0EBdCABKAIAQYCAxABHciIBNgIIIAAgATYCACACKAI4IgAEQCAFQQAgABB1CyACQUBrIAJBMGopAgA3AwAgAiACKQIoNwM4IAJBOGoQ3wEiA0GAgMQARwRAIAJBzABqIgBBA3IhASAAQQJyIQYgAEEBciEFA0ACQCADQYABTwRAIAJBADYCTAJ/IANBgBBPBEAgA0GAgARPBEAgAiADQRJ2QfABcjoATCACIANBBnZBP3FBgAFyOgBOIAIgA0EMdkE/cUGAAXI6AE0gASEAQQQMAgsgAiADQQx2QeABcjoATCACIANBBnZBP3FBgAFyOgBNIAYhAEEDDAELIAIgA0EGdkHAAXI6AEwgBSEAQQILIQggACADQT9xQYABcjoAACAIIAIoAhwgAigCJCIAa0sEfyACQRxqIAAgCBB1IAIoAiQFIAALIAIoAiBqIAJBzABqIAgQLBogAiACKAIkIAhqNgIkDAELIAIoAiQiACACKAIcRgRAIAJBHGpB1IDBABCRAQsgAigCICAAaiADOgAAIAIgAEEBajYCJAsgAkE4ahDfASIDQYCAxABHDQALCyAHQQ9qIQEgAigCHCEFIAIoAiAhBgJAAkAgAigCJEEgRgRAIAEgBikAATcAAiABQQpqIAZBCWopAAA3AAAgAUESaiAGQRFqKQAANwAAIAFBGWogBkEYaikAADcAACAGLQAAIQBBACEDIAUNAQwCC0EBIQBBASEDIAVFDQELIAYgBUEBELEDCyABIAM6AAAgASAAOgABIAJB0ABqJAAgBy0AECEBIARBCGoiAAJ/IActAA9FBEAgACAHKQARNwACIABBGWogB0EoaikAADcAACAAQRJqIAdBIWopAAA3AAAgAEEKaiAHQRlqKQAANwAAIAAgAToAAUEADAELIAACfyMAQUBqIgAkACAAIAFBAXE6AAsgAEEANgIUIABCgICAgBA3AgwgAEG0scAANgI4IABBAzoAMCAAQiA3AiggAEEANgIgIABBADYCGCAAIABBDGo2AjQCfyAAQRhqIQEgAEELai0AAEUEQCABQYSBwQBBDxCHAwwBCyABQZOBwQBBGRCHAwtFBEAgACgCDCEBIAAoAhAiBiAAKAIUEPoCIAEEQCAGIAFBARCxAwsgAEFAayQADAELQdyxwABBNyAAQT9qQcyxwABB4LLAABDCAQALNgIEQQELOgAAIAdBMGokACAKBEAgCyAKQQEQsQMLAn8gBC0ACEUEQCAEQcgAaiAEQSFqKQAANwIAIARBQGsgBEEZaikAADcCACAEQThqIARBEWopAAA3AgAgBCAEKQAJNwIwQQAhACAEQQA2AiwgBEEsahCLAkEIagwBC0EBIQAgBCgCDAshASAJIAA2AgggCSABQQAgABs2AgQgCUEAIAEgABs2AgAgBEHQAGokACAJKAIAIAkoAgQgCSgCCCAJQRBqJAALLQAgASgCHCACIAMgASgCICgCDBECACECIABBADoABSAAIAI6AAQgACABNgIACzIBAX8gASgCHEGEj8IAQQEgASgCICgCDBECACECIABBADoABSAAIAI6AAQgACABNgIA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IgEkACABQQhqIgYgABDYASABQRRqIQQCQCABKAIIIgUoAggiAEEATgRAIAUoAgQhByAARQRAQQEhBQwCC0HRssIALQAAGkEBIQMgAEEBEJwDIgUNAQsgAyAAQbjnwAAQ8wIACyAFIAcgABAsIQMgBCAANgIIIAQgAzYCBCAEIAA2AgAgBhCOAiABIARB0IHAABDNASABKAIEIQAgAiABKAIANgIAIAIgADYCBCABQSBqJAAgAigCACACKAIEIAJBEGokAAtkAQN/IwBBEGsiAiQAIwBBIGsiASQAIAFBCGoiAyAAENgBIAFBFGoiACABKAIIENYBIAMQjwIgASAAQYCFwAAQzQEgAiABKQMANwMAIAFBIGokACACKAIAIAIoAgQgAkEQaiQAC88BAQR/IwBBEGsiAiQAIwBBMGsiASQAIAFBIGoiAyAAENkBIAICfyABKAIgIgAoAiBBgICAgHhGBEAgAxCRAkEAIQBBAAwBCyABQRRqIABBIGoQ1gEgASgCFCEDIAFBIGoiBBCRAkEAIQBBACADQYCAgIB4Rg0AGiABQShqIAFBHGooAgA2AgAgASABKQIUNwMgIAFBCGogBEGMjcAAEM0BIAEoAgghACABKAIMCzYCBCACIAA2AgAgAUEwaiQAIAIoAgAgAigCBCACQRBqJAALywEBBH8jAEEQayICJAAjAEEwayIBJAAgAUEgaiIDIAAQ2QEgAgJ/IAEoAiAiACgCAEEBRwRAIAMQkQJBACEAQQAMAQsgAUEUaiAAQRBqENYBIAEoAhQhAyABQSBqIgQQkQJBACEAQQAgA0GAgICAeEYNABogAUEoaiABQRxqKAIANgIAIAEgASkCFDcDICABQQhqIARBjI3AABDNASABKAIIIQAgASgCDAs2AgQgAiAANgIAIAFBMGokACACKAIAIAIoAgQgAkEQaiQAC5wBAQN/IwBBEGsiASQAIwBBIGsiAiQAAkACQCAABEAgACgCACIDQX9GDQEgACADQQFqNgIAIAJBFGoiAyAAQQRqENYBIAAgACgCAEEBazYCACACQQhqIANBvJ7AABDNASACKAIMIQAgASACKAIINgIAIAEgADYCBCACQSBqJAAMAgsQ2wMACxDcAwALIAEoAgAgASgCBCABQRBqJAALKAAgASAAKAIALQAAQQJ0IgBBwInCAGooAgAgAEGs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QoCA/AeDQhiGIAVCgICA+A+DQgiGhIQgBUIIiEKAgID4D4MgBUIYiEKAgPwHg4QgBUIoiEKA/gODIAVCOIiEhIQ3A6AGIAJBmANqIA4gAkGIBmoQDSACLQCYAyEEIAItAJkDIQwgAi0AmgMhCyACLQCbAyENIAItAJwDIRAgAi0AnQMhESACLQCeAyEPIAItAJ8DIRIgAi0AoAMhEyACLQChAyEUIAItAKIDIRUgAi0AowMhFiACLQCkAyEXIAItAKUDIRggAi0ApgMhGSACLQCnAyEaIAItAKgDIRsgAi0AqQMhHCACLQCqAyEdIAItAKsDIR4gAi0ArAMhHyACLQCtAyEgIAItAK4DISEgAi0ArwMhIiACLQCwAyEjIAItALEDISQgAi0AsgMhJSACLQCzAyEmIAItALQDIScgAi0AtQMhKCACLQC2AyEpIABBAWoiKi0AACErIABBAmoiLC0AACEtIABBA2oiLi0AACEvIABBBGoiMC0AACExIABBBWoiMi0AACEzIABBBmoiNC0AACE1IABBB2oiNi0AACE3IABBCGoiOC0AACE5IABBCWoiOi0AACE7IABBCmoiPC0AACE9IABBC2oiPi0AACE/IABBDGoiQC0AACFBIABBDWoiQi0AACFDIABBDmoiRC0AACFFIABBD2oiRi0AACFHIABBEGoiSC0AACFJIABBEWoiSi0AACFLIABBEmoiTC0AACFNIABBE2oiTi0AACFPIABBFGoiUC0AACFRIABBFWoiUi0AACFTIABBFmoiVC0AACFVIABBF2oiVi0AACFXIABBGGoiWC0AACFZIABBGWoiWi0AACFbIABBGmoiXC0AACFdIABBG2oiXi0AACFfIABBHGoiYC0AACFhIABBHWoiYi0AACFjIABBHmoiZC0AACFlIAAtAAAhZiAAQR9qImcgZy0AACACLQC3A3M6AAAgZCApIGVzOgAAIGIgKCBjczoAACBgICcgYXM6AAAgXiAmIF9zOgAAIFwgJSBdczoAACBaICQgW3M6AAAgWCAjIFlzOgAAIFYgIiBXczoAACBUICEgVXM6AAAgUiAgIFNzOgAAIFAgHyBRczoAACBOIB4gT3M6AAAgTCAdIE1zOgAAIEogHCBLczoAACBIIBsgSXM6AAAgRiAaIEdzOgAAIEQgGSBFczoAACBCIBggQ3M6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2ZHCAGovAAA7AAALAkAgAkEKTwRAIABBAmsiACADQQxqaiACQQF0QdmRwgBqLwAAOwAADAELIABBAWsiACADQQxqaiACQTByOgAACyABQQFBAUEAIANBDGogAGpBFCAAaxAnIANBIGokAAsMACAAIAEgAiUBEAALDgAgAUGcg8AAQQUQhwMLDQAgAEHMnsAAIAEQOAsOACABQZigwABBBRCHAwsOACABQcCnwABBEBCHAwsOACABQfCywABBBRCHAwuPAQECfwJ/QZzdwAAhAkEWIQMCQAJAAkACQAJAAkACQCAAKAIALQAMIgBB/AFrDgQGAQIDAAsgAEEBaw4CBQQDCyABQbLdwABBGhCHAwwFCyABQczdwABBGRCHAwwECyABQeXdwABBEhCHAwwDCyABQQFBABCHAwwCC0H33cAAIQJBKCEDCyABIAIgAxCHAwsL5gEBAn8gACgCACECIwBBMGsiACQAAn8CQAJAAkAgAigCACIDQf//wwBrQQAgA0H+//8AcUGAgMQARhtBAWsOAgECAAsgACADNgIAIAAgAigCBDYCBCAAQQI2AgwgAEGog8EANgIIIABCAjcCFCAAIABBBGqtQoCAgIDADIQ3AyggACAArUKAgICA0AyENwMgIAAgAEEgajYCECABKAIcIAEoAiAgAEEIahA4DAILIAEoAhxBuIPBAEEUIAEoAiAoAgwRAgAMAQsgASgCHEHMg8EAQRUgASgCICgCDBECAAsgAEEwaiQACw0AIABBjODAACABEDgLDgAgAUHI4cAAQQUQhwMLDAAgACgCACABELQDCw4AIAFBs/fAAEEREIcDCwwAIAAoAgAgARCYAQsLACAAKAIAIAEQXwsLACAAKAIAIAEQUgsMACAAKAIAIAEQtQEL/gIBAn8gACgCACEDIwBBEGsiACQAIABBBGoiAiABEM8CIAAgAzYCDCACIABBDGoiAUHkg8EAEG4gACADQQFqNgIMIAIgAUHkg8EAEG4gACADQQJqNgIMIAIgAUHkg8EAEG4gACADQQNqNgIMIAIgAUHkg8EAEG4gACADQQRqNgIMIAIgAUHkg8EAEG4gACADQQVqNgIMIAIgAUHkg8EAEG4gACADQQZqNgIMIAIgAUHkg8EAEG4gACADQQdqNgIMIAIgAUHkg8EAEG4gACADQQhqNgIMIAIgAUHkg8EA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AAAAAgAAAAMAAAAEAEGAgsAAC+EcAQAAAAUAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAAA/ARAASwAAAI4KAAAOAAAARXJyb3IAAAA/ARAASwAAAI0FAAAbAAAAYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkTkNNRmlsZSBub3QgaW5pdGlhbGl6ZWQuL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjk5L3NyYy9jb252ZXJ0L3NsaWNlcy5ycwALAhAAZAAAAOgAAAABAAAACwIQAGQAAAAkAQAADgAAAAAAAAAEAAAABAAAAAYAAABIZWFkZXJNYWdpY0J5dGVzVVZGTmRYTnBZeUJGYm1OV01peExaWGs2eWVlbGlvbi1rdXdvLXRtZXllZWxpb24ta3V3bwAAAAABAABBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1f////////////////////////////////////////////////////////////Pv//NDU2Nzg5Ojs8Pf////////8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGf////8//xobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIz/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wEAAEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky//////////////////////////////////////////////////////////Pv///z80NTY3ODk6Ozw9/////////wABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZ////////GhscHR4fICEiIyQlJicoKSorLC0uLzAxMjP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////YXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkAAAAAQAAAAAAAAAvd29ya3NwYWNlL3VtL2xpYl91bV9jcnlwdG9fcnVzdC91bV9jcnlwdG8vcXRmbS9zcmMvc2VjcmV0LnJzAAAAuAUQAD0AAAAfAAAADwAAACYrKxIREhQKCAAIChQSERIvaF9fXy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3dhc20tYmluZGdlbi0wLjIuOTkvc3JjL2NvbnZlcnQvc2xpY2VzLnJzGAYQAGQAAADoAAAAAQAAABgGEABkAAAAJAEAAA4AAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAnAYQAEoAAAChAAAAGQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL2JveGVkLnJzAAD4BhAASgAAAJwCAAASAAAAL3dvcmtzcGFjZS91bS9saWJfdW1fY3J5cHRvX3J1c3QvdW1fY3J5cHRvL2t1d28vc3JjL2Rlcy9tb2QucnMAAFQHEAA+AAAAIwAAAA8AAABhdHRlbXB0ZWQgdG8gdGFrZSBvd25lcnNoaXAgb2YgUnVzdCB2YWx1ZSB3aGlsZSBpdCB3YXMgYm9ycm93ZWQvcnVzdGMvNGQ5MWRlNGU0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NWI1NTdmL3dhc20tYmluZGdlbi0wLjIuOTkvc3JjL2NvbnZlcnQvc2xpY2VzLnJzAMcOEABkAAAA6AAAAAEAAADHDhAAZAAAACQBAAAOAAAACQAAAAwAAAAEAAAACgAAAAsAAAAEAEHsnsAAC90KAQAAAAwAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAACrDxAASwAAAI4KAAAOAAAAAAAAAAQAAAAEAAAADQAAAEVycm9yAAAAqw8QAEsAAACNBQAAGwAAAFNRTGl0ZSBmb3JtYXQgMwAvd29ya3NwYWNlL3VtL2xpYl91bV9jcnlwdG9fcnVzdC91bV9jcnlwdG8va2dtL3NyYy9wY19kYl9kZWNyeXB0L21vZC5ycwBAEBAARwAAACYAAAAfAAAAQBAQAEcAAAAqAAAAJAAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGU6IGludmFsaWQgT25jZSBzdGF0ZagQEAA8AAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL29uY2Uvbm9fdGhyZWFkcy5ycwDsEBAAWwAAADUAAAASAAAALnAhYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkbWlkID4gbGVuAJoREAAJAAAAZmFpbGVkIHRvIGZpbGwgd2hvbGUgYnVmZmVyAKwREAAbAAAAJQAAAAAAAAACAAAAyBEQAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvc3RkL3NyYy9pby9jdXJzb3IucnPgERAATAAAAOwAAAAPAAAApAvINNaV8xMjI0MjVGOD8wAAAAAAAAAAAQAAAA4AAAAPAAAAEAAAAE9uY2UgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAZBIQACoAAABvbmUtdGltZSBpbml0aWFsaXphdGlvbiBtYXkgbm90IGJlIHBlcmZvcm1lZCByZWN1cnNpdmVseZgSEAA4AAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9zdGQvc3JjL3N5bmMvcG9pc29uL29uY2UucnMA2BIQAFMAAACeAAAAMgAAAGRlc2NyaXB0aW9uKCkgaXMgZGVwcmVjYXRlZDsgdXNlIERpc3BsYXkvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAZBMQAEoAAAChAAAAGQAAAFFNQ1YyTWFwS2V5RW1wdHkAAAAABAAAAAQAAAARAAAASW52YWxpZERlc0RhdGFTaXplAAAAAAAABAAAAAQAAAASAAAASW52YWxpZEhlYWRlck1hZ2ljVjJFS2V5UmVxdWlyZWRVbnN1cHBvcnRlZFZlcnNpb24AAAAAAAAEAAAABAAAABMAAAAAAAAABAAAAAQAAAANAAAASW52YWxpZEJ5dGVJbnZhbGlkTGVuZ3RoSW52YWxpZExhc3RTeW1ib2xJbnZhbGlkUGFkZGluZwAUAAAACAAAAAQAAAAVAAAAFAAAAAgAAAAEAAAAFgAAABUAAACQFBAAFwAAABgAAAAZAAAAGgAAABsAQdSpwAALBQEAAAAcAEHkqcAAC+UHAQAAAB0AAAAcAAAAzBQQAB4AAAAfAAAAIAAAACEAAAAiAAAAAAAAAAgAAAAEAAAAIwAAAAAAAAAIAAAABAAAACQAAAAjAAAACBUQACUAAAAmAAAAJwAAACUAAAAbAAAAAAAAABQAAAAEAAAAKAAAAAAAAAAUAAAABAAAACkAAAAoAAAARBUQACUAAAAqAAAAJwAAACsAAAAbAAAALAAAACQAAAAEAAAALQAAACwAAAAkAAAABAAAAC4AAAAtAAAAgBUQAC8AAAAwAAAAMQAAAC8AAAAyAAAAMwAAADAAAAAEAAAALQAAADMAAAAwAAAABAAAAC4AAAAtAAAAvBUQAC8AAAA0AAAAMQAAAC8AAAAyAAAANQAAACQAAAAEAAAALQAAADUAAAAkAAAABAAAAC4AAAAtAAAA+BUQAC8AAAA2AAAAMQAAAC8AAAAyAAAANwAAABwAAAAEAAAALQAAADcAAAAcAAAABAAAAC4AAAAtAAAANBYQAC8AAAA4AAAAMQAAAC8AAAAyAAAAOQAAADoAAAA7AAAAPAAAAD0AAAA+AAAAPwAAAEAAAABBAAAAQgAAAEMAAAA+AAAARAAAAEUAAABGAAAARwAAAEgAAAA+AAAASQAAAEoAAABLAAAATAAAAD0AAAA+AAAAOIXtknlf+EyzA2FBFqAdRx1aBTQMQY1CnIOSbK4W/lYvd29ya3NwYWNlL3VtL2xpYl91bV9jcnlwdG9fcnVzdC91bV9jcnlwdG8va2dtL3NyYy9oZWFkZXIucnPwFhAAPAAAAD8AAAAoAAAAL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjk5L3NyYy9jb252ZXJ0L3NsaWNlcy5yczwXEABkAAAA6AAAAAEAAAAvaF9fXy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2NvbnNvbGVfZXJyb3JfcGFuaWNfaG9vay0wLjEuNy9zcmMvbGliLnJzsBcQAGQAAACVAAAADgAAAGZhaWxlZCB0byBmaWxsIHdob2xlIGJ1ZmZlcgAkGBAAGwAAACUAAAAAAAAAAgAAAEAYEAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L3N0ZC9zcmMvaW8vbW9kLnJzAAAAWBgQAEkAAAA+AgAAHwAAAE0AAAAMAAAABAAAAE4AAABPAAAABABB1LHAAAvdDgEAAABQAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseS9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAExkQAEsAAACOCgAADgAAAEVycm9yAAAAExkQAEsAAACNBQAAGwAAAGNvdWxkIG5vdCBjb252ZXJ0IHNsaWNlIHRvIGFycmF5YXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkZmFpbGVkIHRvIGd1ZXNzIGtleS9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvY29yZS9zcmMvaXRlci90cmFpdHMvaXRlcmF0b3IucnMAAPoZEABYAAAAswcAAAkAAAAvaF9fXy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2hleC0wLjQuMy9zcmMvbGliLnJzAGQaEABPAAAAxwAAACUAAABkGhAATwAAAMcAAABBAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc9QaEABMAAAAKAIAABEAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL2l0ZXIucnMAADAbEABOAAAA9gUAABUAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAkBsQAEoAAAChAAAAGQAAADkxKSEZEQkBOzMrIxsTCwM9NS0lHRUNBT83LycfFw8HODAoIBgQCAA6MioiGhIKAjw0LCQcFAwEPjYuJh4WDgYnBy8PNxc/HyYGLg42Fj4eJQUtDTUVPR0kBCwMNBQ8HCMDKwszEzsbIgIqCjISOhohASkJMRE5GSAAKAgwEDgYDgAEDw0HAQQCDg8CCw0IAQMKCgYGDAwLBQkJBQADBwgEDwEMDggIAg0EBgkCAQsHDwUMCwkDBw4DCgoABQYADQ8DAQ0IBA4HBg8LAgMIBA8JDAcAAgENCgwGAAkFCwoFAA0OCAcKCwEKAwQPDQQBAgULCAYMBwYMCQADBQIODwkKDQAHCQAOCQYDAwQPBgUKAQINCAwFBw4LDAQLAg8IAQ0BBgoEDQkA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YW1JbnZhbGlkIG91dHB1dCBidWZmZXIgc2l6ZUFkbGVyMzIgY2hlY2tzdW0gbWlzbWF0Y2hJbnZhbGlkIGlucHV0IGRhdGFPdXRwdXQgc2l6ZSBleGNlZWRlZCB0aGUgc3BlY2lmaWVkIGxpbWl0L2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9taW5pel9veGlkZS0wLjguMC9zcmMvaW5mbGF0ZS9tb2QucnMAAB8vEABfAAAAvwAAABwAAABkZXN0IGlzIG91dCBvZiBib3VuZHMAAACQLxAAFQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnOwLxAATAAAACgCAAARAAAAUwAAAAwAAAAEAAAAVAAAAFUAAABWAEGs4MAAC8kWAQAAAFcAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAABrMBAASwAAAI4KAAAOAAAARXJyb3IAAABrMBAASwAAAI0FAAAbAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc+AwEABMAAAAKAIAABEAAAAKClN0YWNrOgoKL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjk5L3NyYy9jb252ZXJ0L3NsaWNlcy5ycwAARjEQAGQAAAAkAQAADgAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAAC8MRAASgAAAKEAAAAZAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5ycxgyEABYAAAAswcAAAkAAAB1bV9jcnlwdG8veG1seS9zcmMvcGMucnOAMhAAGAAAAFEAAAAfAAAAMTIzNDU2NzgxMjM0NTY3ODEyMzQ1Njc4gDIQABgAAABsAAAAGAAAAHhpbWFsYXlheGltYWxheWF4aW1hbGF5YXhpbWFsYXlhgDIQABgAAACHAAAALQAAAIAyEAAYAAAAkwAAAC0AAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzEDMQAEwAAAAoAgAAEQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAABsMxAASgAAAKEAAAAZAAAAL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9oZXgtMC40LjMvc3JjL2xpYi5ycwDIMxAATwAAAMcAAAAlAAAAyDMQAE8AAADHAAAAQQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvY29yZS9zcmMvaXRlci90cmFpdHMvaXRlcmF0b3IucnM4NBAAWAAAALMHAAAJAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pdGVyLnJzAACgNBAATgAAAPYFAAAVAAAARXhwZWN0ZWQgSUQzIG1ldGFkYXRhSUQzIE1ldGFkYXRhIHRvbyBzbWFsbCAocmVxdWlyZSAgYnl0ZXMpFTUQACAAAAA1NRAABwAAAEZhaWxlZCB0byBleHRyYWN0IGVuY3J5cHRlZCBhdWRpbyBzZWdtZW50IHNpemVGYWlsZWQgdG8gZXh0cmFjdCBTdGFnZSAxIElWIGRhdGFGYWlsZWQgdG8gZXh0cmFjdCBTdGFnZSAyIGRlY3J5cHRpb24ga2V5RmFpbGVkIHRvIGV4dHJhY3QgYXVkaW8gaGVhZGVyRGVjcnlwdGlvbiBzdGFnZSAxIGZhaWxlZCAocGFkZGluZylEZWNyeXB0aW9uIHN0YWdlIDEgZmFpbGVkIChiNjQgZGVjb2RlKURlY3J5cHRpb24gc3RhZ2UgMiBmYWlsZWQgKGluaXQpRGVjcnlwdGlvbiBzdGFnZSAyIGZhaWxlZCAocGFkZGluZylEZWNyeXB0aW9uIHN0YWdlIDIgZmFpbGVkIChiNjQgZGVjb2RlKU9uY2UgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAAJM2EAAqAAAAb25lLXRpbWUgaW5pdGlhbGl6YXRpb24gbWF5IG5vdCBiZSBwZXJmb3JtZWQgcmVjdXJzaXZlbHnINhAAOAAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvc3RkL3NyYy9zeW5jL3BvaXNvbi9vbmNlLnJzAAg3EABTAAAAngAAADIAAAAvaF9fXy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2Jhc2U2NC0wLjIyLjEvc3JjL2VuZ2luZS9tb2QucnMAAGw3EABaAAAA+gAAAB4AAABWZWMgaXMgc2l6ZWQgY29uc2VydmF0aXZlbHkA2DcQABsAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiAAAPw3EAAqAAAAbDcQAFoAAAABAQAAGQAAAC93b3Jrc3BhY2UvdW0vbGliX3VtX2NyeXB0b19ydXN0L3VtX2NyeXB0by91dGlscy9zcmMvYmFzZTY0LnJzAABAOBAAPgAAACcAAAAJAAAAAQAAQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL/////////////////////////////////////////////////////////8+////PzQ1Njc4OTo7PD3/////////AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBn///////8aGxwdHh8gISIjJCUmJygpKissLS4vMDEyM/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9jb3VsZCBub3QgZmluZCBpdGVtdW1fY3J5cHRvL3htbHkvc3JjL2FuZHJvaWQucnMA5jkQAB0AAAAXAAAADgAAAHhtbHl4bWx5eG1seXhtbHl4bWx5eG1seXhtbHl4bWx5Mzk4OWQxMTFhYWQ1NjEzOTQwZjRmYzQ0YjYzOWIyOTLmORAAHQAAADIAAAAQAAAAL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9sYXp5X3N0YXRpYy0xLjUuMC9zcmMvaW5saW5lX2xhenkucnMAZDoQAF8AAAAeAAAAEAAAAGhlYWRlciB0b28gc21hbGwsIHJlcXVpcmUgYXQgbGVhc3QgIGJ5dGVzAAAA1DoQACMAAAD3OhAABgAAAG5vdCBhIHhpYW1pIGZpbGUvaF9fXy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2NpcGhlci0wLjQuNC9zcmMvc3RyZWFtLnJzAEGA98AAC9sLAQAAAFsAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlU3RyZWFtQ2lwaGVyRXJyb3IgOxAAVQAAAHgAAAAnAAAARmFpbGVkIHRvIGRlY29kZSBmaWxlIG5hbWUuRmlsZSBuYW1lIGRvZXMgbm90IHN0YXJ0IHdpdGgga25vd24gcHJlZml4LkhlYWRlciBuZWVkIGF0IGxlYXN0ICBtb3JlIGJ5dGVzAAAaPBAAFQAAAC88EAALAAAARmlsZSBJL08gRXJyb3I6IEw8EAAQAAAARmlsZSBJL08gRXJyb3I6IFJlYWQgMCBieXRlc05vdCBhIE5DTSBmaWxlSW52YWxpZCBOQ00gY2hlY2tzdW0uIEV4cGVjdGVkICwgYWN0dWFsOiAAjjwQAB8AAACtPBAACgAAAFVuc3VwcG9ydGVkIGNvdmVyIGltYWdlIHZlcnNpb246IAAAAMg8EAAhAAAAQ292ZXIgaW1hZ2U6IEZyYW1lIHNpemUgaXMgbGVzcyB0aGFuIGltYWdlIDEuIGZyYW1lX3NpemU6LCBpbWFnZTFfc2l6ZToA9DwQADkAAAAtPRAADgAAAENvbnRlbnRLZXk6IEFFUyBQS0NTIzcgRGVjb2RlIEVycm9yQ29udGVudEtleTogSW52YWxpZCBrZXkgcHJlZml4OiAAbz0QACAAAABNZXRhZGF0YTogSW52YWxpZCBwcmVmaXggd2hpbGUgZGVjb2Rpbmc6IAAAAJg9EAApAAAATWV0YWRhdGE6IEFFUyBQS0NTIzcgRGVjb2RlIEVycm9yTWV0YWRhdGE6IERlY29kZSBtZXRhZGF0YSBmYWlsZWQ6IADtPRAAIgAAAE1ldGFkYXRhOiBJbnZhbGlkIHByZWZpeCBvbiBmaW5hbCBqc29uOiAYPhAAKAAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzAABIPhAASgAAAKEAAAAZAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5yc6Q+EABYAAAAswcAAAkAAABoekhSQW1zbzVrSW5iYXhXbmV0ZWFzZWNsb3VkbXVzaWMAAAABI0VniavN7/7cuph2VDIQMDEyMzQ1Njc4OUFCQ0RFRgAAAAAAAAAAAQAAAGIAAABjYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9zdGQvc3JjL3RocmVhZC9sb2NhbC5ycwAAAKY/EABPAAAAEAEAABoAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMACEAQAEsAAACNBQAAGwAAAEFDODlFQzQ3QTcwQjc2RjMwN0NCMzlBMEQ3NEJDQ0IwSW52YWxpZCBGaWxlS2V5Q29udmVydCBoYXNoIHRvIGtleSBlcnJvci9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnOsQBAATAAAACgCAAARAAAAdW1fY3J5cHRvL21nM2Qvc3JjL2d1ZXNzX200YS5ycwAAAAAAZnR5cE00QSAAAAAATTRBIG1wNDJpc29tAAAAAGMAAAAAAAAA//////////9QQRAAQeiCwQALlQwIQRAAHwAAADoAAABAAAAACEEQAB8AAAA8AAAAQAAAAEludmFsaWQgY2hhcmFjdGVyICBhdCBwb3NpdGlvbiAAiEEQABIAAACaQRAADQAAAE9kZCBudW1iZXIgb2YgZGlnaXRzSW52YWxpZCBzdHJpbmcgbGVuZ3RoAAAAAAAAAAQAAAAEAAAAaQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnP0QRAATAAAACgCAAARAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogaW52YWxpZCBPbmNlIHN0YXRlUEIQADwAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L3N0ZC9zcmMvc3lzL3N5bmMvb25jZS9ub190aHJlYWRzLnJzAJRCEABbAAAANQAAABIAAAAgAAAAAQAAAAAAAAAAQxAAAQAAAAAAAAAEAAAABAAAAGoAAABIZWFkZXJNYWdpY0J5dGVzSW52YWxpZCBERVMgZGF0YSBzaXplIChleHBlY3RlZDogIG1vZCA4ID09IDApAAAANEMQACEAAABVQxAADAAAAEludmFsaWQgS1dNIGhlYWRlciBtYWdpYyBieXRlczogdEMQACAAAABLV012MjogRUtleSByZXF1aXJlZEtXTTogVW5zdXBwb3J0ZWQgdmVyc2lvbiAAAACwQxAAGQAAAGRlc2NyaXB0aW9uKCkgaXMgZGVwcmVjYXRlZDsgdXNlIERpc3BsYXkvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMA/EMQAEsAAACNBQAAGwAAAAAAAAAUAAAABAAAACgAAAAAAAAAFAAAAAQAAABrAAAAKAAAAFhEEABsAAAAbQAAAG4AAABvAAAAcAAAAHEAAAAwAAAABAAAAHIAAABxAAAAMAAAAAQAAABzAAAAcgAAAJREEAB0AAAAdQAAAHYAAAB0AAAAdwAAAHgAAAB5AAAAegAAAHsAAAB8AAAAfQAAAH4AAAAMAAAABAAAAH8AAACAAAAAgQAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAAAgAAAAAAAAAAAAQAAAAAAAAACAAAAAAAAAAQAAAAAAAAACAAAAAAAAAAQAAAAAAAAACAAAAAAAAAAQAAAAAAAAACAAAAAAAAAAAABAAAAAAAAAAIAAAAAAAAABAAAAAAAAAAIAAAAAAAAABAAAAAAAAAAIAAAAAAAAABAAAAAAAAAAIAAAAAAAAAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAAAgAAAAAAAAAAAAQAAAAAAAAACAAAAAAAAAAQAAAAAAAAACAAAAAAAAAAQAAAAAAAAACAAAAAAAAAAQAAAAAAAAACAAAAAAAAAAAABAAAAAAAAAAIAAAAAAAAABAAAAAAAAAAIAAAAAAAAABAAAAAAAAAAIAAAAAAAAABAAAAAAAAAAIAAAAAAAAAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAAAgAAAAAAAAAEAAAAAAAAAAgAAAAAAAAAAAAQAAAAAAAAACAAAAAAAAAAQAAAAAAAAACAAAAAAAAAAQAAAAAAAAACAAAAAAAAAAQAAAAAAAAACAAAAAAAQAAAAEAAAAggAAAEludmFsaWREZXNEYXRhU2l6ZQAAAAAAAAQAAAAEAAAAgwAAAEludmFsaWRIZWFkZXJNYWdpY1YyRUtleVJlcXVpcmVkVW5zdXBwb3J0ZWRWZXJzaW9uAACEAAAADAAAAAQAAACFAAAAhgAAAIEAQYiPwQAL1Q4BAAAAhwAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAAMdHEABLAAAAjgoAAA4AAABFcnJvcgAAAMdHEABLAAAAjQUAABsAAAA4MCggGBAIADkxKSEZEQkBOjIqIhoSCgI7MysjPjYuJh4WDgY9NS0lHRUNBTw0LCQcFAwEGxMLAwEBAgICAgICAQICAgICAgEAAAAAAQAQAAAAAAABABAAAAAAAAMAMAAAAAAAAwAwAAAAAAADADAAAAAAAAMAMAAAAAAAAwAwAAAAAAADADAAAAAAAAEAEAAAAAAAAwAwAAAAAAADADAAAAAAAAMAMAAAAAAAAwAwAAAAAAADADAAAAAAAAMAMAAAAAAAAQAQAAAAAAANEAoXAAT//wIbDgUUCf//FhILAxkH//8PBhoTDAH//ygzHiQuNv//HScyLCAv//8rMCY3ITT//y0pMSMcH///HwABAgME//8DBAUGBwj//wcICQoLDP//CwwNDg8Q//8PEBESExT//xMUFRYXGP//FxgZGhsc//8bHB0eHx7//w0HCgAGCQUPCAQDCgsODAUCCwkGDwwAAwQBDg0BAgcIAQIMDwoEAAMNDgYJBwgJBg8BBQwDCg4FCAcLAAQNAgsEAQMKDwwFAAILCQYIBwYJCwQMDwADCgUODQcIDQ4BAg0GDgkEAQIOCw0FAAEKCAMACwMFCQQPAgcIDA8KBwYMDAkABwkCDgEKDwMEBgwFCwEODQACCAcNDwUECggDCwYKBAYLBwkABgQCDQEJDwMIDwMBDgwFCwACDA4HBQoIDQIECA8HCg0GBAEDDAsHDgAMAgUJCg0AAwELDwUGCAkODgsFBgQBAwoCDA8ADQIIBQsIAA8HDgkEDAcKCQENBgMHCgEPAAwLBQ4JCAMJBwQIDQYCAQYLDAIDAAUOCg0PBA0DBAkGCgEMCwACBQANDgIIDwcEDwEKBwUGDAsDCAkOCg0BCwYICwUJBAwCDwMCDgAGDQEDDwQKDgkHDAUACAcNAQIEAwYMCwANBQ4GCA8CBwoIDwQJCwUJAA4DCgcBDA8ACQUGCgwJCAcCDAMNBQIBDgcICwQAAw4LDQYEAQoPAw0MCw8DBgAECgEHCAQLDg0IAAYCDwkFBwEKDA4CBQkOBAMPAg0FAw0OBgkLAgAFBAEKDA8GCQoBCAwHCAsHAAAPCgUOBAkKBwgMAw0BAwYPDAYLAgkFAAQCCw4BBwgNDwYTFBwLGxAADhYZBBEeCQEHFw0fGgIIEgwdBRUKAxh1bV9jcnlwdG8va3V3by9zcmMvZGVzL2NvcmUucnMAAKhLEAAeAAAANAAAABwAAAA5MSkhGREJATszKyMbEwsDPTUtJR0VDQU/Ny8nHxcPBzgwKCAYEAgAOjIqIhoSCgI8NCwkHBQMBD42LiYeFg4GJwcvDzcXPx8mBi4ONhY+HiUFLQ01FT0dJAQsDDQUPBwjAysLMxM7GyICKgoyEjoaIQEpCTERORkgACgIMBA4GAEjRWeJq83v/ty6mHZUMhAdYTFFske/fz0YlnIUT+S/AAAAAHNBbFQBI0VniavN7/7cuph2VDIQL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAJBMEABLAAAAjQUAABsAAACOAAAADAAAAAQAAACPAAAAkAAAAJEAAABIZWFkZXIgdG9vIHNtYWxsLCBuZWVkIGF0IGxlYXN0ICBieXRlcy4ABE0QACAAAAAkTRAABwAAAFVuc3VwcG9ydGVkIGtleSBzbG90OiAAADxNEAAWAAAAVW5zdXBwb3J0ZWQgY2lwaGVyIHZlcnNpb246IFxNEAAcAAAAVjUgcmVxdWlyZXMgZWtleS5Ob3QgS0dNIEZpbGUgKG1hZ2ljIG1pc21hdGNoKVVuc3VwcG9ydGVkIGNpcGhlciAoc2VsZi10ZXN0IGZhaWxlZClGYWlsZWQgZGVjcnlwdCBrdWdvdSBkYiBkYXRhOiAAAADTTRAAHgAAAEludmFsaWQgZGF0YWJhc2Ugc2l6ZTogAPxNEAAXAAAARmFpbGVkIHRvIGRlY3J5cHQgcGFnZSAxIChpbnZhbGlkIGhlYWRlcilEYXRhYmFzZSBkb2VzIG5vdCBzZWVtIHZhbGlkUU1DMkVLZXlFcnJvcjogYU4QAA8AAABQYXJzZSBLR00gaGVhZGVyIHdpdGggaS9vIGVycm9yOiAAAAB4ThAAIQAAAEludmFsaWQgYXVkaW8gaGFzaCBzaXplOiAAAACkThAAGQAAAJIAAAAMAAAABAAAAJMAAACUAAAAkQBB6J3BAAvVAgEAAACVAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseS9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAJ08QAEsAAACOCgAADgAAAEVycm9yAAAAJ08QAEsAAACNBQAAGwAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnOcTxAATAAAACgCAAARAAAAZGVzY3JpcHRpb24oKSBpcyBkZXByZWNhdGVkOyB1c2UgRGlzcGxheVFNQ1YyTWFwS2V5RW1wdHkAAAAAAAAAAAEAAAAcAEHIoMEAC60qAQAAAJYAAAAcAAAAMFAQAJcAAACYAAAAmQAAAJoAAACbAAAAnAAAABwAAAAEAAAAnQAAAJwAAAAcAAAABAAAAJ4AAACdAAAAbFAQAJ8AAACgAAAAoQAAAJ8AAACiAAAAowAAAKQAAAClAAAApgAAAKcAAACoAAAAVVZGTmRYTnBZeUJGYm1OV01peExaWGs2aW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogaW52YWxpZCBPbmNlIHN0YXRl2FAQADwAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L3N0ZC9zcmMvc3lzL3N5bmMvb25jZS9ub190aHJlYWRzLnJzABxREABbAAAANQAAABIAAAB1bV9jcnlwdG8va2dtL3NyYy9wY19kYl9kZWNyeXB0L21vZC5ycwAAiFEQACYAAAALAAAAIwAAAIhREAAmAAAADAAAACMAAABTUUxpdGUgZm9ybWF0IDMAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc+BREABMAAAAKAIAABEAAABjYXBhY2l0eSBvdmVyZmxvdwAAADxSEAARAAAAdW1fY3J5cHRvL3FtYy9zcmMvZm9vdGVyL3V0aWxzLnJzAAAAWFIQACEAAAANAAAAHQAAAFhSEAAhAAAADQAAAEUAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAnFIQAEoAAAChAAAAGQAAAAAAAAAEAAAABAAAAKsAAABLZXlUb29TaG9ydEludmFsaWREYXRhU2l6ZQAAAAAAAAQAAAAEAAAArAAAAERlY3J5cHRCdWZmZXJUb29TbWFsbEVuY3J5cHRCdWZmZXJUb29TbWFsbEludmFsaWRQYWRkaW5nU2xpY2VFcnJvcgAAnFIQAEoAAAAIAwAAGgAAAC9oX19fLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5naW5lL21vZC5ycwAAiFMQAFoAAAD6AAAAHgAAAFZlYyBpcyBzaXplZCBjb25zZXJ2YXRpdmVseQD0UxAAGwAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGU6IAAAGFQQACoAAACIUxAAWgAAAAEBAAAZAAAAL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi90Y190ZWEtMC4yLjEvc3JjL2xpYi5ycwAAXFQQAFIAAAB0AAAAFQAAAG1pZCA+IGxlbgAAAMBUEAAJAAAAdW1fY3J5cHRvL3FtYy9zcmMvZWtleS5ycwAAANRUEAAZAAAAMwAAACEAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2NvcmUvc3JjL2l0ZXIvdHJhaXRzL2l0ZXJhdG9yLnJzAFUQAFgAAACzBwAACQAAADM4NlpKWSFAIyokJV4mKSgqKiMhKCMkJSZeYTFjWixUL2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9sYXp5X3N0YXRpYy0xLjUuMC9zcmMvaW5saW5lX2xhenkucnMAiFUQAF8AAAAeAAAAEAAAAEVLZXkgaXMgdG9vIHNob3J0IGZvciBkZWNyeXB0aW9uRXJyb3Igd2hlbiBkZWNyeXB0aW5nIGVrZXkgdjE6IAAYVhAAHwAAAEVycm9yIHdoZW4gZGVjcnlwdGluZyBla2V5IHYyOiAAQFYQAB8AAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9ib3hlZC9jb252ZXJ0LnJzAABoVhAAUgAAAFIAAAATAAAAdW1fY3J5cHRvL3FtYy9zcmMvdjJfcmM0L2NpcGhlci5ycwAAzFYQACIAAAAiAAAAPwAAAMxWEAAiAAAAJAAAABcAAADMVhAAIgAAAC4AAAAdAAAAT25jZSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkAAAgVxAAKgAAAG9uZS10aW1lIGluaXRpYWxpemF0aW9uIG1heSBub3QgYmUgcGVyZm9ybWVkIHJlY3Vyc2l2ZWx5VFcQADgAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L3N0ZC9zcmMvc3luYy9wb2lzb24vb25jZS5ycwCUVxAAUwAAAJ4AAAAyAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9zdHIvcGF0dGVybi5ycwD4VxAATwAAAM0BAAA3AAAAw0rWypBn91LYoWZin1sJAMNelSOfExF+2JI/vJC7dA7DR3Q9kKo/Udj0EYSf3pUdw8YJ1Z/6ZvnY8PegkKHW88Pz1qGQoPfw2Plm+p/VCcbDHZXen4QR9NhRP6qQPXRHww50u5C8P5LYfhETnyOVXsMACVufYmah2FL3Z5DK1kp1bV9jcnlwdG8vcW1jL3NyYy92Ml9yYzQvcmM0LnJzANhYEAAfAAAAEQAAAA8AAADYWBAAHwAAACIAAAApAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5ycxhZEABYAAAAswcAAAkAAABkZXNjcmlwdGlvbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBEaXNwbGF5L3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAAKhZEABKAAAAoQAAABkAAAAAAAAABAAAAAQAAACtAAAAAAAAAAQAAAAEAAAArgAAAEludmFsaWRCeXRlAAAAAAAEAAAABAAAAKsAAABJbnZhbGlkTGVuZ3RoSW52YWxpZExhc3RTeW1ib2xJbnZhbGlkUGFkZGluZwAAAAAQAAAABAAAAK8AAAAAAAAAEAAAAAQAAACwAAAArwAAAGxaEACxAAAAsgAAALMAAAC0AAAAtQAAAAAAAAAIAAAABAAAACMAAAAAAAAACAAAAAQAAAC2AAAAIwAAAKhaEACxAAAAtwAAALMAAAC4AAAAtQAAALkAAAAkAAAABAAAALoAAAC5AAAAJAAAAAQAAAC7AAAAugAAAORaEAC8AAAAvQAAAL4AAAC8AAAAvwAAAMAAAAAsAAAABAAAALoAAADAAAAALAAAAAQAAAC7AAAAugAAACBbEAC8AAAAwQAAAL4AAAC8AAAAvwAAAMIAAADDAAAAxAAAAMUAAADGAAAAxwAAAMgAAADJAAAAygAAAMsAAADMAAAAxwAAAEVLZXlUb29TaG9ydAAAAAAEAAAABAAAAM0AAABGYWlsRGVjcnlwdFYxRmFpbERlY3J5cHRWMi9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzwlsQAEoAAAChAAAAGQAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMAHFwQAE8AAADNAQAANwAAAG1pZCA+IGxlbgAAAHxcEAAJAAAAdW1fY3J5cHRvL3FtYy9zcmMvZm9vdGVyL211c2ljZXhfdjEucnMAAJBcEAAmAAAAOAAAACkAAACQXBAAJgAAAEAAAAAbAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9pdGVyL3RyYWl0cy9pdGVyYXRvci5yc9hcEABYAAAAswcAAAkAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiBpbnZhbGlkIE9uY2Ugc3RhdGVAXRAAPAAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvc3RkL3NyYy9zeXMvc3luYy9vbmNlL25vX3RocmVhZHMucnMAhF0QAFsAAAA1AAAAEgAAAAEAAEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky//////////////////////////////////////////////////////////Pv///z80NTY3ODk6Ozw9/////////wABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZ////////GhscHR4fICEiIyQlJicoKSorLC0uLzAxMjP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////Rm9vdGVyOiBCdWZmZXIgdG9vIHNtYWxsLCByZXF1aXJlIGF0IGxlYXN0ICBieXRlczNfEAArAAAAXl8QAAYAAABQQ3YxL0VLZXk6IEJ1ZmZlciB0b28gbGFyZ2UsIG1pZ2h0IG5vdCBiZSB2YWxpZCBFS2V5IChsZW49KQB0XxAAOgAAAK5fEAABAAAAUEN2MS9FS2V5OiBGb3VuZCBpbnZhbGlkIEVLZXkgY2hhclBDdjIvTXVzaWNFeDogSW52YWxpZCBtZXRhZGF0YSB2ZXJzaW9uIAAAAOJfEAAnAAAAUEN2Mi9NdXNpY0V4OiBJbnZhbGlkIGBNdXNpY0V4YCBzaXplOiAAABRgEAAmAAAAUEN2Mi9NdXNpY0V4OiBJbnZhbGlkIGBNdXNpY0V4YCBkYXRhOiAAAERgEAAmAAAAQW5kcm9pZC9TVGFnOiBJbnZhbGlkIElEIGZpZWxkOiB0YBAAIAAAAEFuZHJvaWQvU1RhZzogSW52YWxpZCBWZXJzaW9uOiAAnGAQAB8AAABBbmRyb2lkL1NUYWc6IEludmFsaWQgQ1NWIG1ldGFkYXRhOiDEYBAAJAAAAEFuZHJvaWQvUVRhZzogSW52YWxpZCBJRCBmaWVsZDog8GAQACAAAABBbmRyb2lkL1FUYWc6IEludmFsaWQgVmVyc2lvbjogABhhEAAfAAAAQW5kcm9pZC9RVGFnOiBJbnZhbGlkIEVLZXkgZmllbGQ6IAAAQGEQACIAAABQYXJzZTogRmFpbGVkIHRvIHBhcnNlIHN0cmluZyAnJyBhcyBpbnRlZ2VyAGxhEAAfAAAAi2EQAAwAAABRTUMgVjIvTWFwIENpcGhlcjogS2V5IGlzIGVtcHR5L2hfX18vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi90Y190ZWEtMC4yLjEvc3JjL2NiYy5ycwAAAMdhEABSAAAAjwAAAA4AAABLZXkgc2l6ZSBtaXNtYXRjaC4gUmVxdWlyZWQgMTYgYnl0ZXMsIGdvdCAgYnl0ZXMsYhAAKgAAAFZiEAAGAAAAQ2lwaGVyIHRleHQgc2l6ZSBpbnZhbGlkLiAgbW9kIDggIT0gMC4AAGxiEAAaAAAAhmIQAAwAAABEZWNyeXB0IGJ1ZmZlciBzaXplIHRvbyBzbWFsbCwgaXQgc2hvdWxkIGJlIGF0IGxlYXN0ICBieXRlcyAoYWN0dWFsPSBieXRlcykupGIQADUAAADZYhAADwAAAOhiEAAIAAAARW5jcnlwdCBidWZmZXIgc2l6ZSB0b28gc21hbGwsIGl0IHNob3VsZCBiZSBhdCBsZWFzdCAAAAAIYxAANQAAANliEAAPAAAA6GIQAAgAAABJbnZhbGlkIGRhdGEgcGFkZGluZ1NsaWNlIGVycm9yLi9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvY29yZS9zcmMvcHRyL21vZC5ycwB4YxAASwAAAAsCAAABAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwDUYxAATwAAAEwDAAA0AAAA1GMQAE8AAABTAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAG5kEABLAAAAxAcAAB0AAABuZBAASwAAAMwHAAAdAAAAbmQQAEsAAACNBQAAGwAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnPsZBAATAAAACgCAAARAAAA0wAAAAwAAAAEAAAA1AAAANUAAADWAAAA2QAAAAwAAAAEAAAA2gAAANsAAADWAEGAy8EAC403AQAAANwAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAAC/ZRAASwAAAI4KAAAOAAAARXJyb3IAAAC/ZRAASwAAAI0FAAAbAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5pc19jaGFyX2JvdW5kYXJ5KG5ld19sZW4pv2UQAEsAAADABQAADQAAAAAAAAAQAAAABAAAAN0AAADeAAAA3wAAAGJhY2t0cmFjZSBjYXB0dXJlIGZhaWxlZC9oX19fLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYW55aG93LTEuMC45NC9zcmMvZXJyb3IucnMAAACkZhAA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VEFHSUQzdW1fYXVkaW8vc3JjL21ldGFkYXRhLnJzAAAObhAAGAAAADEAAAA5AAAADm4QABgAAAAhAAAAGQAAAG9nZ2FhY21wM200YW00Ym1wNHdtYW1rYWZsYWNkZmZ3YXZhcGViaW4BAAAAAAAAAHVtX2F1ZGlvL3NyYy9saWIucnMAeG4QABMAAABeAAAAIgAAAHhuEAATAAAAcQAAAA8AAAB4bhAAEwAAAHMAAAAmAAAAeG4QABMAAABcAAAAGQAAAG51bGwgcG9pbnRlciBwYXNzZWQgdG8gcnVzdHJlY3Vyc2l2ZSB1c2Ugb2YgYW4gb2JqZWN0IGRldGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQgdG8gdW5zYWZlIGFsaWFzaW5nIGluIHJ1c3RsaWJyYXJ5L3N0ZC9zcmMvcGFuaWNraW5nLnJzAAAAAAAABAAAAAQAAADuAAAAL3J1c3RjLzRkOTFkZTRlNDgxOThkYTJlMzM0MTNlZmRjZDljZDJjYzBjNDY2ODgvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAAGRvEABKAAAAoQAAABkAAAAvcnVzdGMvNGQ5MWRlNGU0ODE5OGRhMmUzMzQxM2VmZGNkOWNkMmNjMGM0NjY4OC9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAwG8QAEsAAACNBQAAGwAAAC9ydXN0Yy80ZDkxZGU0ZTQ4MTk4ZGEyZTMzNDEzZWZkY2Q5Y2QyY2MwYzQ2Njg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnMccBAATAAAACgCAAARAAAAOgAAAAEAAAAAAAAAeHAQAAEAAAB4cBAAAQAAAO8AAAAMAAAABAAAAPAAAADxAAAA8gAAAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjcvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZACscBAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAArHAQACkAAACuBAAADQAAAEFjY2Vzc0Vycm9ybGlicmFyeS9zdGQvc3JjL2JhY2t0cmFjZS5yc29wZXJhdGlvbiBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgcGxhdGZvcm0Ae3EQACgAAAAkAAAAAgAAAKRxEAB1bnN1cHBvcnRlZCBiYWNrdHJhY2VkaXNhYmxlZCBiYWNrdHJhY2UAX3EQABwAAACKAQAAHQAAAPMAAAAQAAAABAAAAPQAAAD1AAAAAQAAAAAAAABlbnRpdHkgbm90IGZvdW5kcGVybWlzc2lvbiBkZW5pZWRjb25uZWN0aW9uIHJlZnVzZWRjb25uZWN0aW9uIHJlc2V0aG9zdCB1bnJlYWNoYWJsZW5ldHdvcmsgdW5yZWFjaGFibGVjb25uZWN0aW9uIGFib3J0ZWRub3QgY29ubmVjdGVkYWRkcmVzcyBpbiB1c2VhZGRyZXNzIG5vdCBhdmFpbGFibGVuZXR3b3JrIGRvd25icm9rZW4gcGlwZWVudGl0eSBhbHJlYWR5IGV4aXN0c29wZXJhdGlvbiB3b3VsZCBibG9ja25vdCBhIGRpcmVjdG9yeWlzIGEgZGlyZWN0b3J5ZGlyZWN0b3J5IG5vdCBlbXB0eXJlYWQtb25seSBmaWxlc3lzdGVtIG9yIHN0b3JhZ2UgbWVkaXVtZmlsZXN5c3RlbSBsb29wIG9yIGluZGlyZWN0aW9uIGxpbWl0IChlLmcuIHN5bWxpbmsgbG9vcClzdGFsZSBuZXR3b3JrIGZpbGUgaGFuZGxlaW52YWxpZCBpbnB1dCBwYXJhbWV0ZXJpbnZhbGlkIGRhdGF0aW1lZCBvdXR3cml0ZSB6ZXJvbm8gc3RvcmFnZSBzcGFjZXNlZWsgb24gdW5zZWVrYWJsZSBmaWxlcXVvdGEgZXhjZWVkZWRmaWxlIHRvbyBsYXJnZXJlc291cmNlIGJ1c3lleGVjdXRhYmxlIGZpbGUgYnVzeWRlYWRsb2NrY3Jvc3MtZGV2aWNlIGxpbmsgb3IgcmVuYW1ldG9vIG1hbnkgbGlua3NpbnZhbGlkIGZpbGVuYW1lYXJndW1lbnQgbGlzdCB0b28gbG9uZ29wZXJhdGlvbiBpbnRlcnJ1cHRlZHVuc3VwcG9ydGVkdW5leHBlY3RlZCBlbmQgb2YgZmlsZW91dCBvZiBtZW1vcnlpbiBwcm9ncmVzc290aGVyIGVycm9ydW5jYXRlZ29yaXplZCBlcnJvck9zAAAAAAAEAAAABAAAAPYAAABjb2RlAAAAAAEAAAABAAAA9wAAAGtpbmTvAAAADAAAAAQAAAD4AAAAbWVzc2FnZUtpbmRFcnJvcgAAAAAIAAAABAAAAPkAAAAAAAAABAAAAAQAAAD6AAAAQ3VzdG9tZXJyb3IgKG9zIGVycm9yICkAAQAAAAAAAABvdRAACwAAAHp1EAABAAAAOiBwYW5pY2tlZCBhdCA6CmNhbm5vdCByZWN1cnNpdmVseSBhY3F1aXJlIG11dGV4pHUQACAAAABsaWJyYXJ5L3N0ZC9zcmMvc3lzL3N5bmMvbXV0ZXgvbm9fdGhyZWFkcy5yc8x1EAAsAAAAEwAAAAkAAABsaWJyYXJ5L3N0ZC9zcmMvc3luYy9wb2lzb24vb25jZS5ycwAIdhAAIwAAAJ4AAAAyAAAAbGlicmFyeS9zdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzAAAAPHYQACEAAADRAAAAEwAAADx1bmtub3duPu+/vW1lbW9yeSBhbGxvY2F0aW9uIG9mICBieXRlcyBmYWlsZWQAAHx2EAAVAAAAkXYQAA0AAABsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnOwdhAAGAAAAGMBAAAJAAAAY2Fubm90IG1vZGlmeSB0aGUgcGFuaWMgaG9vayBmcm9tIGEgcGFuaWNraW5nIHRocmVhZNh2EAA0AAAANm8QABwAAACOAAAACQAAAAoAAADvAAAADAAAAAQAAAD7AAAAAAAAAAgAAAAEAAAA/AAAAAAAAAAIAAAABAAAAP0AAAD+AAAA/wAAAAABAAABAQAAEAAAAAQAAAACAQAAAwEAAAQBAAAFAQAAbGlicmFyeS9zdGQvc3JjLy4uLy4uL2JhY2t0cmFjZS9zcmMvc3ltYm9saXplL21vZC5yc4B3EAA0AAAAZwEAADAAAAABAAAAAAAAAJR1EAACAAAAIC0gAAEAAAAAAAAA1HcQAAMAAAAgICAgICAgICAgICAgICAgICAgYXQgAAB4cBAAAQAAAE5vdEZvdW5kUGVybWlzc2lvbkRlbmllZENvbm5lY3Rpb25SZWZ1c2VkQ29ubmVjdGlvblJlc2V0SG9zdFVucmVhY2hhYmxlTmV0d29ya1VucmVhY2hhYmxlQ29ubmVjdGlvbkFib3J0ZWROb3RDb25uZWN0ZWRBZGRySW5Vc2VBZGRyTm90QXZhaWxhYmxlTmV0d29ya0Rvd25Ccm9rZW5QaXBlQWxyZWFkeUV4aXN0c1dvdWxkQmxvY2tOb3RBRGlyZWN0b3J5SXNBRGlyZWN0b3J5RGlyZWN0b3J5Tm90RW1wdHlSZWFkT25seUZpbGVzeXN0ZW1GaWxlc3lzdGVtTG9vcFN0YWxlTmV0d29ya0ZpbGVIYW5kbGVJbnZhbGlkSW5wdXRJbnZhbGlkRGF0YVRpbWVkT3V0V3JpdGVaZXJvU3RvcmFnZUZ1bGxOb3RTZWVrYWJsZVF1b3RhRXhjZWVkZWRGaWxlVG9vTGFyZ2VSZXNvdXJjZUJ1c3lFeGVjdXRhYmxlRmlsZUJ1c3lEZWFkbG9ja0Nyb3NzZXNEZXZpY2VzVG9vTWFueUxpbmtzSW52YWxpZEZpbGVuYW1lQXJndW1lbnRMaXN0VG9vTG9uZ0ludGVycnVwdGVkVW5zdXBwb3J0ZWRVbmV4cGVjdGVkRW9mT3V0T2ZNZW1vcnlJblByb2dyZXNzT3RoZXJVbmNhdGVnb3JpemVkb3BlcmF0aW9uIHN1Y2Nlc3NmdWxPbmNlIGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQ6ehAAKgAAAG9uZS10aW1lIGluaXRpYWxpemF0aW9uIG1heSBub3QgYmUgcGVyZm9ybWVkIHJlY3Vyc2l2ZWx5bHoQADgAAAAQAAAAEQAAABIAAAAQAAAAEAAAABMAAAASAAAADQAAAA4AAAAVAAAADAAAAAsAAAAVAAAAFQAAAA8AAAAOAAAAEwAAACYAAAA4AAAAGQAAABcAAAAMAAAACQAAAAoAAAAQAAAAFwAAAA4AAAAOAAAADQAAABQAAAAIAAAAGwAAAA4AAAAQAAAAFgAAABUAAAALAAAAFgAAAA0AAAALAAAACwAAABMAAAAMchAAHHIQAC1yEAA/chAAT3IQAF9yEABychAAhHIQAJFyEACfchAAtHIQAMByEADLchAA4HIQAPVyEAAEcxAAEnMQACVzEABLcxAAg3MQAJxzEACzcxAAv3MQAMhzEADScxAA4nMQAPlzEAAHdBAAFXQQACJ0EAA2dBAAPnQQAFl0EABndBAAd3QQAI10EACidBAArXQQAMN0EADQdBAA23QQAOZ0EAAIAAAAEAAAABEAAAAPAAAADwAAABIAAAARAAAA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YSBmb3JtYXR0aW5nIHRyYWl0IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHdoZW4gdGhlIHVuZGVybHlpbmcgc3RyZWFtIGRpZCBub3RsaWJyYXJ5L2FsbG9jL3NyYy9mbXQucnMAAP6GEAAYAAAAigIAAA4AAABsaWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAKIcQABoAAAChAAAAGQAAAO+/vQBshhAAGwAAAI0FAAAbAAAAACkuLjAxMjM0NTY3ODlhYmNkZWYBAAAAAAAAAFtjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyAAALCHEAAgAAAA0IcQABIAAAAAAAAABAAAAAQAAAAbAQAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAD4gQABAAAAAfiBAAFwAAADaIEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAAA+IEAAQAAAAWIgQABAAAABoiBAACQAAADaIEAAJAAAAOiAAAAEAAAAAAAAAlIgQAAIAAAAAAAAADAAAAAQAAAAcAQAAHQEAAB4BAAAgICAgIHsgLCAgewosCn0gfSgoCiwKXTB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTlsaWJyYXJ5L2NvcmUvc3JjL2ZtdC9tb2QucnNmYWxzZXRydWUAAAChiRAAGwAAAKAKAAAmAAAAoYkQABsAAACpCgAAGgAAAHVzZXItcHJvdmlkZWQgY29tcGFyaXNvbiBmdW5jdGlvbiBkb2VzIG5vdCBjb3JyZWN0bHkgaW1wbGVtZW50IGEgdG90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KjCgK2+mYCwCqOAsHvvgLQD+IDae/2A2/QHhNgEKITckDeE3qw5hOS8Y4TkwHOFK8x7hTkA0oVIeYeFT8GphVE9v4VSdvGFVAM9hVmXRoVYA2iFXAOChWK7iIVrs5OFb0OhhXCAA7lzwAX9dAHAABwAtAQEBAgECAQFICzAVEAFlBwIGAgIBBCMBHhtbCzoJCQEYBAEJAQMBBSsDOwkqGAEgNwEBAQQIBAEDBwoCHQE6AQEBAgQIAQkBCgIaAQICOQEEAgQCAgMDAR4CAwELAjkBBAUBAgQBFAIWBgEBOgEBAgEECAEHAwoCHgE7AQEBDAEJASgBAwE3AQEDBQMBBAcCCwIdAToBAgIBAQMDAQQHAgsCHAI5AgEBAgQIAQkBCgIdAUgBBAECAwEBCAFRAQIHDAhiAQIJCwdJAhsBAQEBATcOAQUBAgULASQJAWYEAQYBAgICGQIEAxAEDQECAgYBDwEAAwAEHAMdAh4CQAIBBwgBAgsJAS0DAQF1AiIBdgMEAgkBBgPbAgIBOgEBBwEBAQECCAYKAgEwHzEEMAoEAyYJDAIgBAIGOAEBAgMBAQU4CAICmAMBDQEHBAEGAQMCxkAAAcMhAAONAWAgAAZpAgAEAQogAlACAAEDAQQBGQIFAZcCGhINASYIGQsBASwDMAECBAICAgEkAUMGAgICAgwBCAEvATMBAQMCAgUCAQEqAggB7gECAQQBAAEAEBAQAAIAAeIBlQUAAwECBQQoAwQBpQIABEEFAAJPBEYLMQR7ATYPKQECAgoDMQQCAgcBPQMkBQEIPgEMAjQJAQEIBAIBXwMCBAYBAgGdAQMIFQI5AgEBAQEMAQkBDgcDBUMBAgYBAQIBAQMEAwEBDgJVCAIDAQEXAVEBAgYBAQIBAQIBAusBAgQGAgECGwJVCAIBAQJqAQEBAghlAQEBAgQBBQAJAQL1AQoEBAGQBAICBAEgCigGAgQIAQkGAgMuDQECAAcBBgEBUhYCBwECAQJ6BgMBAQIBBwEBSAIDAQEBAAILAjQFBQMXAQABBg8ADAMDAAU7BwABPwRRAQsCAAIALgIXAAUDBggIAgceBJQDADcEMggBDgEWBQEPAAcBEQIHAQIBBWQBoAcAAT0EAAT+AgAHbQcAYIDwAAICAgICAgICAgMDAQEBAEHvsMIACxABAAAAAAAAAAICAAAAAAACAEGuscIACwECAEHUscIACwEBAEHvscIACwEBAHsJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjg1LjAgKDRkOTFkZTRlNCAyMDI1LTAyLTE3KQZ3YWxydXMGMC4yMy4yDHdhc20tYmluZGdlbhIwLjIuOTkgKDA0Y2E2ZjM0YSkASQ90YXJnZXRfZmVhdHVyZXMEKw9tdXRhYmxlLWdsb2JhbHMrCHNpZ24tZXh0Kw9yZWZlcmVuY2UtdHlwZXMrCm11bHRpdmFsdWU=", module.meta.url);
          const wasm2 = url.protocol === "file:" ? __vitePreload(() => module.import(
            /* @vite-ignore */
            './__vite-browser-external-pcc57R5k.js'
          ), void 0 ).then((fs) => fs.readFile(url)).catch((err) => {
            console.log("read wasm failed", err);
          }) : void 0;
          return __wbg_init({ module_or_path: wasm2 }).then(() => (initPanicHook(), true));
        }
      }
      const ready = loader();
      const workerParseKuwoHeader = async ({ blobURI }) => {
        const blob = await fetch(blobURI, { headers: { Range: "bytes=0-1023" } }).then((r) => r.blob());
        const arrayBuffer = await blob.arrayBuffer();
        try {
          const buffer = new Uint8Array(arrayBuffer.slice(0, 1024));
          const kwm = KuwoHeader.parse(buffer);
          const { qualityId, resourceId } = kwm;
          kwm.free();
          return { qualityId, resourceId };
        } catch {
          return null;
        }
      };
      const workerParseMusicExMediaName = async ({ blobURI }) => {
        const blob = await fetch(blobURI, { headers: { Range: "bytes=-1024" } }).then((r) => r.blob());
        const arrayBuffer = await blob.arrayBuffer();
        console.log("blob", blob);
        console.log("arrayBuffer", arrayBuffer);
        try {
          const buffer = new Uint8Array(arrayBuffer.slice(-1024));
          const footer2 = QMCFooter.parse(buffer);
          return (footer2 == null ? void 0 : footer2.mediaName) || null;
        } catch {
          return null;
        }
      };
      const workerParseKugouHeader = async ({ blobURI }) => {
        const blob = await fetch(blobURI, { headers: { Range: "bytes=0-1023" } }).then((r) => r.blob());
        const arrayBuffer = await blob.arrayBuffer();
        const buffer = new Uint8Array(arrayBuffer.slice(0, 1024));
        let kwm;
        try {
          kwm = new KuGouHeader(buffer);
          const { version: version2, audioHash } = kwm;
          return { version: version2, audioHash };
        } catch {
          return null;
        } finally {
          kwm == null ? void 0 : kwm.free();
        }
      };
      function* chunkBuffer(buffer, blockLen = 4096) {
        const len = buffer.byteLength;
        for (let i = 0; i < len; i += blockLen) {
          const idxEnd = Math.min(i + blockLen, len);
          const slice = buffer.subarray(i, idxEnd);
          yield [slice, i];
        }
      }
      const DecryptErrorType = {
        UNSUPPORTED_FILE: "UNSUPPORTED_FILE",
        UNKNOWN: "UNKNOWN"
      };
      class DecryptError extends Error {
        constructor() {
          super();
          this.code = DecryptErrorType.UNKNOWN;
        }
        toJSON() {
          const { name: name2, message: message2, stack, code } = this;
          return { name: name2, message: message2, stack, code };
        }
      }
      class UnsupportedSourceFile extends DecryptError {
        constructor() {
          super();
          this.code = DecryptErrorType.UNSUPPORTED_FILE;
        }
      }
      class NetEaseCloudMusicDecipher {
        constructor() {
          this.cipherName = "NCM/PC";
        }
        tryInit(ncm, buffer) {
          let neededLength = 1024;
          while (neededLength !== 0) {
            console.debug("NCM/open: read %d bytes", neededLength);
            neededLength = ncm.open(buffer.subarray(0, neededLength));
            if (neededLength === -1) {
              throw new UnsupportedSourceFile("file is not ncm");
            }
          }
        }
        async decrypt(buffer) {
          const ncm = new NCMFile();
          try {
            this.tryInit(ncm, buffer);
            const audioBuffer = buffer.slice(ncm.audioOffset);
            for (const [block, offset] of chunkBuffer(audioBuffer)) {
              ncm.decrypt(block, offset);
            }
            return {
              status: Status$1.OK,
              cipherName: this.cipherName,
              data: audioBuffer
            };
          } finally {
            ncm.free();
          }
        }
        static make() {
          return new NetEaseCloudMusicDecipher();
        }
      }
      class TransparentDecipher {
        constructor() {
          this.cipherName = "none";
        }
        async decrypt(buffer) {
          return {
            cipherName: "None",
            status: Status$1.OK,
            data: buffer,
            message: "No decipher applied"
          };
        }
        static make() {
          return new TransparentDecipher();
        }
      }
      function isDataLooksLikeAudio(buffer) {
        if (buffer.byteLength < 32) {
          return false;
        }
        const detectResult = detectAudioType(buffer.subarray(0, 32));
        const ok = detectResult.needMore !== 0 || detectResult.audioType !== "bin";
        detectResult.free();
        return ok;
      }
      class QQMusicV1Decipher {
        constructor() {
          this.cipherName = "QQMusic/QMC1";
        }
        async decrypt(buffer) {
          const header = buffer.slice(0, 32);
          decryptQMC1(header, 0);
          if (!isDataLooksLikeAudio(header)) {
            throw new UnsupportedSourceFile("does not look like QMC file");
          }
          const audioBuffer = new Uint8Array(buffer);
          for (const [block, offset] of chunkBuffer(audioBuffer)) {
            decryptQMC1(block, offset);
          }
          return {
            status: Status$1.OK,
            cipherName: this.cipherName,
            data: audioBuffer
          };
        }
        static create() {
          return new QQMusicV1Decipher();
        }
      }
      class QQMusicV2Decipher {
        constructor(useUserKey) {
          this.useUserKey = useUserKey;
          this.cipherName = `QQMusic/QMC2(user_key=${+useUserKey})`;
        }
        parseFooter(buffer) {
          const footer2 = QMCFooter.parse(buffer.subarray(buffer.byteLength - 1024));
          if (footer2) {
            const { size: size2, ekey } = footer2;
            footer2.free();
            return { size: size2, ekey };
          }
          if (!this.useUserKey) {
            throw new UnsupportedSourceFile("Not QMC2 File");
          }
          return { size: 0 };
        }
        async decrypt(buffer, options) {
          const footer2 = this.parseFooter(buffer.subarray(buffer.byteLength - 1024));
          const ekey = this.useUserKey ? options.qmc2Key : footer2.ekey;
          if (!ekey) {
            throw new Error("EKey required");
          }
          const qmc2 = new QMC2(ekey);
          const audioBuffer = buffer.slice(0, buffer.byteLength - footer2.size);
          for (const [block, offset] of chunkBuffer(audioBuffer)) {
            qmc2.decrypt(block, offset);
          }
          qmc2.free();
          return {
            status: Status$1.OK,
            cipherName: this.cipherName,
            data: audioBuffer
          };
        }
        static createWithUserKey() {
          return new QQMusicV2Decipher(true);
        }
        static createWithEmbeddedEKey() {
          return new QQMusicV2Decipher(false);
        }
      }
      class KuwoMusicDecipher {
        constructor() {
          this.cipherName = "Kuwo";
        }
        async decrypt(buffer, options) {
          let header;
          let kwm;
          try {
            header = KuwoHeader.parse(buffer.subarray(0, 1024));
            kwm = new KWMDecipher(header, options.kwm2key);
            const audioBuffer = new Uint8Array(buffer.subarray(1024));
            for (const [block, offset] of chunkBuffer(audioBuffer)) {
              kwm.decrypt(block, offset);
            }
            return {
              status: Status$1.OK,
              cipherName: this.cipherName,
              data: audioBuffer
            };
          } finally {
            kwm == null ? void 0 : kwm.free();
            header == null ? void 0 : header.free();
          }
        }
        static make() {
          return new KuwoMusicDecipher();
        }
      }
      class KugouMusicDecipher {
        constructor() {
          __publicField(this, "cipherName", "Kugou");
        }
        async decrypt(buffer, options) {
          let kgm;
          let kgmHdr;
          try {
            kgmHdr = new KuGouHeader(buffer.subarray(0, 1024));
            kgm = KuGou.fromHeaderV5(kgmHdr, options.kugouKey);
            const audioBuffer = new Uint8Array(buffer.subarray(1024));
            for (const [block, offset] of chunkBuffer(audioBuffer)) {
              kgm.decrypt(block, offset);
            }
            return {
              status: Status$1.OK,
              cipherName: this.cipherName,
              data: audioBuffer
            };
          } finally {
            kgmHdr == null ? void 0 : kgmHdr.free();
            kgm == null ? void 0 : kgm.free();
          }
        }
        static make() {
          return new KugouMusicDecipher();
        }
      }
      class XimalayaAndroidDecipher {
        constructor(decipher, cipherType) {
          this.decipher = decipher;
          this.cipherType = cipherType;
          this.cipherName = `Ximalaya (Android, ${cipherType})`;
        }
        async decrypt(buffer, _options) {
          const slice = buffer.slice(0, 1024);
          this.decipher(slice);
          if (!isDataLooksLikeAudio(slice)) {
            throw new UnsupportedSourceFile(`Not a Xmly android file (${this.cipherType})`);
          }
          const result = new Uint8Array(buffer);
          result.set(slice, 0);
          return {
            cipherName: this.cipherName,
            status: Status$1.OK,
            data: result
          };
        }
        static makeX2M() {
          return new XimalayaAndroidDecipher(decryptX2MHeader, "X2M");
        }
        static makeX3M() {
          return new XimalayaAndroidDecipher(decryptX3MHeader, "X3M");
        }
      }
      class XimalayaPCDecipher {
        constructor() {
          this.cipherName = "Ximalaya (PC)";
        }
        async decrypt(buffer, _options) {
          const headerSize = XmlyPC.getHeaderSize(buffer.subarray(0, 1024));
          const xm = new XmlyPC(buffer.subarray(0, headerSize));
          const { audioHeader, encryptedHeaderOffset, encryptedHeaderSize } = xm;
          const plainAudioDataOffset = encryptedHeaderOffset + encryptedHeaderSize;
          const plainAudioDataLength = buffer.byteLength - plainAudioDataOffset;
          const encryptedAudioPart = buffer.slice(encryptedHeaderOffset, plainAudioDataOffset);
          const encryptedAudioPartLen = xm.decrypt(encryptedAudioPart);
          const audioSize = audioHeader.byteLength + encryptedAudioPartLen + plainAudioDataLength;
          xm.free();
          const result = new Uint8Array(audioSize);
          result.set(audioHeader);
          result.set(encryptedAudioPart, audioHeader.byteLength);
          result.set(buffer.subarray(plainAudioDataOffset), audioHeader.byteLength + encryptedAudioPartLen);
          return {
            status: Status$1.OK,
            data: result,
            cipherName: this.cipherName
          };
        }
        static make() {
          return new XimalayaPCDecipher();
        }
      }
      class XiamiDecipher {
        constructor() {
          this.cipherName = "Xiami (XM)";
        }
        async decrypt(buffer) {
          const xm = Xiami.from_header(buffer.subarray(0, 16));
          const { copyPlainLength } = xm;
          const audioBuffer = buffer.slice(16);
          for (const [block] of chunkBuffer(audioBuffer.subarray(copyPlainLength))) {
            xm.decrypt(block);
          }
          xm.free();
          return {
            cipherName: this.cipherName,
            status: Status$1.OK,
            data: audioBuffer
          };
        }
        static make() {
          return new XiamiDecipher();
        }
      }
      function unhex(value2) {
        const bytes = [];
        for (const [byte2] of value2.matchAll(/[0-9a-fA-F]{2}/g)) {
          bytes.push(parseInt(byte2, 16));
        }
        return new Uint8Array(bytes);
      }
      class QignTingFMDecipher {
        constructor() {
          this.cipherName = "QingTingFM (Android, qta)";
        }
        async decrypt(buffer, opts) {
          const key = unhex(opts.qingTingAndroidKey || "");
          const iv = QingTingFM.getFileIV(opts.fileName);
          if (key.byteLength !== 16 || iv.byteLength !== 16) {
            return {
              status: Status$1.FAILED,
              message: "device key or iv invalid"
            };
          }
          const qtfm = new QingTingFM(key, iv);
          const audioBuffer = new Uint8Array(buffer);
          for (const [block, i] of chunkBuffer(audioBuffer)) {
            qtfm.decrypt(block, i);
          }
          return {
            cipherName: this.cipherName,
            status: Status$1.OK,
            data: audioBuffer
          };
        }
        static make() {
          return new QignTingFMDecipher();
        }
      }
      class Migu3DKeylessDecipher {
        constructor() {
          this.cipherName = "Migu3D (Keyless)";
        }
        async decrypt(buffer) {
          const mg3d = Migu3D.fromHeader(buffer.subarray(0, 256));
          const audioBuffer = new Uint8Array(buffer);
          for (const [block, i] of chunkBuffer(audioBuffer)) {
            mg3d.decrypt(block, i);
          }
          mg3d.free();
          return {
            cipherName: this.cipherName,
            status: Status$1.OK,
            data: audioBuffer
          };
        }
        static make() {
          return new Migu3DKeylessDecipher();
        }
      }
      const Status$1 = {
        OK: 0,
        NOT_THIS_CIPHER: 1,
        FAILED: 2
      };
      const allCryptoFactories = [
        /// File with fixed headers goes first.
        // NCM (*.ncm)
        NetEaseCloudMusicDecipher.make,
        // KGM (*.kgm, *.vpr)
        KugouMusicDecipher.make,
        // KWMv1 (*.kwm)
        KuwoMusicDecipher.make,
        // Ximalaya PC (*.xm)
        XimalayaPCDecipher.make,
        // Xiami (*.xm)
        XiamiDecipher.make,
        // QingTingFM Android (*.qta)
        QignTingFMDecipher.make,
        /// File with a fixed footer goes second
        // QMCv2 (*.mflac)
        QQMusicV2Decipher.createWithUserKey,
        QQMusicV2Decipher.createWithEmbeddedEKey,
        /// File without an obvious header or footer goes last.
        // Migu3D/Keyless (*.wav; *.m4a)
        Migu3DKeylessDecipher.make,
        // Crypto that does not implement "checkBySignature" or need to decrypt the entire file and then check audio type,
        //   should be moved to the bottom of the list for performance reasons.
        // QMCv1 (*.qmcflac)
        QQMusicV1Decipher.create,
        // Ximalaya (Android)
        XimalayaAndroidDecipher.makeX2M,
        XimalayaAndroidDecipher.makeX3M,
        // Transparent crypto (not encrypted)
        TransparentDecipher.make
      ];
      async function unlock(file) {
        try {
          const blobURI = URL.createObjectURL(file);
          const fileName = file.name;
          const fileId = "file://" + nanoid();
          debugger;
          const [qmcv2MusicExMediaFile, kuwoHdr, kugouHdr] = await Promise.all([
            workerParseMusicExMediaName({ blobURI }),
            workerParseKuwoHeader({ blobURI }),
            workerParseKugouHeader({ blobURI })
          ]);
          console.log("头信息", qmcv2MusicExMediaFile, kuwoHdr, kugouHdr);
          const options = {
            fileName
            /* qmc2Key: selectQMCv2KeyByFileName(state, qmcv2MusicExMediaFile || file.fileName),
            kwm2key: selectKWMv2Key(state, kuwoHdr),
            kugouKey: selectKugouKey(state, kugouHdr),
            qingTingAndroidKey: selectQtfmAndroidKey(state), */
          };
          await ready;
          const buffer = await fetch(blobURI).then((r) => r.arrayBuffer());
          for (const factory of allCryptoFactories) {
            try {
              const decipher = factory();
              const result = await tryDecryptWith(decipher, new Uint8Array(buffer), options);
              if (result) {
                return result;
              }
            } catch (error) {
              console.log("error", error);
            }
          }
          return null;
        } catch (error) {
          console.log("error", error);
        }
      }
      const Status = {
        OK: 0,
        NOT_THIS_CIPHER: 1,
        FAILED: 2
      };
      async function tryDecryptWith(decipher, buffer, options) {
        try {
          const result = await decipher.decrypt(buffer, options);
          switch (result.status) {
            case Status.NOT_THIS_CIPHER:
              return null;
            case Status.FAILED:
              throw new Error(`failed: ${result.message}`);
            default:
              break;
          }
        } catch (error) {
          console.log("error", error);
        }
      }
      const UnlockList = ({ fileList }) => {
        const columns = [
          {
            title: "文件名",
            dataIndex: "name",
            key: "name",
            width: 300,
            ellipsis: true
          },
          {
            title: "大小",
            dataIndex: "size",
            key: "size",
            width: 100,
            render: (size2) => `${(size2 / 1024 / 1024).toFixed(2)}MB`
          },
          {
            title: "状态",
            dataIndex: "status",
            key: "status",
            width: 100,
            render: (status) => {
              const statusMap = {
                waiting: { text: "等待中", color: "default" },
                unlocking: { text: "解锁中", color: "processing" },
                success: { text: "已完成", color: "success" },
                error: { text: "失败", color: "error" }
              };
              return /* @__PURE__ */ jsxRuntimeExports.jsx(Tag, { color: statusMap[status].color, children: statusMap[status].text });
            }
          },
          {
            title: "进度",
            dataIndex: "progress",
            key: "progress",
            width: 200,
            render: (progress, record) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              Progress,
              {
                percent: progress,
                size: "small",
                status: record.status === "error" ? "exception" : record.status === "success" ? "success" : "active"
              }
            )
          },
          {
            title: "操作",
            key: "action",
            width: 100,
            render: (_, record) => {
              if (record.status === "success") {
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    type: "link",
                    size: "small",
                    children: "下载"
                  }
                );
              }
              return null;
            }
          }
        ];
        const [list, setList] = useState(fileList);
        useEffect(() => {
          console.log("fileList", fileList);
          setList(fileList);
          fileList.forEach(async (item) => {
            if (item.status === "waiting") {
              item.status = "unlocking";
              item.progress = 0;
              await unlock(item.file);
              setTimeout(() => {
                item.status = "success";
                item.progress = 100;
                setList([...fileList]);
              }, 2e3);
            }
          });
        }, [fileList]);
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles.unlockList, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Table,
          {
            dataSource: list,
            columns,
            rowKey: "id",
            pagination: false,
            scroll: { y: 400 }
          }
        ) });
      };
      const UnlockMusic = forwardRef((props, ref) => {
        const [visible, setVisible] = useState(false);
        const open = () => setVisible(true);
        const close = () => setVisible(false);
        const reset = () => {
        };
        useImperativeHandle(ref, () => ({
          open,
          close,
          reset
        }));
        const [fileList, setFileList] = useState([]);
        const handleUpload = (files) => {
          const newFiles = Array.from(files).map((file) => ({
            id: Date.now() + Math.random(),
            file,
            name: file.name,
            size: file.size,
            status: "waiting",
            // waiting, unlocking, success, error
            progress: 0
          }));
          setFileList((list) => [...list, ...newFiles]);
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Modal,
          {
            title: "加密音乐解锁",
            open: visible,
            onCancel: close,
            width: 950,
            footer: null,
            centered: true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$2.container, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(UploadArea, { onUpload: handleUpload }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(UnlockList, { fileList })
            ] })
          }
        );
      });
      const ButtonGroup = () => {
        const quickUploadRef = useRef(null);
        const handleQuickUpload = () => {
          quickUploadRef.current.open();
        };
        const cloudMusicManagerRef = useRef(null);
        const handleCloudMusicManager = () => {
          cloudMusicManagerRef.current.open();
        };
        const qualityUpgradeRef = useRef(null);
        const localUploadRef = useRef(null);
        const handleLocalUpload = () => {
          localUploadRef.current.open();
        };
        const unlockMusicRef = useRef(null);
        const handleUnlockMusic = () => {
          unlockMusicRef.current.open();
        };
        const vipSongARef = useRef(null);
        const vipSongBRef = useRef(null);
        const cloudExportRef = useRef(null);
        const cloudImportRef = useRef(null);
        const testModalRef = useRef(null);
        const handleTestModal = () => {
          testModalRef.current.open();
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6["button-group"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Tooltip,
            {
              title: "云盘快速上传",
              placement: "left",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CloudUploadOutlined, {}),
                  onClick: handleQuickUpload,
                  className: styles$6["button"]
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Tooltip,
            {
              title: "云盘歌曲管理",
              placement: "left",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CustomerServiceOutlined, {}),
                  onClick: handleCloudMusicManager,
                  className: styles$6["button"]
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Tooltip,
            {
              title: "云盘本地上传",
              placement: "left",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UploadOutlined, {}),
                  onClick: handleLocalUpload,
                  className: styles$6["button"]
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Tooltip,
            {
              title: "加密音乐解锁",
              placement: "left",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UnlockOutlined, {}),
                  onClick: handleUnlockMusic,
                  className: styles$6["button"]
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Tooltip,
            {
              title: "testModal",
              placement: "left",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "primary",
                  icon: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoCircleOutlined, {}),
                  onClick: handleTestModal,
                  className: styles$6["button"]
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(QuickUpload$1, { ref: quickUploadRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CloudMusicManager, { ref: cloudMusicManagerRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(QualityUpgrade, { ref: qualityUpgradeRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(LocalUpload, { ref: localUploadRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(VipSongA, { ref: vipSongARef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(VipSongB, { ref: vipSongBRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CloudExport, { ref: cloudExportRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CloudImport, { ref: cloudImportRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(UnlockMusic, { ref: unlockMusicRef }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TestModal, { ref: testModalRef })
        ] });
      };
      function App() {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "App", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ButtonGroup, {}) });
      }
      const theme = {
        // 品牌色
        token: {
          // 主色
          colorPrimary: "#C20C0C",
          // 网易云特征红色
          colorPrimaryHover: "#D81E06",
          colorPrimaryActive: "#A00606",
          // 文字颜色
          colorText: "#333333",
          colorTextSecondary: "#666666",
          colorTextTertiary: "#999999",
          colorTextDescription: "#666666",
          // 背景色
          colorBgContainer: "#FFFFFF",
          colorBgLayout: "#F5F5F5",
          colorBgMask: "rgba(0, 0, 0, 0.45)",
          // 边框颜色
          colorBorder: "#E1E1E1",
          colorBorderSecondary: "#F0F0F0",
          // 链接颜色
          colorLink: "#0C73C2",
          colorLinkHover: "#2994E7",
          colorLinkActive: "#095C9C",
          // 成功、警告、错误状态色
          colorSuccess: "#52C41A",
          colorWarning: "#FAAD14",
          colorError: "#FF4D4F",
          // 字体
          fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif',
          fontSize: 14,
          // 圆角
          borderRadius: 4,
          borderRadiusLG: 8,
          borderRadiusSM: 2,
          // 间距
          marginXS: 8,
          marginSM: 12,
          margin: 16,
          marginMD: 20,
          marginLG: 24,
          marginXL: 32,
          // 动画
          motionDurationFast: "0.1s",
          motionDurationMid: "0.2s",
          motionDurationSlow: "0.3s",
          motionEaseInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
          motionEaseOut: "cubic-bezier(0.0, 0, 0.2, 1)",
          motionEaseIn: "cubic-bezier(0.4, 0, 1, 1)"
        },
        // 组件级别的样式定制
        components: {
          Button: {
            colorPrimary: "#C20C0C",
            algorithm: true
            // 启用算法
          },
          Input: {
            colorBorder: "#E1E1E1",
            algorithm: true
          }
        }
      };
      var zh_CN$6 = {};
      var interopRequireDefault = { exports: {} };
      (function(module) {
        function _interopRequireDefault2(e) {
          return e && e.__esModule ? e : {
            "default": e
          };
        }
        module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
      })(interopRequireDefault);
      var interopRequireDefaultExports = interopRequireDefault.exports;
      var zh_CN$5 = {};
      Object.defineProperty(zh_CN$5, "__esModule", {
        value: true
      });
      zh_CN$5.default = void 0;
      var locale$3 = {
        // Options
        items_per_page: "条/页",
        jump_to: "跳至",
        jump_to_confirm: "确定",
        page: "页",
        // Pagination
        prev_page: "上一页",
        next_page: "下一页",
        prev_5: "向前 5 页",
        next_5: "向后 5 页",
        prev_3: "向前 3 页",
        next_3: "向后 3 页",
        page_size: "页码"
      };
      zh_CN$5.default = locale$3;
      var zh_CN$4 = {};
      var zh_CN$3 = {};
      var zh_CN$2 = {};
      var objectSpread2 = { exports: {} };
      var defineProperty = { exports: {} };
      var toPropertyKey = { exports: {} };
      var _typeof = { exports: {} };
      (function(module) {
        function _typeof2(o) {
          "@babel/helpers - typeof";
          return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
            return typeof o2;
          } : function(o2) {
            return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
          }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
        }
        module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
      })(_typeof);
      var _typeofExports = _typeof.exports;
      var toPrimitive = { exports: {} };
      (function(module) {
        var _typeof2 = _typeofExports["default"];
        function toPrimitive2(t, r) {
          if ("object" != _typeof2(t) || !t) return t;
          var e = t[Symbol.toPrimitive];
          if (void 0 !== e) {
            var i = e.call(t, r || "default");
            if ("object" != _typeof2(i)) return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r ? String : Number)(t);
        }
        module.exports = toPrimitive2, module.exports.__esModule = true, module.exports["default"] = module.exports;
      })(toPrimitive);
      var toPrimitiveExports = toPrimitive.exports;
      (function(module) {
        var _typeof2 = _typeofExports["default"];
        var toPrimitive2 = toPrimitiveExports;
        function toPropertyKey2(t) {
          var i = toPrimitive2(t, "string");
          return "symbol" == _typeof2(i) ? i : i + "";
        }
        module.exports = toPropertyKey2, module.exports.__esModule = true, module.exports["default"] = module.exports;
      })(toPropertyKey);
      var toPropertyKeyExports = toPropertyKey.exports;
      (function(module) {
        var toPropertyKey2 = toPropertyKeyExports;
        function _defineProperty(e, r, t) {
          return (r = toPropertyKey2(r)) in e ? Object.defineProperty(e, r, {
            value: t,
            enumerable: true,
            configurable: true,
            writable: true
          }) : e[r] = t, e;
        }
        module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
      })(defineProperty);
      var definePropertyExports = defineProperty.exports;
      (function(module) {
        var defineProperty2 = definePropertyExports;
        function ownKeys(e, r) {
          var t = Object.keys(e);
          if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            r && (o = o.filter(function(r2) {
              return Object.getOwnPropertyDescriptor(e, r2).enumerable;
            })), t.push.apply(t, o);
          }
          return t;
        }
        function _objectSpread22(e) {
          for (var r = 1; r < arguments.length; r++) {
            var t = null != arguments[r] ? arguments[r] : {};
            r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
              defineProperty2(e, r2, t[r2]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
              Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
            });
          }
          return e;
        }
        module.exports = _objectSpread22, module.exports.__esModule = true, module.exports["default"] = module.exports;
      })(objectSpread2);
      var objectSpread2Exports = objectSpread2.exports;
      var common = {};
      Object.defineProperty(common, "__esModule", {
        value: true
      });
      common.commonLocale = void 0;
      common.commonLocale = {
        yearFormat: "YYYY",
        dayFormat: "D",
        cellMeridiemFormat: "A",
        monthBeforeYear: true
      };
      var _interopRequireDefault$3 = interopRequireDefaultExports.default;
      Object.defineProperty(zh_CN$2, "__esModule", {
        value: true
      });
      zh_CN$2.default = void 0;
      var _objectSpread2 = _interopRequireDefault$3(objectSpread2Exports);
      var _common = common;
      var locale$2 = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _common.commonLocale), {}, {
        locale: "zh_CN",
        today: "今天",
        now: "此刻",
        backToToday: "返回今天",
        ok: "确定",
        timeSelect: "选择时间",
        dateSelect: "选择日期",
        weekSelect: "选择周",
        clear: "清除",
        month: "月",
        year: "年",
        previousMonth: "上个月 (翻页上键)",
        nextMonth: "下个月 (翻页下键)",
        monthSelect: "选择月份",
        yearSelect: "选择年份",
        decadeSelect: "选择年代",
        previousYear: "上一年 (Control键加左方向键)",
        nextYear: "下一年 (Control键加右方向键)",
        previousDecade: "上一年代",
        nextDecade: "下一年代",
        previousCentury: "上一世纪",
        nextCentury: "下一世纪",
        yearFormat: "YYYY年",
        cellDateFormat: "D",
        monthBeforeYear: false
      });
      zh_CN$2.default = locale$2;
      var zh_CN$1 = {};
      Object.defineProperty(zh_CN$1, "__esModule", {
        value: true
      });
      zh_CN$1.default = void 0;
      const locale$1 = {
        placeholder: "请选择时间",
        rangePlaceholder: ["开始时间", "结束时间"]
      };
      zh_CN$1.default = locale$1;
      var _interopRequireDefault$2 = interopRequireDefaultExports.default;
      Object.defineProperty(zh_CN$3, "__esModule", {
        value: true
      });
      zh_CN$3.default = void 0;
      var _zh_CN$2 = _interopRequireDefault$2(zh_CN$2);
      var _zh_CN2$1 = _interopRequireDefault$2(zh_CN$1);
      const locale = {
        lang: Object.assign({
          placeholder: "请选择日期",
          yearPlaceholder: "请选择年份",
          quarterPlaceholder: "请选择季度",
          monthPlaceholder: "请选择月份",
          weekPlaceholder: "请选择周",
          rangePlaceholder: ["开始日期", "结束日期"],
          rangeYearPlaceholder: ["开始年份", "结束年份"],
          rangeMonthPlaceholder: ["开始月份", "结束月份"],
          rangeQuarterPlaceholder: ["开始季度", "结束季度"],
          rangeWeekPlaceholder: ["开始周", "结束周"]
        }, _zh_CN$2.default),
        timePickerLocale: Object.assign({}, _zh_CN2$1.default)
      };
      locale.lang.ok = "确定";
      zh_CN$3.default = locale;
      var _interopRequireDefault$1 = interopRequireDefaultExports.default;
      Object.defineProperty(zh_CN$4, "__esModule", {
        value: true
      });
      zh_CN$4.default = void 0;
      var _zh_CN$1 = _interopRequireDefault$1(zh_CN$3);
      zh_CN$4.default = _zh_CN$1.default;
      var _interopRequireDefault = interopRequireDefaultExports.default;
      Object.defineProperty(zh_CN$6, "__esModule", {
        value: true
      });
      zh_CN$6.default = void 0;
      var _zh_CN = _interopRequireDefault(zh_CN$5);
      var _zh_CN2 = _interopRequireDefault(zh_CN$4);
      var _zh_CN3 = _interopRequireDefault(zh_CN$3);
      var _zh_CN4 = _interopRequireDefault(zh_CN$1);
      const typeTemplate = "${label}不是一个有效的${type}";
      const localeValues = {
        locale: "zh-cn",
        Pagination: _zh_CN.default,
        DatePicker: _zh_CN3.default,
        TimePicker: _zh_CN4.default,
        Calendar: _zh_CN2.default,
        // locales for all components
        global: {
          placeholder: "请选择"
        },
        Table: {
          filterTitle: "筛选",
          filterConfirm: "确定",
          filterReset: "重置",
          filterEmptyText: "无筛选项",
          filterCheckall: "全选",
          filterSearchPlaceholder: "在筛选项中搜索",
          emptyText: "暂无数据",
          selectAll: "全选当页",
          selectInvert: "反选当页",
          selectNone: "清空所有",
          selectionAll: "全选所有",
          sortTitle: "排序",
          expand: "展开行",
          collapse: "关闭行",
          triggerDesc: "点击降序",
          triggerAsc: "点击升序",
          cancelSort: "取消排序"
        },
        Modal: {
          okText: "确定",
          cancelText: "取消",
          justOkText: "知道了"
        },
        Tour: {
          Next: "下一步",
          Previous: "上一步",
          Finish: "结束导览"
        },
        Popconfirm: {
          cancelText: "取消",
          okText: "确定"
        },
        Transfer: {
          titles: ["", ""],
          searchPlaceholder: "请输入搜索内容",
          itemUnit: "项",
          itemsUnit: "项",
          remove: "删除",
          selectCurrent: "全选当页",
          removeCurrent: "删除当页",
          selectAll: "全选所有",
          deselectAll: "取消全选",
          removeAll: "删除全部",
          selectInvert: "反选当页"
        },
        Upload: {
          uploading: "文件上传中",
          removeFile: "删除文件",
          uploadError: "上传错误",
          previewFile: "预览文件",
          downloadFile: "下载文件"
        },
        Empty: {
          description: "暂无数据"
        },
        Icon: {
          icon: "图标"
        },
        Text: {
          edit: "编辑",
          copy: "复制",
          copied: "复制成功",
          expand: "展开",
          collapse: "收起"
        },
        Form: {
          optional: "（可选）",
          defaultValidateMessages: {
            default: "字段验证错误${label}",
            required: "请输入${label}",
            enum: "${label}必须是其中一个[${enum}]",
            whitespace: "${label}不能为空字符",
            date: {
              format: "${label}日期格式无效",
              parse: "${label}不能转换为日期",
              invalid: "${label}是一个无效日期"
            },
            types: {
              string: typeTemplate,
              method: typeTemplate,
              array: typeTemplate,
              object: typeTemplate,
              number: typeTemplate,
              date: typeTemplate,
              boolean: typeTemplate,
              integer: typeTemplate,
              float: typeTemplate,
              regexp: typeTemplate,
              email: typeTemplate,
              url: typeTemplate,
              hex: typeTemplate
            },
            string: {
              len: "${label}须为${len}个字符",
              min: "${label}最少${min}个字符",
              max: "${label}最多${max}个字符",
              range: "${label}须在${min}-${max}字符之间"
            },
            number: {
              len: "${label}必须等于${len}",
              min: "${label}最小值为${min}",
              max: "${label}最大值为${max}",
              range: "${label}须在${min}-${max}之间"
            },
            array: {
              len: "须为${len}个${label}",
              min: "最少${min}个${label}",
              max: "最多${max}个${label}",
              range: "${label}数量须在${min}-${max}之间"
            },
            pattern: {
              mismatch: "${label}与模式不匹配${pattern}"
            }
          }
        },
        Image: {
          preview: "预览"
        },
        QRCode: {
          expired: "二维码过期",
          refresh: "点击刷新",
          scanned: "已扫描"
        },
        ColorPicker: {
          presetEmpty: "暂无",
          transparent: "无色",
          singleColor: "单色",
          gradientColor: "渐变色"
        }
      };
      zh_CN$6.default = localeValues;
      var zh_CN = zh_CN$6;
      const zhCN = /* @__PURE__ */ getDefaultExportFromCjs(zh_CN);
      client.createRoot(
        (() => {
          const app = document.createElement("div");
          document.body.append(app);
          return app;
        })()
      ).render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(require$$0.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ConfigProvider, { locale: zhCN, theme, children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }) })
      );

    })
  };
}));

System.register("./MpegParser-t3JjS_bv-DP4MVn8J.js", ['./__monkey.entry-SDvwpoNt.js', './AbstractID3Parser-FIM36LHz-B5gpnOzd.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge', './ID3v2Parser-eXNf-3mE-7kzMCmWm.js'], (function (exports, module) {
  'use strict';
  var StringType, initDebug, EndOfStreamError$1, getBitAllignedNumber, INT16_BE, Uint8ArrayType, stripNulls, UINT32_BE, makeUnexpectedFileContentError, isBitSet$1, UINT8, UINT16_BE, AbstractID3Parser;
  return {
    setters: [module => {
      StringType = module.S;
      initDebug = module.i;
      EndOfStreamError$1 = module.E;
      getBitAllignedNumber = module.g;
      INT16_BE = module.I;
      Uint8ArrayType = module.U;
      stripNulls = module.s;
      UINT32_BE = module.a;
      makeUnexpectedFileContentError = module.m;
      isBitSet$1 = module.b;
      UINT8 = module.c;
      UINT16_BE = module.d;
    }, module => {
      AbstractID3Parser = module.A;
    }, null, null, null, null, null, null],
    execute: (function () {

      var NameCode;
      (function(NameCode2) {
        NameCode2[NameCode2["not_set"] = 0] = "not_set";
        NameCode2[NameCode2["radio"] = 1] = "radio";
        NameCode2[NameCode2["audiophile"] = 2] = "audiophile";
      })(NameCode || (NameCode = {}));
      var ReplayGainOriginator;
      (function(ReplayGainOriginator2) {
        ReplayGainOriginator2[ReplayGainOriginator2["unspecified"] = 0] = "unspecified";
        ReplayGainOriginator2[ReplayGainOriginator2["engineer"] = 1] = "engineer";
        ReplayGainOriginator2[ReplayGainOriginator2["user"] = 2] = "user";
        ReplayGainOriginator2[ReplayGainOriginator2["automatic"] = 3] = "automatic";
        ReplayGainOriginator2[ReplayGainOriginator2["rms_average"] = 4] = "rms_average";
      })(ReplayGainOriginator || (ReplayGainOriginator = {}));
      const ReplayGain = {
        len: 2,
        get: (buf, off) => {
          const gain_type = getBitAllignedNumber(buf, off, 0, 3);
          const sign = getBitAllignedNumber(buf, off, 6, 1);
          const gain_adj = getBitAllignedNumber(buf, off, 7, 9) / 10;
          if (gain_type > 0) {
            return {
              type: getBitAllignedNumber(buf, off, 0, 3),
              origin: getBitAllignedNumber(buf, off, 3, 3),
              adjustment: sign ? -gain_adj : gain_adj
            };
          }
          return void 0;
        }
      };
      const ExtendedLameHeader = {
        len: 27,
        get: (buf, off) => {
          const track_peak = UINT32_BE.get(buf, off + 2);
          return {
            revision: getBitAllignedNumber(buf, off, 0, 4),
            vbr_method: getBitAllignedNumber(buf, off, 4, 4),
            lowpass_filter: 100 * UINT8.get(buf, off + 1),
            track_peak: track_peak === 0 ? null : track_peak / 2 ** 23,
            track_gain: ReplayGain.get(buf, 6),
            album_gain: ReplayGain.get(buf, 8),
            music_length: UINT32_BE.get(buf, off + 20),
            music_crc: UINT8.get(buf, off + 24),
            header_crc: UINT16_BE.get(buf, off + 24)
          };
        }
      };
      const InfoTagHeaderTag = new StringType(4, "ascii");
      const LameEncoderVersion = new StringType(6, "ascii");
      const XingHeaderFlags = {
        len: 4,
        get: (buf, off) => {
          return {
            frames: isBitSet$1(buf, off, 31),
            bytes: isBitSet$1(buf, off, 30),
            toc: isBitSet$1(buf, off, 29),
            vbrScale: isBitSet$1(buf, off, 28)
          };
        }
      };
      async function readXingHeader(tokenizer) {
        const flags = await tokenizer.readToken(XingHeaderFlags);
        const xingInfoTag = { numFrames: null, streamSize: null, vbrScale: null };
        if (flags.frames) {
          xingInfoTag.numFrames = await tokenizer.readToken(UINT32_BE);
        }
        if (flags.bytes) {
          xingInfoTag.streamSize = await tokenizer.readToken(UINT32_BE);
        }
        if (flags.toc) {
          xingInfoTag.toc = new Uint8Array(100);
          await tokenizer.readBuffer(xingInfoTag.toc);
        }
        if (flags.vbrScale) {
          xingInfoTag.vbrScale = await tokenizer.readToken(UINT32_BE);
        }
        const lameTag = await tokenizer.peekToken(new StringType(4, "ascii"));
        if (lameTag === "LAME") {
          await tokenizer.ignore(4);
          xingInfoTag.lame = {
            version: await tokenizer.readToken(new StringType(5, "ascii"))
          };
          const match = xingInfoTag.lame.version.match(/\d+.\d+/g);
          if (match !== null) {
            const majorMinorVersion = match[0];
            const version = majorMinorVersion.split(".").map((n) => Number.parseInt(n, 10));
            if (version[0] >= 3 && version[1] >= 90) {
              xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader);
            }
          }
        }
        return xingInfoTag;
      }
      const debug = initDebug("music-metadata:parser:mpeg");
      class MpegContentError extends makeUnexpectedFileContentError("MPEG") {
      } exports("MpegContentError", MpegContentError);
      const maxPeekLen = 1024;
      const MPEG4 = {
        /**
         * Audio Object Types
         */
        AudioObjectTypes: [
          "AAC Main",
          "AAC LC",
          // Low Complexity
          "AAC SSR",
          // Scalable Sample Rate
          "AAC LTP"
          // Long Term Prediction
        ],
        /**
         * Sampling Frequencies
         * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies
         */
        SamplingFrequencies: [
          96e3,
          88200,
          64e3,
          48e3,
          44100,
          32e3,
          24e3,
          22050,
          16e3,
          12e3,
          11025,
          8e3,
          7350,
          null,
          null,
          -1
        ]
        /**
         * Channel Configurations
         */
      };
      const MPEG4_ChannelConfigurations = [
        void 0,
        ["front-center"],
        ["front-left", "front-right"],
        ["front-center", "front-left", "front-right"],
        ["front-center", "front-left", "front-right", "back-center"],
        ["front-center", "front-left", "front-right", "back-left", "back-right"],
        ["front-center", "front-left", "front-right", "back-left", "back-right", "LFE-channel"],
        ["front-center", "front-left", "front-right", "side-left", "side-right", "back-left", "back-right", "LFE-channel"]
      ];
      class MpegFrameHeader {
        constructor(buf, off) {
          this.bitrateIndex = null;
          this.sampRateFreqIndex = null;
          this.padding = null;
          this.privateBit = null;
          this.channelModeIndex = null;
          this.modeExtension = null;
          this.isOriginalMedia = null;
          this.version = null;
          this.bitrate = null;
          this.samplingRate = null;
          this.frameLength = 0;
          this.versionIndex = getBitAllignedNumber(buf, off + 1, 3, 2);
          this.layer = MpegFrameHeader.LayerDescription[getBitAllignedNumber(buf, off + 1, 5, 2)];
          if (this.versionIndex > 1 && this.layer === 0) {
            this.parseAdtsHeader(buf, off);
          } else {
            this.parseMpegHeader(buf, off);
          }
          this.isProtectedByCRC = !isBitSet$1(buf, off + 1, 7);
        }
        calcDuration(numFrames) {
          return this.samplingRate == null ? null : numFrames * this.calcSamplesPerFrame() / this.samplingRate;
        }
        calcSamplesPerFrame() {
          return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
        }
        calculateSideInfoLength() {
          if (this.layer !== 3)
            return 2;
          if (this.channelModeIndex === 3) {
            if (this.version === 1) {
              return 17;
            }
            if (this.version === 2 || this.version === 2.5) {
              return 9;
            }
          } else {
            if (this.version === 1) {
              return 32;
            }
            if (this.version === 2 || this.version === 2.5) {
              return 17;
            }
          }
          return null;
        }
        calcSlotSize() {
          return [null, 4, 1, 1][this.layer];
        }
        parseMpegHeader(buf, off) {
          this.container = "MPEG";
          this.bitrateIndex = getBitAllignedNumber(buf, off + 2, 0, 4);
          this.sampRateFreqIndex = getBitAllignedNumber(buf, off + 2, 4, 2);
          this.padding = isBitSet$1(buf, off + 2, 6);
          this.privateBit = isBitSet$1(buf, off + 2, 7);
          this.channelModeIndex = getBitAllignedNumber(buf, off + 3, 0, 2);
          this.modeExtension = getBitAllignedNumber(buf, off + 3, 2, 2);
          this.isCopyrighted = isBitSet$1(buf, off + 3, 4);
          this.isOriginalMedia = isBitSet$1(buf, off + 3, 5);
          this.emphasis = getBitAllignedNumber(buf, off + 3, 7, 2);
          this.version = MpegFrameHeader.VersionID[this.versionIndex];
          this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];
          this.codec = `MPEG ${this.version} Layer ${this.layer}`;
          const bitrateInKbps = this.calcBitrate();
          if (!bitrateInKbps) {
            throw new MpegContentError("Cannot determine bit-rate");
          }
          this.bitrate = bitrateInKbps * 1e3;
          this.samplingRate = this.calcSamplingRate();
          if (this.samplingRate == null) {
            throw new MpegContentError("Cannot determine sampling-rate");
          }
        }
        parseAdtsHeader(buf, off) {
          debug("layer=0 => ADTS");
          this.version = this.versionIndex === 2 ? 4 : 2;
          this.container = `ADTS/MPEG-${this.version}`;
          const profileIndex = getBitAllignedNumber(buf, off + 2, 0, 2);
          this.codec = "AAC";
          this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];
          debug(`MPEG-4 audio-codec=${this.codec}`);
          const samplingFrequencyIndex = getBitAllignedNumber(buf, off + 2, 2, 4);
          this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];
          debug(`sampling-rate=${this.samplingRate}`);
          const channelIndex = getBitAllignedNumber(buf, off + 2, 7, 3);
          this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];
          debug(`channel-config=${this.mp4ChannelConfig ? this.mp4ChannelConfig.join("+") : "?"}`);
          this.frameLength = getBitAllignedNumber(buf, off + 3, 6, 2) << 11;
        }
        calcBitrate() {
          if (this.bitrateIndex === 0 || // free
          this.bitrateIndex === 15) {
            return null;
          }
          if (this.version && this.bitrateIndex) {
            const codecIndex = 10 * Math.floor(this.version) + this.layer;
            return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];
          }
          return null;
        }
        calcSamplingRate() {
          if (this.sampRateFreqIndex === 3 || this.version === null || this.sampRateFreqIndex == null)
            return null;
          return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
        }
      }
      MpegFrameHeader.SyncByte1 = 255;
      MpegFrameHeader.SyncByte2 = 224;
      MpegFrameHeader.VersionID = [2.5, null, 2, 1];
      MpegFrameHeader.LayerDescription = [0, 3, 2, 1];
      MpegFrameHeader.ChannelMode = ["stereo", "joint_stereo", "dual_channel", "mono"];
      MpegFrameHeader.bitrate_index = {
        1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
        2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
        3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
        4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
        5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
        6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
        7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
        8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
        9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
        10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
        11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
        12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
        13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
        14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }
      };
      MpegFrameHeader.sampling_rate_freq_index = {
        1: { 0: 44100, 1: 48e3, 2: 32e3 },
        2: { 0: 22050, 1: 24e3, 2: 16e3 },
        2.5: { 0: 11025, 1: 12e3, 2: 8e3 }
      };
      MpegFrameHeader.samplesInFrameTable = [
        /* Layer   I    II   III */
        [0, 384, 1152, 1152],
        // MPEG-1
        [0, 384, 1152, 576]
        // MPEG-2(.5
      ];
      const FrameHeader = {
        len: 4,
        get: (buf, off) => {
          return new MpegFrameHeader(buf, off);
        }
      };
      function getVbrCodecProfile(vbrScale) {
        return `V${Math.floor((100 - vbrScale) / 10)}`;
      }
      class MpegParser extends AbstractID3Parser {
        constructor() {
          super(...arguments);
          this.frameCount = 0;
          this.syncFrameCount = -1;
          this.countSkipFrameData = 0;
          this.totalDataLength = 0;
          this.bitrates = [];
          this.offset = 0;
          this.frame_size = 0;
          this.crc = null;
          this.calculateEofDuration = false;
          this.samplesPerFrame = null;
          this.buf_frame_header = new Uint8Array(4);
          this.mpegOffset = null;
          this.syncPeek = {
            buf: new Uint8Array(maxPeekLen),
            len: 0
          };
        }
        /**
         * Called after ID3 headers have been parsed
         */
        async postId3v2Parse() {
          this.metadata.setFormat("lossless", false);
          try {
            let quit = false;
            while (!quit) {
              await this.sync();
              quit = await this.parseCommonMpegHeader();
            }
          } catch (err) {
            if (err instanceof EndOfStreamError$1) {
              debug("End-of-stream");
              if (this.calculateEofDuration) {
                if (this.samplesPerFrame !== null) {
                  const numberOfSamples = this.frameCount * this.samplesPerFrame;
                  this.metadata.setFormat("numberOfSamples", numberOfSamples);
                  if (this.metadata.format.sampleRate) {
                    const duration = numberOfSamples / this.metadata.format.sampleRate;
                    debug(`Calculate duration at EOF: ${duration} sec.`, duration);
                    this.metadata.setFormat("duration", duration);
                  }
                }
              }
            } else {
              throw err;
            }
          }
        }
        /**
         * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length
         */
        finalize() {
          const format = this.metadata.format;
          const hasID3v1 = !!this.metadata.native.ID3v1;
          if (this.mpegOffset !== null) {
            if (format.duration && this.tokenizer.fileInfo.size) {
              const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
              if (format.codecProfile && format.codecProfile[0] === "V") {
                this.metadata.setFormat("bitrate", mpegSize * 8 / format.duration);
              }
            }
            if (this.tokenizer.fileInfo.size && format.codecProfile === "CBR") {
              const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);
              if (this.frame_size !== null && this.samplesPerFrame !== null) {
                const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;
                this.metadata.setFormat("numberOfSamples", numberOfSamples);
                if (format.sampleRate && !format.duration) {
                  const duration = numberOfSamples / format.sampleRate;
                  debug("Calculate CBR duration based on file size: %s", duration);
                  this.metadata.setFormat("duration", duration);
                }
              }
            }
          }
        }
        async sync() {
          let gotFirstSync = false;
          while (true) {
            let bo = 0;
            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });
            if (this.syncPeek.len <= 163) {
              throw new EndOfStreamError$1();
            }
            while (true) {
              if (gotFirstSync && (this.syncPeek.buf[bo] & 224) === 224) {
                this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;
                this.buf_frame_header[1] = this.syncPeek.buf[bo];
                await this.tokenizer.ignore(bo);
                debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);
                if (this.syncFrameCount === this.frameCount) {
                  debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);
                  this.frameCount = 0;
                  this.frame_size = 0;
                }
                this.syncFrameCount = this.frameCount;
                return;
              }
              gotFirstSync = false;
              bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);
              if (bo === -1) {
                if (this.syncPeek.len < this.syncPeek.buf.length) {
                  throw new EndOfStreamError$1();
                }
                await this.tokenizer.ignore(this.syncPeek.len);
                break;
              }
              ++bo;
              gotFirstSync = true;
            }
          }
        }
        /**
         * Combined ADTS & MPEG (MP2 & MP3) header handling
         * @return {Promise<boolean>} true if parser should quit
         */
        async parseCommonMpegHeader() {
          if (this.frameCount === 0) {
            this.mpegOffset = this.tokenizer.position - 1;
          }
          await this.tokenizer.peekBuffer(this.buf_frame_header.subarray(1), { length: 3 });
          let header;
          try {
            header = FrameHeader.get(this.buf_frame_header, 0);
          } catch (err) {
            await this.tokenizer.ignore(1);
            if (err instanceof Error) {
              this.metadata.addWarning(`Parse error: ${err.message}`);
              return false;
            }
            throw err;
          }
          await this.tokenizer.ignore(3);
          this.metadata.setFormat("container", header.container);
          this.metadata.setFormat("codec", header.codec);
          this.metadata.setFormat("lossless", false);
          this.metadata.setFormat("sampleRate", header.samplingRate);
          this.frameCount++;
          return header.version !== null && header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);
        }
        /**
         * @return {Promise<boolean>} true if parser should quit
         */
        async parseAudioFrameHeader(header) {
          this.metadata.setFormat("numberOfChannels", header.channelMode === "mono" ? 1 : 2);
          this.metadata.setFormat("bitrate", header.bitrate);
          if (this.frameCount < 20 * 1e4) {
            debug("offset=%s MP%s bitrate=%s sample-rate=%s", this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);
          }
          const slot_size = header.calcSlotSize();
          if (slot_size === null) {
            throw new MpegContentError("invalid slot_size");
          }
          const samples_per_frame = header.calcSamplesPerFrame();
          debug(`samples_per_frame=${samples_per_frame}`);
          const bps = samples_per_frame / 8;
          if (header.bitrate !== null && header.samplingRate != null) {
            const fsize = bps * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);
            this.frame_size = Math.floor(fsize);
          }
          this.audioFrameHeader = header;
          if (header.bitrate !== null) {
            this.bitrates.push(header.bitrate);
          }
          if (this.frameCount === 1) {
            this.offset = FrameHeader.len;
            await this.skipSideInformation();
            return false;
          }
          if (this.frameCount === 3) {
            if (this.areAllSame(this.bitrates)) {
              this.samplesPerFrame = samples_per_frame;
              this.metadata.setFormat("codecProfile", "CBR");
              if (this.tokenizer.fileInfo.size)
                return true;
            } else if (this.metadata.format.duration) {
              return true;
            }
            if (!this.options.duration) {
              return true;
            }
          }
          if (this.options.duration && this.frameCount === 4) {
            this.samplesPerFrame = samples_per_frame;
            this.calculateEofDuration = true;
          }
          this.offset = 4;
          if (header.isProtectedByCRC) {
            await this.parseCrc();
            return false;
          }
          await this.skipSideInformation();
          return false;
        }
        async parseAdts(header) {
          const buf = new Uint8Array(3);
          await this.tokenizer.readBuffer(buf);
          header.frameLength += getBitAllignedNumber(buf, 0, 0, 11);
          this.totalDataLength += header.frameLength;
          this.samplesPerFrame = 1024;
          if (header.samplingRate !== null) {
            const framesPerSec = header.samplingRate / this.samplesPerFrame;
            const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;
            const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;
            this.metadata.setFormat("bitrate", bitrate);
            debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);
          }
          await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);
          if (this.frameCount === 3) {
            this.metadata.setFormat("codecProfile", header.codecProfile);
            if (header.mp4ChannelConfig) {
              this.metadata.setFormat("numberOfChannels", header.mp4ChannelConfig.length);
            }
            if (this.options.duration) {
              this.calculateEofDuration = true;
            } else {
              return true;
            }
          }
          return false;
        }
        async parseCrc() {
          this.crc = await this.tokenizer.readNumber(INT16_BE);
          this.offset += 2;
          return this.skipSideInformation();
        }
        async skipSideInformation() {
          if (this.audioFrameHeader) {
            const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();
            if (sideinfo_length !== null) {
              await this.tokenizer.readToken(new Uint8ArrayType(sideinfo_length));
              this.offset += sideinfo_length;
              await this.readXtraInfoHeader();
              return;
            }
          }
        }
        async readXtraInfoHeader() {
          const headerTag = await this.tokenizer.readToken(InfoTagHeaderTag);
          this.offset += InfoTagHeaderTag.len;
          switch (headerTag) {
            case "Info":
              this.metadata.setFormat("codecProfile", "CBR");
              return this.readXingInfoHeader();
            case "Xing": {
              const infoTag = await this.readXingInfoHeader();
              if (infoTag.vbrScale !== null) {
                const codecProfile = getVbrCodecProfile(infoTag.vbrScale);
                this.metadata.setFormat("codecProfile", codecProfile);
              }
              return null;
            }
            case "Xtra":
              break;
            case "LAME": {
              const version = await this.tokenizer.readToken(LameEncoderVersion);
              if (this.frame_size !== null && this.frame_size >= this.offset + LameEncoderVersion.len) {
                this.offset += LameEncoderVersion.len;
                this.metadata.setFormat("tool", `LAME ${version}`);
                await this.skipFrameData(this.frame_size - this.offset);
                return null;
              }
              this.metadata.addWarning("Corrupt LAME header");
              break;
            }
          }
          const frameDataLeft = this.frame_size - this.offset;
          if (frameDataLeft < 0) {
            this.metadata.addWarning(`Frame ${this.frameCount}corrupt: negative frameDataLeft`);
          } else {
            await this.skipFrameData(frameDataLeft);
          }
          return null;
        }
        /**
         * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
         * @returns {Promise<string>}
         */
        async readXingInfoHeader() {
          const offset = this.tokenizer.position;
          const infoTag = await readXingHeader(this.tokenizer);
          this.offset += this.tokenizer.position - offset;
          if (infoTag.lame) {
            this.metadata.setFormat("tool", `LAME ${stripNulls(infoTag.lame.version)}`);
            if (infoTag.lame.extended) {
              this.metadata.setFormat("trackPeakLevel", infoTag.lame.extended.track_peak);
              if (infoTag.lame.extended.track_gain) {
                this.metadata.setFormat("trackGain", infoTag.lame.extended.track_gain.adjustment);
              }
              if (infoTag.lame.extended.album_gain) {
                this.metadata.setFormat("albumGain", infoTag.lame.extended.album_gain.adjustment);
              }
              this.metadata.setFormat("duration", infoTag.lame.extended.music_length / 1e3);
            }
          }
          if (infoTag.streamSize && this.audioFrameHeader && infoTag.numFrames !== null) {
            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);
            this.metadata.setFormat("duration", duration);
            debug("Get duration from Xing header: %s", this.metadata.format.duration);
            return infoTag;
          }
          const frameDataLeft = this.frame_size - this.offset;
          await this.skipFrameData(frameDataLeft);
          return infoTag;
        }
        async skipFrameData(frameDataLeft) {
          if (frameDataLeft < 0)
            throw new MpegContentError("frame-data-left cannot be negative");
          await this.tokenizer.ignore(frameDataLeft);
          this.countSkipFrameData += frameDataLeft;
        }
        areAllSame(array) {
          const first = array[0];
          return array.every((element) => {
            return element === first;
          });
        }
      } exports("MpegParser", MpegParser);

    })
  };
}));

System.register("./AsfParser-6pj_dtO9-DydKPSph.js", ['./__monkey.entry-SDvwpoNt.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var initDebug, BasicParser, TrackType, uint8ArrayToHex, hexToUint8Array, makeUnexpectedFileContentError, UINT64_LE, UINT32_LE, getBit, UINT16_LE, stripNulls, decodeString, StringType, AttachedPictureType;
  return {
    setters: [module => {
      initDebug = module.i;
      BasicParser = module.B;
      TrackType = module.T;
      uint8ArrayToHex = module.u;
      hexToUint8Array = module.h;
      makeUnexpectedFileContentError = module.m;
      UINT64_LE = module.e;
      UINT32_LE = module.f;
      getBit = module.j;
      UINT16_LE = module.k;
      stripNulls = module.s;
      decodeString = module.l;
      StringType = module.S;
      AttachedPictureType = module.A;
    }, null, null, null, null, null],
    execute: (function () {

      class GUID {
        static fromBin(bin, offset = 0) {
          return new GUID(GUID.decode(bin, offset));
        }
        /**
         * Decode GUID in format like "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
         * @param objectId Binary GUID
         * @param offset Read offset in bytes, default 0
         * @returns GUID as dashed hexadecimal representation
         */
        static decode(objectId, offset = 0) {
          const view = new DataView(objectId.buffer, offset);
          const guid = `${view.getUint32(0, true).toString(16)}-${view.getUint16(4, true).toString(16)}-${view.getUint16(6, true).toString(16)}-${view.getUint16(8).toString(16)}-${uint8ArrayToHex(objectId.slice(offset + 10, offset + 16))}`;
          return guid.toUpperCase();
        }
        /**
         * Decode stream type
         * @param mediaType Media type GUID
         * @returns Media type
         */
        static decodeMediaType(mediaType) {
          switch (mediaType.str) {
            case GUID.AudioMedia.str:
              return "audio";
            case GUID.VideoMedia.str:
              return "video";
            case GUID.CommandMedia.str:
              return "command";
            case GUID.Degradable_JPEG_Media.str:
              return "degradable-jpeg";
            case GUID.FileTransferMedia.str:
              return "file-transfer";
            case GUID.BinaryMedia.str:
              return "binary";
          }
        }
        /**
         * Encode GUID
         * @param guid GUID like: "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
         * @returns Encoded Binary GUID
         */
        static encode(str) {
          const bin = new Uint8Array(16);
          const view = new DataView(bin.buffer);
          view.setUint32(0, Number.parseInt(str.slice(0, 8), 16), true);
          view.setUint16(4, Number.parseInt(str.slice(9, 13), 16), true);
          view.setUint16(6, Number.parseInt(str.slice(14, 18), 16), true);
          bin.set(hexToUint8Array(str.slice(19, 23)), 8);
          bin.set(hexToUint8Array(str.slice(24)), 10);
          return bin;
        }
        constructor(str) {
          this.str = str;
        }
        equals(guid) {
          return this.str === guid.str;
        }
        toBin() {
          return GUID.encode(this.str);
        }
      }
      GUID.HeaderObject = new GUID("75B22630-668E-11CF-A6D9-00AA0062CE6C");
      GUID.DataObject = new GUID("75B22636-668E-11CF-A6D9-00AA0062CE6C");
      GUID.SimpleIndexObject = new GUID("33000890-E5B1-11CF-89F4-00A0C90349CB");
      GUID.IndexObject = new GUID("D6E229D3-35DA-11D1-9034-00A0C90349BE");
      GUID.MediaObjectIndexObject = new GUID("FEB103F8-12AD-4C64-840F-2A1D2F7AD48C");
      GUID.TimecodeIndexObject = new GUID("3CB73FD0-0C4A-4803-953D-EDF7B6228F0C");
      GUID.FilePropertiesObject = new GUID("8CABDCA1-A947-11CF-8EE4-00C00C205365");
      GUID.StreamPropertiesObject = new GUID("B7DC0791-A9B7-11CF-8EE6-00C00C205365");
      GUID.HeaderExtensionObject = new GUID("5FBF03B5-A92E-11CF-8EE3-00C00C205365");
      GUID.CodecListObject = new GUID("86D15240-311D-11D0-A3A4-00A0C90348F6");
      GUID.ScriptCommandObject = new GUID("1EFB1A30-0B62-11D0-A39B-00A0C90348F6");
      GUID.MarkerObject = new GUID("F487CD01-A951-11CF-8EE6-00C00C205365");
      GUID.BitrateMutualExclusionObject = new GUID("D6E229DC-35DA-11D1-9034-00A0C90349BE");
      GUID.ErrorCorrectionObject = new GUID("75B22635-668E-11CF-A6D9-00AA0062CE6C");
      GUID.ContentDescriptionObject = new GUID("75B22633-668E-11CF-A6D9-00AA0062CE6C");
      GUID.ExtendedContentDescriptionObject = new GUID("D2D0A440-E307-11D2-97F0-00A0C95EA850");
      GUID.ContentBrandingObject = new GUID("2211B3FA-BD23-11D2-B4B7-00A0C955FC6E");
      GUID.StreamBitratePropertiesObject = new GUID("7BF875CE-468D-11D1-8D82-006097C9A2B2");
      GUID.ContentEncryptionObject = new GUID("2211B3FB-BD23-11D2-B4B7-00A0C955FC6E");
      GUID.ExtendedContentEncryptionObject = new GUID("298AE614-2622-4C17-B935-DAE07EE9289C");
      GUID.DigitalSignatureObject = new GUID("2211B3FC-BD23-11D2-B4B7-00A0C955FC6E");
      GUID.PaddingObject = new GUID("1806D474-CADF-4509-A4BA-9AABCB96AAE8");
      GUID.ExtendedStreamPropertiesObject = new GUID("14E6A5CB-C672-4332-8399-A96952065B5A");
      GUID.AdvancedMutualExclusionObject = new GUID("A08649CF-4775-4670-8A16-6E35357566CD");
      GUID.GroupMutualExclusionObject = new GUID("D1465A40-5A79-4338-B71B-E36B8FD6C249");
      GUID.StreamPrioritizationObject = new GUID("D4FED15B-88D3-454F-81F0-ED5C45999E24");
      GUID.BandwidthSharingObject = new GUID("A69609E6-517B-11D2-B6AF-00C04FD908E9");
      GUID.LanguageListObject = new GUID("7C4346A9-EFE0-4BFC-B229-393EDE415C85");
      GUID.MetadataObject = new GUID("C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA");
      GUID.MetadataLibraryObject = new GUID("44231C94-9498-49D1-A141-1D134E457054");
      GUID.IndexParametersObject = new GUID("D6E229DF-35DA-11D1-9034-00A0C90349BE");
      GUID.MediaObjectIndexParametersObject = new GUID("6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7");
      GUID.TimecodeIndexParametersObject = new GUID("F55E496D-9797-4B5D-8C8B-604DFE9BFB24");
      GUID.CompatibilityObject = new GUID("26F18B5D-4584-47EC-9F5F-0E651F0452C9");
      GUID.AdvancedContentEncryptionObject = new GUID("43058533-6981-49E6-9B74-AD12CB86D58C");
      GUID.AudioMedia = new GUID("F8699E40-5B4D-11CF-A8FD-00805F5C442B");
      GUID.VideoMedia = new GUID("BC19EFC0-5B4D-11CF-A8FD-00805F5C442B");
      GUID.CommandMedia = new GUID("59DACFC0-59E6-11D0-A3AC-00A0C90348F6");
      GUID.JFIF_Media = new GUID("B61BE100-5B4E-11CF-A8FD-00805F5C442B");
      GUID.Degradable_JPEG_Media = new GUID("35907DE0-E415-11CF-A917-00805F5C442B");
      GUID.FileTransferMedia = new GUID("91BD222C-F21C-497A-8B6D-5AA86BFC0185");
      GUID.BinaryMedia = new GUID("3AFB65E2-47EF-40F2-AC2C-70A90D71D343");
      GUID.ASF_Index_Placeholder_Object = new GUID("D9AADE20-7C17-4F9C-BC28-8555DD98E2A2");
      function getParserForAttr(i) {
        return attributeParsers[i];
      }
      function parseUnicodeAttr(uint8Array) {
        return stripNulls(decodeString(uint8Array, "utf-16le"));
      }
      const attributeParsers = [
        parseUnicodeAttr,
        parseByteArrayAttr,
        parseBoolAttr,
        parseDWordAttr,
        parseQWordAttr,
        parseWordAttr,
        parseByteArrayAttr
      ];
      function parseByteArrayAttr(buf) {
        return new Uint8Array(buf);
      }
      function parseBoolAttr(buf, offset = 0) {
        return parseWordAttr(buf, offset) === 1;
      }
      function parseDWordAttr(buf, offset = 0) {
        return UINT32_LE.get(buf, offset);
      }
      function parseQWordAttr(buf, offset = 0) {
        return UINT64_LE.get(buf, offset);
      }
      function parseWordAttr(buf, offset = 0) {
        return UINT16_LE.get(buf, offset);
      }
      class AsfContentParseError extends makeUnexpectedFileContentError("ASF") {
      }
      var DataType;
      (function(DataType2) {
        DataType2[DataType2["UnicodeString"] = 0] = "UnicodeString";
        DataType2[DataType2["ByteArray"] = 1] = "ByteArray";
        DataType2[DataType2["Bool"] = 2] = "Bool";
        DataType2[DataType2["DWord"] = 3] = "DWord";
        DataType2[DataType2["QWord"] = 4] = "QWord";
        DataType2[DataType2["Word"] = 5] = "Word";
      })(DataType || (DataType = {}));
      const TopLevelHeaderObjectToken = {
        len: 30,
        get: (buf, off) => {
          return {
            objectId: GUID.fromBin(buf, off),
            objectSize: Number(UINT64_LE.get(buf, off + 16)),
            numberOfHeaderObjects: UINT32_LE.get(buf, off + 24)
            // Reserved: 2 bytes
          };
        }
      };
      const HeaderObjectToken = {
        len: 24,
        get: (buf, off) => {
          return {
            objectId: GUID.fromBin(buf, off),
            objectSize: Number(UINT64_LE.get(buf, off + 16))
          };
        }
      };
      class State {
        constructor(header) {
          this.len = Number(header.objectSize) - HeaderObjectToken.len;
        }
        postProcessTag(tags, name, valueType, data) {
          if (name === "WM/Picture") {
            tags.push({ id: name, value: WmPictureToken.fromBuffer(data) });
          } else {
            const parseAttr = getParserForAttr(valueType);
            if (!parseAttr) {
              throw new AsfContentParseError(`unexpected value headerType: ${valueType}`);
            }
            tags.push({ id: name, value: parseAttr(data) });
          }
        }
      }
      class IgnoreObjectState extends State {
        get(buf, off) {
          return null;
        }
      }
      class FilePropertiesObject extends State {
        get(buf, off) {
          return {
            fileId: GUID.fromBin(buf, off),
            fileSize: UINT64_LE.get(buf, off + 16),
            creationDate: UINT64_LE.get(buf, off + 24),
            dataPacketsCount: UINT64_LE.get(buf, off + 32),
            playDuration: UINT64_LE.get(buf, off + 40),
            sendDuration: UINT64_LE.get(buf, off + 48),
            preroll: UINT64_LE.get(buf, off + 56),
            flags: {
              broadcast: getBit(buf, off + 64, 24),
              seekable: getBit(buf, off + 64, 25)
            },
            // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
            minimumDataPacketSize: UINT32_LE.get(buf, off + 68),
            maximumDataPacketSize: UINT32_LE.get(buf, off + 72),
            maximumBitrate: UINT32_LE.get(buf, off + 76)
          };
        }
      }
      FilePropertiesObject.guid = GUID.FilePropertiesObject;
      class StreamPropertiesObject extends State {
        get(buf, off) {
          return {
            streamType: GUID.decodeMediaType(GUID.fromBin(buf, off)),
            errorCorrectionType: GUID.fromBin(buf, off + 8)
            // ToDo
          };
        }
      }
      StreamPropertiesObject.guid = GUID.StreamPropertiesObject;
      class HeaderExtensionObject {
        constructor() {
          this.len = 22;
        }
        get(buf, off) {
          const view = new DataView(buf.buffer, off);
          return {
            reserved1: GUID.fromBin(buf, off),
            reserved2: view.getUint16(16, true),
            extensionDataSize: view.getUint16(18, true)
          };
        }
      }
      HeaderExtensionObject.guid = GUID.HeaderExtensionObject;
      const CodecListObjectHeader = {
        len: 20,
        get: (buf, off) => {
          const view = new DataView(buf.buffer, off);
          return {
            entryCount: view.getUint16(16, true)
          };
        }
      };
      async function readString(tokenizer) {
        const length = await tokenizer.readNumber(UINT16_LE);
        return (await tokenizer.readToken(new StringType(length * 2, "utf-16le"))).replace("\0", "");
      }
      async function readCodecEntries(tokenizer) {
        const codecHeader = await tokenizer.readToken(CodecListObjectHeader);
        const entries = [];
        for (let i = 0; i < codecHeader.entryCount; ++i) {
          entries.push(await readCodecEntry(tokenizer));
        }
        return entries;
      }
      async function readInformation(tokenizer) {
        const length = await tokenizer.readNumber(UINT16_LE);
        const buf = new Uint8Array(length);
        await tokenizer.readBuffer(buf);
        return buf;
      }
      async function readCodecEntry(tokenizer) {
        const type = await tokenizer.readNumber(UINT16_LE);
        return {
          type: {
            videoCodec: (type & 1) === 1,
            audioCodec: (type & 2) === 2
          },
          codecName: await readString(tokenizer),
          description: await readString(tokenizer),
          information: await readInformation(tokenizer)
        };
      }
      class ContentDescriptionObjectState extends State {
        get(buf, off) {
          const tags = [];
          const view = new DataView(buf.buffer, off);
          let pos = 10;
          for (let i = 0; i < ContentDescriptionObjectState.contentDescTags.length; ++i) {
            const length = view.getUint16(i * 2, true);
            if (length > 0) {
              const tagName = ContentDescriptionObjectState.contentDescTags[i];
              const end = pos + length;
              tags.push({ id: tagName, value: parseUnicodeAttr(buf.slice(off + pos, off + end)) });
              pos = end;
            }
          }
          return tags;
        }
      }
      ContentDescriptionObjectState.guid = GUID.ContentDescriptionObject;
      ContentDescriptionObjectState.contentDescTags = ["Title", "Author", "Copyright", "Description", "Rating"];
      class ExtendedContentDescriptionObjectState extends State {
        get(buf, off) {
          const tags = [];
          const view = new DataView(buf.buffer, off);
          const attrCount = view.getUint16(0, true);
          let pos = 2;
          for (let i = 0; i < attrCount; i += 1) {
            const nameLen = view.getUint16(pos, true);
            pos += 2;
            const name = parseUnicodeAttr(buf.slice(off + pos, off + pos + nameLen));
            pos += nameLen;
            const valueType = view.getUint16(pos, true);
            pos += 2;
            const valueLen = view.getUint16(pos, true);
            pos += 2;
            const value = buf.slice(off + pos, off + pos + valueLen);
            pos += valueLen;
            this.postProcessTag(tags, name, valueType, value);
          }
          return tags;
        }
      }
      ExtendedContentDescriptionObjectState.guid = GUID.ExtendedContentDescriptionObject;
      class ExtendedStreamPropertiesObjectState extends State {
        get(buf, off) {
          const view = new DataView(buf.buffer, off);
          return {
            startTime: UINT64_LE.get(buf, off),
            endTime: UINT64_LE.get(buf, off + 8),
            dataBitrate: view.getInt32(12, true),
            bufferSize: view.getInt32(16, true),
            initialBufferFullness: view.getInt32(20, true),
            alternateDataBitrate: view.getInt32(24, true),
            alternateBufferSize: view.getInt32(28, true),
            alternateInitialBufferFullness: view.getInt32(32, true),
            maximumObjectSize: view.getInt32(36, true),
            flags: {
              reliableFlag: getBit(buf, off + 40, 0),
              seekableFlag: getBit(buf, off + 40, 1),
              resendLiveCleanpointsFlag: getBit(buf, off + 40, 2)
            },
            // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
            streamNumber: view.getInt16(42, true),
            streamLanguageId: view.getInt16(44, true),
            averageTimePerFrame: view.getInt32(52, true),
            streamNameCount: view.getInt32(54, true),
            payloadExtensionSystems: view.getInt32(56, true),
            streamNames: [],
            // ToDo
            streamPropertiesObject: null
          };
        }
      }
      ExtendedStreamPropertiesObjectState.guid = GUID.ExtendedStreamPropertiesObject;
      class MetadataObjectState extends State {
        get(uint8Array, off) {
          const tags = [];
          const view = new DataView(uint8Array.buffer, off);
          const descriptionRecordsCount = view.getUint16(0, true);
          let pos = 2;
          for (let i = 0; i < descriptionRecordsCount; i += 1) {
            pos += 4;
            const nameLen = view.getUint16(pos, true);
            pos += 2;
            const dataType = view.getUint16(pos, true);
            pos += 2;
            const dataLen = view.getUint32(pos, true);
            pos += 4;
            const name = parseUnicodeAttr(uint8Array.slice(off + pos, off + pos + nameLen));
            pos += nameLen;
            const data = uint8Array.slice(off + pos, off + pos + dataLen);
            pos += dataLen;
            this.postProcessTag(tags, name, dataType, data);
          }
          return tags;
        }
      }
      MetadataObjectState.guid = GUID.MetadataObject;
      class MetadataLibraryObjectState extends MetadataObjectState {
      }
      MetadataLibraryObjectState.guid = GUID.MetadataLibraryObject;
      class WmPictureToken {
        static fromBuffer(buffer) {
          const pic = new WmPictureToken(buffer.length);
          return pic.get(buffer, 0);
        }
        constructor(len) {
          this.len = len;
        }
        get(buffer, offset) {
          const view = new DataView(buffer.buffer, offset);
          const typeId = view.getUint8(0);
          const size = view.getInt32(1, true);
          let index = 5;
          while (view.getUint16(index) !== 0) {
            index += 2;
          }
          const format = new StringType(index - 5, "utf-16le").get(buffer, 5);
          while (view.getUint16(index) !== 0) {
            index += 2;
          }
          const description = new StringType(index - 5, "utf-16le").get(buffer, 5);
          return {
            type: AttachedPictureType[typeId],
            format,
            description,
            size,
            data: buffer.slice(index + 4)
          };
        }
      }
      const debug = initDebug("music-metadata:parser:ASF");
      const headerType = "asf";
      class AsfParser extends BasicParser {
        async parse() {
          const header = await this.tokenizer.readToken(TopLevelHeaderObjectToken);
          if (!header.objectId.equals(GUID.HeaderObject)) {
            throw new AsfContentParseError(`expected asf header; but was not found; got: ${header.objectId.str}`);
          }
          try {
            await this.parseObjectHeader(header.numberOfHeaderObjects);
          } catch (err) {
            debug("Error while parsing ASF: %s", err);
          }
        }
        async parseObjectHeader(numberOfObjectHeaders) {
          let tags;
          do {
            const header = await this.tokenizer.readToken(HeaderObjectToken);
            debug("header GUID=%s", header.objectId.str);
            switch (header.objectId.str) {
              case FilePropertiesObject.guid.str: {
                const fpo = await this.tokenizer.readToken(new FilePropertiesObject(header));
                this.metadata.setFormat("duration", Number(fpo.playDuration / BigInt(1e3)) / 1e4 - Number(fpo.preroll) / 1e3);
                this.metadata.setFormat("bitrate", fpo.maximumBitrate);
                break;
              }
              case StreamPropertiesObject.guid.str: {
                const spo = await this.tokenizer.readToken(new StreamPropertiesObject(header));
                this.metadata.setFormat("container", `ASF/${spo.streamType}`);
                break;
              }
              case HeaderExtensionObject.guid.str: {
                const extHeader = await this.tokenizer.readToken(new HeaderExtensionObject());
                await this.parseExtensionObject(extHeader.extensionDataSize);
                break;
              }
              case ContentDescriptionObjectState.guid.str:
                tags = await this.tokenizer.readToken(new ContentDescriptionObjectState(header));
                await this.addTags(tags);
                break;
              case ExtendedContentDescriptionObjectState.guid.str:
                tags = await this.tokenizer.readToken(new ExtendedContentDescriptionObjectState(header));
                await this.addTags(tags);
                break;
              case GUID.CodecListObject.str: {
                const codecs = await readCodecEntries(this.tokenizer);
                codecs.forEach((codec) => {
                  this.metadata.addStreamInfo({
                    type: codec.type.videoCodec ? TrackType.video : TrackType.audio,
                    codecName: codec.codecName
                  });
                });
                const audioCodecs = codecs.filter((codec) => codec.type.audioCodec).map((codec) => codec.codecName).join("/");
                this.metadata.setFormat("codec", audioCodecs);
                break;
              }
              case GUID.StreamBitratePropertiesObject.str:
                await this.tokenizer.ignore(header.objectSize - HeaderObjectToken.len);
                break;
              case GUID.PaddingObject.str:
                debug("Padding: %s bytes", header.objectSize - HeaderObjectToken.len);
                await this.tokenizer.ignore(header.objectSize - HeaderObjectToken.len);
                break;
              default:
                this.metadata.addWarning(`Ignore ASF-Object-GUID: ${header.objectId.str}`);
                debug("Ignore ASF-Object-GUID: %s", header.objectId.str);
                await this.tokenizer.readToken(new IgnoreObjectState(header));
            }
          } while (--numberOfObjectHeaders);
        }
        async addTags(tags) {
          await Promise.all(tags.map(({ id, value }) => this.metadata.addTag(headerType, id, value)));
        }
        async parseExtensionObject(extensionSize) {
          do {
            const header = await this.tokenizer.readToken(HeaderObjectToken);
            const remaining = header.objectSize - HeaderObjectToken.len;
            switch (header.objectId.str) {
              case ExtendedStreamPropertiesObjectState.guid.str:
                await this.tokenizer.readToken(new ExtendedStreamPropertiesObjectState(header));
                break;
              case MetadataObjectState.guid.str: {
                const moTags = await this.tokenizer.readToken(new MetadataObjectState(header));
                await this.addTags(moTags);
                break;
              }
              case MetadataLibraryObjectState.guid.str: {
                const mlTags = await this.tokenizer.readToken(new MetadataLibraryObjectState(header));
                await this.addTags(mlTags);
                break;
              }
              case GUID.PaddingObject.str:
                await this.tokenizer.ignore(remaining);
                break;
              case GUID.CompatibilityObject.str:
                await this.tokenizer.ignore(remaining);
                break;
              case GUID.ASF_Index_Placeholder_Object.str:
                await this.tokenizer.ignore(remaining);
                break;
              default:
                this.metadata.addWarning(`Ignore ASF-Object-GUID: ${header.objectId.str}`);
                await this.tokenizer.readToken(new IgnoreObjectState(header));
                break;
            }
            extensionSize -= header.objectSize;
          } while (extensionSize > 0);
        }
      } exports("AsfParser", AsfParser);

    })
  };
}));

System.register("./DsdiffParser-DlPzwyIy-BSxVmTfk.js", ['./__monkey.entry-SDvwpoNt.js', './ID3v2Parser-eXNf-3mE-7kzMCmWm.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var initDebug, BasicParser, FourCcToken, Uint8ArrayType, fromBuffer$1, UINT32_LE, UINT16_BE, UINT8, UINT32_BE, StringType, INT64_BE, makeUnexpectedFileContentError, ID3v2Parser;
  return {
    setters: [module => {
      initDebug = module.i;
      BasicParser = module.B;
      FourCcToken = module.F;
      Uint8ArrayType = module.U;
      fromBuffer$1 = module.n;
      UINT32_LE = module.f;
      UINT16_BE = module.d;
      UINT8 = module.c;
      UINT32_BE = module.a;
      StringType = module.S;
      INT64_BE = module.o;
      makeUnexpectedFileContentError = module.m;
    }, module => {
      ID3v2Parser = module.I;
    }, null, null, null, null, null],
    execute: (function () {

      const ChunkHeader64 = {
        len: 12,
        get: (buf, off) => {
          return {
            // Group-ID
            chunkID: FourCcToken.get(buf, off),
            // Size
            chunkSize: INT64_BE.get(buf, off + 4)
          };
        }
      };
      const debug = initDebug("music-metadata:parser:aiff");
      class DsdiffContentParseError extends makeUnexpectedFileContentError("DSDIFF") {
      } exports("DsdiffContentParseError", DsdiffContentParseError);
      class DsdiffParser extends BasicParser {
        async parse() {
          const header = await this.tokenizer.readToken(ChunkHeader64);
          if (header.chunkID !== "FRM8")
            throw new DsdiffContentParseError("Unexpected chunk-ID");
          const type = (await this.tokenizer.readToken(FourCcToken)).trim();
          switch (type) {
            case "DSD":
              this.metadata.setFormat("container", `DSDIFF/${type}`);
              this.metadata.setFormat("lossless", true);
              return this.readFmt8Chunks(header.chunkSize - BigInt(FourCcToken.len));
            default:
              throw new DsdiffContentParseError(`Unsupported DSDIFF type: ${type}`);
          }
        }
        async readFmt8Chunks(remainingSize) {
          while (remainingSize >= ChunkHeader64.len) {
            const chunkHeader = await this.tokenizer.readToken(ChunkHeader64);
            debug(`Chunk id=${chunkHeader.chunkID}`);
            await this.readData(chunkHeader);
            remainingSize -= BigInt(ChunkHeader64.len) + chunkHeader.chunkSize;
          }
        }
        async readData(header) {
          debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
          const p0 = this.tokenizer.position;
          switch (header.chunkID.trim()) {
            case "FVER": {
              const version = await this.tokenizer.readToken(UINT32_LE);
              debug(`DSDIFF version=${version}`);
              break;
            }
            case "PROP": {
              const propType = await this.tokenizer.readToken(FourCcToken);
              if (propType !== "SND ")
                throw new DsdiffContentParseError("Unexpected PROP-chunk ID");
              await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCcToken.len));
              break;
            }
            case "ID3": {
              const id3_data = await this.tokenizer.readToken(new Uint8ArrayType(Number(header.chunkSize)));
              const rst = fromBuffer$1(id3_data);
              await new ID3v2Parser().parse(this.metadata, rst, this.options);
              break;
            }
            case "DSD":
              if (this.metadata.format.numberOfChannels) {
                this.metadata.setFormat("numberOfSamples", Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));
              }
              if (this.metadata.format.numberOfSamples && this.metadata.format.sampleRate) {
                this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
              }
              break;
            default:
              debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
              break;
          }
          const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);
          if (remaining > 0) {
            debug(`After Parsing chunk, remaining ${remaining} bytes`);
            await this.tokenizer.ignore(Number(remaining));
          }
        }
        async handleSoundPropertyChunks(remainingSize) {
          debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
          while (remainingSize > 0) {
            const sndPropHeader = await this.tokenizer.readToken(ChunkHeader64);
            debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
            const p0 = this.tokenizer.position;
            switch (sndPropHeader.chunkID.trim()) {
              case "FS": {
                const sampleRate = await this.tokenizer.readToken(UINT32_BE);
                this.metadata.setFormat("sampleRate", sampleRate);
                break;
              }
              case "CHNL": {
                const numChannels = await this.tokenizer.readToken(UINT16_BE);
                this.metadata.setFormat("numberOfChannels", numChannels);
                await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(UINT16_BE.len));
                break;
              }
              case "CMPR": {
                const compressionIdCode = (await this.tokenizer.readToken(FourCcToken)).trim();
                const count = await this.tokenizer.readToken(UINT8);
                const compressionName = await this.tokenizer.readToken(new StringType(count, "ascii"));
                if (compressionIdCode === "DSD") {
                  this.metadata.setFormat("lossless", true);
                  this.metadata.setFormat("bitsPerSample", 1);
                }
                this.metadata.setFormat("codec", `${compressionIdCode} (${compressionName})`);
                break;
              }
              case "ABSS": {
                const hours = await this.tokenizer.readToken(UINT16_BE);
                const minutes = await this.tokenizer.readToken(UINT8);
                const seconds = await this.tokenizer.readToken(UINT8);
                const samples = await this.tokenizer.readToken(UINT32_BE);
                debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);
                break;
              }
              case "LSCO": {
                const lsConfig = await this.tokenizer.readToken(UINT16_BE);
                debug(`LSCO lsConfig=${lsConfig}`);
                break;
              }
              default:
                debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
                await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));
            }
            const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);
            if (remaining > 0) {
              debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);
              await this.tokenizer.ignore(Number(remaining));
            }
            remainingSize -= BigInt(ChunkHeader64.len) + sndPropHeader.chunkSize;
            debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
          }
          if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {
            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;
            this.metadata.setFormat("bitrate", bitrate);
          }
        }
        async handleChannelChunks(remainingSize) {
          debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);
          const channels = [];
          while (remainingSize >= FourCcToken.len) {
            const channelId = await this.tokenizer.readToken(FourCcToken);
            debug(`Channel[ID=${channelId}]`);
            channels.push(channelId);
            remainingSize -= BigInt(FourCcToken.len);
          }
          debug(`Channels: ${channels.join(", ")}`);
          return channels;
        }
      } exports("DsdiffParser", DsdiffParser);

    })
  };
}));

System.register("./AiffParser-Bl4qv0ID-Bs_4-QGD.js", ['./__monkey.entry-SDvwpoNt.js', './ID3v2Parser-eXNf-3mE-7kzMCmWm.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var initDebug, BasicParser, FourCcToken, EndOfStreamError$1, Uint8ArrayType, fromBuffer$1, StringType, makeUnexpectedFileContentError, UINT16_BE, UINT32_BE, UINT8, ID3v2Parser;
  return {
    setters: [module => {
      initDebug = module.i;
      BasicParser = module.B;
      FourCcToken = module.F;
      EndOfStreamError$1 = module.E;
      Uint8ArrayType = module.U;
      fromBuffer$1 = module.n;
      StringType = module.S;
      makeUnexpectedFileContentError = module.m;
      UINT16_BE = module.d;
      UINT32_BE = module.a;
      UINT8 = module.c;
    }, module => {
      ID3v2Parser = module.I;
    }, null, null, null, null, null],
    execute: (function () {

      const compressionTypes = {
        NONE: "not compressed	PCM	Apple Computer",
        sowt: "PCM (byte swapped)",
        fl32: "32-bit floating point IEEE 32-bit float",
        fl64: "64-bit floating point IEEE 64-bit float	Apple Computer",
        alaw: "ALaw 2:1	8-bit ITU-T G.711 A-law",
        ulaw: "µLaw 2:1	8-bit ITU-T G.711 µ-law	Apple Computer",
        ULAW: "CCITT G.711 u-law 8-bit ITU-T G.711 µ-law",
        ALAW: "CCITT G.711 A-law 8-bit ITU-T G.711 A-law",
        FL32: "Float 32	IEEE 32-bit float "
      };
      class AiffContentError extends makeUnexpectedFileContentError("AIFF") {
      }
      class Common {
        constructor(header, isAifc) {
          this.isAifc = isAifc;
          const minimumChunkSize = isAifc ? 22 : 18;
          if (header.chunkSize < minimumChunkSize)
            throw new AiffContentError(`COMMON CHUNK size should always be at least ${minimumChunkSize}`);
          this.len = header.chunkSize;
        }
        get(buf, off) {
          const shift = UINT16_BE.get(buf, off + 8) - 16398;
          const baseSampleRate = UINT16_BE.get(buf, off + 8 + 2);
          const res = {
            numChannels: UINT16_BE.get(buf, off),
            numSampleFrames: UINT32_BE.get(buf, off + 2),
            sampleSize: UINT16_BE.get(buf, off + 6),
            sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift
          };
          if (this.isAifc) {
            res.compressionType = FourCcToken.get(buf, off + 18);
            if (this.len > 22) {
              const strLen = UINT8.get(buf, off + 22);
              if (strLen > 0) {
                const padding = (strLen + 1) % 2;
                if (23 + strLen + padding === this.len) {
                  res.compressionName = new StringType(strLen, "latin1").get(buf, off + 23);
                } else {
                  throw new AiffContentError("Illegal pstring length");
                }
              } else {
                res.compressionName = void 0;
              }
            }
          } else {
            res.compressionName = "PCM";
          }
          return res;
        }
      }
      const Header = {
        len: 8,
        get: (buf, off) => {
          return {
            // Chunk type ID
            chunkID: FourCcToken.get(buf, off),
            // Chunk size
            chunkSize: Number(BigInt(UINT32_BE.get(buf, off + 4)))
          };
        }
      };
      const debug = initDebug("music-metadata:parser:aiff");
      class AIFFParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.isCompressed = null;
        }
        async parse() {
          const header = await this.tokenizer.readToken(Header);
          if (header.chunkID !== "FORM")
            throw new AiffContentError("Invalid Chunk-ID, expected 'FORM'");
          const type = await this.tokenizer.readToken(FourCcToken);
          switch (type) {
            case "AIFF":
              this.metadata.setFormat("container", type);
              this.isCompressed = false;
              break;
            case "AIFC":
              this.metadata.setFormat("container", "AIFF-C");
              this.isCompressed = true;
              break;
            default:
              throw new AiffContentError(`Unsupported AIFF type: ${type}`);
          }
          this.metadata.setFormat("lossless", !this.isCompressed);
          try {
            while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= Header.len) {
              debug(`Reading AIFF chunk at offset=${this.tokenizer.position}`);
              const chunkHeader = await this.tokenizer.readToken(Header);
              const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);
              const bytesRead = await this.readData(chunkHeader);
              await this.tokenizer.ignore(nextChunk - bytesRead);
            }
          } catch (err) {
            if (err instanceof EndOfStreamError$1) {
              debug("End-of-stream");
            } else {
              throw err;
            }
          }
        }
        async readData(header) {
          switch (header.chunkID) {
            case "COMM": {
              if (this.isCompressed === null) {
                throw new AiffContentError("Failed to parse AIFF.COMM chunk when compression type is unknown");
              }
              const common = await this.tokenizer.readToken(new Common(header, this.isCompressed));
              this.metadata.setFormat("bitsPerSample", common.sampleSize);
              this.metadata.setFormat("sampleRate", common.sampleRate);
              this.metadata.setFormat("numberOfChannels", common.numChannels);
              this.metadata.setFormat("numberOfSamples", common.numSampleFrames);
              this.metadata.setFormat("duration", common.numSampleFrames / common.sampleRate);
              if (common.compressionName || common.compressionType) {
                this.metadata.setFormat("codec", common.compressionName ?? compressionTypes[common.compressionType]);
              }
              return header.chunkSize;
            }
            case "ID3 ": {
              const id3_data = await this.tokenizer.readToken(new Uint8ArrayType(header.chunkSize));
              const rst = fromBuffer$1(id3_data);
              await new ID3v2Parser().parse(this.metadata, rst, this.options);
              return header.chunkSize;
            }
            case "SSND":
              if (this.metadata.format.duration) {
                this.metadata.setFormat("bitrate", 8 * header.chunkSize / this.metadata.format.duration);
              }
              return 0;
            case "NAME":
            case "AUTH":
            case "(c) ":
            case "ANNO":
              return this.readTextChunk(header);
            default:
              debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);
              return 0;
          }
        }
        async readTextChunk(header) {
          const value = await this.tokenizer.readToken(new StringType(header.chunkSize, "ascii"));
          const values = value.split("\0").map((v) => v.trim()).filter((v) => v == null ? void 0 : v.length);
          await Promise.all(values.map((v) => this.metadata.addTag("AIFF", header.chunkID, v)));
          return header.chunkSize;
        }
      } exports("AIFFParser", AIFFParser);

    })
  };
}));

System.register("./DsfParser-D_jwx0gH-BdUENliv.js", ['./__monkey.entry-SDvwpoNt.js', './AbstractID3Parser-FIM36LHz-B5gpnOzd.js', './ID3v2Parser-eXNf-3mE-7kzMCmWm.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var initDebug, FourCcToken, UINT64_LE, INT64_LE, INT32_LE, makeUnexpectedFileContentError, AbstractID3Parser, ID3v2Parser;
  return {
    setters: [module => {
      initDebug = module.i;
      FourCcToken = module.F;
      UINT64_LE = module.e;
      INT64_LE = module.p;
      INT32_LE = module.q;
      makeUnexpectedFileContentError = module.m;
    }, module => {
      AbstractID3Parser = module.A;
    }, module => {
      ID3v2Parser = module.I;
    }, null, null, null, null, null],
    execute: (function () {

      const ChunkHeader = {
        len: 12,
        get: (buf, off) => {
          return { id: FourCcToken.get(buf, off), size: UINT64_LE.get(buf, off + 4) };
        }
      };
      const DsdChunk = {
        len: 16,
        get: (buf, off) => {
          return {
            fileSize: INT64_LE.get(buf, off),
            metadataPointer: INT64_LE.get(buf, off + 8)
          };
        }
      };
      var ChannelType;
      (function(ChannelType2) {
        ChannelType2[ChannelType2["mono"] = 1] = "mono";
        ChannelType2[ChannelType2["stereo"] = 2] = "stereo";
        ChannelType2[ChannelType2["channels"] = 3] = "channels";
        ChannelType2[ChannelType2["quad"] = 4] = "quad";
        ChannelType2[ChannelType2["4 channels"] = 5] = "4 channels";
        ChannelType2[ChannelType2["5 channels"] = 6] = "5 channels";
        ChannelType2[ChannelType2["5.1 channels"] = 7] = "5.1 channels";
      })(ChannelType || (ChannelType = {}));
      const FormatChunk = {
        len: 40,
        get: (buf, off) => {
          return {
            formatVersion: INT32_LE.get(buf, off),
            formatID: INT32_LE.get(buf, off + 4),
            channelType: INT32_LE.get(buf, off + 8),
            channelNum: INT32_LE.get(buf, off + 12),
            samplingFrequency: INT32_LE.get(buf, off + 16),
            bitsPerSample: INT32_LE.get(buf, off + 20),
            sampleCount: INT64_LE.get(buf, off + 24),
            blockSizePerChannel: INT32_LE.get(buf, off + 32)
          };
        }
      };
      const debug = initDebug("music-metadata:parser:DSF");
      class DsdContentParseError extends makeUnexpectedFileContentError("DSD") {
      } exports("DsdContentParseError", DsdContentParseError);
      class DsfParser extends AbstractID3Parser {
        async postId3v2Parse() {
          const p0 = this.tokenizer.position;
          const chunkHeader = await this.tokenizer.readToken(ChunkHeader);
          if (chunkHeader.id !== "DSD ")
            throw new DsdContentParseError("Invalid chunk signature");
          this.metadata.setFormat("container", "DSF");
          this.metadata.setFormat("lossless", true);
          const dsdChunk = await this.tokenizer.readToken(DsdChunk);
          if (dsdChunk.metadataPointer === BigInt(0)) {
            debug("No ID3v2 tag present");
          } else {
            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);
            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);
            await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);
            return new ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);
          }
        }
        async parseChunks(bytesRemaining) {
          while (bytesRemaining >= ChunkHeader.len) {
            const chunkHeader = await this.tokenizer.readToken(ChunkHeader);
            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);
            switch (chunkHeader.id) {
              case "fmt ": {
                const formatChunk = await this.tokenizer.readToken(FormatChunk);
                this.metadata.setFormat("numberOfChannels", formatChunk.channelNum);
                this.metadata.setFormat("sampleRate", formatChunk.samplingFrequency);
                this.metadata.setFormat("bitsPerSample", formatChunk.bitsPerSample);
                this.metadata.setFormat("numberOfSamples", formatChunk.sampleCount);
                this.metadata.setFormat("duration", Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);
                const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;
                this.metadata.setFormat("bitrate", bitrate);
                return;
              }
              default:
                this.tokenizer.ignore(Number(chunkHeader.size) - ChunkHeader.len);
                break;
            }
            bytesRemaining -= chunkHeader.size;
          }
        }
      } exports("DsfParser", DsfParser);

    })
  };
}));

System.register("./FlacParser-CxiwFQBW-BzeYKlyb.js", ['./__monkey.entry-SDvwpoNt.js', './VorbisParser-C_tWlZNb-Big__tIq.js', './AbstractID3Parser-FIM36LHz-B5gpnOzd.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge', './ID3v2Parser-eXNf-3mE-7kzMCmWm.js'], (function (exports, module) {
  'use strict';
  var initDebug, FourCcToken, Uint8ArrayType, getBit, getBitAllignedNumber, UINT24_BE, UINT16_BE, makeUnexpectedFileContentError, VorbisParser, VorbisPictureToken, VorbisDecoder, AbstractID3Parser;
  return {
    setters: [module => {
      initDebug = module.i;
      FourCcToken = module.F;
      Uint8ArrayType = module.U;
      getBit = module.j;
      getBitAllignedNumber = module.g;
      UINT24_BE = module.r;
      UINT16_BE = module.d;
      makeUnexpectedFileContentError = module.m;
    }, module => {
      VorbisParser = module.V;
      VorbisPictureToken = module.a;
      VorbisDecoder = module.b;
    }, module => {
      AbstractID3Parser = module.A;
    }, null, null, null, null, null, null],
    execute: (function () {

      const debug = initDebug("music-metadata:parser:FLAC");
      class FlacContentError extends makeUnexpectedFileContentError("FLAC") {
      }
      var BlockType;
      (function(BlockType2) {
        BlockType2[BlockType2["STREAMINFO"] = 0] = "STREAMINFO";
        BlockType2[BlockType2["PADDING"] = 1] = "PADDING";
        BlockType2[BlockType2["APPLICATION"] = 2] = "APPLICATION";
        BlockType2[BlockType2["SEEKTABLE"] = 3] = "SEEKTABLE";
        BlockType2[BlockType2["VORBIS_COMMENT"] = 4] = "VORBIS_COMMENT";
        BlockType2[BlockType2["CUESHEET"] = 5] = "CUESHEET";
        BlockType2[BlockType2["PICTURE"] = 6] = "PICTURE";
      })(BlockType || (BlockType = {}));
      class FlacParser extends AbstractID3Parser {
        constructor() {
          super(...arguments);
          this.vorbisParser = new VorbisParser(this.metadata, this.options);
          this.padding = 0;
        }
        async postId3v2Parse() {
          const fourCC = await this.tokenizer.readToken(FourCcToken);
          if (fourCC.toString() !== "fLaC") {
            throw new FlacContentError("Invalid FLAC preamble");
          }
          let blockHeader;
          do {
            blockHeader = await this.tokenizer.readToken(BlockHeader);
            await this.parseDataBlock(blockHeader);
          } while (!blockHeader.lastBlock);
          if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {
            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;
            this.metadata.setFormat("bitrate", 8 * dataSize / this.metadata.format.duration);
          }
        }
        async parseDataBlock(blockHeader) {
          debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);
          switch (blockHeader.type) {
            case BlockType.STREAMINFO:
              return this.parseBlockStreamInfo(blockHeader.length);
            case BlockType.PADDING:
              this.padding += blockHeader.length;
              break;
            case BlockType.APPLICATION:
              break;
            case BlockType.SEEKTABLE:
              break;
            case BlockType.VORBIS_COMMENT:
              return this.parseComment(blockHeader.length);
            case BlockType.CUESHEET:
              break;
            case BlockType.PICTURE:
              await this.parsePicture(blockHeader.length);
              return;
            default:
              this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);
          }
          return this.tokenizer.ignore(blockHeader.length).then();
        }
        /**
         * Parse STREAMINFO
         */
        async parseBlockStreamInfo(dataLen) {
          if (dataLen !== BlockStreamInfo.len)
            throw new FlacContentError("Unexpected block-stream-info length");
          const streamInfo = await this.tokenizer.readToken(BlockStreamInfo);
          this.metadata.setFormat("container", "FLAC");
          this.metadata.setFormat("codec", "FLAC");
          this.metadata.setFormat("lossless", true);
          this.metadata.setFormat("numberOfChannels", streamInfo.channels);
          this.metadata.setFormat("bitsPerSample", streamInfo.bitsPerSample);
          this.metadata.setFormat("sampleRate", streamInfo.sampleRate);
          if (streamInfo.totalSamples > 0) {
            this.metadata.setFormat("duration", streamInfo.totalSamples / streamInfo.sampleRate);
          }
        }
        /**
         * Parse VORBIS_COMMENT
         * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3
         */
        async parseComment(dataLen) {
          const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));
          const decoder = new VorbisDecoder(data, 0);
          decoder.readStringUtf8();
          const commentListLength = decoder.readInt32();
          const tags = new Array(commentListLength);
          for (let i = 0; i < commentListLength; i++) {
            tags[i] = decoder.parseUserComment();
          }
          await Promise.all(tags.map((tag) => this.vorbisParser.addTag(tag.key, tag.value)));
        }
        async parsePicture(dataLen) {
          if (this.options.skipCovers) {
            return this.tokenizer.ignore(dataLen);
          }
          const picture = await this.tokenizer.readToken(new VorbisPictureToken(dataLen));
          this.vorbisParser.addTag("METADATA_BLOCK_PICTURE", picture);
        }
      } exports("FlacParser", FlacParser);
      const BlockHeader = {
        len: 4,
        get: (buf, off) => {
          return {
            lastBlock: getBit(buf, off, 7),
            type: getBitAllignedNumber(buf, off, 1, 7),
            length: UINT24_BE.get(buf, off + 1)
          };
        }
      };
      const BlockStreamInfo = {
        len: 34,
        get: (buf, off) => {
          return {
            // The minimum block size (in samples) used in the stream.
            minimumBlockSize: UINT16_BE.get(buf, off),
            // The maximum block size (in samples) used in the stream.
            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.
            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1e3,
            // The minimum frame size (in bytes) used in the stream.
            // May be 0 to imply the value is not known.
            minimumFrameSize: UINT24_BE.get(buf, off + 4),
            // The maximum frame size (in bytes) used in the stream.
            // May be 0 to imply the value is not known.
            maximumFrameSize: UINT24_BE.get(buf, off + 7),
            // Sample rate in Hz. Though 20 bits are available,
            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.
            // Also, a value of 0 is invalid.
            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,
            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),
            // (number of channels)-1. FLAC supports from 1 to 8 channels
            channels: getBitAllignedNumber(buf, off + 12, 4, 3) + 1,
            // bits per sample)-1.
            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.
            bitsPerSample: getBitAllignedNumber(buf, off + 12, 7, 5) + 1,
            // Total samples in stream.
            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.
            // A value of zero here means the number of total samples is unknown.
            totalSamples: getBitAllignedNumber(buf, off + 13, 4, 36),
            // the MD5 hash of the file (see notes for usage... it's a littly tricky)
            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)
          };
        }
      };

    })
  };
}));

System.register("./MatroskaParser-DlYom4Kd-CpEy0LtJ.js", ['./__monkey.entry-SDvwpoNt.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var initDebug, BasicParser, TargetType, TrackType, EndOfStreamError$1, UINT8, Float64_BE, Float32_BE, StringType, UINT64_BE, makeUnexpectedFileContentError;
  return {
    setters: [module => {
      initDebug = module.i;
      BasicParser = module.B;
      TargetType = module.t;
      TrackType = module.T;
      EndOfStreamError$1 = module.E;
      UINT8 = module.c;
      Float64_BE = module.v;
      Float32_BE = module.w;
      StringType = module.S;
      UINT64_BE = module.x;
      makeUnexpectedFileContentError = module.m;
    }, null, null, null, null, null],
    execute: (function () {

      var DataType;
      (function(DataType2) {
        DataType2[DataType2["string"] = 0] = "string";
        DataType2[DataType2["uint"] = 1] = "uint";
        DataType2[DataType2["uid"] = 2] = "uid";
        DataType2[DataType2["bool"] = 3] = "bool";
        DataType2[DataType2["binary"] = 4] = "binary";
        DataType2[DataType2["float"] = 5] = "float";
      })(DataType || (DataType = {}));
      const matroskaDtd = {
        name: "dtd",
        container: {
          440786851: {
            name: "ebml",
            container: {
              17030: { name: "ebmlVersion", value: DataType.uint },
              // 5.1.1
              17143: { name: "ebmlReadVersion", value: DataType.uint },
              // 5.1.2
              17138: { name: "ebmlMaxIDWidth", value: DataType.uint },
              // 5.1.3
              17139: { name: "ebmlMaxSizeWidth", value: DataType.uint },
              // 5.1.4
              17026: { name: "docType", value: DataType.string },
              // 5.1.5
              17031: { name: "docTypeVersion", value: DataType.uint },
              // 5.1.6
              17029: { name: "docTypeReadVersion", value: DataType.uint }
              // 5.1.7
            }
          },
          // Matroska segments
          408125543: {
            name: "segment",
            container: {
              // Meta Seek Information (also known as MetaSeek)
              290298740: {
                name: "seekHead",
                container: {
                  19899: {
                    name: "seek",
                    multiple: true,
                    container: {
                      21419: { name: "id", value: DataType.binary },
                      21420: { name: "position", value: DataType.uint }
                    }
                  }
                }
              },
              // Segment Information
              357149030: {
                name: "info",
                container: {
                  29604: { name: "uid", value: DataType.uid },
                  29572: { name: "filename", value: DataType.string },
                  3979555: { name: "prevUID", value: DataType.uid },
                  3965867: { name: "prevFilename", value: DataType.string },
                  4110627: { name: "nextUID", value: DataType.uid },
                  4096955: { name: "nextFilename", value: DataType.string },
                  2807729: { name: "timecodeScale", value: DataType.uint },
                  17545: { name: "duration", value: DataType.float },
                  17505: { name: "dateUTC", value: DataType.uint },
                  31657: { name: "title", value: DataType.string },
                  19840: { name: "muxingApp", value: DataType.string },
                  22337: { name: "writingApp", value: DataType.string }
                }
              },
              // Cluster
              524531317: {
                name: "cluster",
                multiple: true,
                container: {
                  231: { name: "timecode", value: DataType.uid },
                  22743: { name: "silentTracks ", multiple: true },
                  167: { name: "position", value: DataType.uid },
                  171: { name: "prevSize", value: DataType.uid },
                  160: { name: "blockGroup" },
                  163: { name: "simpleBlock" }
                }
              },
              // Track
              374648427: {
                name: "tracks",
                container: {
                  174: {
                    name: "entries",
                    multiple: true,
                    container: {
                      215: { name: "trackNumber", value: DataType.uint },
                      29637: { name: "uid", value: DataType.uid },
                      131: { name: "trackType", value: DataType.uint },
                      185: { name: "flagEnabled", value: DataType.bool },
                      136: { name: "flagDefault", value: DataType.bool },
                      21930: { name: "flagForced", value: DataType.bool },
                      // extended
                      156: { name: "flagLacing", value: DataType.bool },
                      28135: { name: "minCache", value: DataType.uint },
                      28136: { name: "maxCache", value: DataType.uint },
                      2352003: { name: "defaultDuration", value: DataType.uint },
                      2306383: { name: "timecodeScale", value: DataType.float },
                      21358: { name: "name", value: DataType.string },
                      2274716: { name: "language", value: DataType.string },
                      134: { name: "codecID", value: DataType.string },
                      25506: { name: "codecPrivate", value: DataType.binary },
                      2459272: { name: "codecName", value: DataType.string },
                      3839639: { name: "codecSettings", value: DataType.string },
                      3883072: { name: "codecInfoUrl", value: DataType.string },
                      2536e3: { name: "codecDownloadUrl", value: DataType.string },
                      170: { name: "codecDecodeAll", value: DataType.bool },
                      28587: { name: "trackOverlay", value: DataType.uint },
                      // Video
                      224: {
                        name: "video",
                        container: {
                          154: { name: "flagInterlaced", value: DataType.bool },
                          21432: { name: "stereoMode", value: DataType.uint },
                          176: { name: "pixelWidth", value: DataType.uint },
                          186: { name: "pixelHeight", value: DataType.uint },
                          21680: { name: "displayWidth", value: DataType.uint },
                          21690: { name: "displayHeight", value: DataType.uint },
                          21683: { name: "aspectRatioType", value: DataType.uint },
                          3061028: { name: "colourSpace", value: DataType.uint },
                          3126563: { name: "gammaValue", value: DataType.float }
                        }
                      },
                      // Audio
                      225: {
                        name: "audio",
                        container: {
                          181: { name: "samplingFrequency", value: DataType.float },
                          30901: { name: "outputSamplingFrequency", value: DataType.float },
                          159: { name: "channels", value: DataType.uint },
                          // https://www.matroska.org/technical/specs/index.html
                          148: { name: "channels", value: DataType.uint },
                          32123: { name: "channelPositions", value: DataType.binary },
                          25188: { name: "bitDepth", value: DataType.uint }
                        }
                      },
                      // Content Encoding
                      28032: {
                        name: "contentEncodings",
                        container: {
                          25152: {
                            name: "contentEncoding",
                            container: {
                              20529: { name: "order", value: DataType.uint },
                              20530: { name: "scope", value: DataType.bool },
                              20531: { name: "type", value: DataType.uint },
                              20532: {
                                name: "contentEncoding",
                                container: {
                                  16980: { name: "contentCompAlgo", value: DataType.uint },
                                  16981: { name: "contentCompSettings", value: DataType.binary }
                                }
                              },
                              20533: {
                                name: "contentEncoding",
                                container: {
                                  18401: { name: "contentEncAlgo", value: DataType.uint },
                                  18402: { name: "contentEncKeyID", value: DataType.binary },
                                  18403: { name: "contentSignature ", value: DataType.binary },
                                  18404: { name: "ContentSigKeyID  ", value: DataType.binary },
                                  18405: { name: "contentSigAlgo ", value: DataType.uint },
                                  18406: { name: "contentSigHashAlgo ", value: DataType.uint }
                                }
                              },
                              25188: { name: "bitDepth", value: DataType.uint }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              // Cueing Data
              475249515: {
                name: "cues",
                container: {
                  187: {
                    name: "cuePoint",
                    container: {
                      179: { name: "cueTime", value: DataType.uid },
                      183: {
                        name: "positions",
                        container: {
                          247: { name: "track", value: DataType.uint },
                          241: { name: "clusterPosition", value: DataType.uint },
                          21368: { name: "blockNumber", value: DataType.uint },
                          234: { name: "codecState", value: DataType.uint },
                          219: {
                            name: "reference",
                            container: {
                              150: { name: "time", value: DataType.uint },
                              151: { name: "cluster", value: DataType.uint },
                              21343: { name: "number", value: DataType.uint },
                              235: { name: "codecState", value: DataType.uint }
                            }
                          },
                          240: { name: "relativePosition", value: DataType.uint }
                          // extended
                        }
                      }
                    }
                  }
                }
              },
              // Attachment
              423732329: {
                name: "attachments",
                container: {
                  24999: {
                    name: "attachedFiles",
                    multiple: true,
                    container: {
                      18046: { name: "description", value: DataType.string },
                      18030: { name: "name", value: DataType.string },
                      18016: { name: "mimeType", value: DataType.string },
                      18012: { name: "data", value: DataType.binary },
                      18094: { name: "uid", value: DataType.uid }
                    }
                  }
                }
              },
              // Chapters
              272869232: {
                name: "chapters",
                container: {
                  17849: {
                    name: "editionEntry",
                    container: {
                      182: {
                        name: "chapterAtom",
                        container: {
                          29636: { name: "uid", value: DataType.uid },
                          145: { name: "timeStart", value: DataType.uint },
                          146: { name: "timeEnd", value: DataType.uid },
                          152: { name: "hidden", value: DataType.bool },
                          17816: { name: "enabled", value: DataType.uid },
                          143: {
                            name: "track",
                            container: {
                              137: { name: "trackNumber", value: DataType.uid },
                              128: {
                                name: "display",
                                container: {
                                  133: { name: "string", value: DataType.string },
                                  17276: { name: "language ", value: DataType.string },
                                  17278: { name: "country ", value: DataType.string }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              // Tagging
              307544935: {
                name: "tags",
                container: {
                  29555: {
                    name: "tag",
                    multiple: true,
                    container: {
                      25536: {
                        name: "target",
                        container: {
                          25541: { name: "tagTrackUID", value: DataType.uid },
                          25540: { name: "tagChapterUID", value: DataType.uint },
                          25542: { name: "tagAttachmentUID", value: DataType.uid },
                          25546: { name: "targetType", value: DataType.string },
                          // extended
                          26826: { name: "targetTypeValue", value: DataType.uint },
                          // extended
                          25545: { name: "tagEditionUID", value: DataType.uid }
                          // extended
                        }
                      },
                      26568: {
                        name: "simpleTags",
                        multiple: true,
                        container: {
                          17827: { name: "name", value: DataType.string },
                          17543: { name: "string", value: DataType.string },
                          17541: { name: "binary", value: DataType.binary },
                          17530: { name: "language", value: DataType.string },
                          // extended
                          17531: { name: "languageIETF", value: DataType.string },
                          // extended
                          17540: { name: "default", value: DataType.bool }
                          // extended
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      };
      const debug$1 = initDebug("music-metadata:parser:ebml");
      class EbmlContentError extends makeUnexpectedFileContentError("EBML") {
      }
      var ParseAction;
      (function(ParseAction2) {
        ParseAction2[ParseAction2["ReadNext"] = 0] = "ReadNext";
        ParseAction2[ParseAction2["IgnoreElement"] = 2] = "IgnoreElement";
        ParseAction2[ParseAction2["SkipSiblings"] = 3] = "SkipSiblings";
        ParseAction2[ParseAction2["TerminateParsing"] = 4] = "TerminateParsing";
        ParseAction2[ParseAction2["SkipElement"] = 5] = "SkipElement";
      })(ParseAction || (ParseAction = {}));
      class EbmlIterator {
        /**
         * @param {ITokenizer} tokenizer Input
         * @param tokenizer
         */
        constructor(tokenizer) {
          this.tokenizer = tokenizer;
          this.padding = 0;
          this.parserMap = /* @__PURE__ */ new Map();
          this.ebmlMaxIDLength = 4;
          this.ebmlMaxSizeLength = 8;
          this.parserMap.set(DataType.uint, (e) => this.readUint(e));
          this.parserMap.set(DataType.string, (e) => this.readString(e));
          this.parserMap.set(DataType.binary, (e) => this.readBuffer(e));
          this.parserMap.set(DataType.uid, async (e) => this.readBuffer(e));
          this.parserMap.set(DataType.bool, (e) => this.readFlag(e));
          this.parserMap.set(DataType.float, (e) => this.readFloat(e));
        }
        async iterate(dtdElement, posDone, listener) {
          return this.parseContainer(linkParents(dtdElement), posDone, listener);
        }
        async parseContainer(dtdElement, posDone, listener) {
          const tree = {};
          while (this.tokenizer.position < posDone) {
            let element;
            const elementPosition = this.tokenizer.position;
            try {
              element = await this.readElement();
            } catch (error) {
              if (error instanceof EndOfStreamError$1) {
                break;
              }
              throw error;
            }
            const child = dtdElement.container[element.id];
            if (child) {
              const action = listener.startNext(child);
              switch (action) {
                case ParseAction.ReadNext:
                  {
                    if (element.id === 524531317) ;
                    debug$1(`Read element: name=${getElementPath(child)}{id=0x${element.id.toString(16)}, container=${!!child.container}} at position=${elementPosition}`);
                    if (child.container) {
                      const res = await this.parseContainer(child, element.len >= 0 ? this.tokenizer.position + element.len : -1, listener);
                      if (child.multiple) {
                        if (!tree[child.name]) {
                          tree[child.name] = [];
                        }
                        tree[child.name].push(res);
                      } else {
                        tree[child.name] = res;
                      }
                      await listener.elementValue(child, res, elementPosition);
                    } else {
                      const parser = this.parserMap.get(child.value);
                      if (typeof parser === "function") {
                        const value = await parser(element);
                        tree[child.name] = value;
                        await listener.elementValue(child, value, elementPosition);
                      }
                    }
                  }
                  break;
                case ParseAction.SkipElement:
                  debug$1(`Go to next element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
                  break;
                case ParseAction.IgnoreElement:
                  debug$1(`Ignore element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
                  await this.tokenizer.ignore(element.len);
                  break;
                case ParseAction.SkipSiblings:
                  debug$1(`Ignore remaining container, at: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
                  await this.tokenizer.ignore(posDone - this.tokenizer.position);
                  break;
                case ParseAction.TerminateParsing:
                  debug$1(`Terminate parsing at element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);
                  return tree;
              }
            } else {
              switch (element.id) {
                case 236:
                  this.padding += element.len;
                  await this.tokenizer.ignore(element.len);
                  break;
                default:
                  debug$1(`parseEbml: parent=${getElementPath(dtdElement)}, unknown child: id=${element.id.toString(16)} at position=${elementPosition}`);
                  this.padding += element.len;
                  await this.tokenizer.ignore(element.len);
              }
            }
          }
          return tree;
        }
        async readVintData(maxLength) {
          const msb = await this.tokenizer.peekNumber(UINT8);
          let mask = 128;
          let oc = 1;
          while ((msb & mask) === 0) {
            if (oc > maxLength) {
              throw new EbmlContentError("VINT value exceeding maximum size");
            }
            ++oc;
            mask >>= 1;
          }
          const id = new Uint8Array(oc);
          await this.tokenizer.readBuffer(id);
          return id;
        }
        async readElement() {
          const id = await this.readVintData(this.ebmlMaxIDLength);
          const lenField = await this.readVintData(this.ebmlMaxSizeLength);
          lenField[0] ^= 128 >> lenField.length - 1;
          return {
            id: readUIntBE(id, id.length),
            len: readUIntBE(lenField, lenField.length)
          };
        }
        async readFloat(e) {
          switch (e.len) {
            case 0:
              return 0;
            case 4:
              return this.tokenizer.readNumber(Float32_BE);
            case 8:
              return this.tokenizer.readNumber(Float64_BE);
            case 10:
              return this.tokenizer.readNumber(Float64_BE);
            default:
              throw new EbmlContentError(`Invalid IEEE-754 float length: ${e.len}`);
          }
        }
        async readFlag(e) {
          return await this.readUint(e) === 1;
        }
        async readUint(e) {
          const buf = await this.readBuffer(e);
          return readUIntBE(buf, e.len);
        }
        async readString(e) {
          const rawString = await this.tokenizer.readToken(new StringType(e.len, "utf-8"));
          return rawString.replace(/\x00.*$/g, "");
        }
        async readBuffer(e) {
          const buf = new Uint8Array(e.len);
          await this.tokenizer.readBuffer(buf);
          return buf;
        }
      }
      function readUIntBE(buf, len) {
        return Number(readUIntBeAsBigInt(buf, len));
      }
      function readUIntBeAsBigInt(buf, len) {
        const normalizedNumber = new Uint8Array(8);
        const cleanNumber = buf.subarray(0, len);
        try {
          normalizedNumber.set(cleanNumber, 8 - len);
          return UINT64_BE.get(normalizedNumber, 0);
        } catch (error) {
          return BigInt(-1);
        }
      }
      function linkParents(element) {
        if (element.container) {
          Object.keys(element.container).map((id) => {
            const child = element.container[id];
            child.id = Number.parseInt(id);
            return child;
          }).forEach((child) => {
            child.parent = element;
            linkParents(child);
          });
        }
        return element;
      }
      function getElementPath(element) {
        let path = "";
        if (element.parent && element.parent.name !== "dtd") {
          path += `${getElementPath(element.parent)}/`;
        }
        return path + element.name;
      }
      const debug = initDebug("music-metadata:parser:matroska");
      class MatroskaParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.seekHeadOffset = 0;
          this.flagUseIndexToSkipClusters = this.options.mkvUseIndex ?? false;
        }
        async parse() {
          const containerSize = this.tokenizer.fileInfo.size ?? Number.MAX_SAFE_INTEGER;
          const matroskaIterator = new EbmlIterator(this.tokenizer);
          debug("Initializing DTD end MatroskaIterator");
          await matroskaIterator.iterate(matroskaDtd, containerSize, {
            startNext: (element) => {
              switch (element.id) {
                case 475249515:
                  debug(`Skip element: name=${element.name}, id=0x${element.id.toString(16)}`);
                  return ParseAction.IgnoreElement;
                case 524531317:
                  if (this.flagUseIndexToSkipClusters && this.seekHead) {
                    const index = this.seekHead.seek.find((index2) => index2.position + this.seekHeadOffset > this.tokenizer.position);
                    if (index) {
                      const ignoreSize = index.position + this.seekHeadOffset - this.tokenizer.position;
                      debug(`Use index to go to next position, ignoring ${ignoreSize} bytes`);
                      this.tokenizer.ignore(ignoreSize);
                      return ParseAction.SkipElement;
                    }
                  }
                  return ParseAction.IgnoreElement;
                default:
                  return ParseAction.ReadNext;
              }
            },
            elementValue: async (element, value, offset) => {
              debug(`Received: name=${element.name}, value=${value}`);
              switch (element.id) {
                case 17026:
                  this.metadata.setFormat("container", `EBML/${value}`);
                  break;
                case 290298740:
                  this.seekHead = value;
                  this.seekHeadOffset = offset;
                  break;
                case 357149030:
                  {
                    const info = value;
                    const timecodeScale = info.timecodeScale ? info.timecodeScale : 1e6;
                    if (typeof info.duration === "number") {
                      const duration = info.duration * timecodeScale / 1e9;
                      await this.addTag("segment:title", info.title);
                      this.metadata.setFormat("duration", Number(duration));
                    }
                  }
                  break;
                case 374648427:
                  {
                    const audioTracks = value;
                    if (audioTracks == null ? void 0 : audioTracks.entries) {
                      audioTracks.entries.forEach((entry) => {
                        const stream = {
                          codecName: entry.codecID.replace("A_", "").replace("V_", ""),
                          codecSettings: entry.codecSettings,
                          flagDefault: entry.flagDefault,
                          flagLacing: entry.flagLacing,
                          flagEnabled: entry.flagEnabled,
                          language: entry.language,
                          name: entry.name,
                          type: entry.trackType,
                          audio: entry.audio,
                          video: entry.video
                        };
                        this.metadata.addStreamInfo(stream);
                      });
                      const audioTrack = audioTracks.entries.filter((entry) => entry.trackType === TrackType.audio).reduce((acc, cur) => {
                        if (!acc)
                          return cur;
                        if (cur.flagDefault && !acc.flagDefault)
                          return cur;
                        if (cur.trackNumber < acc.trackNumber)
                          return cur;
                        return acc;
                      }, null);
                      if (audioTrack) {
                        this.metadata.setFormat("codec", audioTrack.codecID.replace("A_", ""));
                        this.metadata.setFormat("sampleRate", audioTrack.audio.samplingFrequency);
                        this.metadata.setFormat("numberOfChannels", audioTrack.audio.channels);
                      }
                    }
                  }
                  break;
                case 307544935:
                  {
                    const tags = value;
                    await Promise.all(tags.tag.map(async (tag) => {
                      const target = tag.target;
                      const targetType = (target == null ? void 0 : target.targetTypeValue) ? TargetType[target.targetTypeValue] : (target == null ? void 0 : target.targetType) ? target.targetType : "track";
                      await Promise.all(tag.simpleTags.map(async (simpleTag) => {
                        const value2 = simpleTag.string ? simpleTag.string : simpleTag.binary;
                        await this.addTag(`${targetType}:${simpleTag.name}`, value2);
                      }));
                    }));
                  }
                  break;
                case 423732329:
                  {
                    const attachments = value;
                    await Promise.all(attachments.attachedFiles.filter((file) => file.mimeType.startsWith("image/")).map((file) => this.addTag("picture", {
                      data: file.data,
                      format: file.mimeType,
                      description: file.description,
                      name: file.name
                    })));
                  }
                  break;
              }
            }
          });
        }
        async addTag(tagId, value) {
          await this.metadata.addTag("matroska", tagId, value);
        }
      } exports("MatroskaParser", MatroskaParser);

    })
  };
}));

System.register("./MP4Parser-CJGrwS9Y-yroBH10s.js", ['./__monkey.entry-SDvwpoNt.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var initDebug, BasicParser, UINT32_BE, StringType, Token, TrackType, Uint8ArrayType, uint8ArrayToHex, uint8ArrayToString, UINT16_BE, UINT8, makeUnexpectedFileContentError, FourCcToken, UINT24_BE, INT16_BE, INT32_BE, INT8, INT24_BE, Genres, UINT64_BE;
  return {
    setters: [module => {
      initDebug = module.i;
      BasicParser = module.B;
      UINT32_BE = module.a;
      StringType = module.S;
      Token = module.y;
      TrackType = module.T;
      Uint8ArrayType = module.U;
      uint8ArrayToHex = module.u;
      uint8ArrayToString = module.z;
      UINT16_BE = module.d;
      UINT8 = module.c;
      makeUnexpectedFileContentError = module.m;
      FourCcToken = module.F;
      UINT24_BE = module.r;
      INT16_BE = module.I;
      INT32_BE = module.C;
      INT8 = module.D;
      INT24_BE = module.G;
      Genres = module.H;
      UINT64_BE = module.x;
    }, null, null, null, null, null],
    execute: (function () {

      const debug$2 = initDebug("music-metadata:parser:MP4:atom");
      class Mp4ContentError extends makeUnexpectedFileContentError("MP4") {
      }
      const Header = {
        len: 8,
        get: (buf, off) => {
          const length = UINT32_BE.get(buf, off);
          if (length < 0)
            throw new Mp4ContentError("Invalid atom header length");
          return {
            length: BigInt(length),
            name: new StringType(4, "latin1").get(buf, off + 4)
          };
        },
        put: (buf, off, hdr) => {
          UINT32_BE.put(buf, off, Number(hdr.length));
          return FourCcToken.put(buf, off + 4, hdr.name);
        }
      };
      const ExtendedSize = UINT64_BE;
      const ftyp = {
        len: 4,
        get: (buf, off) => {
          return {
            type: new StringType(4, "ascii").get(buf, off)
          };
        }
      };
      class FixedLengthAtom {
        /**
         *
         * @param {number} len Length as specified in the size field
         * @param {number} expLen Total length of sum of specified fields in the standard
         * @param atomId Atom ID
         */
        constructor(len, expLen, atomId) {
          this.len = len;
          if (len < expLen) {
            throw new Mp4ContentError(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);
          }
          if (len > expLen) {
            debug$2(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);
          }
        }
      }
      const SecondsSinceMacEpoch = {
        len: 4,
        get: (buf, off) => {
          const secondsSinceUnixEpoch = UINT32_BE.get(buf, off) - 2082844800;
          return new Date(secondsSinceUnixEpoch * 1e3);
        }
      };
      class MdhdAtom extends FixedLengthAtom {
        constructor(len) {
          super(len, 24, "mdhd");
          this.len = len;
        }
        get(buf, off) {
          return {
            version: UINT8.get(buf, off + 0),
            flags: UINT24_BE.get(buf, off + 1),
            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
            timeScale: UINT32_BE.get(buf, off + 12),
            duration: UINT32_BE.get(buf, off + 16),
            language: UINT16_BE.get(buf, off + 20),
            quality: UINT16_BE.get(buf, off + 22)
          };
        }
      }
      class MvhdAtom extends FixedLengthAtom {
        constructor(len) {
          super(len, 100, "mvhd");
          this.len = len;
        }
        get(buf, off) {
          return {
            version: UINT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
            timeScale: UINT32_BE.get(buf, off + 12),
            duration: UINT32_BE.get(buf, off + 16),
            preferredRate: UINT32_BE.get(buf, off + 20),
            preferredVolume: UINT16_BE.get(buf, off + 24),
            // ignore reserver: 10 bytes
            // ignore matrix structure: 36 bytes
            previewTime: UINT32_BE.get(buf, off + 72),
            previewDuration: UINT32_BE.get(buf, off + 76),
            posterTime: UINT32_BE.get(buf, off + 80),
            selectionTime: UINT32_BE.get(buf, off + 84),
            selectionDuration: UINT32_BE.get(buf, off + 88),
            currentTime: UINT32_BE.get(buf, off + 92),
            nextTrackID: UINT32_BE.get(buf, off + 96)
          };
        }
      }
      class DataAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          return {
            type: {
              set: UINT8.get(buf, off + 0),
              type: UINT24_BE.get(buf, off + 1)
            },
            locale: UINT24_BE.get(buf, off + 4),
            value: new Uint8ArrayType(this.len - 8).get(buf, off + 8)
          };
        }
      }
      class NameAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          return {
            version: UINT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            name: new StringType(this.len - 4, "utf-8").get(buf, off + 4)
          };
        }
      }
      class TrackHeaderAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          return {
            version: UINT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),
            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),
            trackId: UINT32_BE.get(buf, off + 12),
            // reserved 4 bytes
            duration: UINT32_BE.get(buf, off + 20),
            layer: UINT16_BE.get(buf, off + 24),
            alternateGroup: UINT16_BE.get(buf, off + 26),
            volume: UINT16_BE.get(buf, off + 28)
            // ToDo: fixed point
            // ToDo: add remaining fields
          };
        }
      }
      const stsdHeader = {
        len: 8,
        get: (buf, off) => {
          return {
            version: UINT8.get(buf, off),
            flags: UINT24_BE.get(buf, off + 1),
            numberOfEntries: UINT32_BE.get(buf, off + 4)
          };
        }
      };
      class SampleDescriptionTable {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const descrLen = this.len - 12;
          return {
            dataFormat: FourCcToken.get(buf, off),
            dataReferenceIndex: UINT16_BE.get(buf, off + 10),
            description: descrLen > 0 ? new Uint8ArrayType(descrLen).get(buf, off + 12) : void 0
          };
        }
      }
      class StsdAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const header = stsdHeader.get(buf, off);
          off += stsdHeader.len;
          const table = [];
          for (let n = 0; n < header.numberOfEntries; ++n) {
            const size = UINT32_BE.get(buf, off);
            off += UINT32_BE.len;
            table.push(new SampleDescriptionTable(size - UINT32_BE.len).get(buf, off));
            off += size;
          }
          return {
            header,
            table
          };
        }
      }
      const SoundSampleDescriptionVersion = {
        len: 8,
        get(buf, off) {
          return {
            version: INT16_BE.get(buf, off),
            revision: INT16_BE.get(buf, off + 2),
            vendor: INT32_BE.get(buf, off + 4)
          };
        }
      };
      const SoundSampleDescriptionV0 = {
        len: 12,
        get(buf, off) {
          return {
            numAudioChannels: INT16_BE.get(buf, off + 0),
            sampleSize: INT16_BE.get(buf, off + 2),
            compressionId: INT16_BE.get(buf, off + 4),
            packetSize: INT16_BE.get(buf, off + 6),
            sampleRate: UINT16_BE.get(buf, off + 8) + UINT16_BE.get(buf, off + 10) / 1e4
          };
        }
      };
      class SimpleTableAtom {
        constructor(len, token) {
          this.len = len;
          this.token = token;
        }
        get(buf, off) {
          const nrOfEntries = INT32_BE.get(buf, off + 4);
          return {
            version: INT8.get(buf, off + 0),
            flags: INT24_BE.get(buf, off + 1),
            numberOfEntries: nrOfEntries,
            entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)
          };
        }
      }
      const TimeToSampleToken = {
        len: 8,
        get(buf, off) {
          return {
            count: INT32_BE.get(buf, off + 0),
            duration: INT32_BE.get(buf, off + 4)
          };
        }
      };
      class SttsAtom extends SimpleTableAtom {
        constructor(len) {
          super(len, TimeToSampleToken);
          this.len = len;
        }
      }
      const SampleToChunkToken = {
        len: 12,
        get(buf, off) {
          return {
            firstChunk: INT32_BE.get(buf, off),
            samplesPerChunk: INT32_BE.get(buf, off + 4),
            sampleDescriptionId: INT32_BE.get(buf, off + 8)
          };
        }
      };
      class StscAtom extends SimpleTableAtom {
        constructor(len) {
          super(len, SampleToChunkToken);
          this.len = len;
        }
      }
      class StszAtom {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const nrOfEntries = INT32_BE.get(buf, off + 8);
          return {
            version: INT8.get(buf, off),
            flags: INT24_BE.get(buf, off + 1),
            sampleSize: INT32_BE.get(buf, off + 4),
            numberOfEntries: nrOfEntries,
            entries: readTokenTable(buf, INT32_BE, off + 12, this.len - 12, nrOfEntries)
          };
        }
      }
      class StcoAtom extends SimpleTableAtom {
        constructor(len) {
          super(len, INT32_BE);
          this.len = len;
        }
      }
      class ChapterText {
        constructor(len) {
          this.len = len;
        }
        get(buf, off) {
          const titleLen = INT16_BE.get(buf, off + 0);
          const str = new StringType(titleLen, "utf-8");
          return str.get(buf, off + 2);
        }
      }
      function readTokenTable(buf, token, off, remainingLen, numberOfEntries) {
        debug$2(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`);
        if (remainingLen === 0)
          return [];
        if (remainingLen !== numberOfEntries * token.len)
          throw new Mp4ContentError("mismatch number-of-entries with remaining atom-length");
        const entries = [];
        for (let n = 0; n < numberOfEntries; ++n) {
          entries.push(token.get(buf, off));
          off += token.len;
        }
        return entries;
      }
      const debug$1 = initDebug("music-metadata:parser:MP4:Atom");
      class Atom {
        static async readAtom(tokenizer, dataHandler, parent, remaining) {
          const offset = tokenizer.position;
          debug$1(`Reading next token on offset=${offset}...`);
          const header = await tokenizer.readToken(Header);
          const extended = header.length === 1n;
          if (extended) {
            header.length = await tokenizer.readToken(ExtendedSize);
          }
          const atomBean = new Atom(header, extended, parent);
          const payloadLength = atomBean.getPayloadLength(remaining);
          debug$1(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`);
          await atomBean.readData(tokenizer, dataHandler, payloadLength);
          return atomBean;
        }
        constructor(header, extended, parent) {
          this.header = header;
          this.extended = extended;
          this.parent = parent;
          this.children = [];
          this.atomPath = (this.parent ? `${this.parent.atomPath}.` : "") + this.header.name;
        }
        getHeaderLength() {
          return this.extended ? 16 : 8;
        }
        getPayloadLength(remaining) {
          return (this.header.length === 0n ? remaining : Number(this.header.length)) - this.getHeaderLength();
        }
        async readAtoms(tokenizer, dataHandler, size) {
          while (size > 0) {
            const atomBean = await Atom.readAtom(tokenizer, dataHandler, this, size);
            this.children.push(atomBean);
            size -= atomBean.header.length === 0n ? size : Number(atomBean.header.length);
          }
        }
        async readData(tokenizer, dataHandler, remaining) {
          switch (this.header.name) {
            case "moov":
            case "udta":
            case "trak":
            case "mdia":
            case "minf":
            case "stbl":
            case "<id>":
            case "ilst":
            case "tref":
              return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining));
            case "meta": {
              const peekHeader = await tokenizer.peekToken(Header);
              const paddingLength = peekHeader.name === "hdlr" ? 0 : 4;
              await tokenizer.ignore(paddingLength);
              return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength);
            }
            default:
              return dataHandler(this, remaining);
          }
        }
      }
      const debug = initDebug("music-metadata:parser:MP4");
      const tagFormat = "iTunes";
      const encoderDict = {
        raw: {
          lossy: false,
          format: "raw"
        },
        MAC3: {
          lossy: true,
          format: "MACE 3:1"
        },
        MAC6: {
          lossy: true,
          format: "MACE 6:1"
        },
        ima4: {
          lossy: true,
          format: "IMA 4:1"
        },
        ulaw: {
          lossy: true,
          format: "uLaw 2:1"
        },
        alaw: {
          lossy: true,
          format: "uLaw 2:1"
        },
        Qclp: {
          lossy: true,
          format: "QUALCOMM PureVoice"
        },
        ".mp3": {
          lossy: true,
          format: "MPEG-1 layer 3"
        },
        alac: {
          lossy: false,
          format: "ALAC"
        },
        "ac-3": {
          lossy: true,
          format: "AC-3"
        },
        mp4a: {
          lossy: true,
          format: "MPEG-4/AAC"
        },
        mp4s: {
          lossy: true,
          format: "MP4S"
        },
        // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87
        c608: {
          lossy: true,
          format: "CEA-608"
        },
        c708: {
          lossy: true,
          format: "CEA-708"
        }
      };
      function distinct(value, index, self) {
        return self.indexOf(value) === index;
      }
      class MP4Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.tracks = [];
          this.atomParsers = {
            /**
             * Parse movie header (mvhd) atom
             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313
             */
            mvhd: async (len) => {
              const mvhd = await this.tokenizer.readToken(new MvhdAtom(len));
              this.metadata.setFormat("creationTime", mvhd.creationTime);
              this.metadata.setFormat("modificationTime", mvhd.modificationTime);
            },
            /**
             * Parse media header (mdhd) atom
             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25615
             */
            mdhd: async (len) => {
              const mdhd_data = await this.tokenizer.readToken(new MdhdAtom(len));
              const td = this.getTrackDescription();
              td.creationTime = mdhd_data.creationTime;
              td.modificationTime = mdhd_data.modificationTime;
              td.timeScale = mdhd_data.timeScale;
              td.duration = mdhd_data.duration;
            },
            chap: async (len) => {
              const td = this.getTrackDescription();
              const trackIds = [];
              while (len >= UINT32_BE.len) {
                trackIds.push(await this.tokenizer.readNumber(UINT32_BE));
                len -= UINT32_BE.len;
              }
              td.chapterList = trackIds;
            },
            tkhd: async (len) => {
              const track = await this.tokenizer.readToken(new TrackHeaderAtom(len));
              this.tracks.push(track);
            },
            /**
             * Parse mdat atom.
             * Will scan for chapters
             */
            mdat: async (len) => {
              this.audioLengthInBytes = len;
              this.calculateBitRate();
              if (this.options.includeChapters) {
                const trackWithChapters = this.tracks.filter((track) => track.chapterList);
                if (trackWithChapters.length === 1) {
                  const chapterTrackIds = trackWithChapters[0].chapterList;
                  const chapterTracks = this.tracks.filter((track) => chapterTrackIds.indexOf(track.trackId) !== -1);
                  if (chapterTracks.length === 1) {
                    return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);
                  }
                }
              }
              await this.tokenizer.ignore(len);
            },
            ftyp: async (len) => {
              const types = [];
              while (len > 0) {
                const ftype = await this.tokenizer.readToken(ftyp);
                len -= ftyp.len;
                const value = ftype.type.replace(/\W/g, "");
                if (value.length > 0) {
                  types.push(value);
                }
              }
              debug(`ftyp: ${types.join("/")}`);
              const x = types.filter(distinct).join("/");
              this.metadata.setFormat("container", x);
            },
            /**
             * Parse sample description atom
             */
            stsd: async (len) => {
              const stsd = await this.tokenizer.readToken(new StsdAtom(len));
              const trackDescription = this.getTrackDescription();
              trackDescription.soundSampleDescription = stsd.table.map((dfEntry) => this.parseSoundSampleDescription(dfEntry));
            },
            /**
             * sample-to-Chunk Atoms
             */
            stsc: async (len) => {
              const stsc = await this.tokenizer.readToken(new StscAtom(len));
              this.getTrackDescription().sampleToChunkTable = stsc.entries;
            },
            /**
             * time-to-sample table
             */
            stts: async (len) => {
              const stts = await this.tokenizer.readToken(new SttsAtom(len));
              this.getTrackDescription().timeToSampleTable = stts.entries;
            },
            /**
             * Parse sample-sizes atom ('stsz')
             */
            stsz: async (len) => {
              const stsz = await this.tokenizer.readToken(new StszAtom(len));
              const td = this.getTrackDescription();
              td.sampleSize = stsz.sampleSize;
              td.sampleSizeTable = stsz.entries;
            },
            /**
             * Parse chunk-offset atom ('stco')
             */
            stco: async (len) => {
              const stco = await this.tokenizer.readToken(new StcoAtom(len));
              this.getTrackDescription().chunkOffsetTable = stco.entries;
            },
            date: async (len) => {
              const date = await this.tokenizer.readToken(new StringType(len, "utf-8"));
              await this.addTag("date", date);
            }
          };
        }
        static read_BE_Integer(array, signed) {
          const integerType = (signed ? "INT" : "UINT") + array.length * 8 + (array.length > 1 ? "_BE" : "");
          const token = Token[integerType];
          if (!token) {
            throw new Mp4ContentError(`Token for integer type not found: "${integerType}"`);
          }
          return Number(token.get(array, 0));
        }
        async parse() {
          this.tracks = [];
          let remainingFileSize = this.tokenizer.fileInfo.size || 0;
          while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {
            try {
              const token = await this.tokenizer.peekToken(Header);
              if (token.name === "\0\0\0\0") {
                const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;
                debug(errMsg);
                this.addWarning(errMsg);
                break;
              }
            } catch (error) {
              if (error instanceof Error) {
                const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;
                debug(errMsg);
                this.addWarning(errMsg);
              } else
                throw error;
              break;
            }
            const rootAtom = await Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);
            remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);
          }
          const formatList = [];
          this.tracks.forEach((track) => {
            const trackFormats = [];
            track.soundSampleDescription.forEach((ssd) => {
              const streamInfo = {};
              const encoderInfo = encoderDict[ssd.dataFormat];
              if (encoderInfo) {
                trackFormats.push(encoderInfo.format);
                streamInfo.codecName = encoderInfo.format;
              } else {
                streamInfo.codecName = `<${ssd.dataFormat}>`;
              }
              if (ssd.description) {
                const { description } = ssd;
                if (description.sampleRate > 0) {
                  streamInfo.type = TrackType.audio;
                  streamInfo.audio = {
                    samplingFrequency: description.sampleRate,
                    bitDepth: description.sampleSize,
                    channels: description.numAudioChannels
                  };
                }
              }
              this.metadata.addStreamInfo(streamInfo);
            });
            if (trackFormats.length >= 1) {
              formatList.push(trackFormats.join("/"));
            }
          });
          if (formatList.length > 0) {
            this.metadata.setFormat("codec", formatList.filter(distinct).join("+"));
          }
          const audioTracks = this.tracks.filter((track) => {
            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;
          });
          if (audioTracks.length >= 1) {
            const audioTrack = audioTracks[0];
            if (audioTrack.timeScale > 0) {
              const duration = audioTrack.duration / audioTrack.timeScale;
              this.metadata.setFormat("duration", duration);
            }
            const ssd = audioTrack.soundSampleDescription[0];
            if (ssd.description) {
              this.metadata.setFormat("sampleRate", ssd.description.sampleRate);
              this.metadata.setFormat("bitsPerSample", ssd.description.sampleSize);
              this.metadata.setFormat("numberOfChannels", ssd.description.numAudioChannels);
              if (audioTrack.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {
                const totalSampleSize = audioTrack.timeToSampleTable.map((ttstEntry) => ttstEntry.count * ttstEntry.duration).reduce((total, sampleSize) => total + sampleSize);
                const duration = totalSampleSize / ssd.description.sampleRate;
                this.metadata.setFormat("duration", duration);
              }
            }
            const encoderInfo = encoderDict[ssd.dataFormat];
            if (encoderInfo) {
              this.metadata.setFormat("lossless", !encoderInfo.lossy);
            }
            this.calculateBitRate();
          }
        }
        async handleAtom(atom, remaining) {
          if (atom.parent) {
            switch (atom.parent.header.name) {
              case "ilst":
              case "<id>":
                return this.parseMetadataItemData(atom);
            }
          }
          if (this.atomParsers[atom.header.name]) {
            return this.atomParsers[atom.header.name](remaining);
          }
          debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);
          await this.tokenizer.ignore(remaining);
        }
        getTrackDescription() {
          return this.tracks[this.tracks.length - 1];
        }
        calculateBitRate() {
          if (this.audioLengthInBytes && this.metadata.format.duration) {
            this.metadata.setFormat("bitrate", 8 * this.audioLengthInBytes / this.metadata.format.duration);
          }
        }
        async addTag(id, value) {
          await this.metadata.addTag(tagFormat, id, value);
        }
        addWarning(message) {
          debug(`Warning: ${message}`);
          this.metadata.addWarning(message);
        }
        /**
         * Parse data of Meta-item-list-atom (item of 'ilst' atom)
         * @param metaAtom
         * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
         */
        parseMetadataItemData(metaAtom) {
          let tagKey = metaAtom.header.name;
          return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {
            const payLoadLength = child.getPayloadLength(remaining);
            switch (child.header.name) {
              case "data":
                return this.parseValueAtom(tagKey, child);
              case "name":
              case "mean":
              case "rate": {
                const name = await this.tokenizer.readToken(new NameAtom(payLoadLength));
                tagKey += `:${name.name}`;
                break;
              }
              default: {
                const uint8Array = await this.tokenizer.readToken(new Uint8ArrayType(payLoadLength));
                this.addWarning(`Unsupported meta-item: ${tagKey}[${child.header.name}] => value=${uint8ArrayToHex(uint8Array)} ascii=${uint8ArrayToString(uint8Array, "ascii")}`);
              }
            }
          }, metaAtom.getPayloadLength(0));
        }
        async parseValueAtom(tagKey, metaAtom) {
          const dataAtom = await this.tokenizer.readToken(new DataAtom(Number(metaAtom.header.length) - Header.len));
          if (dataAtom.type.set !== 0) {
            throw new Mp4ContentError(`Unsupported type-set != 0: ${dataAtom.type.set}`);
          }
          switch (dataAtom.type.type) {
            case 0:
              switch (tagKey) {
                case "trkn":
                case "disk": {
                  const num = UINT8.get(dataAtom.value, 3);
                  const of = UINT8.get(dataAtom.value, 5);
                  await this.addTag(tagKey, `${num}/${of}`);
                  break;
                }
                case "gnre": {
                  const genreInt = UINT8.get(dataAtom.value, 1);
                  const genreStr = Genres[genreInt - 1];
                  await this.addTag(tagKey, genreStr);
                  break;
                }
                case "rate": {
                  const rate = new TextDecoder("ascii").decode(dataAtom.value);
                  await this.addTag(tagKey, rate);
                  break;
                }
                default:
                  debug(`unknown proprietary value type for: ${metaAtom.atomPath}`);
              }
              break;
            case 1:
            case 18:
              await this.addTag(tagKey, new TextDecoder("utf-8").decode(dataAtom.value));
              break;
            case 13:
              if (this.options.skipCovers)
                break;
              await this.addTag(tagKey, {
                format: "image/jpeg",
                data: Uint8Array.from(dataAtom.value)
              });
              break;
            case 14:
              if (this.options.skipCovers)
                break;
              await this.addTag(tagKey, {
                format: "image/png",
                data: Uint8Array.from(dataAtom.value)
              });
              break;
            case 21:
              await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));
              break;
            case 22:
              await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));
              break;
            case 65:
              await this.addTag(tagKey, UINT8.get(dataAtom.value, 0));
              break;
            case 66:
              await this.addTag(tagKey, UINT16_BE.get(dataAtom.value, 0));
              break;
            case 67:
              await this.addTag(tagKey, UINT32_BE.get(dataAtom.value, 0));
              break;
            default:
              this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);
          }
        }
        /**
         * @param sampleDescription
         * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916
         */
        parseSoundSampleDescription(sampleDescription) {
          const ssd = {
            dataFormat: sampleDescription.dataFormat,
            dataReferenceIndex: sampleDescription.dataReferenceIndex
          };
          let offset = 0;
          if (sampleDescription.description) {
            const version = SoundSampleDescriptionVersion.get(sampleDescription.description, offset);
            offset += SoundSampleDescriptionVersion.len;
            if (version.version === 0 || version.version === 1) {
              ssd.description = SoundSampleDescriptionV0.get(sampleDescription.description, offset);
            } else {
              debug(`Warning: sound-sample-description ${version} not implemented`);
            }
          }
          return ssd;
        }
        async parseChapterTrack(chapterTrack, track, len) {
          if (!chapterTrack.sampleSize) {
            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)
              throw new Error("Expected equal chunk-offset-table & sample-size-table length.");
          }
          const chapters = [];
          for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {
            const chunkOffset = chapterTrack.chunkOffsetTable[i];
            const nextChunkLen = chunkOffset - this.tokenizer.position;
            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];
            len -= nextChunkLen + sampleSize;
            if (len < 0)
              throw new Mp4ContentError("Chapter chunk exceeding token length");
            await this.tokenizer.ignore(nextChunkLen);
            const title = await this.tokenizer.readToken(new ChapterText(sampleSize));
            debug(`Chapter ${i + 1}: ${title}`);
            const chapter = {
              title,
              sampleOffset: this.findSampleOffset(track, this.tokenizer.position)
            };
            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${this.tracks[0].duration}`);
            chapters.push(chapter);
          }
          this.metadata.setFormat("chapters", chapters);
          await this.tokenizer.ignore(len);
        }
        findSampleOffset(track, chapterOffset) {
          let totalDuration = 0;
          track.timeToSampleTable.forEach((e) => {
            totalDuration += e.count * e.duration;
          });
          debug(`Total duration=${totalDuration}`);
          let chunkIndex = 0;
          while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {
            ++chunkIndex;
          }
          return this.getChunkDuration(chunkIndex + 1, track);
        }
        getChunkDuration(chunkId, track) {
          let ttsi = 0;
          let ttsc = track.timeToSampleTable[ttsi].count;
          let ttsd = track.timeToSampleTable[ttsi].duration;
          let curChunkId = 1;
          let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
          let totalDuration = 0;
          while (curChunkId < chunkId) {
            const nrOfSamples = Math.min(ttsc, samplesPerChunk);
            totalDuration += nrOfSamples * ttsd;
            ttsc -= nrOfSamples;
            samplesPerChunk -= nrOfSamples;
            if (samplesPerChunk === 0) {
              ++curChunkId;
              samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);
            } else {
              ++ttsi;
              ttsc = track.timeToSampleTable[ttsi].count;
              ttsd = track.timeToSampleTable[ttsi].duration;
            }
          }
          return totalDuration;
        }
        getSamplesPerChunk(chunkId, stcTable) {
          for (let i = 0; i < stcTable.length - 1; ++i) {
            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {
              return stcTable[i].samplesPerChunk;
            }
          }
          return stcTable[stcTable.length - 1].samplesPerChunk;
        }
      } exports("MP4Parser", MP4Parser);

    })
  };
}));

System.register("./MusepackParser-ImJ4EqDU-CBDf08G9.js", ['./__monkey.entry-SDvwpoNt.js', './AbstractID3Parser-FIM36LHz-B5gpnOzd.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge', './ID3v2Parser-eXNf-3mE-7kzMCmWm.js'], (function (exports, module) {
  'use strict';
  var initDebug, StringType, makeUnexpectedFileContentError, BasicParser, FourCcToken, APEv2Parser, UINT8, UINT32_LE, getBitAllignedNumber, UINT16_LE, isBitSet$1, AbstractID3Parser;
  return {
    setters: [module => {
      initDebug = module.i;
      StringType = module.S;
      makeUnexpectedFileContentError = module.m;
      BasicParser = module.B;
      FourCcToken = module.F;
      APEv2Parser = module.J;
      UINT8 = module.c;
      UINT32_LE = module.f;
      getBitAllignedNumber = module.g;
      UINT16_LE = module.k;
      isBitSet$1 = module.b;
    }, module => {
      AbstractID3Parser = module.A;
    }, null, null, null, null, null, null],
    execute: (function () {

      const debug$3 = initDebug("music-metadata:parser:musepack:sv8");
      const PacketKey = new StringType(2, "latin1");
      const SH_part1 = {
        len: 5,
        get: (buf, off) => {
          return {
            crc: UINT32_LE.get(buf, off),
            streamVersion: UINT8.get(buf, off + 4)
          };
        }
      };
      const SH_part3 = {
        len: 2,
        get: (buf, off) => {
          return {
            sampleFrequency: [44100, 48e3, 37800, 32e3][getBitAllignedNumber(buf, off, 0, 3)],
            maxUsedBands: getBitAllignedNumber(buf, off, 3, 5),
            channelCount: getBitAllignedNumber(buf, off + 1, 0, 4) + 1,
            msUsed: isBitSet$1(buf, off + 1, 4),
            audioBlockFrames: getBitAllignedNumber(buf, off + 1, 5, 3)
          };
        }
      };
      class StreamReader {
        constructor(tokenizer) {
          this.tokenizer = tokenizer;
        }
        async readPacketHeader() {
          const key = await this.tokenizer.readToken(PacketKey);
          const size = await this.readVariableSizeField();
          return {
            key,
            payloadLength: size.value - 2 - size.len
          };
        }
        async readStreamHeader(size) {
          const streamHeader = {};
          debug$3(`Reading SH at offset=${this.tokenizer.position}`);
          const part1 = await this.tokenizer.readToken(SH_part1);
          size -= SH_part1.len;
          Object.assign(streamHeader, part1);
          debug$3(`SH.streamVersion = ${part1.streamVersion}`);
          const sampleCount = await this.readVariableSizeField();
          size -= sampleCount.len;
          streamHeader.sampleCount = sampleCount.value;
          const bs = await this.readVariableSizeField();
          size -= bs.len;
          streamHeader.beginningOfSilence = bs.value;
          const part3 = await this.tokenizer.readToken(SH_part3);
          size -= SH_part3.len;
          Object.assign(streamHeader, part3);
          await this.tokenizer.ignore(size);
          return streamHeader;
        }
        async readVariableSizeField(len = 1, hb = 0) {
          let n = await this.tokenizer.readNumber(UINT8);
          if ((n & 128) === 0) {
            return { len, value: hb + n };
          }
          n &= 127;
          n += hb;
          return this.readVariableSizeField(len + 1, n << 7);
        }
      }
      class MusepackContentError extends makeUnexpectedFileContentError("Musepack") {
      }
      const debug$2 = initDebug("music-metadata:parser:musepack");
      class MpcSv8Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.audioLength = 0;
        }
        async parse() {
          const signature = await this.tokenizer.readToken(FourCcToken);
          if (signature !== "MPCK")
            throw new MusepackContentError("Invalid Magic number");
          this.metadata.setFormat("container", "Musepack, SV8");
          return this.parsePacket();
        }
        async parsePacket() {
          const sv8reader = new StreamReader(this.tokenizer);
          do {
            const header = await sv8reader.readPacketHeader();
            debug$2(`packet-header key=${header.key}, payloadLength=${header.payloadLength}`);
            switch (header.key) {
              case "SH": {
                const sh = await sv8reader.readStreamHeader(header.payloadLength);
                this.metadata.setFormat("numberOfSamples", sh.sampleCount);
                this.metadata.setFormat("sampleRate", sh.sampleFrequency);
                this.metadata.setFormat("duration", sh.sampleCount / sh.sampleFrequency);
                this.metadata.setFormat("numberOfChannels", sh.channelCount);
                break;
              }
              case "AP":
                this.audioLength += header.payloadLength;
                await this.tokenizer.ignore(header.payloadLength);
                break;
              case "RG":
              case "EI":
              case "SO":
              case "ST":
              case "CT":
                await this.tokenizer.ignore(header.payloadLength);
                break;
              case "SE":
                if (this.metadata.format.duration) {
                  this.metadata.setFormat("bitrate", this.audioLength * 8 / this.metadata.format.duration);
                }
                return APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
              default:
                throw new MusepackContentError(`Unexpected header: ${header.key}`);
            }
          } while (true);
        }
      }
      class BitReader {
        constructor(tokenizer) {
          this.tokenizer = tokenizer;
          this.pos = 0;
          this.dword = null;
        }
        /**
         *
         * @param bits 1..30 bits
         */
        async read(bits) {
          while (this.dword === null) {
            this.dword = await this.tokenizer.readToken(UINT32_LE);
          }
          let out = this.dword;
          this.pos += bits;
          if (this.pos < 32) {
            out >>>= 32 - this.pos;
            return out & (1 << bits) - 1;
          }
          this.pos -= 32;
          if (this.pos === 0) {
            this.dword = null;
            return out & (1 << bits) - 1;
          }
          this.dword = await this.tokenizer.readToken(UINT32_LE);
          if (this.pos) {
            out <<= this.pos;
            out |= this.dword >>> 32 - this.pos;
          }
          return out & (1 << bits) - 1;
        }
        async ignore(bits) {
          if (this.pos > 0) {
            const remaining = 32 - this.pos;
            this.dword = null;
            bits -= remaining;
            this.pos = 0;
          }
          const remainder = bits % 32;
          const numOfWords = (bits - remainder) / 32;
          await this.tokenizer.ignore(numOfWords * 4);
          return this.read(remainder);
        }
      }
      const Header = {
        len: 6 * 4,
        get: (buf, off) => {
          const header = {
            // word 0
            signature: new TextDecoder("latin1").decode(buf.subarray(off, off + 3)),
            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
            streamMinorVersion: getBitAllignedNumber(buf, off + 3, 0, 4),
            streamMajorVersion: getBitAllignedNumber(buf, off + 3, 4, 4),
            // word 1
            frameCount: UINT32_LE.get(buf, off + 4),
            // word 2
            maxLevel: UINT16_LE.get(buf, off + 8),
            sampleFrequency: [44100, 48e3, 37800, 32e3][getBitAllignedNumber(buf, off + 10, 0, 2)],
            link: getBitAllignedNumber(buf, off + 10, 2, 2),
            profile: getBitAllignedNumber(buf, off + 10, 4, 4),
            maxBand: getBitAllignedNumber(buf, off + 11, 0, 6),
            intensityStereo: isBitSet$1(buf, off + 11, 6),
            midSideStereo: isBitSet$1(buf, off + 11, 7),
            // word 3
            titlePeak: UINT16_LE.get(buf, off + 12),
            titleGain: UINT16_LE.get(buf, off + 14),
            // word 4
            albumPeak: UINT16_LE.get(buf, off + 16),
            albumGain: UINT16_LE.get(buf, off + 18),
            // word
            lastFrameLength: UINT32_LE.get(buf, off + 20) >>> 20 & 2047,
            trueGapless: isBitSet$1(buf, off + 23, 0)
          };
          header.lastFrameLength = header.trueGapless ? UINT32_LE.get(buf, 20) >>> 20 & 2047 : 0;
          return header;
        }
      };
      const debug$1 = initDebug("music-metadata:parser:musepack");
      class MpcSv7Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.bitreader = null;
          this.audioLength = 0;
          this.duration = null;
        }
        async parse() {
          const header = await this.tokenizer.readToken(Header);
          if (header.signature !== "MP+")
            throw new MusepackContentError("Unexpected magic number");
          debug$1(`stream-version=${header.streamMajorVersion}.${header.streamMinorVersion}`);
          this.metadata.setFormat("container", "Musepack, SV7");
          this.metadata.setFormat("sampleRate", header.sampleFrequency);
          const numberOfSamples = 1152 * (header.frameCount - 1) + header.lastFrameLength;
          this.metadata.setFormat("numberOfSamples", numberOfSamples);
          this.duration = numberOfSamples / header.sampleFrequency;
          this.metadata.setFormat("duration", this.duration);
          this.bitreader = new BitReader(this.tokenizer);
          this.metadata.setFormat("numberOfChannels", header.midSideStereo || header.intensityStereo ? 2 : 1);
          const version = await this.bitreader.read(8);
          this.metadata.setFormat("codec", (version / 100).toFixed(2));
          await this.skipAudioData(header.frameCount);
          debug$1(`End of audio stream, switching to APEv2, offset=${this.tokenizer.position}`);
          return APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
        }
        async skipAudioData(frameCount) {
          while (frameCount-- > 0) {
            const frameLength = await this.bitreader.read(20);
            this.audioLength += 20 + frameLength;
            await this.bitreader.ignore(frameLength);
          }
          const lastFrameLength = await this.bitreader.read(11);
          this.audioLength += lastFrameLength;
          if (this.duration !== null) {
            this.metadata.setFormat("bitrate", this.audioLength / this.duration);
          }
        }
      }
      const debug = initDebug("music-metadata:parser:musepack");
      class MusepackParser extends AbstractID3Parser {
        async postId3v2Parse() {
          const signature = await this.tokenizer.peekToken(new StringType(3, "latin1"));
          let mpcParser;
          switch (signature) {
            case "MP+": {
              debug("Stream-version 7");
              mpcParser = new MpcSv7Parser(this.metadata, this.tokenizer, this.options);
              break;
            }
            case "MPC": {
              debug("Stream-version 8");
              mpcParser = new MpcSv8Parser(this.metadata, this.tokenizer, this.options);
              break;
            }
            default: {
              throw new MusepackContentError("Invalid signature prefix");
            }
          }
          return mpcParser.parse();
        }
      } exports("MusepackParser", MusepackParser);

    })
  };
}));

System.register("./AbstractID3Parser-FIM36LHz-B5gpnOzd.js", ['./__monkey.entry-SDvwpoNt.js', './ID3v2Parser-eXNf-3mE-7kzMCmWm.js'], (function (exports, module) {
  'use strict';
  var initDebug, BasicParser, ID3v2Header, EndOfStreamError$1, ID3v1Parser, ID3v2Parser;
  return {
    setters: [module => {
      initDebug = module.i;
      BasicParser = module.B;
      ID3v2Header = module.K;
      EndOfStreamError$1 = module.E;
      ID3v1Parser = module.L;
    }, module => {
      ID3v2Parser = module.I;
    }],
    execute: (function () {

      const debug = initDebug("music-metadata:parser:ID3");
      class AbstractID3Parser extends BasicParser {
        constructor() {
          super(...arguments);
          this.id3parser = new ID3v2Parser();
        }
        static async startsWithID3v2Header(tokenizer) {
          return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === "ID3";
        }
        async parse() {
          try {
            await this.parseID3v2();
          } catch (err) {
            if (err instanceof EndOfStreamError$1) {
              debug("End-of-stream");
            } else {
              throw err;
            }
          }
        }
        finalize() {
          return;
        }
        async parseID3v2() {
          await this.tryReadId3v2Headers();
          debug("End of ID3v2 header, go to MPEG-parser: pos=%s", this.tokenizer.position);
          await this.postId3v2Parse();
          if (this.options.skipPostHeaders && this.metadata.hasAny()) {
            this.finalize();
          } else {
            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);
            await id3v1parser.parse();
            this.finalize();
          }
        }
        async tryReadId3v2Headers() {
          const id3Header = await this.tokenizer.peekToken(ID3v2Header);
          if (id3Header.fileIdentifier === "ID3") {
            debug("Found ID3v2 header, pos=%s", this.tokenizer.position);
            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);
            return this.tryReadId3v2Headers();
          }
        }
      } exports("A", AbstractID3Parser);

    })
  };
}));

System.register("./OggParser-BBZnDK-h-D6aAHGsc.js", ['./__monkey.entry-SDvwpoNt.js', './VorbisParser-C_tWlZNb-Big__tIq.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var initDebug, BasicParser, Uint8ArrayType, EndOfStreamError$1, FourCcToken, UINT8, getBit, UINT64_LE, UINT32_LE, StringType, makeUnexpectedFileContentError, UINT16_LE, trimRightNull, INT32_LE, UINT16_BE, UINT24_BE, VorbisParser;
  return {
    setters: [module => {
      initDebug = module.i;
      BasicParser = module.B;
      Uint8ArrayType = module.U;
      EndOfStreamError$1 = module.E;
      FourCcToken = module.F;
      UINT8 = module.c;
      getBit = module.j;
      UINT64_LE = module.e;
      UINT32_LE = module.f;
      StringType = module.S;
      makeUnexpectedFileContentError = module.m;
      UINT16_LE = module.k;
      trimRightNull = module.M;
      INT32_LE = module.q;
      UINT16_BE = module.d;
      UINT24_BE = module.r;
    }, module => {
      VorbisParser = module.V;
    }, null, null, null, null, null],
    execute: (function () {

      class OpusContentError extends makeUnexpectedFileContentError("Opus") {
      }
      class IdHeader {
        constructor(len) {
          this.len = len;
          if (len < 19) {
            throw new OpusContentError("ID-header-page 0 should be at least 19 bytes long");
          }
        }
        get(buf, off) {
          return {
            magicSignature: new StringType(8, "ascii").get(buf, off + 0),
            version: UINT8.get(buf, off + 8),
            channelCount: UINT8.get(buf, off + 9),
            preSkip: UINT16_LE.get(buf, off + 10),
            inputSampleRate: UINT32_LE.get(buf, off + 12),
            outputGain: UINT16_LE.get(buf, off + 16),
            channelMapping: UINT8.get(buf, off + 18)
          };
        }
      }
      class OpusParser extends VorbisParser {
        constructor(metadata, options, tokenizer) {
          super(metadata, options);
          this.tokenizer = tokenizer;
          this.idHeader = null;
          this.lastPos = -1;
        }
        /**
         * Parse first Opus Ogg page
         * @param {IPageHeader} header
         * @param {Uint8Array} pageData
         */
        parseFirstPage(header, pageData) {
          this.metadata.setFormat("codec", "Opus");
          this.idHeader = new IdHeader(pageData.length).get(pageData, 0);
          if (this.idHeader.magicSignature !== "OpusHead")
            throw new OpusContentError("Illegal ogg/Opus magic-signature");
          this.metadata.setFormat("sampleRate", this.idHeader.inputSampleRate);
          this.metadata.setFormat("numberOfChannels", this.idHeader.channelCount);
        }
        async parseFullPage(pageData) {
          const magicSignature = new StringType(8, "ascii").get(pageData, 0);
          switch (magicSignature) {
            case "OpusTags":
              await this.parseUserCommentList(pageData, 8);
              this.lastPos = this.tokenizer.position - pageData.length;
              break;
          }
        }
        calculateDuration(header) {
          if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {
            const pos_48bit = header.absoluteGranulePosition - this.idHeader.preSkip;
            this.metadata.setFormat("numberOfSamples", pos_48bit);
            this.metadata.setFormat("duration", pos_48bit / 48e3);
            if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {
              const dataSize = this.tokenizer.fileInfo.size - this.lastPos;
              this.metadata.setFormat("bitrate", 8 * dataSize / this.metadata.format.duration);
            }
          }
        }
      }
      const Header = {
        len: 80,
        get: (buf, off) => {
          return {
            speex: new StringType(8, "ascii").get(buf, off + 0),
            version: trimRightNull(new StringType(20, "ascii").get(buf, off + 8)),
            version_id: INT32_LE.get(buf, off + 28),
            header_size: INT32_LE.get(buf, off + 32),
            rate: INT32_LE.get(buf, off + 36),
            mode: INT32_LE.get(buf, off + 40),
            mode_bitstream_version: INT32_LE.get(buf, off + 44),
            nb_channels: INT32_LE.get(buf, off + 48),
            bitrate: INT32_LE.get(buf, off + 52),
            frame_size: INT32_LE.get(buf, off + 56),
            vbr: INT32_LE.get(buf, off + 60),
            frames_per_packet: INT32_LE.get(buf, off + 64),
            extra_headers: INT32_LE.get(buf, off + 68),
            reserved1: INT32_LE.get(buf, off + 72),
            reserved2: INT32_LE.get(buf, off + 76)
          };
        }
      };
      const debug$2 = initDebug("music-metadata:parser:ogg:speex");
      class SpeexParser extends VorbisParser {
        constructor(metadata, options, tokenizer) {
          super(metadata, options);
          this.tokenizer = tokenizer;
        }
        /**
         * Parse first Speex Ogg page
         * @param {IPageHeader} header
         * @param {Uint8Array} pageData
         */
        parseFirstPage(header, pageData) {
          debug$2("First Ogg/Speex page");
          const speexHeader = Header.get(pageData, 0);
          this.metadata.setFormat("codec", `Speex ${speexHeader.version}`);
          this.metadata.setFormat("numberOfChannels", speexHeader.nb_channels);
          this.metadata.setFormat("sampleRate", speexHeader.rate);
          if (speexHeader.bitrate !== -1) {
            this.metadata.setFormat("bitrate", speexHeader.bitrate);
          }
        }
      }
      const IdentificationHeader = {
        len: 42,
        get: (buf, off) => {
          return {
            id: new StringType(7, "ascii").get(buf, off),
            vmaj: UINT8.get(buf, off + 7),
            vmin: UINT8.get(buf, off + 8),
            vrev: UINT8.get(buf, off + 9),
            vmbw: UINT16_BE.get(buf, off + 10),
            vmbh: UINT16_BE.get(buf, off + 17),
            nombr: UINT24_BE.get(buf, off + 37),
            nqual: UINT8.get(buf, off + 40)
          };
        }
      };
      const debug$1 = initDebug("music-metadata:parser:ogg:theora");
      class TheoraParser {
        constructor(metadata, options, tokenizer) {
          this.metadata = metadata;
          this.tokenizer = tokenizer;
        }
        /**
         * Vorbis 1 parser
         * @param header Ogg Page Header
         * @param pageData Page data
         */
        async parsePage(header, pageData) {
          if (header.headerType.firstPage) {
            await this.parseFirstPage(header, pageData);
          }
        }
        async flush() {
          debug$1("flush");
        }
        calculateDuration(header) {
          debug$1("duration calculation not implemented");
        }
        /**
         * Parse first Theora Ogg page. the initial identification header packet
         * @param {IPageHeader} header
         * @param {Buffer} pageData
         */
        async parseFirstPage(header, pageData) {
          debug$1("First Ogg/Theora page");
          this.metadata.setFormat("codec", "Theora");
          const idHeader = IdentificationHeader.get(pageData, 0);
          this.metadata.setFormat("bitrate", idHeader.nombr);
        }
      }
      class OggContentError extends makeUnexpectedFileContentError("Ogg") {
      } exports("OggContentError", OggContentError);
      const debug = initDebug("music-metadata:parser:ogg");
      class SegmentTable {
        static sum(buf, off, len) {
          const dv = new DataView(buf.buffer, 0);
          let s = 0;
          for (let i = off; i < off + len; ++i) {
            s += dv.getUint8(i);
          }
          return s;
        }
        constructor(header) {
          this.len = header.page_segments;
        }
        get(buf, off) {
          return {
            totalPageSize: SegmentTable.sum(buf, off, this.len)
          };
        }
      } exports("SegmentTable", SegmentTable);
      class OggParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.header = null;
          this.pageNumber = 0;
          this.pageConsumer = null;
        }
        /**
         * Parse page
         * @returns {Promise<void>}
         */
        async parse() {
          debug("pos=%s, parsePage()", this.tokenizer.position);
          try {
            let header;
            do {
              header = await this.tokenizer.readToken(OggParser.Header);
              if (header.capturePattern !== "OggS")
                throw new OggContentError("Invalid Ogg capture pattern");
              this.metadata.setFormat("container", "Ogg");
              this.header = header;
              this.pageNumber = header.pageSequenceNo;
              debug("page#=%s, Ogg.id=%s", header.pageSequenceNo, header.capturePattern);
              const segmentTable = await this.tokenizer.readToken(new SegmentTable(header));
              debug("totalPageSize=%s", segmentTable.totalPageSize);
              const pageData = await this.tokenizer.readToken(new Uint8ArrayType(segmentTable.totalPageSize));
              debug("firstPage=%s, lastPage=%s, continued=%s", header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);
              if (header.headerType.firstPage) {
                const id = new TextDecoder("ascii").decode(pageData.subarray(0, 7));
                switch (id) {
                  case "vorbis":
                    debug("Set page consumer to Ogg/Vorbis");
                    this.pageConsumer = new VorbisParser(this.metadata, this.options);
                    break;
                  case "OpusHea":
                    debug("Set page consumer to Ogg/Opus");
                    this.pageConsumer = new OpusParser(this.metadata, this.options, this.tokenizer);
                    break;
                  case "Speex  ":
                    debug("Set page consumer to Ogg/Speex");
                    this.pageConsumer = new SpeexParser(this.metadata, this.options, this.tokenizer);
                    break;
                  case "fishead":
                  case "\0theora":
                    debug("Set page consumer to Ogg/Theora");
                    this.pageConsumer = new TheoraParser(this.metadata, this.options, this.tokenizer);
                    break;
                  default:
                    throw new OggContentError(`gg audio-codec not recognized (id=${id})`);
                }
              }
              await this.pageConsumer.parsePage(header, pageData);
            } while (!header.headerType.lastPage);
          } catch (err) {
            if (err instanceof Error) {
              if (err instanceof EndOfStreamError$1) {
                this.metadata.addWarning("Last OGG-page is not marked with last-page flag");
                debug("End-of-stream");
                this.metadata.addWarning("Last OGG-page is not marked with last-page flag");
                if (this.header) {
                  this.pageConsumer.calculateDuration(this.header);
                }
              } else if (err.message.startsWith("FourCC")) {
                if (this.pageNumber > 0) {
                  this.metadata.addWarning("Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag");
                  await this.pageConsumer.flush();
                }
              }
            } else
              throw err;
          }
        }
      } exports("OggParser", OggParser);
      OggParser.Header = {
        len: 27,
        get: (buf, off) => {
          return {
            capturePattern: FourCcToken.get(buf, off),
            version: UINT8.get(buf, off + 4),
            headerType: {
              continued: getBit(buf, off + 5, 0),
              firstPage: getBit(buf, off + 5, 1),
              lastPage: getBit(buf, off + 5, 2)
            },
            // packet_flag: Token.UINT8.get(buf, off + 5),
            absoluteGranulePosition: Number(UINT64_LE.get(buf, off + 6)),
            streamSerialNumber: UINT32_LE.get(buf, off + 14),
            pageSequenceNo: UINT32_LE.get(buf, off + 18),
            pageChecksum: UINT32_LE.get(buf, off + 22),
            page_segments: UINT8.get(buf, off + 26)
          };
        }
      };

    })
  };
}));

System.register("./VorbisParser-C_tWlZNb-Big__tIq.js", ['./__monkey.entry-SDvwpoNt.js'], (function (exports, module) {
  'use strict';
  var initDebug, AttachedPictureType, UINT32_BE, StringType, UINT32_LE, UINT8, makeUnexpectedFileContentError;
  return {
    setters: [module => {
      initDebug = module.i;
      AttachedPictureType = module.A;
      UINT32_BE = module.a;
      StringType = module.S;
      UINT32_LE = module.f;
      UINT8 = module.c;
      makeUnexpectedFileContentError = module.m;
    }],
    execute: (function () {

      class VorbisPictureToken {
        static fromBase64(base64str) {
          return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), (c) => c.charCodeAt(0)));
        }
        static fromBuffer(buffer) {
          const pic = new VorbisPictureToken(buffer.length);
          return pic.get(buffer, 0);
        }
        constructor(len) {
          this.len = len;
        }
        get(buffer, offset) {
          const type = AttachedPictureType[UINT32_BE.get(buffer, offset)];
          offset += 4;
          const mimeLen = UINT32_BE.get(buffer, offset);
          offset += 4;
          const format = new StringType(mimeLen, "utf-8").get(buffer, offset);
          offset += mimeLen;
          const descLen = UINT32_BE.get(buffer, offset);
          offset += 4;
          const description = new StringType(descLen, "utf-8").get(buffer, offset);
          offset += descLen;
          const width = UINT32_BE.get(buffer, offset);
          offset += 4;
          const height = UINT32_BE.get(buffer, offset);
          offset += 4;
          const colour_depth = UINT32_BE.get(buffer, offset);
          offset += 4;
          const indexed_color = UINT32_BE.get(buffer, offset);
          offset += 4;
          const picDataLen = UINT32_BE.get(buffer, offset);
          offset += 4;
          const data = Uint8Array.from(buffer.slice(offset, offset + picDataLen));
          return {
            type,
            format,
            description,
            width,
            height,
            colour_depth,
            indexed_color,
            data
          };
        }
      } exports("a", VorbisPictureToken);
      const CommonHeader = {
        len: 7,
        get: (buf, off) => {
          return {
            packetType: UINT8.get(buf, off),
            vorbis: new StringType(6, "ascii").get(buf, off + 1)
          };
        }
      };
      const IdentificationHeader = {
        len: 23,
        get: (uint8Array, off) => {
          return {
            version: UINT32_LE.get(uint8Array, off + 0),
            channelMode: UINT8.get(uint8Array, off + 4),
            sampleRate: UINT32_LE.get(uint8Array, off + 5),
            bitrateMax: UINT32_LE.get(uint8Array, off + 9),
            bitrateNominal: UINT32_LE.get(uint8Array, off + 13),
            bitrateMin: UINT32_LE.get(uint8Array, off + 17)
          };
        }
      };
      class VorbisDecoder {
        constructor(data, offset) {
          this.data = data;
          this.offset = offset;
        }
        readInt32() {
          const value = UINT32_LE.get(this.data, this.offset);
          this.offset += 4;
          return value;
        }
        readStringUtf8() {
          const len = this.readInt32();
          const value = new TextDecoder("utf-8").decode(this.data.subarray(this.offset, this.offset + len));
          this.offset += len;
          return value;
        }
        parseUserComment() {
          const offset0 = this.offset;
          const v = this.readStringUtf8();
          const idx = v.indexOf("=");
          return {
            key: v.slice(0, idx).toUpperCase(),
            value: v.slice(idx + 1),
            len: this.offset - offset0
          };
        }
      } exports("b", VorbisDecoder);
      const debug = initDebug("music-metadata:parser:ogg:vorbis1");
      class VorbisContentError extends makeUnexpectedFileContentError("Vorbis") {
      }
      class VorbisParser {
        constructor(metadata, options) {
          this.metadata = metadata;
          this.options = options;
          this.pageSegments = [];
        }
        /**
         * Vorbis 1 parser
         * @param header Ogg Page Header
         * @param pageData Page data
         */
        async parsePage(header, pageData) {
          if (header.headerType.firstPage) {
            this.parseFirstPage(header, pageData);
          } else {
            if (header.headerType.continued) {
              if (this.pageSegments.length === 0) {
                throw new VorbisContentError("Cannot continue on previous page");
              }
              this.pageSegments.push(pageData);
            }
            if (header.headerType.lastPage || !header.headerType.continued) {
              if (this.pageSegments.length > 0) {
                const fullPage = VorbisParser.mergeUint8Arrays(this.pageSegments);
                await this.parseFullPage(fullPage);
              }
              this.pageSegments = header.headerType.lastPage ? [] : [pageData];
            }
          }
          if (header.headerType.lastPage) {
            this.calculateDuration(header);
          }
        }
        static mergeUint8Arrays(arrays) {
          const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);
          const merged = new Uint8Array(totalSize);
          arrays.forEach((array, i, _arrays) => {
            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);
            merged.set(array, offset);
          });
          return merged;
        }
        async flush() {
          await this.parseFullPage(VorbisParser.mergeUint8Arrays(this.pageSegments));
        }
        async parseUserComment(pageData, offset) {
          const decoder = new VorbisDecoder(pageData, offset);
          const tag = decoder.parseUserComment();
          await this.addTag(tag.key, tag.value);
          return tag.len;
        }
        async addTag(id, value) {
          if (id === "METADATA_BLOCK_PICTURE" && typeof value === "string") {
            if (this.options.skipCovers) {
              debug("Ignore picture");
              return;
            }
            value = VorbisPictureToken.fromBase64(value);
            debug(`Push picture: id=${id}, format=${value.format}`);
          } else {
            debug(`Push tag: id=${id}, value=${value}`);
          }
          await this.metadata.addTag("vorbis", id, value);
        }
        calculateDuration(header) {
          if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {
            this.metadata.setFormat("numberOfSamples", header.absoluteGranulePosition);
            this.metadata.setFormat("duration", header.absoluteGranulePosition / this.metadata.format.sampleRate);
          }
        }
        /**
         * Parse first Ogg/Vorbis page
         * @param header
         * @param pageData
         */
        parseFirstPage(header, pageData) {
          this.metadata.setFormat("codec", "Vorbis I");
          debug("Parse first page");
          const commonHeader = CommonHeader.get(pageData, 0);
          if (commonHeader.vorbis !== "vorbis")
            throw new VorbisContentError("Metadata does not look like Vorbis");
          if (commonHeader.packetType === 1) {
            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);
            this.metadata.setFormat("sampleRate", idHeader.sampleRate);
            this.metadata.setFormat("bitrate", idHeader.bitrateNominal);
            this.metadata.setFormat("numberOfChannels", idHeader.channelMode);
            debug("sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);
          } else
            throw new VorbisContentError("First Ogg page should be type 1: the identification header");
        }
        async parseFullPage(pageData) {
          const commonHeader = CommonHeader.get(pageData, 0);
          debug("Parse full page: type=%s, byteLength=%s", commonHeader.packetType, pageData.byteLength);
          switch (commonHeader.packetType) {
            case 3:
              return this.parseUserCommentList(pageData, CommonHeader.len);
          }
        }
        /**
         * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2
         */
        async parseUserCommentList(pageData, offset) {
          const strLen = UINT32_LE.get(pageData, offset);
          offset += 4;
          offset += strLen;
          let userCommentListLength = UINT32_LE.get(pageData, offset);
          offset += 4;
          while (userCommentListLength-- > 0) {
            offset += await this.parseUserComment(pageData, offset);
          }
        }
      } exports("V", VorbisParser);

    })
  };
}));

System.register("./WavPackParser-CP3cSPHA-DUluwt_e.js", ['./__monkey.entry-SDvwpoNt.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var initDebug, BasicParser, APEv2Parser, FourCcToken, UINT24_LE, UINT8, uint8ArrayToHex, UINT32_LE, UINT16_LE, Uint8ArrayType, makeUnexpectedFileContentError;
  return {
    setters: [module => {
      initDebug = module.i;
      BasicParser = module.B;
      APEv2Parser = module.J;
      FourCcToken = module.F;
      UINT24_LE = module.N;
      UINT8 = module.c;
      uint8ArrayToHex = module.u;
      UINT32_LE = module.f;
      UINT16_LE = module.k;
      Uint8ArrayType = module.U;
      makeUnexpectedFileContentError = module.m;
    }, null, null, null, null, null],
    execute: (function () {

      const SampleRates = [
        6e3,
        8e3,
        9600,
        11025,
        12e3,
        16e3,
        22050,
        24e3,
        32e3,
        44100,
        48e3,
        64e3,
        88200,
        96e3,
        192e3,
        -1
      ];
      const BlockHeaderToken = {
        len: 32,
        get: (buf, off) => {
          const flags = UINT32_LE.get(buf, off + 24);
          const res = {
            // should equal 'wvpk'
            BlockID: FourCcToken.get(buf, off),
            //  0x402 to 0x410 are valid for decode
            blockSize: UINT32_LE.get(buf, off + 4),
            //  0x402 (1026) to 0x410 are valid for decode
            version: UINT16_LE.get(buf, off + 8),
            //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
            totalSamples: (
              /* replace with bigint? (Token.UINT8.get(buf, off + 11) << 32) + */
              UINT32_LE.get(buf, off + 12)
            ),
            // 40-bit block_index
            blockIndex: (
              /* replace with bigint? (Token.UINT8.get(buf, off + 10) << 32) + */
              UINT32_LE.get(buf, off + 16)
            ),
            // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
            blockSamples: UINT32_LE.get(buf, off + 20),
            // various flags for id and decoding
            flags: {
              bitsPerSample: (1 + getBitAllignedNumber(flags, 0, 2)) * 8,
              isMono: isBitSet(flags, 2),
              isHybrid: isBitSet(flags, 3),
              isJointStereo: isBitSet(flags, 4),
              crossChannel: isBitSet(flags, 5),
              hybridNoiseShaping: isBitSet(flags, 6),
              floatingPoint: isBitSet(flags, 7),
              samplingRate: SampleRates[getBitAllignedNumber(flags, 23, 4)],
              isDSD: isBitSet(flags, 31)
            },
            // crc for actual decoded data
            crc: new Uint8ArrayType(4).get(buf, off + 28)
          };
          if (res.flags.isDSD) {
            res.totalSamples *= 8;
          }
          return res;
        }
      };
      const MetadataIdToken = {
        len: 1,
        get: (buf, off) => {
          return {
            functionId: getBitAllignedNumber(buf[off], 0, 6),
            // functionId overlaps with isOptional flag
            isOptional: isBitSet(buf[off], 5),
            isOddSize: isBitSet(buf[off], 6),
            largeBlock: isBitSet(buf[off], 7)
          };
        }
      };
      function isBitSet(flags, bitOffset) {
        return getBitAllignedNumber(flags, bitOffset, 1) === 1;
      }
      function getBitAllignedNumber(flags, bitOffset, len) {
        return flags >>> bitOffset & 4294967295 >>> 32 - len;
      }
      const debug = initDebug("music-metadata:parser:WavPack");
      class WavPackContentError extends makeUnexpectedFileContentError("WavPack") {
      } exports("WavPackContentError", WavPackContentError);
      class WavPackParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.audioDataSize = 0;
        }
        async parse() {
          this.audioDataSize = 0;
          await this.parseWavPackBlocks();
          return APEv2Parser.tryParseApeHeader(this.metadata, this.tokenizer, this.options);
        }
        async parseWavPackBlocks() {
          do {
            const blockId = await this.tokenizer.peekToken(FourCcToken);
            if (blockId !== "wvpk")
              break;
            const header = await this.tokenizer.readToken(BlockHeaderToken);
            if (header.BlockID !== "wvpk")
              throw new WavPackContentError("Invalid WavPack Block-ID");
            debug(`WavPack header blockIndex=${header.blockIndex}, len=${BlockHeaderToken.len}`);
            if (header.blockIndex === 0 && !this.metadata.format.container) {
              this.metadata.setFormat("container", "WavPack");
              this.metadata.setFormat("lossless", !header.flags.isHybrid);
              this.metadata.setFormat("bitsPerSample", header.flags.bitsPerSample);
              if (!header.flags.isDSD) {
                this.metadata.setFormat("sampleRate", header.flags.samplingRate);
                this.metadata.setFormat("duration", header.totalSamples / header.flags.samplingRate);
              }
              this.metadata.setFormat("numberOfChannels", header.flags.isMono ? 1 : 2);
              this.metadata.setFormat("numberOfSamples", header.totalSamples);
              this.metadata.setFormat("codec", header.flags.isDSD ? "DSD" : "PCM");
            }
            const ignoreBytes = header.blockSize - (BlockHeaderToken.len - 8);
            await (header.blockIndex === 0 ? this.parseMetadataSubBlock(header, ignoreBytes) : this.tokenizer.ignore(ignoreBytes));
            if (header.blockSamples > 0) {
              this.audioDataSize += header.blockSize;
            }
          } while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= BlockHeaderToken.len);
          if (this.metadata.format.duration) {
            this.metadata.setFormat("bitrate", this.audioDataSize * 8 / this.metadata.format.duration);
          }
        }
        /**
         * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf, 3.0 Metadata Sub-blocks
         * @param header Header
         * @param remainingLength Remaining length
         */
        async parseMetadataSubBlock(header, remainingLength) {
          let remaining = remainingLength;
          while (remaining > MetadataIdToken.len) {
            const id = await this.tokenizer.readToken(MetadataIdToken);
            const dataSizeInWords = await this.tokenizer.readNumber(id.largeBlock ? UINT24_LE : UINT8);
            const data = new Uint8Array(dataSizeInWords * 2 - (id.isOddSize ? 1 : 0));
            await this.tokenizer.readBuffer(data);
            debug(`Metadata Sub-Blocks functionId=0x${id.functionId.toString(16)}, id.largeBlock=${id.largeBlock},data-size=${data.length}`);
            switch (id.functionId) {
              case 0:
                break;
              case 14: {
                debug("ID_DSD_BLOCK");
                const mp = 1 << UINT8.get(data, 0);
                const samplingRate = header.flags.samplingRate * mp * 8;
                if (!header.flags.isDSD)
                  throw new WavPackContentError("Only expect DSD block if DSD-flag is set");
                this.metadata.setFormat("sampleRate", samplingRate);
                this.metadata.setFormat("duration", header.totalSamples / samplingRate);
                break;
              }
              case 36:
                debug("ID_ALT_TRAILER: trailer for non-wav files");
                break;
              case 38:
                this.metadata.setFormat("audioMD5", data);
                break;
              case 47:
                debug(`ID_BLOCK_CHECKSUM: checksum=${uint8ArrayToHex(data)}`);
                break;
              default:
                debug(`Ignore unsupported meta-sub-block-id functionId=0x${id.functionId.toString(16)}`);
                break;
            }
            remaining -= MetadataIdToken.len + (id.largeBlock ? UINT24_LE.len : UINT8.len) + dataSizeInWords * 2;
            debug(`remainingLength=${remaining}`);
            if (id.isOddSize)
              this.tokenizer.ignore(1);
          }
          if (remaining !== 0)
            throw new WavPackContentError("metadata-sub-block should fit it remaining length");
        }
      } exports("WavPackParser", WavPackParser);

    })
  };
}));

System.register("./WaveParser-BOR6tCgw-CFnjS9DE.js", ['./__monkey.entry-SDvwpoNt.js', './ID3v2Parser-eXNf-3mE-7kzMCmWm.js', 'react', 'antd', 'react-dom', '@ant-design/icons', 'node-forge'], (function (exports, module) {
  'use strict';
  var initDebug, BasicParser, EndOfStreamError$1, FourCcToken, Uint8ArrayType, fromBuffer$1, StringType, stripNulls, UINT32_LE, makeUnexpectedFileContentError, UINT16_LE, ID3v2Parser;
  return {
    setters: [module => {
      initDebug = module.i;
      BasicParser = module.B;
      EndOfStreamError$1 = module.E;
      FourCcToken = module.F;
      Uint8ArrayType = module.U;
      fromBuffer$1 = module.n;
      StringType = module.S;
      stripNulls = module.s;
      UINT32_LE = module.f;
      makeUnexpectedFileContentError = module.m;
      UINT16_LE = module.k;
    }, module => {
      ID3v2Parser = module.I;
    }, null, null, null, null, null],
    execute: (function () {

      const Header = {
        len: 8,
        get: (buf, off) => {
          return {
            // Group-ID
            chunkID: new StringType(4, "latin1").get(buf, off),
            // Size
            chunkSize: UINT32_LE.get(buf, off + 4)
          };
        }
      };
      class ListInfoTagValue {
        constructor(tagHeader) {
          this.tagHeader = tagHeader;
          this.len = tagHeader.chunkSize;
          this.len += this.len & 1;
        }
        get(buf, off) {
          return new StringType(this.tagHeader.chunkSize, "ascii").get(buf, off);
        }
      }
      class WaveContentError extends makeUnexpectedFileContentError("Wave") {
      }
      var WaveFormat;
      (function(WaveFormat2) {
        WaveFormat2[WaveFormat2["PCM"] = 1] = "PCM";
        WaveFormat2[WaveFormat2["ADPCM"] = 2] = "ADPCM";
        WaveFormat2[WaveFormat2["IEEE_FLOAT"] = 3] = "IEEE_FLOAT";
        WaveFormat2[WaveFormat2["MPEG_ADTS_AAC"] = 5632] = "MPEG_ADTS_AAC";
        WaveFormat2[WaveFormat2["MPEG_LOAS"] = 5634] = "MPEG_LOAS";
        WaveFormat2[WaveFormat2["RAW_AAC1"] = 255] = "RAW_AAC1";
        WaveFormat2[WaveFormat2["DOLBY_AC3_SPDIF"] = 146] = "DOLBY_AC3_SPDIF";
        WaveFormat2[WaveFormat2["DVM"] = 8192] = "DVM";
        WaveFormat2[WaveFormat2["RAW_SPORT"] = 576] = "RAW_SPORT";
        WaveFormat2[WaveFormat2["ESST_AC3"] = 577] = "ESST_AC3";
        WaveFormat2[WaveFormat2["DRM"] = 9] = "DRM";
        WaveFormat2[WaveFormat2["DTS2"] = 8193] = "DTS2";
        WaveFormat2[WaveFormat2["MPEG"] = 80] = "MPEG";
      })(WaveFormat || (WaveFormat = {}));
      class Format {
        constructor(header) {
          if (header.chunkSize < 16)
            throw new WaveContentError("Invalid chunk size");
          this.len = header.chunkSize;
        }
        get(buf, off) {
          return {
            wFormatTag: UINT16_LE.get(buf, off),
            nChannels: UINT16_LE.get(buf, off + 2),
            nSamplesPerSec: UINT32_LE.get(buf, off + 4),
            nAvgBytesPerSec: UINT32_LE.get(buf, off + 8),
            nBlockAlign: UINT16_LE.get(buf, off + 12),
            wBitsPerSample: UINT16_LE.get(buf, off + 14)
          };
        }
      }
      class FactChunk {
        constructor(header) {
          if (header.chunkSize < 4) {
            throw new WaveContentError("Invalid fact chunk size.");
          }
          this.len = header.chunkSize;
        }
        get(buf, off) {
          return {
            dwSampleLength: UINT32_LE.get(buf, off)
          };
        }
      }
      const BroadcastAudioExtensionChunk = {
        len: 420,
        get: (uint8array, off) => {
          return {
            description: stripNulls(new StringType(256, "ascii").get(uint8array, off)).trim(),
            originator: stripNulls(new StringType(32, "ascii").get(uint8array, off + 256)).trim(),
            originatorReference: stripNulls(new StringType(32, "ascii").get(uint8array, off + 288)).trim(),
            originationDate: stripNulls(new StringType(10, "ascii").get(uint8array, off + 320)).trim(),
            originationTime: stripNulls(new StringType(8, "ascii").get(uint8array, off + 330)).trim(),
            timeReferenceLow: UINT32_LE.get(uint8array, off + 338),
            timeReferenceHigh: UINT32_LE.get(uint8array, off + 342),
            version: UINT16_LE.get(uint8array, off + 346),
            umid: new Uint8ArrayType(64).get(uint8array, off + 348),
            loudnessValue: UINT16_LE.get(uint8array, off + 412),
            maxTruePeakLevel: UINT16_LE.get(uint8array, off + 414),
            maxMomentaryLoudness: UINT16_LE.get(uint8array, off + 416),
            maxShortTermLoudness: UINT16_LE.get(uint8array, off + 418)
          };
        }
      };
      const debug = initDebug("music-metadata:parser:RIFF");
      class WaveParser extends BasicParser {
        constructor() {
          super(...arguments);
          this.blockAlign = 0;
        }
        async parse() {
          const riffHeader = await this.tokenizer.readToken(Header);
          debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);
          if (riffHeader.chunkID !== "RIFF")
            return;
          return this.parseRiffChunk(riffHeader.chunkSize).catch((err) => {
            if (!(err instanceof EndOfStreamError$1)) {
              throw err;
            }
          });
        }
        async parseRiffChunk(chunkSize) {
          const type = await this.tokenizer.readToken(FourCcToken);
          this.metadata.setFormat("container", type);
          switch (type) {
            case "WAVE":
              return this.readWaveChunk(chunkSize - FourCcToken.len);
            default:
              throw new WaveContentError(`Unsupported RIFF format: RIFF/${type}`);
          }
        }
        async readWaveChunk(remaining) {
          while (remaining >= Header.len) {
            const header = await this.tokenizer.readToken(Header);
            remaining -= Header.len + header.chunkSize;
            if (header.chunkSize > remaining) {
              this.metadata.addWarning("Data chunk size exceeds file size");
            }
            this.header = header;
            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);
            switch (header.chunkID) {
              case "LIST":
                await this.parseListTag(header);
                break;
              case "fact":
                this.metadata.setFormat("lossless", false);
                this.fact = await this.tokenizer.readToken(new FactChunk(header));
                break;
              case "fmt ": {
                const fmt = await this.tokenizer.readToken(new Format(header));
                let subFormat = WaveFormat[fmt.wFormatTag];
                if (!subFormat) {
                  debug(`WAVE/non-PCM format=${fmt.wFormatTag}`);
                  subFormat = `non-PCM (${fmt.wFormatTag})`;
                }
                this.metadata.setFormat("codec", subFormat);
                this.metadata.setFormat("bitsPerSample", fmt.wBitsPerSample);
                this.metadata.setFormat("sampleRate", fmt.nSamplesPerSec);
                this.metadata.setFormat("numberOfChannels", fmt.nChannels);
                this.metadata.setFormat("bitrate", fmt.nBlockAlign * fmt.nSamplesPerSec * 8);
                this.blockAlign = fmt.nBlockAlign;
                break;
              }
              case "id3 ":
              case "ID3 ": {
                const id3_data = await this.tokenizer.readToken(new Uint8ArrayType(header.chunkSize));
                const rst = fromBuffer$1(id3_data);
                await new ID3v2Parser().parse(this.metadata, rst, this.options);
                break;
              }
              case "data": {
                if (this.metadata.format.lossless !== false) {
                  this.metadata.setFormat("lossless", true);
                }
                let chunkSize = header.chunkSize;
                if (this.tokenizer.fileInfo.size) {
                  const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;
                  if (calcRemaining < chunkSize) {
                    this.metadata.addWarning("data chunk length exceeding file length");
                    chunkSize = calcRemaining;
                  }
                }
                const numberOfSamples = this.fact ? this.fact.dwSampleLength : chunkSize === 4294967295 ? void 0 : chunkSize / this.blockAlign;
                if (numberOfSamples) {
                  this.metadata.setFormat("numberOfSamples", numberOfSamples);
                  if (this.metadata.format.sampleRate) {
                    this.metadata.setFormat("duration", numberOfSamples / this.metadata.format.sampleRate);
                  }
                }
                if (this.metadata.format.codec === "ADPCM") {
                  this.metadata.setFormat("bitrate", 352e3);
                } else if (this.metadata.format.sampleRate) {
                  this.metadata.setFormat("bitrate", this.blockAlign * this.metadata.format.sampleRate * 8);
                }
                await this.tokenizer.ignore(header.chunkSize);
                break;
              }
              case "bext": {
                const bext = await this.tokenizer.readToken(BroadcastAudioExtensionChunk);
                Object.keys(bext).forEach((key) => {
                  this.metadata.addTag("exif", `bext.${key}`, bext[key]);
                });
                const bextRemaining = header.chunkSize - BroadcastAudioExtensionChunk.len;
                await this.tokenizer.ignore(bextRemaining);
                break;
              }
              case "\0\0\0\0":
                debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
                this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);
                await this.tokenizer.ignore(header.chunkSize);
                break;
              default:
                debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
                this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);
                await this.tokenizer.ignore(header.chunkSize);
            }
            if (this.header.chunkSize % 2 === 1) {
              debug("Read odd padding byte");
              await this.tokenizer.ignore(1);
            }
          }
        }
        async parseListTag(listHeader) {
          const listType = await this.tokenizer.readToken(new StringType(4, "latin1"));
          debug("pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s", this.tokenizer.position, listType);
          switch (listType) {
            case "INFO":
              return this.parseRiffInfoTags(listHeader.chunkSize - 4);
            default:
              this.metadata.addWarning(`Ignore chunk: RIFF/WAVE/LIST/${listType}`);
              debug(`Ignoring chunkID=RIFF/WAVE/LIST/${listType}`);
              return this.tokenizer.ignore(listHeader.chunkSize - 4).then();
          }
        }
        async parseRiffInfoTags(chunkSize) {
          while (chunkSize >= 8) {
            const header = await this.tokenizer.readToken(Header);
            const valueToken = new ListInfoTagValue(header);
            const value = await this.tokenizer.readToken(valueToken);
            this.addTag(header.chunkID, stripNulls(value));
            chunkSize -= 8 + valueToken.len;
          }
          if (chunkSize !== 0) {
            throw new WaveContentError(`Illegal remaining size: ${chunkSize}`);
          }
        }
        addTag(id, value) {
          this.metadata.addTag("exif", id, value);
        }
      } exports("WaveParser", WaveParser);

    })
  };
}));

System.register("./ID3v2Parser-eXNf-3mE-7kzMCmWm.js", ['./__monkey.entry-SDvwpoNt.js'], (function (exports, module) {
  'use strict';
  var initDebug, getBit, ID3v2Header, ExtendedHeader, Uint8ArrayType, UINT32SYNCSAFE, UINT32_BE, UINT24_BE, makeUnexpectedFileContentError, TextEncodingToken, decodeString, findZero, UINT8, TextHeader, SyncTextHeader, AttachedPictureType, Genres;
  return {
    setters: [module => {
      initDebug = module.i;
      getBit = module.j;
      ID3v2Header = module.K;
      ExtendedHeader = module.O;
      Uint8ArrayType = module.U;
      UINT32SYNCSAFE = module.P;
      UINT32_BE = module.a;
      UINT24_BE = module.r;
      makeUnexpectedFileContentError = module.m;
      TextEncodingToken = module.Q;
      decodeString = module.l;
      findZero = module.R;
      UINT8 = module.c;
      TextHeader = module.V;
      SyncTextHeader = module.W;
      AttachedPictureType = module.A;
      Genres = module.H;
    }],
    execute: (function () {

      const debug = initDebug("music-metadata:id3v2:frame-parser");
      const defaultEnc = "latin1";
      function parseGenre(origVal) {
        const genres = [];
        let code;
        let word = "";
        for (const c of origVal) {
          if (typeof code === "string") {
            if (c === "(" && code === "") {
              word += "(";
              code = void 0;
            } else if (c === ")") {
              if (word !== "") {
                genres.push(word);
                word = "";
              }
              const genre = parseGenreCode(code);
              if (genre) {
                genres.push(genre);
              }
              code = void 0;
            } else
              code += c;
          } else if (c === "(") {
            code = "";
          } else {
            word += c;
          }
        }
        if (word) {
          if (genres.length === 0 && word.match(/^\d*$/)) {
            word = parseGenreCode(word);
          }
          if (word) {
            genres.push(word);
          }
        }
        return genres;
      }
      function parseGenreCode(code) {
        if (code === "RX")
          return "Remix";
        if (code === "CR")
          return "Cover";
        if (code.match(/^\d*$/)) {
          return Genres[Number.parseInt(code)];
        }
      }
      class FrameParser {
        /**
         * Create id3v2 frame parser
         * @param major - Major version, e.g. (4) for  id3v2.4
         * @param warningCollector - Used to collect decode issue
         */
        constructor(major, warningCollector) {
          this.major = major;
          this.warningCollector = warningCollector;
        }
        readData(uint8Array, type, includeCovers) {
          if (uint8Array.length === 0) {
            this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);
            return;
          }
          const { encoding, bom } = TextEncodingToken.get(uint8Array, 0);
          const length = uint8Array.length;
          let offset = 0;
          let output = [];
          const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);
          let fzero;
          debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);
          switch (type !== "TXXX" && type[0] === "T" ? "T*" : type) {
            case "T*":
            case "GRP1":
            case "IPLS":
            case "MVIN":
            case "MVNM":
            case "PCS":
            case "PCST": {
              let text;
              try {
                text = decodeString(uint8Array.slice(1), encoding).replace(/\x00+$/, "");
              } catch (error) {
                if (error instanceof Error) {
                  this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);
                  break;
                }
                throw error;
              }
              switch (type) {
                case "TMCL":
                case "TIPL":
                case "IPLS":
                  output = FrameParser.functionList(this.splitValue(type, text));
                  break;
                case "TRK":
                case "TRCK":
                case "TPOS":
                  output = text;
                  break;
                case "TCOM":
                case "TEXT":
                case "TOLY":
                case "TOPE":
                case "TPE1":
                case "TSRC":
                  output = this.splitValue(type, text);
                  break;
                case "TCO":
                case "TCON":
                  output = this.splitValue(type, text).map((v) => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);
                  break;
                case "PCS":
                case "PCST":
                  output = this.major >= 4 ? this.splitValue(type, text) : [text];
                  output = Array.isArray(output) && output[0] === "" ? 1 : 0;
                  break;
                default:
                  output = this.major >= 4 ? this.splitValue(type, text) : [text];
              }
              break;
            }
            case "TXXX": {
              const idAndData = FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);
              const textTag = {
                description: idAndData.id,
                text: this.splitValue(type, decodeString(idAndData.data, encoding).replace(/\x00+$/, ""))
              };
              output = textTag;
              break;
            }
            case "PIC":
            case "APIC":
              if (includeCovers) {
                const pic = {};
                offset += 1;
                switch (this.major) {
                  case 2:
                    pic.format = decodeString(uint8Array.slice(offset, offset + 3), "latin1");
                    offset += 3;
                    break;
                  case 3:
                  case 4:
                    fzero = findZero(uint8Array, offset, length, defaultEnc);
                    pic.format = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
                    offset = fzero + 1;
                    break;
                  default:
                    throw makeUnexpectedMajorVersionError$1(this.major);
                }
                pic.format = FrameParser.fixPictureMimeType(pic.format);
                pic.type = AttachedPictureType[uint8Array[offset]];
                offset += 1;
                fzero = findZero(uint8Array, offset, length, encoding);
                pic.description = decodeString(uint8Array.slice(offset, fzero), encoding);
                offset = fzero + nullTerminatorLength;
                pic.data = uint8Array.slice(offset, length);
                output = pic;
              }
              break;
            case "CNT":
            case "PCNT":
              output = UINT32_BE.get(uint8Array, 0);
              break;
            case "SYLT": {
              const syltHeader = SyncTextHeader.get(uint8Array, 0);
              offset += SyncTextHeader.len;
              const result = {
                descriptor: "",
                language: syltHeader.language,
                contentType: syltHeader.contentType,
                timeStampFormat: syltHeader.timeStampFormat,
                syncText: []
              };
              let readSyllables = false;
              while (offset < length) {
                const nullStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), syltHeader.encoding);
                offset += nullStr.len;
                if (readSyllables) {
                  const timestamp = UINT32_BE.get(uint8Array, offset);
                  offset += UINT32_BE.len;
                  result.syncText.push({
                    text: nullStr.text,
                    timestamp
                  });
                } else {
                  result.descriptor = nullStr.text;
                  readSyllables = true;
                }
              }
              output = result;
              break;
            }
            case "ULT":
            case "USLT":
            case "COM":
            case "COMM": {
              const textHeader = TextHeader.get(uint8Array, offset);
              offset += TextHeader.len;
              const descriptorStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);
              offset += descriptorStr.len;
              const textStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);
              const comment = {
                language: textHeader.language,
                descriptor: descriptorStr.text,
                text: textStr.text
              };
              output = comment;
              break;
            }
            case "UFID": {
              const ufid = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
              output = { owner_identifier: ufid.id, identifier: ufid.data };
              break;
            }
            case "PRIV": {
              const priv = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);
              output = { owner_identifier: priv.id, data: priv.data };
              break;
            }
            case "POPM": {
              fzero = findZero(uint8Array, offset, length, defaultEnc);
              const email = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
              offset = fzero + 1;
              const dataLen = length - offset;
              output = {
                email,
                rating: UINT8.get(uint8Array, offset),
                counter: dataLen >= 5 ? UINT32_BE.get(uint8Array, offset + 1) : void 0
              };
              break;
            }
            case "GEOB": {
              fzero = findZero(uint8Array, offset + 1, length, encoding);
              const mimeType = decodeString(uint8Array.slice(offset + 1, fzero), defaultEnc);
              offset = fzero + 1;
              fzero = findZero(uint8Array, offset, length, encoding);
              const filename = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
              offset = fzero + 1;
              fzero = findZero(uint8Array, offset, length, encoding);
              const description = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
              offset = fzero + 1;
              const geob = {
                type: mimeType,
                filename,
                description,
                data: uint8Array.slice(offset, length)
              };
              output = geob;
              break;
            }
            case "WCOM":
            case "WCOP":
            case "WOAF":
            case "WOAR":
            case "WOAS":
            case "WORS":
            case "WPAY":
            case "WPUB":
              fzero = findZero(uint8Array, offset + 1, length, encoding);
              output = decodeString(uint8Array.slice(offset, fzero), defaultEnc);
              break;
            case "WXXX": {
              fzero = findZero(uint8Array, offset + 1, length, encoding);
              const description = decodeString(uint8Array.slice(offset + 1, fzero), encoding);
              offset = fzero + (encoding === "utf-16le" ? 2 : 1);
              output = { description, url: decodeString(uint8Array.slice(offset, length), defaultEnc) };
              break;
            }
            case "WFD":
            case "WFED":
              output = decodeString(uint8Array.slice(offset + 1, findZero(uint8Array, offset + 1, length, encoding)), encoding);
              break;
            case "MCDI": {
              output = uint8Array.slice(0, length);
              break;
            }
            default:
              debug(`Warning: unsupported id3v2-tag-type: ${type}`);
              break;
          }
          return output;
        }
        static readNullTerminatedString(uint8Array, encoding) {
          let offset = encoding.bom ? 2 : 0;
          const zeroIndex = findZero(uint8Array, offset, uint8Array.length, encoding.encoding);
          const txt = uint8Array.slice(offset, zeroIndex);
          if (encoding.encoding === "utf-16le") {
            offset = zeroIndex + 2;
          } else {
            offset = zeroIndex + 1;
          }
          return {
            text: decodeString(txt, encoding.encoding),
            len: offset
          };
        }
        static fixPictureMimeType(pictureType) {
          pictureType = pictureType.toLocaleLowerCase();
          switch (pictureType) {
            case "jpg":
              return "image/jpeg";
            case "png":
              return "image/png";
          }
          return pictureType;
        }
        /**
         * Converts TMCL (Musician credits list) or TIPL (Involved people list)
         * @param entries
         */
        static functionList(entries) {
          const res = {};
          for (let i = 0; i + 1 < entries.length; i += 2) {
            const names = entries[i + 1].split(",");
            res[entries[i]] = res[entries[i]] ? res[entries[i]].concat(names) : names;
          }
          return res;
        }
        /**
         * id3v2.4 defines that multiple T* values are separated by 0x00
         * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
         * @param tag - Tag name
         * @param text - Concatenated tag value
         * @returns Split tag value
         */
        splitValue(tag, text) {
          let values;
          if (this.major < 4) {
            values = text.split(/\x00/g);
            if (values.length > 1) {
              this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);
            } else {
              values = text.split(/\//g);
            }
          } else {
            values = text.split(/\x00/g);
          }
          return FrameParser.trimArray(values);
        }
        static trimArray(values) {
          return values.map((value) => value.replace(/\x00+$/, "").trim());
        }
        static readIdentifierAndData(uint8Array, offset, length, encoding) {
          const fzero = findZero(uint8Array, offset, length, encoding);
          const id = decodeString(uint8Array.slice(offset, fzero), encoding);
          offset = fzero + FrameParser.getNullTerminatorLength(encoding);
          return { id, data: uint8Array.slice(offset, length) };
        }
        static getNullTerminatorLength(enc) {
          return enc === "utf-16le" ? 2 : 1;
        }
      }
      class Id3v2ContentError extends makeUnexpectedFileContentError("id3v2") {
      }
      function makeUnexpectedMajorVersionError$1(majorVer) {
        throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);
      }
      const asciiDecoder = new TextDecoder("ascii");
      class ID3v2Parser {
        constructor() {
          this.tokenizer = void 0;
          this.id3Header = void 0;
          this.metadata = void 0;
          this.headerType = void 0;
          this.options = void 0;
        }
        static removeUnsyncBytes(buffer) {
          let readI = 0;
          let writeI = 0;
          while (readI < buffer.length - 1) {
            if (readI !== writeI) {
              buffer[writeI] = buffer[readI];
            }
            readI += buffer[readI] === 255 && buffer[readI + 1] === 0 ? 2 : 1;
            writeI++;
          }
          if (readI < buffer.length) {
            buffer[writeI++] = buffer[readI];
          }
          return buffer.slice(0, writeI);
        }
        static getFrameHeaderLength(majorVer) {
          switch (majorVer) {
            case 2:
              return 6;
            case 3:
            case 4:
              return 10;
            default:
              throw makeUnexpectedMajorVersionError(majorVer);
          }
        }
        static readFrameFlags(b) {
          return {
            status: {
              tag_alter_preservation: getBit(b, 0, 6),
              file_alter_preservation: getBit(b, 0, 5),
              read_only: getBit(b, 0, 4)
            },
            format: {
              grouping_identity: getBit(b, 1, 7),
              compression: getBit(b, 1, 3),
              encryption: getBit(b, 1, 2),
              unsynchronisation: getBit(b, 1, 1),
              data_length_indicator: getBit(b, 1, 0)
            }
          };
        }
        static readFrameData(uint8Array, frameHeader, majorVer, includeCovers, warningCollector) {
          var _a, _b;
          const frameParser = new FrameParser(majorVer, warningCollector);
          switch (majorVer) {
            case 2:
              return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
            case 3:
            case 4:
              if ((_a = frameHeader.flags) == null ? void 0 : _a.format.unsynchronisation) {
                uint8Array = ID3v2Parser.removeUnsyncBytes(uint8Array);
              }
              if ((_b = frameHeader.flags) == null ? void 0 : _b.format.data_length_indicator) {
                uint8Array = uint8Array.slice(4, uint8Array.length);
              }
              return frameParser.readData(uint8Array, frameHeader.id, includeCovers);
            default:
              throw makeUnexpectedMajorVersionError(majorVer);
          }
        }
        /**
         * Create a combined tag key, of tag & description
         * @param tag e.g.: COM
         * @param description e.g. iTunPGAP
         * @returns string e.g. COM:iTunPGAP
         */
        static makeDescriptionTagName(tag, description) {
          return tag + (description ? `:${description}` : "");
        }
        async parse(metadata, tokenizer, options) {
          this.tokenizer = tokenizer;
          this.metadata = metadata;
          this.options = options;
          const id3Header = await this.tokenizer.readToken(ID3v2Header);
          if (id3Header.fileIdentifier !== "ID3") {
            throw new Id3v2ContentError("expected ID3-header file-identifier 'ID3' was not found");
          }
          this.id3Header = id3Header;
          this.headerType = `ID3v2.${id3Header.version.major}`;
          return id3Header.flags.isExtendedHeader ? this.parseExtendedHeader() : this.parseId3Data(id3Header.size);
        }
        async parseExtendedHeader() {
          const extendedHeader = await this.tokenizer.readToken(ExtendedHeader);
          const dataRemaining = extendedHeader.size - ExtendedHeader.len;
          return dataRemaining > 0 ? this.parseExtendedHeaderData(dataRemaining, extendedHeader.size) : this.parseId3Data(this.id3Header.size - extendedHeader.size);
        }
        async parseExtendedHeaderData(dataRemaining, extendedHeaderSize) {
          await this.tokenizer.ignore(dataRemaining);
          return this.parseId3Data(this.id3Header.size - extendedHeaderSize);
        }
        async parseId3Data(dataLen) {
          const uint8Array = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));
          for (const tag of this.parseMetadata(uint8Array)) {
            switch (tag.id) {
              case "TXXX":
                if (tag.value) {
                  await this.handleTag(tag, tag.value.text, () => tag.value.description);
                }
                break;
              default:
                await (Array.isArray(tag.value) ? Promise.all(tag.value.map((value) => this.addTag(tag.id, value))) : this.addTag(tag.id, tag.value));
            }
          }
        }
        async handleTag(tag, values, descriptor, resolveValue = (value) => value) {
          await Promise.all(values.map((value) => this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, descriptor(value)), resolveValue(value))));
        }
        async addTag(id, value) {
          await this.metadata.addTag(this.headerType, id, value);
        }
        parseMetadata(data) {
          let offset = 0;
          const tags = [];
          while (true) {
            if (offset === data.length)
              break;
            const frameHeaderLength = ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);
            if (offset + frameHeaderLength > data.length) {
              this.metadata.addWarning("Illegal ID3v2 tag length");
              break;
            }
            const frameHeaderBytes = data.slice(offset, offset + frameHeaderLength);
            offset += frameHeaderLength;
            const frameHeader = this.readFrameHeader(frameHeaderBytes, this.id3Header.version.major);
            const frameDataBytes = data.slice(offset, offset + frameHeader.length);
            offset += frameHeader.length;
            const values = ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers, this.metadata);
            if (values) {
              tags.push({ id: frameHeader.id, value: values });
            }
          }
          return tags;
        }
        readFrameHeader(uint8Array, majorVer) {
          let header;
          switch (majorVer) {
            case 2:
              header = {
                id: asciiDecoder.decode(uint8Array.slice(0, 3)),
                length: UINT24_BE.get(uint8Array, 3)
              };
              if (!header.id.match(/[A-Z0-9]{3}/g)) {
                this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
              }
              break;
            case 3:
            case 4:
              header = {
                id: asciiDecoder.decode(uint8Array.slice(0, 4)),
                length: (majorVer === 4 ? UINT32SYNCSAFE : UINT32_BE).get(uint8Array, 4),
                flags: ID3v2Parser.readFrameFlags(uint8Array.slice(8, 10))
              };
              if (!header.id.match(/[A-Z0-9]{4}/g)) {
                this.metadata.addWarning(`Invalid ID3v2.${this.id3Header.version.major} frame-header-ID: ${header.id}`);
              }
              break;
            default:
              throw makeUnexpectedMajorVersionError(majorVer);
          }
          return header;
        }
      } exports("I", ID3v2Parser);
      function makeUnexpectedMajorVersionError(majorVer) {
        throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);
      }

    })
  };
}));

System.register("./__vite-browser-external-pcc57R5k.js", [], (function (exports, module) {
	'use strict';
	return {
		execute: (function () {

			const __viteBrowserExternal = exports("default", {});

		})
	};
}));

System.import("./__entry.js", "./");